;;
;;  ANSI Common Lisp 日本語訳
;;  4. 型とクラス
;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  4.3.5 {class-precedence-list}の決定
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@begin: 4.3.5
@type: text

クラスの{defclass:link}フォームは、
そのクラスとその`direct`スーパークラスの全体の順序を提供します。
その順番は{local-precedence-order}と呼ばれます。
これはそのクラスとその`direct`スーパークラスを順序付けしたリストです。
クラス`C`の{class-precedence-list}は、
`C`とその`direct`スーパークラスの全体の順序であり、
これは各`C`とその`direct`スーパークラスの
{local-precedence-order}を含みます。

あるクラスは、その`direct`スーパークラスの先に立ち、
ある`direct`スーパークラスは、
{defclass:link}フォームのスーパークラスのリストの右側に指定された
その他の全ての`direct`スーパークラスに先立ちます。
全てのクラス`C`に対して、次のような定義をします。

```
R_C = {(C,C1), (C1,C2), , ..., (Cn-1,Cn)}
```

ただし`C1,...,Cn`は`C`の{defclass:link}フォームを参考に
順序付けられた`direct`スーパークラスです。
これらの順序付けられたペアは、
クラス`C`とその`direct`スーパークラスの全体の順番を生成します。

ここで`S_C`を`C`とそのスーパークラスの集合とします。
ここで`R`は次のようになります。

```
R = U_{CはS_Cの要素} R_C
```

（TeXで書くと`R = \bigcup_{C \in S_C} R_C`）

`R_C`と`CはS_Cの要素`が矛盾するかどうかによって、
`R`の集合が部分的な順序を生成するかもしれませんし、しないかもしれません。
それらが矛盾しないことを仮定すると`R`は部分順序を生成します。
もし`R_C`が矛盾しているときは、`R`に一貫性が無いと言います。

`C`の{class-precedence-list}の計算をするために、
`R`によって生成された部分順序を反映した`S_C`の要素に対して
トポロジカルソートを行います。
トポロジカルソートが、Rに関して他のクラスが先行しない
2つ以上のクラスの集合からクラスを選択しなければならないとき、
選択されるクラスは、以下に述べるように決定的に選ばれます。

もし`R`が矛盾していたとき、エラーが発生します。

@index

@end

