;;
;;  ANSI Common Lisp 日本語訳
;;  4. 型とクラス
;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  4.3.5.1 トポロジカルソート
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@begin: 4.3.5.1
@type: text

トポロジカルソートは、
`S_C`の中にあるクラスを`C`としたとき、
`C`ではない他のクラスが`R`内で対応する要素に先行するものが無いような
クラス`C`を検索する処理によって行われます。
クラス`C`は結果の最初に配置されます。
`S_C`から`C`を削除し、
`D`が`S_C`に含まれるもののとき`(C,D)`の全てのペアを削除します。
この処理を繰り返し、
結果の最後の、先行するものがないものとしてクラスを追加します。
先行するものを持たない要素が見つからなかったときに停止します。

もし`S_C`が空でないときに処理が停止したら、集合`R`には矛盾があります。
もし有限のクラスの集合である全てのクラスが
他のものによって先行されていたら、`R`にはループが含まれています。
つまり、クラス`C1,...,Cn`の繋がりに対して、
`Ci`が`Ci+1`ただし`1<=i<n`に先行し、`Cn`が`C1`に先行しています。

ときには`S_C`に先行するものがないクラスが存在することがあります。
このような場合は、これまでに計算された{class-precedence-list}で
もっとも右にある{direct-superclasses}を持つものを選択します
（そのような候補クラスがないときは`R`は部分順序を生成できず、
`C`が`S_C`に含まれるときの`R_C`は矛盾しています）。

より正確な言葉であらわすと、
`{N1,...,Nm}`, `m>=2`を`S_C`に先行するものがないクラスとします。
`(C1,...,Cn)`, `n>=1`をこれまでに構築した{class-precedence-list}とします。
`C1`はもっとも特定的なクラスであり、
`Cn`はもっとも特定的ではないクラスです。
ここで`1<-j<=n`のもっとも大きな数

`1<=j<=n`を、`1<=i<=m`で`Ni`が`Cj`の{direct-superclasses}である
`i`が存在するような最大の数とします。
このとき`Ni`は次に配置されるものになります。

先行するものがないクラスの集合から選択するというこのルールの効果は、
単純なスーパークラスのつながりであるクラスが
{class-precedence-list}で隣接しており、
相対的に分離した各サブグラフのクラスが
{class-precedence-list}で隣接するようになります。
例えば、`T1`と`T2`をクラス`J`のみを共通要素とするサブグラフとします。
`J`のスーパークラスは`T1`と`T2`のいずれにも現れず、
`J`は`T1`と`T2`の両方のクラスのスーパークラス内にあるとします。
`T1`の底を`C1`とし、
`T2`の底を`C2`とします。
あるクラスの{direct-superclasses}に`C1,C2`という順番で
現れているようなクラスを`C`としたとき、
`C`の{class-precedence-list}は`C`で始まり、
`T1`の`J`を除くすべてのクラスが続きます。
クラス`T2`のすべてのクラスが次に続きます。
クラス`J`とそのスーパークラスは最後に現れます。

@end

