;;
;;  ANSI Common Lisp 日本語訳
;;  10. シンボル
;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  System Class SYMBOL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@begin: 10.2.symbol
@name: symbol
@type: system-class

System Class `SYMBOL`


## {class-precedence-list}

{symbol:link}, {t!system-class:link}


## {description}

シンボルは、オブジェクトの同一性のために、
Common Lispでは、変数や関数といった（しかし限定はしない）言語的な実体を含む、
様々な実体に名前を付けるために使用されます。

シンボルはパッケージの中に集めることができます。
もしシンボルがパッケージからアクセス可能な時、
シンボルはパッケージに`intern`されたと言います。
同じシンボルは、複数のパッケージに`intern`することができます。
もしシンボルがどのパッケージにも`intern`されていないとき、
それは`unintern`と呼ばれます。

`intern`されたシンボルは、
アクセス可能などのパッケージからもその名前によって
一意に識別することができます。

歴史的な理由からこれを`cell`と呼ぶことがありますが、
実際のシンボルの内部表現とそれらの属性は実装依存です。

- 名前
  - シンボルの名前は文字列であり、シンボルの同一性のために使われます。
    全てのシンボルは名前を持っており、
    もし名前が変更されたときの結果は未定義です。
    名前は、外部の機能であるシンボルの印字表現に使われます。
    {2.1:ab}をご確認ください。
    関数{symbol-name:link}は、引数のシンボルの名前を返却します。
    シンボルはその名前にどのような文字も保有します。
	<br><br>

- パッケージ
  - オブジェクトのこの領域は、シンボルのホームパッケージと呼ばれます。
    もしホームパッケージが{nil!variable:link}のときは、
    シンボルはホームパッケージを持たないと言われることがあります。
    <br><br>
    パッケージが最初に作成されたときは、ホームパッケージを持ちません。
    それが最初に`intern`されたとき、
    その最初に`intern`されたパッケージがホームパッケージになります。
    シンボルのホームパッケージは、
    関数{symbol-package:link}を使うことでアクセスできます。
    <br><br>
    もしシンボルがホームパッケージから`unintern`されたとき、
    そのホームパッケージには{nil!variable:link}が設定されます。
    そのシンボルが他に`intern`されているパッケージがあるかどうかによって、
    シンボルが本当に`unintern`されたシンボルかもしれませんし、
    そうでないかもしれません。
    したがって、ホームパッケージがないシンボルは、
    見かけ上は`unintern`されたと呼ばれます。
    <br><br>
    もし`COMMON-LISP`パッケージか、`KEYWORD`パッケージの
    外部シンボルのホームパッケージを変更しようとしたときの
    結果は未定義です。
	<br><br>

- プロパティリスト
  - シンボルのプロパティリストは、
    そのシンボルに名前付きの属性を関連付けるための仕組みです。
    要素の追加と削除の操作は、プロパティリストに対して破壊的に行われます。
    Common Lispはプロパティリストのオブジェクトを直接操作するものと
    （{getf:link}, {remf:link}, {symbol-plist:link}など）、
    シンボルのプロパティリストを参照し暗黙に操作するもの
    （{get:link}, {remprop:link}など）の両方を提供しています。
    新しいシンボルに関連付けられるプロパティリストは、
    初期状態では`null`です。
	<br><br>

- 値
  - シンボルが値の属性を持つ場合、それは束縛`bound`されていると言われ、
    そのことは関数{boundp:link}によって検出できます。
    `bound`シンボルの値のセルに含まれるオブジェクトは
    そのシンボルによって名付けられたグローバル変数の値あり、
    関数{symbol-value:link}によってアクセスできます。
    シンボルは、関数{makunbound:link}によって`unbound`にできます。
    <br><br>
    もし定数の変数の名前のシンボル値を変更しようとしたり、
    そのようなシンボルを`unbound`にしようとしたときの結果は未定義です。
	<br><br>

- 関数
  - シンボルが関数の属性を持つ場合、それは`fbound`されていると言われ、
    そのことは関数{fboundp:link}によって検出できます。
    もしシンボルがグローバル環境下の関数の名前である場合は、
    関数のセルにはその関数が含まれ、
    関数{symbol-function:link}によってアクセスできます。
    もしシンボルがグローバル環境下のマクロ名か（{macro-function:link}を参照）、
    あるいは{special-operator}名（{special-operator-p:link}を参照）であるときは
    シンボルは`fbound`であり、関数{symbol-function:link}でアクセス可能です。
    しかしその関数のセルに含まれるオブジェクトは実装依存の型と意味なります。
    シンボルは、関数{fmakunbound:link}によって`funbound`にすることができます。
    <br><br>
    スペシャルフォームと名前付けられたシンボルの
    関数の値を変更しようとした結果は未定義です。
	<br><br>

シンボルの値のセルや関数のセルに対する操作は、
シンボル自身に対する影響という観点から説明されることがありますが、
ユーザーは、これらのセルの内容とグローバル変数やグローバル関数定義との間に
密接な関係があることを心に留めておく必要があります。

シンボルはレキシカル変数やレキシカル関数の定義の識別子として使用されますが、
その役割においては、ただオブジェクトの同一性のみが重要です。
Common Lispはシンボルに対して、レキシカル変数やレキシカル関数の定義に
影響を与えるような操作は提供されません。


## {see-also}

{2.3.4:ab},
{2.3.1.1:ab},
{22.1.3.3:ab}

@end

