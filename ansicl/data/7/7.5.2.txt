;;
;;  ANSI Common Lisp 日本語訳
;;  7. オブジェクト
;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  7.5.2 スロットへのアクセス
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@begin: 7.5.2
@type: text

スロットは次の2つの方法にてアクセスできます。
関数{slot-value:link}を使用する方法、
そして{defclass:link}フォームによって生成されるジェネリック関数を使用する方法です。

関数{slot-value:link}は、
{defclass:link}フォームで対象のクラスのインスタンスにて
アクセス可能に設定したスロットに対しては、
どんなスロットの名前でも指定してアクセスすることができます。

マクロ{defclass:link}は、スロットの読み書きをするメソッドを生成するための構文が提供されています。
もし`reader`のメソッドが要求された場合、
スロットの値を読むためのメソッドが自動的に生成されますが、
ただし値を格納するためのメソッドは生成されません。
もし`writer`のメソッドが要求された場合、
スロットの値を書き込むためのメソッドが自動的に生成されますが、
ただし値を読み込むためのメソッドは生成されません。
もし`accessor`のメソッドが要求された場合は、
スロットの値を読むためのメソッドと、
スロットの値を書き込むためのメソッドが自動的に生成されます。
`reader`と`writer`のメソッドは、{slot-value:link}を使用して実装されます。

スロットに対して`reader`か`writer`のメソッドを指定するときは、
ジェネリック関数の名前とそれに沿って生成されるメソッドの名前を直接指定します。
もし`writer`メソッドの名前をシンボル`name`に指定した場合、
スロットへ書き込むためのジェネリック関数の名前がシンボル`name`となり、
そのジェネリック関数の引数は、
新しい値、インスタンスの順に2つ取ります。
もし`accessor`メソッドの名前をシンボル`name`に指定した場合、
スロットから読み込むためのジェネリック関数の名前がシンボル`name`となり、
そしてスロットへ書き込むためのジェネリック関数の名前が、リストの`(setf name)`となります。

スロットオプションの`:reader`, `:writer`, `:accessor`の指定により、
作成か修正が行われたジェネリック関数は、
正確に普通のジェネリック関数として扱うことができます。

注意として、{slot-value:link}はスロットから値を読み込むか書き込む時に使われますが、
そのスロットの`reader`か`writer`のメソッドが存在するかどうかに関わらず使用できます。
{slot-value:link}が使われる時、`reader`か`writer`のメソッドは実行されません。

マクロ{with-slots:link}は、
指定されたスロットがレキシカル変数として使えるようにするレキシカル環境を確立します。
マクロ{with-slots:link}は、指定したスロットへアクセスするために関数{slot-value:link}を実行します。

マクロ{with-accessors:link}は、
指定したスロットがレキシカル変数としてスロットの`accessor`を通して
使えるようにするレキシカル環境を確立します。
マクロ{with-accessors:link}は、指定したスロットへアクセスするために、
適切な`accessor`を実行します。

@end

