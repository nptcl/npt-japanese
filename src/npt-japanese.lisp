;;
;;  draft proposed American National Standard for Information Systems
;;  Programming Language Common Lisp
;;  Version 15.17R, X3J13/94-101R.
;;  Fri 12-Aug-1994 6:35pm EDT
;;  http://www.cs.cmu.edu/afs/cs/Web/Groups/AI/lang/lisp/doc/standard/ansi/dpans/
;;  
;;  ドラフト版提案書　ANSIプログラミング言語Common Lisp
;;  Version 15.17R, X3J13/94-101R.
;;  1994年8月12日金曜日　午後6時35分（米国東部標準時・夏時間）
;;  https://github.com/nptcl/npt-japanese
;;
(defpackage #:npt-japanese
  (:use #:common-lisp)
  (:export #:docjp #:doc-japanese))

(in-package #:npt-japanese)

(defvar *table*)
(defvar *name*)
(setq *table* (make-hash-table :test 'equal))
(setq *name* (make-hash-table :test 'equal))
(setf (gethash "*BREAK-ON-SIGNALS*" *name*) '("VARIABLE"))
(setf (gethash "*DEBUG-IO*" *name*) '("VARIABLE"))
(setf (gethash "*DEBUGGER-HOOK*" *name*) '("VARIABLE"))
(setf (gethash "*DEFAULT-PATHNAME-DEFAULTS*" *name*) '("VARIABLE"))
(setf (gethash "*ERROR-OUTPUT*" *name*) '("VARIABLE"))
(setf (gethash "*GENSYM-COUNTER*" *name*) '("VARIABLE"))
(setf (gethash "*MACROEXPAND-HOOK*" *name*) '("VARIABLE"))
(setf (gethash "*PACKAGE*" *name*) '("VARIABLE"))
(setf (gethash "*PRINT-ARRAY*" *name*) '("VARIABLE"))
(setf (gethash "*PRINT-BASE*" *name*) '("VARIABLE"))
(setf (gethash "*PRINT-CASE*" *name*) '("VARIABLE"))
(setf (gethash "*PRINT-CIRCLE*" *name*) '("VARIABLE"))
(setf (gethash "*PRINT-ESCAPE*" *name*) '("VARIABLE"))
(setf (gethash "*PRINT-GENSYM*" *name*) '("VARIABLE"))
(setf (gethash "*PRINT-LENGTH*" *name*) '("VARIABLE"))
(setf (gethash "*PRINT-LEVEL*" *name*) '("VARIABLE"))
(setf (gethash "*PRINT-LINES*" *name*) '("VARIABLE"))
(setf (gethash "*PRINT-RADIX*" *name*) '("VARIABLE"))
(setf (gethash "*QUERY-IO*" *name*) '("VARIABLE"))
(setf (gethash "*STANDARD-INPUT*" *name*) '("VARIABLE"))
(setf (gethash "*STANDARD-OUTPUT*" *name*) '("VARIABLE"))
(setf (gethash "*TERMINAL-IO*" *name*) '("VARIABLE"))
(setf (gethash "*TRACE-OUTPUT*" *name*) '("VARIABLE"))
(setf (gethash "ABORT" *name*) '("FUNCTION" "RESTART"))
(setf (gethash "ACONS" *name*) '("FUNCTION"))
(setf (gethash "ADD-METHOD" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "ADJOIN" *name*) '("FUNCTION"))
(setf (gethash "ADJUST-ARRAY" *name*) '("FUNCTION"))
(setf (gethash "ADJUSTABLE-ARRAY-P" *name*) '("FUNCTION"))
(setf (gethash "ALLOCATE-INSTANCE" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "ALPHA-CHAR-P" *name*) '("FUNCTION"))
(setf (gethash "ALPHANUMERICP" *name*) '("FUNCTION"))
(setf (gethash "AND" *name*) '("MACRO" "TYPE-SPECIFIER"))
(setf (gethash "APPEND" *name*) '("FUNCTION"))
(setf (gethash "APPLY" *name*) '("FUNCTION"))
(setf (gethash "AREF" *name*) '("ACCESSOR"))
(setf (gethash "ARRAY" *name*) '("SYSTEM-CLASS"))
(setf (gethash "ARRAY-DIMENSION" *name*) '("FUNCTION"))
(setf (gethash "ARRAY-DIMENSION-LIMIT" *name*) '("CONSTANT-VARIABLE"))
(setf (gethash "ARRAY-DIMENSIONS" *name*) '("FUNCTION"))
(setf (gethash "ARRAY-DISPLACEMENT" *name*) '("FUNCTION"))
(setf (gethash "ARRAY-ELEMENT-TYPE" *name*) '("FUNCTION"))
(setf (gethash "ARRAY-HAS-FILL-POINTER-P" *name*) '("FUNCTION"))
(setf (gethash "ARRAY-IN-BOUNDS-P" *name*) '("FUNCTION"))
(setf (gethash "ARRAY-RANK" *name*) '("FUNCTION"))
(setf (gethash "ARRAY-RANK-LIMIT" *name*) '("CONSTANT-VARIABLE"))
(setf (gethash "ARRAY-ROW-MAJOR-INDEX" *name*) '("FUNCTION"))
(setf (gethash "ARRAY-TOTAL-SIZE" *name*) '("FUNCTION"))
(setf (gethash "ARRAY-TOTAL-SIZE-LIMIT" *name*) '("CONSTANT-VARIABLE"))
(setf (gethash "ARRAYP" *name*) '("FUNCTION"))
(setf (gethash "ASSERT" *name*) '("MACRO"))
(setf (gethash "ASSOC" *name*) '("FUNCTION"))
(setf (gethash "ASSOC-IF" *name*) '("FUNCTION"))
(setf (gethash "ASSOC-IF-NOT" *name*) '("FUNCTION"))
(setf (gethash "ATOM" *name*) '("FUNCTION" "TYPE"))
(setf (gethash "BASE-CHAR" *name*) '("TYPE"))
(setf (gethash "BASE-STRING" *name*) '("TYPE"))
(setf (gethash "BIT" *name*) '("ACCESSOR"))
(setf (gethash "BIT-AND" *name*) '("FUNCTION"))
(setf (gethash "BIT-ANDC1" *name*) '("FUNCTION"))
(setf (gethash "BIT-ANDC2" *name*) '("FUNCTION"))
(setf (gethash "BIT-EQV" *name*) '("FUNCTION"))
(setf (gethash "BIT-IOR" *name*) '("FUNCTION"))
(setf (gethash "BIT-NAND" *name*) '("FUNCTION"))
(setf (gethash "BIT-NOR" *name*) '("FUNCTION"))
(setf (gethash "BIT-NOT" *name*) '("FUNCTION"))
(setf (gethash "BIT-ORC1" *name*) '("FUNCTION"))
(setf (gethash "BIT-ORC2" *name*) '("FUNCTION"))
(setf (gethash "BIT-VECTOR" *name*) '("SYSTEM-CLASS"))
(setf (gethash "BIT-VECTOR-P" *name*) '("FUNCTION"))
(setf (gethash "BIT-XOR" *name*) '("FUNCTION"))
(setf (gethash "BLOCK" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "BOOLEAN" *name*) '("TYPE"))
(setf (gethash "BOTH-CASE-P" *name*) '("FUNCTION"))
(setf (gethash "BOUNDP" *name*) '("FUNCTION"))
(setf (gethash "BREAK" *name*) '("FUNCTION"))
(setf (gethash "BROADCAST-STREAM" *name*) '("SYSTEM-CLASS"))
(setf (gethash "BROADCAST-STREAM-STREAMS" *name*) '("FUNCTION"))
(setf (gethash "BUILT-IN-CLASS" *name*) '("SYSTEM-CLASS"))
(setf (gethash "BUTLAST" *name*) '("FUNCTION"))
(setf (gethash "CAAAAR" *name*) '("ACCESSOR"))
(setf (gethash "CAAADR" *name*) '("ACCESSOR"))
(setf (gethash "CAAAR" *name*) '("ACCESSOR"))
(setf (gethash "CAADAR" *name*) '("ACCESSOR"))
(setf (gethash "CAADDR" *name*) '("ACCESSOR"))
(setf (gethash "CAADR" *name*) '("ACCESSOR"))
(setf (gethash "CAAR" *name*) '("ACCESSOR"))
(setf (gethash "CADAAR" *name*) '("ACCESSOR"))
(setf (gethash "CADADR" *name*) '("ACCESSOR"))
(setf (gethash "CADAR" *name*) '("ACCESSOR"))
(setf (gethash "CADDAR" *name*) '("ACCESSOR"))
(setf (gethash "CADDDR" *name*) '("ACCESSOR"))
(setf (gethash "CADDR" *name*) '("ACCESSOR"))
(setf (gethash "CADR" *name*) '("ACCESSOR"))
(setf (gethash "CALL-ARGUMENTS-LIMIT" *name*) '("CONSTANT-VARIABLE"))
(setf (gethash "CALL-METHOD" *name*) '("LOCAL-MACRO"))
(setf (gethash "CALL-NEXT-METHOD" *name*) '("LOCAL-FUNCTION"))
(setf (gethash "CAR" *name*) '("ACCESSOR"))
(setf (gethash "CASE" *name*) '("MACRO"))
(setf (gethash "CATCH" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "CCASE" *name*) '("MACRO"))
(setf (gethash "CDAAAR" *name*) '("ACCESSOR"))
(setf (gethash "CDAADR" *name*) '("ACCESSOR"))
(setf (gethash "CDAAR" *name*) '("ACCESSOR"))
(setf (gethash "CDADAR" *name*) '("ACCESSOR"))
(setf (gethash "CDADDR" *name*) '("ACCESSOR"))
(setf (gethash "CDADR" *name*) '("ACCESSOR"))
(setf (gethash "CDAR" *name*) '("ACCESSOR"))
(setf (gethash "CDDAAR" *name*) '("ACCESSOR"))
(setf (gethash "CDDADR" *name*) '("ACCESSOR"))
(setf (gethash "CDDAR" *name*) '("ACCESSOR"))
(setf (gethash "CDDDAR" *name*) '("ACCESSOR"))
(setf (gethash "CDDDDR" *name*) '("ACCESSOR"))
(setf (gethash "CDDDR" *name*) '("ACCESSOR"))
(setf (gethash "CDDR" *name*) '("ACCESSOR"))
(setf (gethash "CDR" *name*) '("ACCESSOR"))
(setf (gethash "CELL-ERROR" *name*) '("CONDITION-TYPE"))
(setf (gethash "CELL-ERROR-NAME" *name*) '("FUNCTION"))
(setf (gethash "CERROR" *name*) '("FUNCTION"))
(setf (gethash "CHANGE-CLASS" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "CHAR" *name*) '("ACCESSOR"))
(setf (gethash "CHAR-CODE" *name*) '("FUNCTION"))
(setf (gethash "CHAR-CODE-LIMIT" *name*) '("CONSTANT-VARIABLE"))
(setf (gethash "CHAR-DOWNCASE" *name*) '("FUNCTION"))
(setf (gethash "CHAR-EQUAL" *name*) '("FUNCTION"))
(setf (gethash "CHAR-GREATERP" *name*) '("FUNCTION"))
(setf (gethash "CHAR-INT" *name*) '("FUNCTION"))
(setf (gethash "CHAR-LESSP" *name*) '("FUNCTION"))
(setf (gethash "CHAR-NAME" *name*) '("FUNCTION"))
(setf (gethash "CHAR-NOT-EQUAL" *name*) '("FUNCTION"))
(setf (gethash "CHAR-NOT-GREATERP" *name*) '("FUNCTION"))
(setf (gethash "CHAR-NOT-LESSP" *name*) '("FUNCTION"))
(setf (gethash "CHAR-UPCASE" *name*) '("FUNCTION"))
(setf (gethash "CHAR/=" *name*) '("FUNCTION"))
(setf (gethash "CHAR<" *name*) '("FUNCTION"))
(setf (gethash "CHAR<=" *name*) '("FUNCTION"))
(setf (gethash "CHAR=" *name*) '("FUNCTION"))
(setf (gethash "CHAR>" *name*) '("FUNCTION"))
(setf (gethash "CHAR>=" *name*) '("FUNCTION"))
(setf (gethash "CHARACTER" *name*) '("FUNCTION" "SYSTEM-CLASS"))
(setf (gethash "CHARACTERP" *name*) '("FUNCTION"))
(setf (gethash "CHECK-TYPE" *name*) '("MACRO"))
(setf (gethash "CLASS" *name*) '("SYSTEM-CLASS"))
(setf (gethash "CLASS-NAME" *name*) '("SETF" "STANDARD-GENERIC-FUNCTION"))
(setf (gethash "CLASS-OF" *name*) '("FUNCTION"))
(setf (gethash "CLEAR-INPUT" *name*) '("FUNCTION"))
(setf (gethash "CLEAR-OUTPUT" *name*) '("FUNCTION"))
(setf (gethash "CLOSE" *name*) '("FUNCTION"))
(setf (gethash "CLRHASH" *name*) '("FUNCTION"))
(setf (gethash "CODE-CHAR" *name*) '("FUNCTION"))
(setf (gethash "COERCE" *name*) '("FUNCTION"))
(setf (gethash "COMPILE" *name*) '("FUNCTION"))
(setf (gethash "COMPILED-FUNCTION" *name*) '("TYPE"))
(setf (gethash "COMPILED-FUNCTION-P" *name*) '("FUNCTION"))
(setf (gethash "COMPILER-MACRO-FUNCTION" *name*) '("ACCESSOR"))
(setf (gethash "COMPLEMENT" *name*) '("FUNCTION"))
(setf (gethash "COMPUTE-APPLICABLE-METHODS" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "COMPUTE-RESTARTS" *name*) '("FUNCTION"))
(setf (gethash "CONCATENATE" *name*) '("FUNCTION"))
(setf (gethash "CONCATENATED-STREAM" *name*) '("SYSTEM-CLASS"))
(setf (gethash "CONCATENATED-STREAM-STREAMS" *name*) '("FUNCTION"))
(setf (gethash "COND" *name*) '("MACRO"))
(setf (gethash "CONDITION" *name*) '("CONDITION-TYPE"))
(setf (gethash "CONS" *name*) '("FUNCTION" "SYSTEM-CLASS"))
(setf (gethash "CONSP" *name*) '("FUNCTION"))
(setf (gethash "CONSTANTLY" *name*) '("FUNCTION"))
(setf (gethash "CONSTANTP" *name*) '("FUNCTION"))
(setf (gethash "CONTINUE" *name*) '("FUNCTION" "RESTART"))
(setf (gethash "CONTROL-ERROR" *name*) '("CONDITION-TYPE"))
(setf (gethash "COPY-ALIST" *name*) '("FUNCTION"))
(setf (gethash "COPY-LIST" *name*) '("FUNCTION"))
(setf (gethash "COPY-PPRINT-DISPATCH" *name*) '("FUNCTION"))
(setf (gethash "COPY-SEQ" *name*) '("FUNCTION"))
(setf (gethash "COPY-STRUCTURE" *name*) '("FUNCTION"))
(setf (gethash "COPY-SYMBOL" *name*) '("FUNCTION"))
(setf (gethash "COPY-TREE" *name*) '("FUNCTION"))
(setf (gethash "COUNT" *name*) '("FUNCTION"))
(setf (gethash "COUNT-IF" *name*) '("FUNCTION"))
(setf (gethash "COUNT-IF-NOT" *name*) '("FUNCTION"))
(setf (gethash "CTYPECASE" *name*) '("MACRO"))
(setf (gethash "DECLAIM" *name*) '("MACRO"))
(setf (gethash "DECLARATION" *name*) '("DECLARATION"))
(setf (gethash "DECLARE" *name*) '("SYMBOL"))
(setf (gethash "DEFCLASS" *name*) '("MACRO"))
(setf (gethash "DEFCONSTANT" *name*) '("MACRO"))
(setf (gethash "DEFGENERIC" *name*) '("MACRO"))
(setf (gethash "DEFINE-COMPILER-MACRO" *name*) '("MACRO"))
(setf (gethash "DEFINE-CONDITION" *name*) '("MACRO"))
(setf (gethash "DEFINE-METHOD-COMBINATION" *name*) '("MACRO"))
(setf (gethash "DEFINE-MODIFY-MACRO" *name*) '("MACRO"))
(setf (gethash "DEFINE-SETF-EXPANDER" *name*) '("MACRO"))
(setf (gethash "DEFINE-SYMBOL-MACRO" *name*) '("MACRO"))
(setf (gethash "DEFMACRO" *name*) '("MACRO"))
(setf (gethash "DEFMETHOD" *name*) '("MACRO"))
(setf (gethash "DEFPACKAGE" *name*) '("MACRO"))
(setf (gethash "DEFPARAMETER" *name*) '("MACRO"))
(setf (gethash "DEFSETF" *name*) '("MACRO"))
(setf (gethash "DEFSTRUCT" *name*) '("MACRO"))
(setf (gethash "DEFTYPE" *name*) '("MACRO"))
(setf (gethash "DEFUN" *name*) '("MACRO"))
(setf (gethash "DEFVAR" *name*) '("MACRO"))
(setf (gethash "DELETE" *name*) '("FUNCTION"))
(setf (gethash "DELETE-DUPLICATES" *name*) '("FUNCTION"))
(setf (gethash "DELETE-FILE" *name*) '("FUNCTION"))
(setf (gethash "DELETE-IF" *name*) '("FUNCTION"))
(setf (gethash "DELETE-IF-NOT" *name*) '("FUNCTION"))
(setf (gethash "DELETE-PACKAGE" *name*) '("FUNCTION"))
(setf (gethash "DESTRUCTURING-BIND" *name*) '("MACRO"))
(setf (gethash "DIGIT-CHAR" *name*) '("FUNCTION"))
(setf (gethash "DIGIT-CHAR-P" *name*) '("FUNCTION"))
(setf (gethash "DIRECTORY" *name*) '("FUNCTION"))
(setf (gethash "DIRECTORY-NAMESTRING" *name*) '("FUNCTION"))
(setf (gethash "DO" *name*) '("MACRO"))
(setf (gethash "DO*" *name*) '("MACRO"))
(setf (gethash "DO-ALL-SYMBOLS" *name*) '("MACRO"))
(setf (gethash "DO-EXTERNAL-SYMBOLS" *name*) '("MACRO"))
(setf (gethash "DO-SYMBOLS" *name*) '("MACRO"))
(setf (gethash "DOCUMENTATION" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "DOLIST" *name*) '("MACRO"))
(setf (gethash "DOTIMES" *name*) '("MACRO"))
(setf (gethash "DYNAMIC-EXTENT" *name*) '("DECLARATION"))
(setf (gethash "ECASE" *name*) '("MACRO"))
(setf (gethash "ECHO-STREAM" *name*) '("SYSTEM-CLASS"))
(setf (gethash "ECHO-STREAM-INPUT-STREAM" *name*) '("FUNCTION"))
(setf (gethash "ECHO-STREAM-OUTPUT-STREAM" *name*) '("FUNCTION"))
(setf (gethash "EIGHTH" *name*) '("ACCESSOR"))
(setf (gethash "ELT" *name*) '("ACCESSOR"))
(setf (gethash "END-OF-FILE" *name*) '("CONDITION-TYPE"))
(setf (gethash "ENDP" *name*) '("FUNCTION"))
(setf (gethash "ENOUGH-NAMESTRING" *name*) '("FUNCTION"))
(setf (gethash "ENSURE-DIRECTORIES-EXIST" *name*) '("FUNCTION"))
(setf (gethash "ENSURE-GENERIC-FUNCTION" *name*) '("FUNCTION"))
(setf (gethash "EQ" *name*) '("FUNCTION"))
(setf (gethash "EQL" *name*) '("FUNCTION" "TYPE-SPECIFIER"))
(setf (gethash "EQUAL" *name*) '("FUNCTION"))
(setf (gethash "EQUALP" *name*) '("FUNCTION"))
(setf (gethash "ERROR" *name*) '("FUNCTION" "CONDITION-TYPE"))
(setf (gethash "ETYPECASE" *name*) '("MACRO"))
(setf (gethash "EVAL" *name*) '("FUNCTION"))
(setf (gethash "EVAL-WHEN" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "EVERY" *name*) '("FUNCTION"))
(setf (gethash "EXPORT" *name*) '("FUNCTION"))
(setf (gethash "EXTENDED-CHAR" *name*) '("TYPE"))
(setf (gethash "FBOUNDP" *name*) '("FUNCTION"))
(setf (gethash "FDEFINITION" *name*) '("ACCESSOR"))
(setf (gethash "FIFTH" *name*) '("ACCESSOR"))
(setf (gethash "FILE-AUTHOR" *name*) '("FUNCTION"))
(setf (gethash "FILE-ERROR" *name*) '("CONDITION-TYPE"))
(setf (gethash "FILE-ERROR-PATHNAME" *name*) '("FUNCTION"))
(setf (gethash "FILE-LENGTH" *name*) '("FUNCTION"))
(setf (gethash "FILE-NAMESTRING" *name*) '("FUNCTION"))
(setf (gethash "FILE-POSITION" *name*) '("FUNCTION"))
(setf (gethash "FILE-STREAM" *name*) '("SYSTEM-CLASS"))
(setf (gethash "FILE-STRING-LENGTH" *name*) '("FUNCTION"))
(setf (gethash "FILE-WRITE-DATE" *name*) '("FUNCTION"))
(setf (gethash "FILL" *name*) '("FUNCTION"))
(setf (gethash "FILL-POINTER" *name*) '("ACCESSOR"))
(setf (gethash "FIND" *name*) '("FUNCTION"))
(setf (gethash "FIND-ALL-SYMBOLS" *name*) '("FUNCTION"))
(setf (gethash "FIND-CLASS" *name*) '("ACCESSOR"))
(setf (gethash "FIND-IF" *name*) '("FUNCTION"))
(setf (gethash "FIND-IF-NOT" *name*) '("FUNCTION"))
(setf (gethash "FIND-METHOD" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "FIND-PACKAGE" *name*) '("FUNCTION"))
(setf (gethash "FIND-RESTART" *name*) '("FUNCTION"))
(setf (gethash "FIND-SYMBOL" *name*) '("FUNCTION"))
(setf (gethash "FINISH-OUTPUT" *name*) '("FUNCTION"))
(setf (gethash "FIRST" *name*) '("ACCESSOR"))
(setf (gethash "FLET" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "FMAKUNBOUND" *name*) '("FUNCTION"))
(setf (gethash "FORCE-OUTPUT" *name*) '("FUNCTION"))
(setf (gethash "FORMATTER" *name*) '("MACRO"))
(setf (gethash "FOURTH" *name*) '("ACCESSOR"))
(setf (gethash "FRESH-LINE" *name*) '("FUNCTION"))
(setf (gethash "FTYPE" *name*) '("DECLARATION"))
(setf (gethash "FUNCALL" *name*) '("FUNCTION"))
(setf (gethash "FUNCTION" *name*) '("SPECIAL-OPERATOR" "SYSTEM-CLASS"))
(setf (gethash "FUNCTION-KEYWORDS" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "FUNCTION-LAMBDA-EXPRESSION" *name*) '("FUNCTION"))
(setf (gethash "FUNCTIONP" *name*) '("FUNCTION"))
(setf (gethash "GENERIC-FUNCTION" *name*) '("SYSTEM-CLASS"))
(setf (gethash "GENSYM" *name*) '("FUNCTION"))
(setf (gethash "GENTEMP" *name*) '("FUNCTION"))
(setf (gethash "GET" *name*) '("ACCESSOR"))
(setf (gethash "GET-OUTPUT-STREAM-STRING" *name*) '("FUNCTION"))
(setf (gethash "GET-PROPERTIES" *name*) '("FUNCTION"))
(setf (gethash "GET-SETF-EXPANSION" *name*) '("FUNCTION"))
(setf (gethash "GETF" *name*) '("ACCESSOR"))
(setf (gethash "GETHASH" *name*) '("ACCESSOR"))
(setf (gethash "GO" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "GRAPHIC-CHAR-P" *name*) '("FUNCTION"))
(setf (gethash "HANDLER-BIND" *name*) '("MACRO"))
(setf (gethash "HANDLER-CASE" *name*) '("MACRO"))
(setf (gethash "HASH-TABLE" *name*) '("SYSTEM-CLASS"))
(setf (gethash "HASH-TABLE-COUNT" *name*) '("FUNCTION"))
(setf (gethash "HASH-TABLE-P" *name*) '("FUNCTION"))
(setf (gethash "HASH-TABLE-REHASH-SIZE" *name*) '("FUNCTION"))
(setf (gethash "HASH-TABLE-REHASH-THRESHOLD" *name*) '("FUNCTION"))
(setf (gethash "HASH-TABLE-SIZE" *name*) '("FUNCTION"))
(setf (gethash "HASH-TABLE-TEST" *name*) '("FUNCTION"))
(setf (gethash "HOST-NAMESTRING" *name*) '("FUNCTION"))
(setf (gethash "IDENTITY" *name*) '("FUNCTION"))
(setf (gethash "IF" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "IGNORABLE" *name*) '("DECLARATION"))
(setf (gethash "IGNORE" *name*) '("DECLARATION"))
(setf (gethash "IGNORE-ERRORS" *name*) '("MACRO"))
(setf (gethash "IMPORT" *name*) '("FUNCTION"))
(setf (gethash "IN-PACKAGE" *name*) '("MACRO"))
(setf (gethash "INITIALIZE-INSTANCE" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "INLINE" *name*) '("DECLARATION"))
(setf (gethash "INPUT-STREAM-P" *name*) '("FUNCTION"))
(setf (gethash "INTERACTIVE-STREAM-P" *name*) '("FUNCTION"))
(setf (gethash "INTERN" *name*) '("FUNCTION"))
(setf (gethash "INTERSECTION" *name*) '("FUNCTION"))
(setf (gethash "INVALID-METHOD-ERROR" *name*) '("FUNCTION"))
(setf (gethash "INVOKE-DEBUGGER" *name*) '("FUNCTION"))
(setf (gethash "INVOKE-RESTART" *name*) '("FUNCTION"))
(setf (gethash "INVOKE-RESTART-INTERACTIVELY" *name*) '("FUNCTION"))
(setf (gethash "KEYWORD" *name*) '("TYPE"))
(setf (gethash "KEYWORDP" *name*) '("FUNCTION"))
(setf (gethash "LABELS" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "LAMBDA" *name*) '("MACRO" "SYMBOL"))
(setf (gethash "LAMBDA-LIST-KEYWORDS" *name*) '("CONSTANT-VARIABLE"))
(setf (gethash "LAMBDA-PARAMETERS-LIMIT" *name*) '("CONSTANT-VARIABLE"))
(setf (gethash "LAST" *name*) '("FUNCTION"))
(setf (gethash "LDIFF" *name*) '("FUNCTION"))
(setf (gethash "LENGTH" *name*) '("FUNCTION"))
(setf (gethash "LET" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "LET*" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "LIST" *name*) '("FUNCTION" "SYSTEM-CLASS"))
(setf (gethash "LIST*" *name*) '("FUNCTION"))
(setf (gethash "LIST-ALL-PACKAGES" *name*) '("FUNCTION"))
(setf (gethash "LIST-LENGTH" *name*) '("FUNCTION"))
(setf (gethash "LISTEN" *name*) '("FUNCTION"))
(setf (gethash "LISTP" *name*) '("FUNCTION"))
(setf (gethash "LOAD-LOGICAL-PATHNAME-TRANSLATIONS" *name*) '("FUNCTION"))
(setf (gethash "LOAD-TIME-VALUE" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "LOCALLY" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "LOGICAL-PATHNAME" *name*) '("FUNCTION" "SYSTEM-CLASS"))
(setf (gethash "LOGICAL-PATHNAME-TRANSLATIONS" *name*) '("ACCESSOR"))
(setf (gethash "LOOP" *name*) '("MACRO"))
(setf (gethash "LOOP-FINISH" *name*) '("LOCA-MACRO"))
(setf (gethash "LOWER-CASE-P" *name*) '("FUNCTION"))
(setf (gethash "MACRO-FUNCTION" *name*) '("ACCESSOR"))
(setf (gethash "MACROEXPAND" *name*) '("FUNCTION"))
(setf (gethash "MACROEXPAND-1" *name*) '("FUNCTION"))
(setf (gethash "MACROLET" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "MAKE-ARRAY" *name*) '("FUNCTION"))
(setf (gethash "MAKE-BROADCAST-STREAM" *name*) '("FUNCTION"))
(setf (gethash "MAKE-CONCATENATED-STREAM" *name*) '("FUNCTION"))
(setf (gethash "MAKE-CONDITION" *name*) '("FUNCTION"))
(setf (gethash "MAKE-ECHO-STREAM" *name*) '("FUNCTION"))
(setf (gethash "MAKE-HASH-TABLE" *name*) '("FUNCTION"))
(setf (gethash "MAKE-INSTANCE" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "MAKE-INSTANCES-OBSOLETE" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "MAKE-LIST" *name*) '("FUNCTION"))
(setf (gethash "MAKE-LOAD-FORM" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "MAKE-LOAD-FORM-SAVING-SLOTS" *name*) '("FUNCTION"))
(setf (gethash "MAKE-METHOD" *name*) '("LOCAL-MACRO"))
(setf (gethash "MAKE-PACKAGE" *name*) '("FUNCTION"))
(setf (gethash "MAKE-PATHNAME" *name*) '("FUNCTION"))
(setf (gethash "MAKE-SEQUENCE" *name*) '("FUNCTION"))
(setf (gethash "MAKE-STRING" *name*) '("FUNCTION"))
(setf (gethash "MAKE-STRING-INPUT-STREAM" *name*) '("FUNCTION"))
(setf (gethash "MAKE-STRING-OUTPUT-STREAM" *name*) '("FUNCTION"))
(setf (gethash "MAKE-SYMBOL" *name*) '("FUNCTION"))
(setf (gethash "MAKE-SYNONYM-STREAM" *name*) '("FUNCTION"))
(setf (gethash "MAKE-TWO-WAY-STREAM" *name*) '("FUNCTION"))
(setf (gethash "MAKUNBOUND" *name*) '("FUNCTION"))
(setf (gethash "MAP" *name*) '("FUNCTION"))
(setf (gethash "MAP-INTO" *name*) '("FUNCTION"))
(setf (gethash "MAPC" *name*) '("FUNCTION"))
(setf (gethash "MAPCAN" *name*) '("FUNCTION"))
(setf (gethash "MAPCAR" *name*) '("FUNCTION"))
(setf (gethash "MAPCON" *name*) '("FUNCTION"))
(setf (gethash "MAPHASH" *name*) '("FUNCTION"))
(setf (gethash "MAPL" *name*) '("FUNCTION"))
(setf (gethash "MAPLIST" *name*) '("FUNCTION"))
(setf (gethash "MEMBER" *name*) '("FUNCTION" "TYPE-SPECIFIER"))
(setf (gethash "MEMBER-IF" *name*) '("FUNCTION"))
(setf (gethash "MEMBER-IF-NOT" *name*) '("FUNCTION"))
(setf (gethash "MERGE" *name*) '("FUNCTION"))
(setf (gethash "MERGE-PATHNAMES" *name*) '("FUNCTION"))
(setf (gethash "METHOD" *name*) '("SYSTEM-CLASS"))
(setf (gethash "METHOD-COMBINATION" *name*) '("SYSTEM-CLASS"))
(setf (gethash "METHOD-COMBINATION-ERROR" *name*) '("FUNCTION"))
(setf (gethash "METHOD-QUALIFIERS" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "MISMATCH" *name*) '("FUNCTION"))
(setf (gethash "MUFFLE-WARNING" *name*) '("FUNCTION" "RESTART"))
(setf (gethash "MULTIPLE-VALUE-BIND" *name*) '("MACRO"))
(setf (gethash "MULTIPLE-VALUE-CALL" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "MULTIPLE-VALUE-LIST" *name*) '("MACRO"))
(setf (gethash "MULTIPLE-VALUE-PROG1" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "MULTIPLE-VALUE-SETQ" *name*) '("MACRO"))
(setf (gethash "MULTIPLE-VALUES-LIMIT" *name*) '("CONSTANT-VARIABLE"))
(setf (gethash "NAME-CHAR" *name*) '("FUNCTION"))
(setf (gethash "NAMESTRING" *name*) '("FUNCTION"))
(setf (gethash "NBUTLAST" *name*) '("FUNCTION"))
(setf (gethash "NCONC" *name*) '("FUNCTION"))
(setf (gethash "NEXT-METHOD-P" *name*) '("LOCAL-FUNCTION"))
(setf (gethash "NIL" *name*) '("CONSTANT-VARIABLE" "TYPE"))
(setf (gethash "NINTERSECTION" *name*) '("FUNCTION"))
(setf (gethash "NINTH" *name*) '("ACCESSOR"))
(setf (gethash "NO-APPLICABLE-METHOD" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "NO-NEXT-METHOD" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "NOT" *name*) '("FUNCTION" "TYPE-SPECIFIER"))
(setf (gethash "NOTANY" *name*) '("FUNCTION"))
(setf (gethash "NOTEVERY" *name*) '("FUNCTION"))
(setf (gethash "NOTINLINE" *name*) '("DECLARATION"))
(setf (gethash "NRECONC" *name*) '("FUNCTION"))
(setf (gethash "NREVERSE" *name*) '("FUNCTION"))
(setf (gethash "NSET-DIFFERENCE" *name*) '("FUNCTION"))
(setf (gethash "NSET-EXCLUSIVE-OR" *name*) '("FUNCTION"))
(setf (gethash "NSTRING-CAPITALIZE" *name*) '("FUNCTION"))
(setf (gethash "NSTRING-DOWNCASE" *name*) '("FUNCTION"))
(setf (gethash "NSTRING-UPCASE" *name*) '("FUNCTION"))
(setf (gethash "NSUBLIS" *name*) '("FUNCTION"))
(setf (gethash "NSUBST" *name*) '("FUNCTION"))
(setf (gethash "NSUBST-IF" *name*) '("FUNCTION"))
(setf (gethash "NSUBST-IF-NOT" *name*) '("FUNCTION"))
(setf (gethash "NSUBSTITUTE" *name*) '("FUNCTION"))
(setf (gethash "NSUBSTITUTE-IF" *name*) '("FUNCTION"))
(setf (gethash "NSUBSTITUTE-IF-NOT" *name*) '("FUNCTION"))
(setf (gethash "NTH" *name*) '("ACCESSOR"))
(setf (gethash "NTH-VALUE" *name*) '("MACRO"))
(setf (gethash "NTHCDR" *name*) '("FUNCTION"))
(setf (gethash "NULL" *name*) '("FUNCTION" "SYSTEM-CLASS"))
(setf (gethash "NUNION" *name*) '("FUNCTION"))
(setf (gethash "OPEN" *name*) '("FUNCTION"))
(setf (gethash "OPEN-STREAM-P" *name*) '("FUNCTION"))
(setf (gethash "OPTIMIZE" *name*) '("DECLARATION"))
(setf (gethash "OR" *name*) '("MACRO" "TYPE-SPECIFIER"))
(setf (gethash "OUTPUT-STREAM-P" *name*) '("FUNCTION"))
(setf (gethash "PACKAGE" *name*) '("SYSTEM-CLASS"))
(setf (gethash "PACKAGE-ERROR" *name*) '("CONDITION-TYPE"))
(setf (gethash "PACKAGE-ERROR-PACKAGE" *name*) '("FUNCTION"))
(setf (gethash "PACKAGE-NAME" *name*) '("FUNCTION"))
(setf (gethash "PACKAGE-NICKNAMES" *name*) '("FUNCTION"))
(setf (gethash "PACKAGE-SHADOWING-SYMBOLS" *name*) '("FUNCTION"))
(setf (gethash "PACKAGE-USE-LIST" *name*) '("FUNCTION"))
(setf (gethash "PACKAGE-USED-BY-LIST" *name*) '("FUNCTION"))
(setf (gethash "PACKAGEP" *name*) '("FUNCTION"))
(setf (gethash "PAIRLIS" *name*) '("FUNCTION"))
(setf (gethash "PARSE-ERROR" *name*) '("CONDITION-TYPE"))
(setf (gethash "PARSE-NAMESTRING" *name*) '("FUNCTION"))
(setf (gethash "PATHNAME" *name*) '("FUNCTION" "SYSTEM-CLASS"))
(setf (gethash "PATHNAME-DEVICE" *name*) '("FUNCTION"))
(setf (gethash "PATHNAME-DIRECTORY" *name*) '("FUNCTION"))
(setf (gethash "PATHNAME-HOST" *name*) '("FUNCTION"))
(setf (gethash "PATHNAME-MATCH-P" *name*) '("FUNCTION"))
(setf (gethash "PATHNAME-NAME" *name*) '("FUNCTION"))
(setf (gethash "PATHNAME-TYPE" *name*) '("FUNCTION"))
(setf (gethash "PATHNAME-VERSION" *name*) '("FUNCTION"))
(setf (gethash "PATHNAMEP" *name*) '("FUNCTION"))
(setf (gethash "PEEK-CHAR" *name*) '("FUNCTION"))
(setf (gethash "POP" *name*) '("MACRO"))
(setf (gethash "POSITION" *name*) '("FUNCTION"))
(setf (gethash "POSITION-IF" *name*) '("FUNCTION"))
(setf (gethash "POSITION-IF-NOT" *name*) '("FUNCTION"))
(setf (gethash "PPRINT" *name*) '("FUNCTION"))
(setf (gethash "PPRINT-DISPATCH" *name*) '("FUNCTION"))
(setf (gethash "PPRINT-EXIT-IF-LIST-EXHAUSTED" *name*) '("FUNCTION"))
(setf (gethash "PPRINT-FILL" *name*) '("FUNCTION"))
(setf (gethash "PPRINT-INDENT" *name*) '("FUNCTION"))
(setf (gethash "PPRINT-LINEAR" *name*) '("FUNCTION"))
(setf (gethash "PPRINT-LOGICAL-BLOCK" *name*) '("MACRO"))
(setf (gethash "PPRINT-NEWLINE" *name*) '("FUNCTION"))
(setf (gethash "PPRINT-POP" *name*) '("LOCAL-MACRO"))
(setf (gethash "PPRINT-TAB" *name*) '("FUNCTION"))
(setf (gethash "PPRINT-TABULAR" *name*) '("FUNCTION"))
(setf (gethash "PRIN1" *name*) '("FUNCTION"))
(setf (gethash "PRIN1-TO-STRING" *name*) '("FUNCTION"))
(setf (gethash "PRINC" *name*) '("FUNCTION"))
(setf (gethash "PRINC-TO-STRING" *name*) '("FUNCTION"))
(setf (gethash "PRINT" *name*) '("FUNCTION"))
(setf (gethash "PRINT-OBJECT" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "PRINT-UNREADABLE-OBJECT" *name*) '("MACRO"))
(setf (gethash "PROBE-FILE" *name*) '("FUNCTION"))
(setf (gethash "PROCLAIM" *name*) '("FUNCTION"))
(setf (gethash "PROG" *name*) '("MACRO"))
(setf (gethash "PROG*" *name*) '("MACRO"))
(setf (gethash "PROG1" *name*) '("MACRO"))
(setf (gethash "PROG2" *name*) '("MACRO"))
(setf (gethash "PROGN" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "PROGRAM-ERROR" *name*) '("CONDITION-TYPE"))
(setf (gethash "PROGV" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "PSETF" *name*) '("MACRO"))
(setf (gethash "PSETQ" *name*) '("MACRO"))
(setf (gethash "PUSH" *name*) '("MACRO"))
(setf (gethash "PUSHNEW" *name*) '("FUNCTION"))
(setf (gethash "QUOTE" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "RASSOC" *name*) '("FUNCTION"))
(setf (gethash "RASSOC-IF" *name*) '("FUNCTION"))
(setf (gethash "RASSOC-IF-NOT" *name*) '("FUNCTION"))
(setf (gethash "READ-BYTE" *name*) '("FUNCTION"))
(setf (gethash "READ-CHAR" *name*) '("FUNCTION"))
(setf (gethash "READ-CHAR-NO-HANG" *name*) '("FUNCTION"))
(setf (gethash "READ-LINE" *name*) '("FUNCTION"))
(setf (gethash "READ-SEQUENCE" *name*) '("FUNCTION"))
(setf (gethash "REDUCE" *name*) '("FUNCTION"))
(setf (gethash "REINITIALIZE-INSTANCE" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "REMF" *name*) '("MACRO"))
(setf (gethash "REMHASH" *name*) '("FUNCTION"))
(setf (gethash "REMOVE" *name*) '("FUNCTION"))
(setf (gethash "REMOVE-DUPLICATES" *name*) '("FUNCTION"))
(setf (gethash "REMOVE-IF" *name*) '("FUNCTION"))
(setf (gethash "REMOVE-IF-NOT" *name*) '("FUNCTION"))
(setf (gethash "REMOVE-METHOD" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "REMPROP" *name*) '("FUNCTION"))
(setf (gethash "RENAME-FILE" *name*) '("FUNCTION"))
(setf (gethash "RENAME-PACKAGE" *name*) '("FUNCTION"))
(setf (gethash "REPLACE" *name*) '("FUNCTION"))
(setf (gethash "REST" *name*) '("ACCESSOR"))
(setf (gethash "RESTART" *name*) '("SYSTEM-CLASS"))
(setf (gethash "RESTART-BIND" *name*) '("MACRO"))
(setf (gethash "RESTART-CASE" *name*) '("MACRO"))
(setf (gethash "RESTART-NAME" *name*) '("FUNCTION"))
(setf (gethash "RETURN" *name*) '("MACRO"))
(setf (gethash "RETURN-FROM" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "REVAPPEND" *name*) '("FUNCTION"))
(setf (gethash "REVERSE" *name*) '("FUNCTION"))
(setf (gethash "ROTATEF" *name*) '("MACRO"))
(setf (gethash "ROW-MAJOR-AREF" *name*) '("ACCESSOR"))
(setf (gethash "RPLACA" *name*) '("FUNCTION"))
(setf (gethash "RPLACD" *name*) '("FUNCTION"))
(setf (gethash "SATISFIES" *name*) '("TYPE-SPECIFIER"))
(setf (gethash "SBIT" *name*) '("ACCESSOR"))
(setf (gethash "SCHAR" *name*) '("ACCESSOR"))
(setf (gethash "SEARCH" *name*) '("FUNCTION"))
(setf (gethash "SECOND" *name*) '("ACCESSOR"))
(setf (gethash "SEQUENCE" *name*) '("SYSTEM-CLASS"))
(setf (gethash "SERIOUS-CONDITION" *name*) '("CONDITION-TYPE"))
(setf (gethash "SET" *name*) '("FUNCTION"))
(setf (gethash "SET-DIFFERENCE" *name*) '("FUNCTION"))
(setf (gethash "SET-EXCLUSIVE-OR" *name*) '("FUNCTION"))
(setf (gethash "SET-PPRINT-DISPATCH" *name*) '("FUNCTION"))
(setf (gethash "SETF" *name*) '("MACRO"))
(setf (gethash "SETQ" *name*) '("SPECIAL-FORM"))
(setf (gethash "SEVENTH" *name*) '("ACCESSOR"))
(setf (gethash "SHADOW" *name*) '("FUNCTION"))
(setf (gethash "SHADOWING-IMPORT" *name*) '("FUNCTION"))
(setf (gethash "SHARED-INITIALIZE" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "SHIFTF" *name*) '("MACRO"))
(setf (gethash "SIGNAL" *name*) '("FUNCTION"))
(setf (gethash "SIMPLE-ARRAY" *name*) '("TYPE"))
(setf (gethash "SIMPLE-BASE-STRING" *name*) '("TYPE"))
(setf (gethash "SIMPLE-BIT-VECTOR" *name*) '("TYPE"))
(setf (gethash "SIMPLE-BIT-VECTOR-P" *name*) '("FUNCTION"))
(setf (gethash "SIMPLE-CONDITION" *name*) '("CONDITION-TYPE"))
(setf (gethash "SIMPLE-CONDITION-FORMAT-ARGUMENTS" *name*) '("FUNCTION"))
(setf (gethash "SIMPLE-CONDITION-FORMAT-CONTROL" *name*) '("FUNCTION"))
(setf (gethash "SIMPLE-ERROR" *name*) '("CONDITION-TYPE"))
(setf (gethash "SIMPLE-STRING" *name*) '("TYPE"))
(setf (gethash "SIMPLE-STRING-P" *name*) '("FUNCTION"))
(setf (gethash "SIMPLE-TYPE-ERROR" *name*) '("CONDITION-TYPE"))
(setf (gethash "SIMPLE-VECTOR" *name*) '("TYPE"))
(setf (gethash "SIMPLE-VECTOR-P" *name*) '("FUNCTION"))
(setf (gethash "SIMPLE-WARNING" *name*) '("CONDITION-TYPE"))
(setf (gethash "SIXTH" *name*) '("ACCESSOR"))
(setf (gethash "SLOT-BOUNDP" *name*) '("FUNCTION"))
(setf (gethash "SLOT-BOUNDP-USING-CLASS" *name*) '("GENERIC-FUNCTION"))
(setf (gethash "SLOT-EXISTS-P" *name*) '("FUNCTION"))
(setf (gethash "SLOT-MAKUNBOUND" *name*) '("FUNCTION"))
(setf (gethash "SLOT-MAKUNBOUND-USING-CLASS" *name*) '("GENERIC-FUNCTION"))
(setf (gethash "SLOT-MISSING" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "SLOT-UNBOUND" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "SLOT-VALUE" *name*) '("FUNCTION"))
(setf (gethash "SLOT-VALUE-USING-CLASS" *name*) '("GENERIC-FUNCTION"))
(setf (gethash "SOME" *name*) '("FUNCTION"))
(setf (gethash "SORT" *name*) '("FUNCTION"))
(setf (gethash "SPECIAL" *name*) '("DECLARATION"))
(setf (gethash "SPECIAL-OPERATOR-P" *name*) '("FUNCTION"))
(setf (gethash "STABLE-SORT" *name*) '("FUNCTION"))
(setf (gethash "STANDARD-CHAR" *name*) '("TYPE"))
(setf (gethash "STANDARD-CHAR-P" *name*) '("FUNCTION"))
(setf (gethash "STANDARD-CLASS" *name*) '("SYSTEM-CLASS"))
(setf (gethash "STANDARD-GENERIC-FUNCTION" *name*) '("SYSTEM-CLASS"))
(setf (gethash "STANDARD-METHOD" *name*) '("SYSTEM-CLASS"))
(setf (gethash "STANDARD-OBJECT" *name*) '("CLASS"))
(setf (gethash "STORAGE-CONDITION" *name*) '("CONDITION-TYPE"))
(setf (gethash "STORE-VALUE" *name*) '("FUNCTION" "RESTART"))
(setf (gethash "STREAM" *name*) '("SYSTEM-CLASS"))
(setf (gethash "STREAM-ELEMENT-TYPE" *name*) '("FUNCTION"))
(setf (gethash "STREAM-ERROR" *name*) '("CONDITION-TYPE"))
(setf (gethash "STREAM-ERROR-STREAM" *name*) '("FUNCTION"))
(setf (gethash "STREAM-EXTERNAL-FORMAT" *name*) '("FUNCTION"))
(setf (gethash "STREAMP" *name*) '("FUNCTION"))
(setf (gethash "STRING" *name*) '("FUNCTION" "SYSTEM-CLASS"))
(setf (gethash "STRING-CAPITALIZE" *name*) '("FUNCTION"))
(setf (gethash "STRING-DOWNCASE" *name*) '("FUNCTION"))
(setf (gethash "STRING-EQUAL" *name*) '("FUNCTION"))
(setf (gethash "STRING-GREATERP" *name*) '("FUNCTION"))
(setf (gethash "STRING-LEFT-TRIM" *name*) '("FUNCTION"))
(setf (gethash "STRING-LESSP" *name*) '("FUNCTION"))
(setf (gethash "STRING-NOT-EQUAL" *name*) '("FUNCTION"))
(setf (gethash "STRING-NOT-GREATERP" *name*) '("FUNCTION"))
(setf (gethash "STRING-NOT-LESSP" *name*) '("FUNCTION"))
(setf (gethash "STRING-RIGHT-TRIM" *name*) '("FUNCTION"))
(setf (gethash "STRING-STREAM" *name*) '("SYSTEM-CLASS"))
(setf (gethash "STRING-TRIM" *name*) '("FUNCTION"))
(setf (gethash "STRING-UPCASE" *name*) '("FUNCTION"))
(setf (gethash "STRING/=" *name*) '("FUNCTION"))
(setf (gethash "STRING<" *name*) '("FUNCTION"))
(setf (gethash "STRING<=" *name*) '("FUNCTION"))
(setf (gethash "STRING=" *name*) '("FUNCTION"))
(setf (gethash "STRING>" *name*) '("FUNCTION"))
(setf (gethash "STRING>=" *name*) '("FUNCTION"))
(setf (gethash "STRINGP" *name*) '("FUNCTION"))
(setf (gethash "STRUCTURE-CLASS" *name*) '("SYSTEM-CLASS"))
(setf (gethash "STRUCTURE-OBJECT" *name*) '("CLASS"))
(setf (gethash "STYLE-WARNING" *name*) '("CONDITION-TYPE"))
(setf (gethash "SUBLIS" *name*) '("FUNCTION"))
(setf (gethash "SUBSEQ" *name*) '("ACCESSOR"))
(setf (gethash "SUBSETP" *name*) '("FUNCTION"))
(setf (gethash "SUBST" *name*) '("FUNCTION"))
(setf (gethash "SUBST-IF" *name*) '("FUNCTION"))
(setf (gethash "SUBST-IF-NOT" *name*) '("FUNCTION"))
(setf (gethash "SUBSTITUTE" *name*) '("FUNCTION"))
(setf (gethash "SUBSTITUTE-IF" *name*) '("FUNCTION"))
(setf (gethash "SUBSTITUTE-IF-NOT" *name*) '("FUNCTION"))
(setf (gethash "SUBTYPEP" *name*) '("FUNCTION"))
(setf (gethash "SVREF" *name*) '("ACCESSOR"))
(setf (gethash "SXHASH" *name*) '("FUNCTION"))
(setf (gethash "SYMBOL" *name*) '("SYSTEM-CLASS"))
(setf (gethash "SYMBOL-FUNCTION" *name*) '("ACCESSOR"))
(setf (gethash "SYMBOL-MACROLET" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "SYMBOL-NAME" *name*) '("FUNCTION"))
(setf (gethash "SYMBOL-PACKAGE" *name*) '("FUNCTION"))
(setf (gethash "SYMBOL-PLIST" *name*) '("ACCESSOR"))
(setf (gethash "SYMBOL-VALUE" *name*) '("ACCESSOR"))
(setf (gethash "SYMBOLP" *name*) '("FUNCTION"))
(setf (gethash "SYNONYM-STREAM" *name*) '("SYSTEM-CLASS"))
(setf (gethash "SYNONYM-STREAM-SYMBOL" *name*) '("FUNCTION"))
(setf (gethash "T" *name*) '("CONSTANT-VARIABLE" "SYSTEM-CLASS"))
(setf (gethash "TAGBODY" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "TAILP" *name*) '("FUNCTION"))
(setf (gethash "TENTH" *name*) '("ACCESSOR"))
(setf (gethash "TERPRI" *name*) '("FUNCTION"))
(setf (gethash "THE" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "THIRD" *name*) '("ACCESSOR"))
(setf (gethash "THROW" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "TRANSLATE-LOGICAL-PATHNAME" *name*) '("FUNCTION"))
(setf (gethash "TRANSLATE-PATHNAME" *name*) '("FUNCTION"))
(setf (gethash "TREE-EQUAL" *name*) '("FUNCTION"))
(setf (gethash "TRUENAME" *name*) '("FUNCTION"))
(setf (gethash "TWO-WAY-STREAM" *name*) '("SYSTEM-CLASS"))
(setf (gethash "TWO-WAY-STREAM-INPUT-STREAM" *name*) '("FUNCTION"))
(setf (gethash "TWO-WAY-STREAM-OUTPUT-STREAM" *name*) '("FUNCTION"))
(setf (gethash "TYPE" *name*) '("DECLARATION"))
(setf (gethash "TYPE-ERROR" *name*) '("CONDITION-TYPE"))
(setf (gethash "TYPE-ERROR-DATUM" *name*) '("FUNCTION"))
(setf (gethash "TYPE-ERROR-EXPECTED-TYPE" *name*) '("FUNCTION"))
(setf (gethash "TYPE-OF" *name*) '("FUNCTION"))
(setf (gethash "TYPECASE" *name*) '("MACRO"))
(setf (gethash "TYPEP" *name*) '("FUNCTION"))
(setf (gethash "UNBOUND-SLOT" *name*) '("CONDITION-TYPE"))
(setf (gethash "UNBOUND-SLOT-INSTANCE" *name*) '("FUNCTION"))
(setf (gethash "UNBOUND-VARIABLE" *name*) '("CONDITION-TYPE"))
(setf (gethash "UNDEFINED-FUNCTION" *name*) '("CONDITION-TYPE"))
(setf (gethash "UNEXPORT" *name*) '("FUNCTION"))
(setf (gethash "UNINTERN" *name*) '("FUNCTION"))
(setf (gethash "UNION" *name*) '("FUNCTION"))
(setf (gethash "UNLESS" *name*) '("MACRO"))
(setf (gethash "UNREAD-CHAR" *name*) '("FUNCTION"))
(setf (gethash "UNUSE-PACKAGE" *name*) '("FUNCTION"))
(setf (gethash "UNWIND-PROTECT" *name*) '("SPECIAL-OPERATOR"))
(setf (gethash "UPDATE-INSTANCE-FOR-DIFFERENT-CLASS" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "UPDATE-INSTANCE-FOR-REDEFINED-CLASS" *name*) '("STANDARD-GENERIC-FUNCTION"))
(setf (gethash "UPGRADED-ARRAY-ELEMENT-TYPE" *name*) '("FUNCTION"))
(setf (gethash "UPPER-CASE-P" *name*) '("FUNCTION"))
(setf (gethash "USE-PACKAGE" *name*) '("FUNCTION"))
(setf (gethash "USE-VALUE" *name*) '("FUNCTION" "RESTART"))
(setf (gethash "VALUES" *name*) '("ACCESSOR" "TYPE-SPECIFIER"))
(setf (gethash "VALUES-LIST" *name*) '("FUNCTION"))
(setf (gethash "VECTOR" *name*) '("FUNCTION" "SYSTEM-CLASS"))
(setf (gethash "VECTOR-POP" *name*) '("FUNCTION"))
(setf (gethash "VECTOR-PUSH" *name*) '("FUNCTION"))
(setf (gethash "VECTOR-PUSH-EXTEND" *name*) '("FUNCTION"))
(setf (gethash "VECTORP" *name*) '("FUNCTION"))
(setf (gethash "WARN" *name*) '("FUNCTION"))
(setf (gethash "WARNING" *name*) '("CONDITION-TYPE"))
(setf (gethash "WHEN" *name*) '("MACRO"))
(setf (gethash "WILD-PATHNAME-P" *name*) '("FUNCTION"))
(setf (gethash "WITH-ACCESSORS" *name*) '("MACRO"))
(setf (gethash "WITH-CONDITION-RESTARTS" *name*) '("MACRO"))
(setf (gethash "WITH-HASH-TABLE-ITERATOR" *name*) '("MACRO"))
(setf (gethash "WITH-INPUT-FROM-STRING" *name*) '("MACRO"))
(setf (gethash "WITH-OPEN-FILE" *name*) '("MACRO"))
(setf (gethash "WITH-OPEN-STREAM" *name*) '("MACRO"))
(setf (gethash "WITH-OUTPUT-TO-STRING" *name*) '("MACRO"))
(setf (gethash "WITH-PACKAGE-ITERATOR" *name*) '("MACRO"))
(setf (gethash "WITH-SIMPLE-RESTART" *name*) '("MACRO"))
(setf (gethash "WITH-SLOTS" *name*) '("MACRO"))
(setf (gethash "WRITE" *name*) '("FUNCTION"))
(setf (gethash "WRITE-BYTE" *name*) '("FUNCTION"))
(setf (gethash "WRITE-CHAR" *name*) '("FUNCTION"))
(setf (gethash "WRITE-LINE" *name*) '("FUNCTION"))
(setf (gethash "WRITE-SEQUENCE" *name*) '("FUNCTION"))
(setf (gethash "WRITE-STRING" *name*) '("FUNCTION"))
(setf (gethash "WRITE-TO-STRING" *name*) '("FUNCTION"))
(setf (gethash "Y-OR-N-P" *name*) '("FUNCTION"))
(setf (gethash "YES-OR-NO-P" *name*) '("FUNCTION"))
(setf (gethash "*BREAK-ON-SIGNALS*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*BREAK-ON-SIGNALS*"))
    (CHAPTER ("## 値の型") 2 "型指定子") (CHAPTER ("## 初期値") 2 (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "式" (CODE1 "(typep condition *break-on-signals*)") "が"
     (STRONG "true") "のとき、" (CODE1 "signal") "の呼び出しや、" "その他の暗黙的に" (CODE1 "signal")
     "を呼び出す、" (CODE1 "error") "のような操作は、" "そのコンディションを通知する前にデバッガーに入ります。" EOL2
     (CODE1 "continue") " " (CODE1 "restart") "は" (CODE1 "*break-on-signals*")
     "による処理の中断が生じたときに、" "通常の通知処理を継続するときに使われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "*break-on-signals* =>  NIL"
      "(ignore-errors (error 'simple-error :format-control \"Fooey!\"))"
      "=>  NIL, #<SIMPLE-ERROR 32207172>" NIL "(let ((*break-on-signals* 'error))"
      "  (ignore-errors (error 'simple-error :format-control \"Fooey!\")))"
      ">>  Break: Fooey!" ">>  BREAK entered because of *BREAK-ON-SIGNALS*."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Continue to signal." ">>   2: Top level." ">>  Debug> :CONTINUE 1"
      ">>  Continue to signal." "=>  NIL, #<SIMPLE-ERROR 32212257>" NIL
      "(let ((*break-on-signals* 'error))"
      "  (error 'simple-error :format-control \"Fooey!\"))" ">>  Break: Fooey!"
      ">>  BREAK entered because of *BREAK-ON-SIGNALS*."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Continue to signal." ">>   2: Top level." ">>  Debug> :CONTINUE 1"
      ">>  Continue to signal." ">>  Error: Fooey!"
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Top level." ">>  Debug> :CONTINUE 1" ">>  Top level."))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "break") "," (CODE1 "signal") "," (CODE1 "warn") ","
     (CODE1 "error") "," (CODE1 "typep") "," "9.1. コンディションシステムの説明")
    (CHAPTER ("## 備考") 2 (CODE1 "*break-on-signals*") "は、" "主に通知したコードのデバッグに使う意図があります。"
     (CODE1 "*break-on-signals*") "が設定されたとき、" "ユーザは最も厳しい仕様を選択することが推奨されます。"
     (CODE1 "*break-on-signals*") "を設定することは、" "コンディションの通知を捕捉することのモジュラー処理に違反します。" "実際には"
     (CODE1 "*break-on-signals*") "を設定することの完全な効果は、" "場合によっては予測できないかもしれません。" "なぜなら、ユーザーは"
     (CODE1 "signal") "がコード内で、" "どれくらいの種類や数で呼び出されているのか" "気が付いていないかもしれないからです。" EOL2
     (CODE1 "*break-on-signals*") "は、" "デバッガーに早く入ることができますが、" "このような場合でも" (CODE1 "error")
     "や" (CODE1 "cerror") "のような操作で起こる" "追加のデバッガーの起動を排除するようなものではありません。")))
(setf (gethash '("*BREAK-ON-SIGNALS*" . "VARIABLE") *table*) (gethash "*BREAK-ON-SIGNALS*" *table*))
(setf (gethash "*DEBUG-IO*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*DEBUG-IO*") ", " (CODE1 "*ERROR-OUTPUT*") ", "
     (CODE1 "*QUERY-IO*") "," " " (CODE1 "*STANDARD-INPUT*") ", "
     (CODE1 "*STANDARD-OUTPUT*") ", " (CODE1 "*TRACE-OUTPUT*"))
    (CHAPTER ("## 値の型") 2 (CODE1 "*standard-input*") "は、入力ストリーム" EOL1
     (CODE1 "*error-output*") "," (CODE1 "*standard-output*") ","
     (CODE1 "*trace-output*") "は、出力ストリーム" EOL1 (CODE1 "*debug-io*") ","
     (CODE1 "*query-io*") "は、双方向ストリーム")
    (CHAPTER ("## 初期値") 2 "実装依存ですが、" "開いたストリームでなければならず、" "それはI/Oカスタマイズ変数に対する一般化された"
     (CODE1 "synonym") "ストリームではなく、" "あるI/Oカスタマイズ変数の値に対する一般化された" (CODE1 "synonym")
     "ストリームの" "可能性があります。" "その初期値もまた一般化された" (CODE1 "synonym") "ストリームであり、"
     (CODE1 "*terminal-io*") "かその値のストリームかのどちらかを指します。")
    (CHAPTER ("## 定義") 2 "これらの変数はまとめて標準化されたI/Oカスタマイズ変数と呼ばれます。"
     "これらは、様々な標準化された操作と機能によって使われる入出力の" "標準での宛先を変更するために、束縛と代入をすることができます。" EOL2
     (CODE1 "*debug-io*") "の値は、デバッグI/Oと呼ばれ、" "対話式のデバッグ機能を使うためのストリームです。" EOL2
     (CODE1 "*error-output*") "の値は、エラー出力と呼ばれ、" "警告と非対話式エラーメッセージが送られるべきストリームです。" EOL2
     (CODE1 "*query-io*") "の値は、クエリ―I/Oと呼ばれ、" "ユーザーの質問と返答を行うために使われる双方向ストリームです。"
     "質問はこのストリームに出力され、" "返信はこのストリームから読み込まれるべきです。" EOL2 (CODE1 "*standard-input*")
     "の値は、標準入力と呼ばれ、" "多くの操作で入力ストリームが指定されなかったときに" "デフォルトの入力元として暗に指定されたものとして"
     "利用されるストリームです。" EOL2 (CODE1 "*standard-output*") "の値は、標準出力と呼ばれ、"
     "多くの操作で出力ストリームが指定されなかったときに" "デフォルトの出力元として暗に指定されたものとして" "利用されるストリームです。" EOL2
     (CODE1 "*trace-output*") "の値は、トレース出力と呼ばれ、" "トレースを行う関数（" (CODE1 "trace") "を参照）と、"
     (CODE1 "time") "マクロによる出力によって印字されるストリームです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-output-to-string (*error-output*)"
      "  (warn \"this string is sent to *error-output*\"))"
      "=>  \"Warning: this string is sent to *error-output*"
      "\" ;The exact format of this string is implementation-dependent." NIL
      "(with-input-from-string (*standard-input* \"1001\")"
      "   (+ 990 (read))) =>  1991                       " NIL
      "(progn (setq out (with-output-to-string (*standard-output*)"
      "                    (print \"print and format t send things to\")"
      "                    (format t \"*standard-output* now going to a string\")))"
      "       :done)" "=>  :DONE" "out" "=>  \""
      "\\\"print and format t send things to\\\" *standard-output* now going to a string\""
      NIL "(defun fact (n) (if (< n 2) 1 (* n (fact (- n 1)))))" "=>  FACT"
      "(trace fact)" "=>  (FACT)" ";; もちろん、トレースの出力の書式は実装依存です。"
      "(with-output-to-string (*trace-output*)" "  (fact 3)) " "=>  \"" "1 Enter FACT 3"
      "| 2 Enter FACT 2" "|   3 Enter FACT 1" "|   3 Exit FACT 1" "| 2 Exit FACT 2"
      "1 Exit FACT 6\""))
    (CHAPTER ("## 参考") 2 (CODE1 "*terminal-io*") "," (CODE1 "synonym-stream") ","
     (CODE1 "time") "," (CODE1 "trace") "," "9. コンディション," "23. リーダー," "22. プリンター")
    (CHAPTER ("## 備考") 2 "I/Oカスタマイズ変数の初期値に対する制限の意図は、" "実装の柔軟性を過度に制限することなく、"
     "これらの変数を別のI/Oカスタマイズ変数の値に束縛と代入することが" "常に安全であることを保証ためです。" EOL2 (CODE1 "*debug-io*")
     "と" (CODE1 "*query-io*") "の初期値を同じストリームに、" (CODE1 "*error-output*") "と"
     (CODE1 "*standard-output*") "の初期値を同じストリームにするような" "実装が一般的です。" EOL2 (CODE1 "y-or-n-p")
     "と" (CODE1 "yes-or-no-p") "関数は、" "入出力にクエリ―I/Oを使用します。" EOL2 "通常の"
     (CODE1 "Lisp read-eval-print-loop") "では、入力は標準入力から行います。" "多くの入力関数について、"
     (CODE1 "read") "と" (CODE1 "read-char") "を含む関数は、" "引数のデフォルトに標準入力のストリームを取ります。" EOL2
     "通常の" (CODE1 "Lisp read-eval-print-loop") "では、出力は標準出力から行います。" "多くの出力関数について、"
     (CODE1 "print") "と" (CODE1 "write-char") "を含む関数は、" "引数のデフォルトに標準出力のストリームを取ります。" EOL2
     "例えば、あるプログラムは出力をファイルに対して行いたいときは" (CODE1 "*standard-output*") "を束縛することによって実施するべきです。"
     "そうすることによって" "（" (CODE1 "*error-output*") "が" (CODE1 "*terminal-io*")
     "に束縛されているときは）、" (CODE1 "*error-output*") "に送信されたエラーメッセージは、" "通常望まれる形で、"
     (CODE1 "*terminal-io*") "を経由してユーザーに届きます。")))
(setf (gethash '("*DEBUG-IO*" . "VARIABLE") *table*) (gethash "*DEBUG-IO*" *table*))
(setf (gethash "*DEBUGGER-HOOK*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*DEBUGGER-HOOK*"))
    (CHAPTER ("## 値の型") 2 "2つの引数（コンディションと、" "デバッガーに入った時点での" (CODE1 "*debugger-hook*")
     "の値）" "の関数指定子か、" (CODE1 "nil") "。")
    (CHAPTER ("## 初期値") 2 (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "*debugger-hook*") "の値が" (CODE1 "nil") "ではない場合、"
     (CODE1 "invoke-debugger") "の呼び出しによるものか、" "あるいは捕捉されないコンディションを" (CODE1 "error") "か"
     (CODE1 "cerror") "で呼び出して" "自動的にデバッガーに入ろうとしたとき、" "この変数の値のものが通常の方法でデバッガーに入る前に呼び出されます。"
     "この関数は、コンディションを捕捉するか（遷移制御）、" "あるいは普通に終了するか（標準デバッガーが実行される）の" "どちらかになります。"
     "デバッグ中に再帰エラーを抑えるため、" "その関数が呼ばれる前に" (CODE1 "invoke-debugger") "によって"
     (CODE1 "*debugger-hook*") "が" (CODE1 "nil") "に束縛されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun one-of (choices &optional (prompt \"Choice\"))"
      "  (let ((n (length choices)) (i))" "    (do ((c choices (cdr c)) (i 1 (+ i 1)))"
      "        ((null c))" "      (format t \"~&[~D] ~A~%\" i (car c)))"
      "    (do () ((typep i `(integer 1 ,n)))" "      (format t \"~&~A: \" prompt)"
      "      (setq i (read))" "      (fresh-line))" "    (nth (- i 1) choices)))" NIL
      "(defun my-debugger (condition me-or-my-encapsulation)"
      "  (format t \"~&Fooey: ~A\" condition)"
      "  (let ((restart (one-of (compute-restarts))))"
      "    (if (not restart) (error \"My debugger got an error.\"))"
      "    (let ((*debugger-hook* me-or-my-encapsulation))"
      "      (invoke-restart-interactively restart))))" NIL
      "(let ((*debugger-hook* #'my-debugger))" "  (+ 3 'a))"
      ">>  Fooey: The argument to +, A, is not a number."
      ">>   [1] Supply a replacement for A." ">>   [2] Return to Cloe Toplevel."
      ">>  Choice: 1" ">>   Form to evaluate and use: (+ 5 'b)"
      ">>   Fooey: The argument to +, B, is not a number."
      ">>   [1] Supply a replacement for B." ">>   [2] Supply a replacement for A."
      ">>   [3] Return to Cloe Toplevel." ">>  Choice: 1"
      ">>   Form to evaluate and use: 1" "=>  9"))
    (CHAPTER ("## 影響") 2 (CODE1 "invoke-debugger")) (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 "ユーザーが対話形式で打ち込んだコードを評価するとき、" "フック関数がその第2引数である関数に"
     (CODE1 "*debugger-hook*") "を束縛すると、" "同じ対話的機能を使用して再帰的エラーを処理することができるので" "便利なことがあります。")))
(setf (gethash '("*DEBUGGER-HOOK*" . "VARIABLE") *table*) (gethash "*DEBUGGER-HOOK*" *table*))
(setf (gethash "*DEFAULT-PATHNAME-DEFAULTS*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "DEFAULT-PATHNAME-DEFAULTS"))
    (CHAPTER ("## 値の型") 2 "パス名オブジェクト")
    (CHAPTER ("## 初期値") 2 "実装依存のパス名であり、" "典型的にはCommon Lispが開始されたときの現在の作業ディレクトリ。")
    (CHAPTER ("## 定義") 2 "パス名であり、" "関数がデフォルトのパス名を必要としたときに、" "それが指定されなかったときはいつでも"
     "デフォルト値として使用されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; この例はDEC TOPS-20ファイルシステム上で動作している仮想的なLispでの"
      ";; 可能性のある使い方を示しています。パス名の変換がLispの実装と" ";; ホストファイルシステムタイプの間で変化するときそれが一般的な目的として"
      ";; 提供される可能性はないので適合された例ではありません。" "*default-pathname-defaults* =>  #P\"PS:<FRED>\""
      "(merge-pathnames (make-pathname :name \"CALENDAR\"))"
      "=>  #P\"PS:<FRED>CALENDAR\""
      "(let ((*default-pathname-defaults* (pathname \"<MARY>\")))"
      "  (merge-pathnames (make-pathname :name \"CALENDAR\")))"
      "=>  #P\"<MARY>CALENDAR\""))
    (CHAPTER ("## 影響") 2 "実装。") (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("*DEFAULT-PATHNAME-DEFAULTS*" . "VARIABLE") *table*) (gethash "*DEFAULT-PATHNAME-DEFAULTS*" *table*))
(setf (gethash "*ERROR-OUTPUT*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*DEBUG-IO*") ", " (CODE1 "*ERROR-OUTPUT*") ", "
     (CODE1 "*QUERY-IO*") "," " " (CODE1 "*STANDARD-INPUT*") ", "
     (CODE1 "*STANDARD-OUTPUT*") ", " (CODE1 "*TRACE-OUTPUT*"))
    (CHAPTER ("## 値の型") 2 (CODE1 "*standard-input*") "は、入力ストリーム" EOL1
     (CODE1 "*error-output*") "," (CODE1 "*standard-output*") ","
     (CODE1 "*trace-output*") "は、出力ストリーム" EOL1 (CODE1 "*debug-io*") ","
     (CODE1 "*query-io*") "は、双方向ストリーム")
    (CHAPTER ("## 初期値") 2 "実装依存ですが、" "開いたストリームでなければならず、" "それはI/Oカスタマイズ変数に対する一般化された"
     (CODE1 "synonym") "ストリームではなく、" "あるI/Oカスタマイズ変数の値に対する一般化された" (CODE1 "synonym")
     "ストリームの" "可能性があります。" "その初期値もまた一般化された" (CODE1 "synonym") "ストリームであり、"
     (CODE1 "*terminal-io*") "かその値のストリームかのどちらかを指します。")
    (CHAPTER ("## 定義") 2 "これらの変数はまとめて標準化されたI/Oカスタマイズ変数と呼ばれます。"
     "これらは、様々な標準化された操作と機能によって使われる入出力の" "標準での宛先を変更するために、束縛と代入をすることができます。" EOL2
     (CODE1 "*debug-io*") "の値は、デバッグI/Oと呼ばれ、" "対話式のデバッグ機能を使うためのストリームです。" EOL2
     (CODE1 "*error-output*") "の値は、エラー出力と呼ばれ、" "警告と非対話式エラーメッセージが送られるべきストリームです。" EOL2
     (CODE1 "*query-io*") "の値は、クエリ―I/Oと呼ばれ、" "ユーザーの質問と返答を行うために使われる双方向ストリームです。"
     "質問はこのストリームに出力され、" "返信はこのストリームから読み込まれるべきです。" EOL2 (CODE1 "*standard-input*")
     "の値は、標準入力と呼ばれ、" "多くの操作で入力ストリームが指定されなかったときに" "デフォルトの入力元として暗に指定されたものとして"
     "利用されるストリームです。" EOL2 (CODE1 "*standard-output*") "の値は、標準出力と呼ばれ、"
     "多くの操作で出力ストリームが指定されなかったときに" "デフォルトの出力元として暗に指定されたものとして" "利用されるストリームです。" EOL2
     (CODE1 "*trace-output*") "の値は、トレース出力と呼ばれ、" "トレースを行う関数（" (CODE1 "trace") "を参照）と、"
     (CODE1 "time") "マクロによる出力によって印字されるストリームです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-output-to-string (*error-output*)"
      "  (warn \"this string is sent to *error-output*\"))"
      "=>  \"Warning: this string is sent to *error-output*"
      "\" ;The exact format of this string is implementation-dependent." NIL
      "(with-input-from-string (*standard-input* \"1001\")"
      "   (+ 990 (read))) =>  1991                       " NIL
      "(progn (setq out (with-output-to-string (*standard-output*)"
      "                    (print \"print and format t send things to\")"
      "                    (format t \"*standard-output* now going to a string\")))"
      "       :done)" "=>  :DONE" "out" "=>  \""
      "\\\"print and format t send things to\\\" *standard-output* now going to a string\""
      NIL "(defun fact (n) (if (< n 2) 1 (* n (fact (- n 1)))))" "=>  FACT"
      "(trace fact)" "=>  (FACT)" ";; もちろん、トレースの出力の書式は実装依存です。"
      "(with-output-to-string (*trace-output*)" "  (fact 3)) " "=>  \"" "1 Enter FACT 3"
      "| 2 Enter FACT 2" "|   3 Enter FACT 1" "|   3 Exit FACT 1" "| 2 Exit FACT 2"
      "1 Exit FACT 6\""))
    (CHAPTER ("## 参考") 2 (CODE1 "*terminal-io*") "," (CODE1 "synonym-stream") ","
     (CODE1 "time") "," (CODE1 "trace") "," "9. コンディション," "23. リーダー," "22. プリンター")
    (CHAPTER ("## 備考") 2 "I/Oカスタマイズ変数の初期値に対する制限の意図は、" "実装の柔軟性を過度に制限することなく、"
     "これらの変数を別のI/Oカスタマイズ変数の値に束縛と代入することが" "常に安全であることを保証ためです。" EOL2 (CODE1 "*debug-io*")
     "と" (CODE1 "*query-io*") "の初期値を同じストリームに、" (CODE1 "*error-output*") "と"
     (CODE1 "*standard-output*") "の初期値を同じストリームにするような" "実装が一般的です。" EOL2 (CODE1 "y-or-n-p")
     "と" (CODE1 "yes-or-no-p") "関数は、" "入出力にクエリ―I/Oを使用します。" EOL2 "通常の"
     (CODE1 "Lisp read-eval-print-loop") "では、入力は標準入力から行います。" "多くの入力関数について、"
     (CODE1 "read") "と" (CODE1 "read-char") "を含む関数は、" "引数のデフォルトに標準入力のストリームを取ります。" EOL2
     "通常の" (CODE1 "Lisp read-eval-print-loop") "では、出力は標準出力から行います。" "多くの出力関数について、"
     (CODE1 "print") "と" (CODE1 "write-char") "を含む関数は、" "引数のデフォルトに標準出力のストリームを取ります。" EOL2
     "例えば、あるプログラムは出力をファイルに対して行いたいときは" (CODE1 "*standard-output*") "を束縛することによって実施するべきです。"
     "そうすることによって" "（" (CODE1 "*error-output*") "が" (CODE1 "*terminal-io*")
     "に束縛されているときは）、" (CODE1 "*error-output*") "に送信されたエラーメッセージは、" "通常望まれる形で、"
     (CODE1 "*terminal-io*") "を経由してユーザーに届きます。")))
(setf (gethash '("*ERROR-OUTPUT*" . "VARIABLE") *table*) (gethash "*ERROR-OUTPUT*" *table*))
(setf (gethash "*GENSYM-COUNTER*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*GENSYM-COUNTER*")) (CHAPTER ("## 値の型") 2 "非負の整数")
    (CHAPTER ("## 初期値") 2 "実装依存")
    (CHAPTER ("## 定義") 2 "値の数は、 関数" (CODE1 "gensym") "によって生成される"
     "次のシンボルの名前を構築する際に使われるでしょう。" EOL2 (CODE1 "*gensym-counter*") "は、"
     "いつでも割り当てか束縛かを行えますが、" "その値は常に非負の整数でなければなりません。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 (CODE1 "gensym"))
    (CHAPTER ("## 参考") 2 (CODE1 "gensym"))
    (CHAPTER ("## 備考") 2 (CODE1 "gensym") "の引数に数値を渡す機能は非推奨であり、" "明に"
     (CODE1 "*gensym-counter*") "を束縛するのが今では様式的に好まれます。")))
(setf (gethash '("*GENSYM-COUNTER*" . "VARIABLE") *table*) (gethash "*GENSYM-COUNTER*" *table*))
(setf (gethash "*MACROEXPAND-HOOK*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*MACROEXPAND-HOOK*"))
    (CHAPTER ("## 値の型") 2 "3つの引数（マクロ関数、マクロフォーム、環境オブジェクト）を" "受け付ける関数指定子。")
    (CHAPTER ("## 初期値") 2 "関数" (CODE1 "funcall") "と同等の関数指定子。"
     "しかし追加で実装依存の副作用を持つかもしれません。")
    (CHAPTER ("## 定義") 2 (CODE1 "macroexpand-1") "は" "この値を展開インターフェイスとしてフックし"
     "マクロ展開処理を制御するために使用します。" "マクロフォームを展開するときに、"
     "その関数を3つの引数（マクロ関数、マクロフォーム、環境オブジェクト）で呼び出し、" "マクロフォームを展開します。" "環境オブジェクトは動的生存期間を持っており、"
     "その関数オブジェクトがマクロ展開関数の動的生存期間の外で" "参照されたときの結果は未定義です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun hook (expander form env)"
      "   (format t \"Now expanding: ~S~%\" form)"
      "   (funcall expander form env)) =>  HOOK "
      "(defmacro machook (x y) `(/ (+ ,x ,y) 2)) =>  MACHOOK "
      "(macroexpand '(machook 1 2)) =>  (/ (+ 1 2) 2), true "
      "(let ((*macroexpand-hook* #'hook)) (macroexpand '(machook 1 2)))"
      ">>  Now expanding (MACHOOK 1 2) " "=>  (/ (+ 1 2) 2), true"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "macroexpand") "," (CODE1 "macroexpand-1") ","
     (CODE1 "funcall") "," "3.1. 評価")
    (CHAPTER ("## 備考") 2 "初期値の動作は、ただマクロ関数を起動するだけであり、" "引数はマクロフォームと環境オブジェクトの2つになります。" EOL2
     "ユーザーとそのプログラムは、マクロ展開の仕組みを用いて、" "変数の代入をカスタイマイズしたりトレースすることができます。"
     "しかし、その変数がグローバルリソースであり、" "複数のプログラムによって共有される可能性がある場合、"
     "例えば2つのプログラムが変数の正しくないセッティングに依存していたときは" "それらのプログラムは同じLispイメージ上でも正しく実行されないかもしれません。"
     "そのような理由で、デバッグ用途に限定して使用したほうがよいでしょう。" EOL2 (CODE1 "*macroexpand-hook*")
     "を自分の関数に置き換えるユーザーは、" "以前のフックの値を保存しておいて、" "自分の関数上で以前の値を呼び出すように考える必要があります。")))
(setf (gethash '("*MACROEXPAND-HOOK*" . "VARIABLE") *table*) (gethash "*MACROEXPAND-HOOK*" *table*))
(setf (gethash "*PACKAGE*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*PACKAGE*")) (CHAPTER ("## 値の型") 2 "パッケージオブジェクト")
    (CHAPTER ("## 初期値") 2 (CODE1 "COMMON-LISP-USER") "パッケージ")
    (CHAPTER ("## 定義") 2 (CODE1 "*package*") "の現在の値のパッケージオブジェクトは、" "現在のパッケージとして参照されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(in-package \"COMMON-LISP-USER\") =>  #<PACKAGE \"COMMON-LISP-USER\">"
      "*package* =>  #<PACKAGE \"COMMON-LISP-USER\">"
      "(make-package \"SAMPLE-PACKAGE\" :use '(\"COMMON-LISP\"))"
      "=>  #<PACKAGE \"SAMPLE-PACKAGE\">" "(list " "  (symbol-package"
      "    (let ((*package* (find-package 'sample-package)))"
      "      (setq *some-symbol* (read-from-string \"just-testing\"))))" "  *package*)"
      "=>  (#<PACKAGE \"SAMPLE-PACKAGE\"> #<PACKAGE \"COMMON-LISP-USER\">)"
      "(list (symbol-package (read-from-string \"just-testing\"))" "      *package*)"
      "=>  (#<PACKAGE \"COMMON-LISP-USER\"> #<PACKAGE \"COMMON-LISP-USER\">)"
      "(eq 'foo (intern \"FOO\")) =>  true"
      "(eq 'foo (let ((*package* (find-package 'sample-package)))"
      "           (intern \"FOO\")))" "=>  false"))
    (CHAPTER ("## 影響") 2 (CODE1 "load") "," (CODE1 "compile-file") ","
     (CODE1 "in-package"))
    (CHAPTER ("## 参考") 2 (CODE1 "compile-file") "," (CODE1 "in-package") ","
     (CODE1 "load") "," (CODE1 "package"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("*PACKAGE*" . "VARIABLE") *table*) (gethash "*PACKAGE*" *table*))
(setf (gethash "*PRINT-ARRAY*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*PRINT-ARRAY*"))
    (CHAPTER ("## 値の型") 2 "generalized-boolean") (CHAPTER ("## 初期値") 2 "実装依存")
    (CHAPTER ("## 定義") 2 "配列の印刷についての書式を制御します。" "もしこの値が" (STRONG "false") "のとき、"
     "文字列以外の配列の内容は印刷されません。" "代わりに、配列は" (CODE1 "#<") "を用いて簡潔なフォームとして印刷され、"
     "ユーザーがその配列の同一性を確認できるのに十分な情報が表示されます。" "しかし配列の全体の内容は含まれません。" "もしこの値が" (STRONG "true")
     "のとき、" "文字列ではない配列は、" (CODE1 "#(...)") "か、" (CODE1 "#*") "か、" (CODE1 "#nA")
     "の構文で印刷されます。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "実装。")
    (CHAPTER ("## 参考") 2 "2.4.8.3. シャープサイン 左かっこ," "2.4.8.20. シャープサイン " (CODE1 "<"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("*PRINT-ARRAY*" . "VARIABLE") *table*) (gethash "*PRINT-ARRAY*" *table*))
(setf (gethash "*PRINT-BASE*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*PRINT-BASE*") ", " (CODE1 "*PRINT-RADIX*"))
    (CHAPTER ("## 値の型") 2 (CODE1 "*print-base*") " - 基数" EOL1 (CODE1 "*print-radix*")
     " - generalized-boolean")
    (CHAPTER ("## 初期値") 2 (CODE1 "*print-base*") "の初期値は" (CODE1 "10") "。" EOL1
     (CODE1 "*print-radix*") "の初期値は" (STRONG "false") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "*print-base*") "と" (CODE1 "*print-radix*") "は、"
     (CODE1 "rational") "の印刷を制御します。" (CODE1 "*print-base*") "の値は、現在の出力の基数と呼ばれます。" EOL2
     (CODE1 "*print-base*") "の値は、プリンターが" (CODE1 "rational") "を印刷する基数です。" "基数が"
     (CODE1 "10") "より大きいとき、" "アルファベットの文字が9より上の数字の表現に使用されます。" EOL2 (CODE1 "*print-radix*")
     "の値が" (STRONG "true") "のとき、" "プリンターは" (CODE1 "rational") "の数を印刷するときに"
     "指定した基数を表す基数指定子を印刷します。" "基数指定子は、常に小文字で印刷されます。" "もし" (CODE1 "*print-base*") "が"
     (CODE1 "2") ", " (CODE1 "8") ", " (CODE1 "6") "のとき、" "基数指定子はそれぞれ" (CODE1 "#b") ", "
     (CODE1 "#o") ", " (CODE1 "#x") "が使用されます。" EOL2 "整数のとき、基数" (CODE1 "10") "ということを"
     "先行する基数指定子のかわりに、" "末尾の小数点で示します。" (CODE1 "ratio") "のときは、" (CODE1 "#10r") "を使用します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(let ((*print-base* 24.) (*print-radix* t))"
      "  (print 23.))" ">>  #24rN" "=>  23" "(setq *print-base* 10) =>  10"
      "(setq *print-radix* nil) =>  NIL" "(dotimes (i 35)"
      "   (let ((*print-base* (+ i 2)))           ;10進数の40を2から36進数で"
      "     (write 40)                            ;それぞれ印刷します"
      "     (if (zerop (mod i 10)) (terpri) (format t \" \"))))" ">>  101000"
      ">>  1111 220 130 104 55 50 44 40 37 34" ">>  31 2C 2A 28 26 24 22 20 1J 1I"
      ">>  1H 1G 1F 1E 1D 1C 1B 1A 19 18" ">>  17 16 15 14" "=>  NIL"
      "(dolist (pb '(2 3 8 10 16))"
      "   (let ((*print-radix* t)                 ;整数の10と分数の1/10を"
      "         (*print-base* pb))                ;基数2, 3, 8, 10, 16で"
      "    (format t \"~&~S  ~S~%\" 10 1/10)))        ;それぞれ印刷します" ">>  #b1010  #b1/1010"
      ">>  #3r101  #3r1/101" ">>  #o12  #o1/12" ">>  10.  #10r1/10" ">>  #xA  #x1/A"
      "=>  NIL"))
    (CHAPTER ("## 影響") 2 (CODE1 "format") ", " (CODE1 "write") ", "
     (CODE1 "write-to-string") "によって" "束縛が生じるかもしれません。")
    (CHAPTER ("## 参考") 2 (CODE1 "format") "," (CODE1 "write") ","
     (CODE1 "write-to-string"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("*PRINT-BASE*" . "VARIABLE") *table*) (gethash "*PRINT-BASE*" *table*))
(setf (gethash "*PRINT-CASE*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*PRINT-CASE*"))
    (CHAPTER ("## 値の型") 2 "シンボル" (CODE1 ":upcase") ", " (CODE1 ":downcase") ", "
     (CODE1 ":capitalize") "のうちのひとつ。")
    (CHAPTER ("## 初期値") 2 "シンボルの" (CODE1 ":upcase") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "*print-case*") "の値は、" "垂直バー構文を使用していないもののシンボルの名前に対して、"
     "各文字を大文字に印刷するかどうかという" "文字の種別（大文字、小文字、あるいは混合）を制御します。" EOL2 (CODE1 "*print-case*") "は"
     (CODE1 "*print-escape*") "の値が" (STRONG "false") "のときは" "いつでも効果があります。"
     (CODE1 "*print-case*") "は、また" (CODE1 "*print-escape*") "の値が" (STRONG "false")
     "のときでも、" "内部にエスケープ構文" "（例えば、垂直バー間かスラッシュのあとではないとき）" "がない限り効果があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun test-print-case ()"
      "  (dolist (*print-case* '(:upcase :downcase :capitalize))"
      "    (format t \"~&~S ~S~%\" 'this-and-that '|And-something-elSE|)))" "=>  TEST-PC"
      ";; エスケープが指定された文字は*PRINT-CASE*によって扱われますが、" ";; それらの文字（例えば、単体のエスケープか複数のエスケープかによらず）が"
      ";; どのように扱われるかは処理系依存です。" ";; 下記に示す2つの例は、エスケープを表す方法としては正当です。"
      "(test-print-case) ;実装A" ">>  THIS-AND-THAT |And-something-elSE|"
      ">>  this-and-that a\\n\\d-\\s\\o\\m\\e\\t\\h\\i\\n\\g-\\e\\lse"
      ">>  This-And-That A\\n\\d-\\s\\o\\m\\e\\t\\h\\i\\n\\g-\\e\\lse" "=>  NIL"
      "(test-print-case) ;実装B" ">>  THIS-AND-THAT |And-something-elSE|"
      ">>  this-and-that a|nd-something-el|se" ">>  This-And-That A|nd-something-el|se"
      "=>  NIL"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "write"))
    (CHAPTER ("## 備考") 2 (CODE1 "read") "は通常は" "シンボルに現れる小文字を対応する大文字に変換しますが、"
     "内部では通常は大文字の文字のみ含むような名前で印刷します。" EOL2 "もし" (CODE1 "*print-escape*") "が"
     (STRONG "true") "のとき、" "シンボルの名前にある小文字は、" "常に小文字として印刷され、"
     "その文字に先行して単体のエスケープ文字が配置されるか、" "あるいは複数のエスケープ文字によって囲まれます。" "一方、シンボルの名前にある大文字は、"
     "大文字か、小文字か、" "単語として大文字で書かれたような混合した場合は、" (CODE1 "*print-case*") "の値に従って印刷されます。"
     "「単語」がどのように構成されて変換するかは、" (CODE1 "string-capitalize") "と同じです。")))
(setf (gethash '("*PRINT-CASE*" . "VARIABLE") *table*) (gethash "*PRINT-CASE*" *table*))
(setf (gethash "*PRINT-CIRCLE*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*PRINT-CIRCLE*"))
    (CHAPTER ("## 値の型") 2 "generalized-boolean") (CHAPTER ("## 初期値") 2 (STRONG "false"))
    (CHAPTER ("## 定義") 2 "印刷を行うオブジェクトの" "循環と共有を検出するかどうかを制御します。" EOL2 "もし値が"
     (STRONG "false") "のとき、" "印刷の処理は、循環と共有の検出をすることなく" "再帰的に降下していくことによって行います。" EOL2 "もし値が"
     (STRONG "true") "のとき、" "プリンターは構造を印刷する中で" "循環と共有を検出するよう努力し、" "循環か共有の要素を示す"
     (CODE1 "#n=") "と" (CODE1 "#n#") "構文を使用します。" "もしユーザーが定義した" (CODE1 "print-object")
     "メソッドが" "提供されたストリーム以外に印刷するとき、" "循環の検出はそのストリームに対してやり直しされます。" EOL2
     "Lispリーダーが自動的にオブジェクトの共有の保証を行うときは" "（例えば内部シンボルに生じたときなど）、" "実装は" (CODE1 "#n#")
     "表記を使用するべきではないことに注意してください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(let ((a (list 1 2 3)))" "  (setf (cdddr a) a)"
      "  (let ((*print-circle* t))" "    (write a)" "    :done))" ">>  #1=(1 2 3 . #1#)"
      "=>  :DONE"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "write"))
    (CHAPTER ("## 備考") 2 (CODE1 "*print-circle*") "に" (CODE1 "nil") "がされた状態で"
     "循環構造を印刷しようとしたときは、" "おそらくループの状態を引き起こし、" "終了できない状態になります。")))
(setf (gethash '("*PRINT-CIRCLE*" . "VARIABLE") *table*) (gethash "*PRINT-CIRCLE*" *table*))
(setf (gethash "*PRINT-ESCAPE*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*PRINT-ESCAPE*"))
    (CHAPTER ("## 値の型") 2 "generalized-boolean") (CHAPTER ("## 初期値") 2 (STRONG "true"))
    (CHAPTER ("## 定義") 2 "もし値が" (STRONG "false") "のとき、" "式が印刷されるときにエスケープ文字と"
     "パッケージのパッケージのプレフィックスは出力されません。" EOL2 "もし値が" (STRONG "true") "のとき、" "ある式が印刷され、"
     "その出力された結果が再び読み込まれたときに" (CODE1 "equal") "式で同一になるようなものを生成できるような方法によって"
     "印刷するように試みられます" "（これはただのガイドラインであって、要求ではありません。" (CODE1 "*print-readably*")
     "をご確認ください）。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(let ((*print-escape* t)) (write #\\a))" ">>  #\\a"
      "=>  #\\a" "(let ((*print-escape* nil)) (write #\\a))" ">>  a" "=>  #\\a"))
    (CHAPTER ("## 影響") 2 (CODE1 "princ") "," (CODE1 "prin1") "," (CODE1 "format"))
    (CHAPTER ("## 参考") 2 (CODE1 "write") "," (CODE1 "readtable-case"))
    (CHAPTER ("## 備考") 2 (CODE1 "princ") "は、" (CODE1 "*print-escape*") "に"
     (STRONG "false") "を束縛する効果があります。" (CODE1 "prin1") "は、" (CODE1 "*print-escape*") "に"
     (STRONG "true") "を束縛する効果があります。")))
(setf (gethash '("*PRINT-ESCAPE*" . "VARIABLE") *table*) (gethash "*PRINT-ESCAPE*" *table*))
(setf (gethash "*PRINT-GENSYM*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*PRINT-GENSYM*"))
    (CHAPTER ("## 値の型") 2 "generalized-boolean") (CHAPTER ("## 初期値") 2 (STRONG "true"))
    (CHAPTER ("## 定義") 2 (CODE1 "intern") "されていないシンボルの前に" "プレフィックスの" (CODE1 "#:")
     "が印刷されるかどうかを制御します。" "このプレフィックスは" "そのようなシンボルに対して" (CODE1 "*print-gensym*") "の値が"
     (STRONG "true") "のときのみに印刷されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(let ((*print-gensym* nil))" "  (print (gensym)))"
      ">>  G6040" "=>  #:G6040"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "write") "," (CODE1 "*print-escape*"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("*PRINT-GENSYM*" . "VARIABLE") *table*) (gethash "*PRINT-GENSYM*" *table*))
(setf (gethash "*PRINT-LENGTH*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*PRINT-LEVEL*") ", " (CODE1 "*PRINT-LENGTH*"))
    (CHAPTER ("## 値の型") 2 "非負の整数か、" (CODE1 "nil")) (CHAPTER ("## 初期値") 2 (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "*print-level*") "は、"
     "どれくらい深いレベルの階層にネストされたオブジェクトを印刷するかを制御します。" "もし値が" (STRONG "false") "のときは、制御は行われません。"
     "そうではないとき、その整数は印刷する最大の階層のレベルを示します。" "オブジェクトが印刷されるときが階層" (CODE1 "0") "であり、"
     "その要素（リストか配列の）が階層" (CODE1 "1") "であり、それが続きます。" "もし再帰的に印刷されるオブジェクトが要素を持っており、"
     "オブジェクトの階層のレベルが" (CODE1 "*print-level*") "の値以上のときは、" "そのオブジェクトは" (CODE1 "#")
     "として印刷されます。" EOL2 (CODE1 "*print-length*") "は" "どれくらいの要素を印刷するかを制御します。" "もし値が"
     (STRONG "false") "のときは、印刷される要素の数に制限はありません。" "そうではないとき、"
     "疎の整数は印刷されるオブジェクトの最大の要素数を示します。" "もし超過したとき、プリンターはその他の要素の場所に" (CODE1 "...") "を印刷します。"
     "ドットリストの場合、そのリストが正確に" (CODE1 "*print-length*") "の値と同じ要素数を含んでいたとき、" (CODE1 "...")
     "を印刷するのではなく、終端しているアトムが印刷されます。" EOL2 (CODE1 "*print-level*") "と"
     (CODE1 "*print-length*") "は、" "リストのような構文で印刷されるどのような" "オブジェクトの印刷にも影響を与えます。"
     "シンボル、文字列、ビット配列といった印刷には影響しません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq a '(1 (2 (3 (4 (5 (6))))))) =>  (1 (2 (3 (4 (5 (6))))))" "(dotimes (i 8)"
      "  (let ((*print-level* i))" "    (format t \"~&~D -- ~S~%\" i a)))" ">>  0 -- #"
      ">>  1 -- (1 #)" ">>  2 -- (1 (2 #))" ">>  3 -- (1 (2 (3 #)))"
      ">>  4 -- (1 (2 (3 (4 #))))" ">>  5 -- (1 (2 (3 (4 (5 #)))))"
      ">>  6 -- (1 (2 (3 (4 (5 (6))))))" ">>  7 -- (1 (2 (3 (4 (5 (6))))))" "=>  NIL" NIL
      "(setq a '(1 2 3 4 5 6)) =>  (1 2 3 4 5 6)" "(dotimes (i 7)"
      "  (let ((*print-length* i))" "    (format t \"~&~D -- ~S~%\" i a)))"
      ">>  0 -- (...)" ">>  1 -- (1 ...)" ">>  2 -- (1 2 ...)" ">>  3 -- (1 2 3 ...)"
      ">>  4 -- (1 2 3 4 ...)" ">>  5 -- (1 2 3 4 5 6)" ">>  6 -- (1 2 3 4 5 6)"
      "=>  NIL" NIL "(dolist (level-length '((0 1) (1 1) (1 2) (1 3) (1 4)"
      "                        (2 1) (2 2) (2 3) (3 2) (3 3) (3 4)))"
      " (let ((*print-level*  (first  level-length))"
      "       (*print-length* (second level-length)))" "   (format t \"~&~D ~D -- ~S~%\""
      "           *print-level* *print-length*"
      "           '(if (member x y) (+ (car x) 3) '(foo . #(a b c d \"Baz\"))))))"
      ">>  0 1 -- #" ">>  1 1 -- (IF ...)" ">>  1 2 -- (IF # ...)"
      ">>  1 3 -- (IF # # ...)" ">>  1 4 -- (IF # # #)" ">>  2 1 -- (IF ...)"
      ">>  2 2 -- (IF (MEMBER X ...) ...)" ">>  2 3 -- (IF (MEMBER X Y) (+ # 3) ...)"
      ">>  3 2 -- (IF (MEMBER X ...) ...)"
      ">>  3 3 -- (IF (MEMBER X Y) (+ (CAR X) 3) ...)"
      ">>  3 4 -- (IF (MEMBER X Y) (+ (CAR X) 3) '(FOO . #(A B C D ...)))" "=>  NIL"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "write"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("*PRINT-LENGTH*" . "VARIABLE") *table*) (gethash "*PRINT-LENGTH*" *table*))
(setf (gethash "*PRINT-LEVEL*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*PRINT-LEVEL*") ", " (CODE1 "*PRINT-LENGTH*"))
    (CHAPTER ("## 値の型") 2 "非負の整数か、" (CODE1 "nil")) (CHAPTER ("## 初期値") 2 (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "*print-level*") "は、"
     "どれくらい深いレベルの階層にネストされたオブジェクトを印刷するかを制御します。" "もし値が" (STRONG "false") "のときは、制御は行われません。"
     "そうではないとき、その整数は印刷する最大の階層のレベルを示します。" "オブジェクトが印刷されるときが階層" (CODE1 "0") "であり、"
     "その要素（リストか配列の）が階層" (CODE1 "1") "であり、それが続きます。" "もし再帰的に印刷されるオブジェクトが要素を持っており、"
     "オブジェクトの階層のレベルが" (CODE1 "*print-level*") "の値以上のときは、" "そのオブジェクトは" (CODE1 "#")
     "として印刷されます。" EOL2 (CODE1 "*print-length*") "は" "どれくらいの要素を印刷するかを制御します。" "もし値が"
     (STRONG "false") "のときは、印刷される要素の数に制限はありません。" "そうではないとき、"
     "疎の整数は印刷されるオブジェクトの最大の要素数を示します。" "もし超過したとき、プリンターはその他の要素の場所に" (CODE1 "...") "を印刷します。"
     "ドットリストの場合、そのリストが正確に" (CODE1 "*print-length*") "の値と同じ要素数を含んでいたとき、" (CODE1 "...")
     "を印刷するのではなく、終端しているアトムが印刷されます。" EOL2 (CODE1 "*print-level*") "と"
     (CODE1 "*print-length*") "は、" "リストのような構文で印刷されるどのような" "オブジェクトの印刷にも影響を与えます。"
     "シンボル、文字列、ビット配列といった印刷には影響しません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq a '(1 (2 (3 (4 (5 (6))))))) =>  (1 (2 (3 (4 (5 (6))))))" "(dotimes (i 8)"
      "  (let ((*print-level* i))" "    (format t \"~&~D -- ~S~%\" i a)))" ">>  0 -- #"
      ">>  1 -- (1 #)" ">>  2 -- (1 (2 #))" ">>  3 -- (1 (2 (3 #)))"
      ">>  4 -- (1 (2 (3 (4 #))))" ">>  5 -- (1 (2 (3 (4 (5 #)))))"
      ">>  6 -- (1 (2 (3 (4 (5 (6))))))" ">>  7 -- (1 (2 (3 (4 (5 (6))))))" "=>  NIL" NIL
      "(setq a '(1 2 3 4 5 6)) =>  (1 2 3 4 5 6)" "(dotimes (i 7)"
      "  (let ((*print-length* i))" "    (format t \"~&~D -- ~S~%\" i a)))"
      ">>  0 -- (...)" ">>  1 -- (1 ...)" ">>  2 -- (1 2 ...)" ">>  3 -- (1 2 3 ...)"
      ">>  4 -- (1 2 3 4 ...)" ">>  5 -- (1 2 3 4 5 6)" ">>  6 -- (1 2 3 4 5 6)"
      "=>  NIL" NIL "(dolist (level-length '((0 1) (1 1) (1 2) (1 3) (1 4)"
      "                        (2 1) (2 2) (2 3) (3 2) (3 3) (3 4)))"
      " (let ((*print-level*  (first  level-length))"
      "       (*print-length* (second level-length)))" "   (format t \"~&~D ~D -- ~S~%\""
      "           *print-level* *print-length*"
      "           '(if (member x y) (+ (car x) 3) '(foo . #(a b c d \"Baz\"))))))"
      ">>  0 1 -- #" ">>  1 1 -- (IF ...)" ">>  1 2 -- (IF # ...)"
      ">>  1 3 -- (IF # # ...)" ">>  1 4 -- (IF # # #)" ">>  2 1 -- (IF ...)"
      ">>  2 2 -- (IF (MEMBER X ...) ...)" ">>  2 3 -- (IF (MEMBER X Y) (+ # 3) ...)"
      ">>  3 2 -- (IF (MEMBER X ...) ...)"
      ">>  3 3 -- (IF (MEMBER X Y) (+ (CAR X) 3) ...)"
      ">>  3 4 -- (IF (MEMBER X Y) (+ (CAR X) 3) '(FOO . #(A B C D ...)))" "=>  NIL"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "write"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("*PRINT-LEVEL*" . "VARIABLE") *table*) (gethash "*PRINT-LEVEL*" *table*))
(setf (gethash "*PRINT-LINES*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*PRINT-LINES*"))
    (CHAPTER ("## 値の型") 2 "非負の整数か、" (CODE1 "nil")) (CHAPTER ("## 初期値") 2 (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "*print-lines*") "の値が" (CODE1 "nil") "ではないとき、"
     "何かをプリティプリンターで印刷するときに" "生成された出力の行数を制限します。" "もし行数を越えて行こうとしたとき、" "最後の行の終端に"
     (CODE1 "..") "を印刷し、" "続いて保留されていた全てのサフィックス（閉じる区切り記号）を印刷します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(let ((*print-right-margin* 25) (*print-lines* 3))"
      "  (pprint '(progn (setq a 1 b 2 c 3 d 4))))" ">>  (PROGN (SETQ A 1"
      ">>               B 2" ">>               C 3 ..))" "=>  <no values>"))
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 (CODE1 "..") "の表記は、レベルの省略形として使われる" (CODE1 "...")
     "とは意図的に違うものにしています。" "よって二つの違った状況は視覚的に区別できます。" EOL2 "この表記は、省略された出力を後で読もうとしたときに、"
     "Lispリーダーがエラーを通知する可能性を高めるために使用されます。" "ただし、" (CODE1 "\"この文字列は切り捨てられた... \"") "のように"
     "文字列の中で切り捨てが発生した場合は、" "後で問題の状況を検出することができないため、" "そのようなエラーは通知されないことに注意してください。")))
(setf (gethash '("*PRINT-LINES*" . "VARIABLE") *table*) (gethash "*PRINT-LINES*" *table*))
(setf (gethash "*PRINT-RADIX*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*PRINT-BASE*") ", " (CODE1 "*PRINT-RADIX*"))
    (CHAPTER ("## 値の型") 2 (CODE1 "*print-base*") " - 基数" EOL1 (CODE1 "*print-radix*")
     " - generalized-boolean")
    (CHAPTER ("## 初期値") 2 (CODE1 "*print-base*") "の初期値は" (CODE1 "10") "。" EOL1
     (CODE1 "*print-radix*") "の初期値は" (STRONG "false") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "*print-base*") "と" (CODE1 "*print-radix*") "は、"
     (CODE1 "rational") "の印刷を制御します。" (CODE1 "*print-base*") "の値は、現在の出力の基数と呼ばれます。" EOL2
     (CODE1 "*print-base*") "の値は、プリンターが" (CODE1 "rational") "を印刷する基数です。" "基数が"
     (CODE1 "10") "より大きいとき、" "アルファベットの文字が9より上の数字の表現に使用されます。" EOL2 (CODE1 "*print-radix*")
     "の値が" (STRONG "true") "のとき、" "プリンターは" (CODE1 "rational") "の数を印刷するときに"
     "指定した基数を表す基数指定子を印刷します。" "基数指定子は、常に小文字で印刷されます。" "もし" (CODE1 "*print-base*") "が"
     (CODE1 "2") ", " (CODE1 "8") ", " (CODE1 "6") "のとき、" "基数指定子はそれぞれ" (CODE1 "#b") ", "
     (CODE1 "#o") ", " (CODE1 "#x") "が使用されます。" EOL2 "整数のとき、基数" (CODE1 "10") "ということを"
     "先行する基数指定子のかわりに、" "末尾の小数点で示します。" (CODE1 "ratio") "のときは、" (CODE1 "#10r") "を使用します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(let ((*print-base* 24.) (*print-radix* t))"
      "  (print 23.))" ">>  #24rN" "=>  23" "(setq *print-base* 10) =>  10"
      "(setq *print-radix* nil) =>  NIL" "(dotimes (i 35)"
      "   (let ((*print-base* (+ i 2)))           ;10進数の40を2から36進数で"
      "     (write 40)                            ;それぞれ印刷します"
      "     (if (zerop (mod i 10)) (terpri) (format t \" \"))))" ">>  101000"
      ">>  1111 220 130 104 55 50 44 40 37 34" ">>  31 2C 2A 28 26 24 22 20 1J 1I"
      ">>  1H 1G 1F 1E 1D 1C 1B 1A 19 18" ">>  17 16 15 14" "=>  NIL"
      "(dolist (pb '(2 3 8 10 16))"
      "   (let ((*print-radix* t)                 ;整数の10と分数の1/10を"
      "         (*print-base* pb))                ;基数2, 3, 8, 10, 16で"
      "    (format t \"~&~S  ~S~%\" 10 1/10)))        ;それぞれ印刷します" ">>  #b1010  #b1/1010"
      ">>  #3r101  #3r1/101" ">>  #o12  #o1/12" ">>  10.  #10r1/10" ">>  #xA  #x1/A"
      "=>  NIL"))
    (CHAPTER ("## 影響") 2 (CODE1 "format") ", " (CODE1 "write") ", "
     (CODE1 "write-to-string") "によって" "束縛が生じるかもしれません。")
    (CHAPTER ("## 参考") 2 (CODE1 "format") "," (CODE1 "write") ","
     (CODE1 "write-to-string"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("*PRINT-RADIX*" . "VARIABLE") *table*) (gethash "*PRINT-RADIX*" *table*))
(setf (gethash "*QUERY-IO*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*DEBUG-IO*") ", " (CODE1 "*ERROR-OUTPUT*") ", "
     (CODE1 "*QUERY-IO*") "," " " (CODE1 "*STANDARD-INPUT*") ", "
     (CODE1 "*STANDARD-OUTPUT*") ", " (CODE1 "*TRACE-OUTPUT*"))
    (CHAPTER ("## 値の型") 2 (CODE1 "*standard-input*") "は、入力ストリーム" EOL1
     (CODE1 "*error-output*") "," (CODE1 "*standard-output*") ","
     (CODE1 "*trace-output*") "は、出力ストリーム" EOL1 (CODE1 "*debug-io*") ","
     (CODE1 "*query-io*") "は、双方向ストリーム")
    (CHAPTER ("## 初期値") 2 "実装依存ですが、" "開いたストリームでなければならず、" "それはI/Oカスタマイズ変数に対する一般化された"
     (CODE1 "synonym") "ストリームではなく、" "あるI/Oカスタマイズ変数の値に対する一般化された" (CODE1 "synonym")
     "ストリームの" "可能性があります。" "その初期値もまた一般化された" (CODE1 "synonym") "ストリームであり、"
     (CODE1 "*terminal-io*") "かその値のストリームかのどちらかを指します。")
    (CHAPTER ("## 定義") 2 "これらの変数はまとめて標準化されたI/Oカスタマイズ変数と呼ばれます。"
     "これらは、様々な標準化された操作と機能によって使われる入出力の" "標準での宛先を変更するために、束縛と代入をすることができます。" EOL2
     (CODE1 "*debug-io*") "の値は、デバッグI/Oと呼ばれ、" "対話式のデバッグ機能を使うためのストリームです。" EOL2
     (CODE1 "*error-output*") "の値は、エラー出力と呼ばれ、" "警告と非対話式エラーメッセージが送られるべきストリームです。" EOL2
     (CODE1 "*query-io*") "の値は、クエリ―I/Oと呼ばれ、" "ユーザーの質問と返答を行うために使われる双方向ストリームです。"
     "質問はこのストリームに出力され、" "返信はこのストリームから読み込まれるべきです。" EOL2 (CODE1 "*standard-input*")
     "の値は、標準入力と呼ばれ、" "多くの操作で入力ストリームが指定されなかったときに" "デフォルトの入力元として暗に指定されたものとして"
     "利用されるストリームです。" EOL2 (CODE1 "*standard-output*") "の値は、標準出力と呼ばれ、"
     "多くの操作で出力ストリームが指定されなかったときに" "デフォルトの出力元として暗に指定されたものとして" "利用されるストリームです。" EOL2
     (CODE1 "*trace-output*") "の値は、トレース出力と呼ばれ、" "トレースを行う関数（" (CODE1 "trace") "を参照）と、"
     (CODE1 "time") "マクロによる出力によって印字されるストリームです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-output-to-string (*error-output*)"
      "  (warn \"this string is sent to *error-output*\"))"
      "=>  \"Warning: this string is sent to *error-output*"
      "\" ;The exact format of this string is implementation-dependent." NIL
      "(with-input-from-string (*standard-input* \"1001\")"
      "   (+ 990 (read))) =>  1991                       " NIL
      "(progn (setq out (with-output-to-string (*standard-output*)"
      "                    (print \"print and format t send things to\")"
      "                    (format t \"*standard-output* now going to a string\")))"
      "       :done)" "=>  :DONE" "out" "=>  \""
      "\\\"print and format t send things to\\\" *standard-output* now going to a string\""
      NIL "(defun fact (n) (if (< n 2) 1 (* n (fact (- n 1)))))" "=>  FACT"
      "(trace fact)" "=>  (FACT)" ";; もちろん、トレースの出力の書式は実装依存です。"
      "(with-output-to-string (*trace-output*)" "  (fact 3)) " "=>  \"" "1 Enter FACT 3"
      "| 2 Enter FACT 2" "|   3 Enter FACT 1" "|   3 Exit FACT 1" "| 2 Exit FACT 2"
      "1 Exit FACT 6\""))
    (CHAPTER ("## 参考") 2 (CODE1 "*terminal-io*") "," (CODE1 "synonym-stream") ","
     (CODE1 "time") "," (CODE1 "trace") "," "9. コンディション," "23. リーダー," "22. プリンター")
    (CHAPTER ("## 備考") 2 "I/Oカスタマイズ変数の初期値に対する制限の意図は、" "実装の柔軟性を過度に制限することなく、"
     "これらの変数を別のI/Oカスタマイズ変数の値に束縛と代入することが" "常に安全であることを保証ためです。" EOL2 (CODE1 "*debug-io*")
     "と" (CODE1 "*query-io*") "の初期値を同じストリームに、" (CODE1 "*error-output*") "と"
     (CODE1 "*standard-output*") "の初期値を同じストリームにするような" "実装が一般的です。" EOL2 (CODE1 "y-or-n-p")
     "と" (CODE1 "yes-or-no-p") "関数は、" "入出力にクエリ―I/Oを使用します。" EOL2 "通常の"
     (CODE1 "Lisp read-eval-print-loop") "では、入力は標準入力から行います。" "多くの入力関数について、"
     (CODE1 "read") "と" (CODE1 "read-char") "を含む関数は、" "引数のデフォルトに標準入力のストリームを取ります。" EOL2
     "通常の" (CODE1 "Lisp read-eval-print-loop") "では、出力は標準出力から行います。" "多くの出力関数について、"
     (CODE1 "print") "と" (CODE1 "write-char") "を含む関数は、" "引数のデフォルトに標準出力のストリームを取ります。" EOL2
     "例えば、あるプログラムは出力をファイルに対して行いたいときは" (CODE1 "*standard-output*") "を束縛することによって実施するべきです。"
     "そうすることによって" "（" (CODE1 "*error-output*") "が" (CODE1 "*terminal-io*")
     "に束縛されているときは）、" (CODE1 "*error-output*") "に送信されたエラーメッセージは、" "通常望まれる形で、"
     (CODE1 "*terminal-io*") "を経由してユーザーに届きます。")))
(setf (gethash '("*QUERY-IO*" . "VARIABLE") *table*) (gethash "*QUERY-IO*" *table*))
(setf (gethash "*STANDARD-INPUT*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*DEBUG-IO*") ", " (CODE1 "*ERROR-OUTPUT*") ", "
     (CODE1 "*QUERY-IO*") "," " " (CODE1 "*STANDARD-INPUT*") ", "
     (CODE1 "*STANDARD-OUTPUT*") ", " (CODE1 "*TRACE-OUTPUT*"))
    (CHAPTER ("## 値の型") 2 (CODE1 "*standard-input*") "は、入力ストリーム" EOL1
     (CODE1 "*error-output*") "," (CODE1 "*standard-output*") ","
     (CODE1 "*trace-output*") "は、出力ストリーム" EOL1 (CODE1 "*debug-io*") ","
     (CODE1 "*query-io*") "は、双方向ストリーム")
    (CHAPTER ("## 初期値") 2 "実装依存ですが、" "開いたストリームでなければならず、" "それはI/Oカスタマイズ変数に対する一般化された"
     (CODE1 "synonym") "ストリームではなく、" "あるI/Oカスタマイズ変数の値に対する一般化された" (CODE1 "synonym")
     "ストリームの" "可能性があります。" "その初期値もまた一般化された" (CODE1 "synonym") "ストリームであり、"
     (CODE1 "*terminal-io*") "かその値のストリームかのどちらかを指します。")
    (CHAPTER ("## 定義") 2 "これらの変数はまとめて標準化されたI/Oカスタマイズ変数と呼ばれます。"
     "これらは、様々な標準化された操作と機能によって使われる入出力の" "標準での宛先を変更するために、束縛と代入をすることができます。" EOL2
     (CODE1 "*debug-io*") "の値は、デバッグI/Oと呼ばれ、" "対話式のデバッグ機能を使うためのストリームです。" EOL2
     (CODE1 "*error-output*") "の値は、エラー出力と呼ばれ、" "警告と非対話式エラーメッセージが送られるべきストリームです。" EOL2
     (CODE1 "*query-io*") "の値は、クエリ―I/Oと呼ばれ、" "ユーザーの質問と返答を行うために使われる双方向ストリームです。"
     "質問はこのストリームに出力され、" "返信はこのストリームから読み込まれるべきです。" EOL2 (CODE1 "*standard-input*")
     "の値は、標準入力と呼ばれ、" "多くの操作で入力ストリームが指定されなかったときに" "デフォルトの入力元として暗に指定されたものとして"
     "利用されるストリームです。" EOL2 (CODE1 "*standard-output*") "の値は、標準出力と呼ばれ、"
     "多くの操作で出力ストリームが指定されなかったときに" "デフォルトの出力元として暗に指定されたものとして" "利用されるストリームです。" EOL2
     (CODE1 "*trace-output*") "の値は、トレース出力と呼ばれ、" "トレースを行う関数（" (CODE1 "trace") "を参照）と、"
     (CODE1 "time") "マクロによる出力によって印字されるストリームです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-output-to-string (*error-output*)"
      "  (warn \"this string is sent to *error-output*\"))"
      "=>  \"Warning: this string is sent to *error-output*"
      "\" ;The exact format of this string is implementation-dependent." NIL
      "(with-input-from-string (*standard-input* \"1001\")"
      "   (+ 990 (read))) =>  1991                       " NIL
      "(progn (setq out (with-output-to-string (*standard-output*)"
      "                    (print \"print and format t send things to\")"
      "                    (format t \"*standard-output* now going to a string\")))"
      "       :done)" "=>  :DONE" "out" "=>  \""
      "\\\"print and format t send things to\\\" *standard-output* now going to a string\""
      NIL "(defun fact (n) (if (< n 2) 1 (* n (fact (- n 1)))))" "=>  FACT"
      "(trace fact)" "=>  (FACT)" ";; もちろん、トレースの出力の書式は実装依存です。"
      "(with-output-to-string (*trace-output*)" "  (fact 3)) " "=>  \"" "1 Enter FACT 3"
      "| 2 Enter FACT 2" "|   3 Enter FACT 1" "|   3 Exit FACT 1" "| 2 Exit FACT 2"
      "1 Exit FACT 6\""))
    (CHAPTER ("## 参考") 2 (CODE1 "*terminal-io*") "," (CODE1 "synonym-stream") ","
     (CODE1 "time") "," (CODE1 "trace") "," "9. コンディション," "23. リーダー," "22. プリンター")
    (CHAPTER ("## 備考") 2 "I/Oカスタマイズ変数の初期値に対する制限の意図は、" "実装の柔軟性を過度に制限することなく、"
     "これらの変数を別のI/Oカスタマイズ変数の値に束縛と代入することが" "常に安全であることを保証ためです。" EOL2 (CODE1 "*debug-io*")
     "と" (CODE1 "*query-io*") "の初期値を同じストリームに、" (CODE1 "*error-output*") "と"
     (CODE1 "*standard-output*") "の初期値を同じストリームにするような" "実装が一般的です。" EOL2 (CODE1 "y-or-n-p")
     "と" (CODE1 "yes-or-no-p") "関数は、" "入出力にクエリ―I/Oを使用します。" EOL2 "通常の"
     (CODE1 "Lisp read-eval-print-loop") "では、入力は標準入力から行います。" "多くの入力関数について、"
     (CODE1 "read") "と" (CODE1 "read-char") "を含む関数は、" "引数のデフォルトに標準入力のストリームを取ります。" EOL2
     "通常の" (CODE1 "Lisp read-eval-print-loop") "では、出力は標準出力から行います。" "多くの出力関数について、"
     (CODE1 "print") "と" (CODE1 "write-char") "を含む関数は、" "引数のデフォルトに標準出力のストリームを取ります。" EOL2
     "例えば、あるプログラムは出力をファイルに対して行いたいときは" (CODE1 "*standard-output*") "を束縛することによって実施するべきです。"
     "そうすることによって" "（" (CODE1 "*error-output*") "が" (CODE1 "*terminal-io*")
     "に束縛されているときは）、" (CODE1 "*error-output*") "に送信されたエラーメッセージは、" "通常望まれる形で、"
     (CODE1 "*terminal-io*") "を経由してユーザーに届きます。")))
(setf (gethash '("*STANDARD-INPUT*" . "VARIABLE") *table*) (gethash "*STANDARD-INPUT*" *table*))
(setf (gethash "*STANDARD-OUTPUT*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*DEBUG-IO*") ", " (CODE1 "*ERROR-OUTPUT*") ", "
     (CODE1 "*QUERY-IO*") "," " " (CODE1 "*STANDARD-INPUT*") ", "
     (CODE1 "*STANDARD-OUTPUT*") ", " (CODE1 "*TRACE-OUTPUT*"))
    (CHAPTER ("## 値の型") 2 (CODE1 "*standard-input*") "は、入力ストリーム" EOL1
     (CODE1 "*error-output*") "," (CODE1 "*standard-output*") ","
     (CODE1 "*trace-output*") "は、出力ストリーム" EOL1 (CODE1 "*debug-io*") ","
     (CODE1 "*query-io*") "は、双方向ストリーム")
    (CHAPTER ("## 初期値") 2 "実装依存ですが、" "開いたストリームでなければならず、" "それはI/Oカスタマイズ変数に対する一般化された"
     (CODE1 "synonym") "ストリームではなく、" "あるI/Oカスタマイズ変数の値に対する一般化された" (CODE1 "synonym")
     "ストリームの" "可能性があります。" "その初期値もまた一般化された" (CODE1 "synonym") "ストリームであり、"
     (CODE1 "*terminal-io*") "かその値のストリームかのどちらかを指します。")
    (CHAPTER ("## 定義") 2 "これらの変数はまとめて標準化されたI/Oカスタマイズ変数と呼ばれます。"
     "これらは、様々な標準化された操作と機能によって使われる入出力の" "標準での宛先を変更するために、束縛と代入をすることができます。" EOL2
     (CODE1 "*debug-io*") "の値は、デバッグI/Oと呼ばれ、" "対話式のデバッグ機能を使うためのストリームです。" EOL2
     (CODE1 "*error-output*") "の値は、エラー出力と呼ばれ、" "警告と非対話式エラーメッセージが送られるべきストリームです。" EOL2
     (CODE1 "*query-io*") "の値は、クエリ―I/Oと呼ばれ、" "ユーザーの質問と返答を行うために使われる双方向ストリームです。"
     "質問はこのストリームに出力され、" "返信はこのストリームから読み込まれるべきです。" EOL2 (CODE1 "*standard-input*")
     "の値は、標準入力と呼ばれ、" "多くの操作で入力ストリームが指定されなかったときに" "デフォルトの入力元として暗に指定されたものとして"
     "利用されるストリームです。" EOL2 (CODE1 "*standard-output*") "の値は、標準出力と呼ばれ、"
     "多くの操作で出力ストリームが指定されなかったときに" "デフォルトの出力元として暗に指定されたものとして" "利用されるストリームです。" EOL2
     (CODE1 "*trace-output*") "の値は、トレース出力と呼ばれ、" "トレースを行う関数（" (CODE1 "trace") "を参照）と、"
     (CODE1 "time") "マクロによる出力によって印字されるストリームです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-output-to-string (*error-output*)"
      "  (warn \"this string is sent to *error-output*\"))"
      "=>  \"Warning: this string is sent to *error-output*"
      "\" ;The exact format of this string is implementation-dependent." NIL
      "(with-input-from-string (*standard-input* \"1001\")"
      "   (+ 990 (read))) =>  1991                       " NIL
      "(progn (setq out (with-output-to-string (*standard-output*)"
      "                    (print \"print and format t send things to\")"
      "                    (format t \"*standard-output* now going to a string\")))"
      "       :done)" "=>  :DONE" "out" "=>  \""
      "\\\"print and format t send things to\\\" *standard-output* now going to a string\""
      NIL "(defun fact (n) (if (< n 2) 1 (* n (fact (- n 1)))))" "=>  FACT"
      "(trace fact)" "=>  (FACT)" ";; もちろん、トレースの出力の書式は実装依存です。"
      "(with-output-to-string (*trace-output*)" "  (fact 3)) " "=>  \"" "1 Enter FACT 3"
      "| 2 Enter FACT 2" "|   3 Enter FACT 1" "|   3 Exit FACT 1" "| 2 Exit FACT 2"
      "1 Exit FACT 6\""))
    (CHAPTER ("## 参考") 2 (CODE1 "*terminal-io*") "," (CODE1 "synonym-stream") ","
     (CODE1 "time") "," (CODE1 "trace") "," "9. コンディション," "23. リーダー," "22. プリンター")
    (CHAPTER ("## 備考") 2 "I/Oカスタマイズ変数の初期値に対する制限の意図は、" "実装の柔軟性を過度に制限することなく、"
     "これらの変数を別のI/Oカスタマイズ変数の値に束縛と代入することが" "常に安全であることを保証ためです。" EOL2 (CODE1 "*debug-io*")
     "と" (CODE1 "*query-io*") "の初期値を同じストリームに、" (CODE1 "*error-output*") "と"
     (CODE1 "*standard-output*") "の初期値を同じストリームにするような" "実装が一般的です。" EOL2 (CODE1 "y-or-n-p")
     "と" (CODE1 "yes-or-no-p") "関数は、" "入出力にクエリ―I/Oを使用します。" EOL2 "通常の"
     (CODE1 "Lisp read-eval-print-loop") "では、入力は標準入力から行います。" "多くの入力関数について、"
     (CODE1 "read") "と" (CODE1 "read-char") "を含む関数は、" "引数のデフォルトに標準入力のストリームを取ります。" EOL2
     "通常の" (CODE1 "Lisp read-eval-print-loop") "では、出力は標準出力から行います。" "多くの出力関数について、"
     (CODE1 "print") "と" (CODE1 "write-char") "を含む関数は、" "引数のデフォルトに標準出力のストリームを取ります。" EOL2
     "例えば、あるプログラムは出力をファイルに対して行いたいときは" (CODE1 "*standard-output*") "を束縛することによって実施するべきです。"
     "そうすることによって" "（" (CODE1 "*error-output*") "が" (CODE1 "*terminal-io*")
     "に束縛されているときは）、" (CODE1 "*error-output*") "に送信されたエラーメッセージは、" "通常望まれる形で、"
     (CODE1 "*terminal-io*") "を経由してユーザーに届きます。")))
(setf (gethash '("*STANDARD-OUTPUT*" . "VARIABLE") *table*) (gethash "*STANDARD-OUTPUT*" *table*))
(setf (gethash "*TERMINAL-IO*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*TERMINAL-IO*")) (CHAPTER ("## 値の型") 2 "双方向ストリーム")
    (CHAPTER ("## 初期値") 2 "実装依存ですが、" "開いたストリームでなければならず、" "それはI/Oカスタマイズ変数に対する一般化された"
     (CODE1 "synonym") "ストリームではなく、" "あるI/Oカスタマイズ変数の値に対する一般化された" (CODE1 "synonym")
     "ストリームの" "可能性があります。")
    (CHAPTER ("## 定義") 2 (CODE1 "*terminal-io*") "の値は、端末I/Oと呼ばれ、"
     "ユーザーの端末に接続された通常の双方向ストリームです。" "例えば、典型的にはこのストリームの書き込みはディスプレイの画面上に" "出力として現れるものとなり、"
     "このストリームの読み込みは、" "キーボードからの入力として受け付けられます。" "これは、" (CODE1 "read") "や"
     (CODE1 "read-char") "のような標準入力を使う関数が" "これらがストリームを使用するとき、"
     "入力のエコーがそのストリームの出力に行われることを意図しています。" "これがどのように実行されるかは実装依存です。" EOL2
     (CODE1 "*terminal-io*") "の値の変更についての効果は、" "それが束縛か代入かに関わらず、実装依存です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(progn (prin1 'foo) (prin1 'bar *terminal-io*))"
      ">>  FOOBAR" "=>  BAR" "(with-output-to-string (*standard-output*)"
      "  (prin1 'foo) " "  (prin1 'bar *terminal-io*))" ">>  BAR" "=>  \"FOO\""))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "*debug-io*") "," (CODE1 "*error-output*") ","
     (CODE1 "*query-io*") "," (CODE1 "*standard-input*") "," (CODE1 "*standard-output*")
     "," (CODE1 "*trace-output*"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("*TERMINAL-IO*" . "VARIABLE") *table*) (gethash "*TERMINAL-IO*" *table*))
(setf (gethash "*TRACE-OUTPUT*" *table*)
  '((CHAPTER NIL 0 "Variable " (CODE1 "*DEBUG-IO*") ", " (CODE1 "*ERROR-OUTPUT*") ", "
     (CODE1 "*QUERY-IO*") "," " " (CODE1 "*STANDARD-INPUT*") ", "
     (CODE1 "*STANDARD-OUTPUT*") ", " (CODE1 "*TRACE-OUTPUT*"))
    (CHAPTER ("## 値の型") 2 (CODE1 "*standard-input*") "は、入力ストリーム" EOL1
     (CODE1 "*error-output*") "," (CODE1 "*standard-output*") ","
     (CODE1 "*trace-output*") "は、出力ストリーム" EOL1 (CODE1 "*debug-io*") ","
     (CODE1 "*query-io*") "は、双方向ストリーム")
    (CHAPTER ("## 初期値") 2 "実装依存ですが、" "開いたストリームでなければならず、" "それはI/Oカスタマイズ変数に対する一般化された"
     (CODE1 "synonym") "ストリームではなく、" "あるI/Oカスタマイズ変数の値に対する一般化された" (CODE1 "synonym")
     "ストリームの" "可能性があります。" "その初期値もまた一般化された" (CODE1 "synonym") "ストリームであり、"
     (CODE1 "*terminal-io*") "かその値のストリームかのどちらかを指します。")
    (CHAPTER ("## 定義") 2 "これらの変数はまとめて標準化されたI/Oカスタマイズ変数と呼ばれます。"
     "これらは、様々な標準化された操作と機能によって使われる入出力の" "標準での宛先を変更するために、束縛と代入をすることができます。" EOL2
     (CODE1 "*debug-io*") "の値は、デバッグI/Oと呼ばれ、" "対話式のデバッグ機能を使うためのストリームです。" EOL2
     (CODE1 "*error-output*") "の値は、エラー出力と呼ばれ、" "警告と非対話式エラーメッセージが送られるべきストリームです。" EOL2
     (CODE1 "*query-io*") "の値は、クエリ―I/Oと呼ばれ、" "ユーザーの質問と返答を行うために使われる双方向ストリームです。"
     "質問はこのストリームに出力され、" "返信はこのストリームから読み込まれるべきです。" EOL2 (CODE1 "*standard-input*")
     "の値は、標準入力と呼ばれ、" "多くの操作で入力ストリームが指定されなかったときに" "デフォルトの入力元として暗に指定されたものとして"
     "利用されるストリームです。" EOL2 (CODE1 "*standard-output*") "の値は、標準出力と呼ばれ、"
     "多くの操作で出力ストリームが指定されなかったときに" "デフォルトの出力元として暗に指定されたものとして" "利用されるストリームです。" EOL2
     (CODE1 "*trace-output*") "の値は、トレース出力と呼ばれ、" "トレースを行う関数（" (CODE1 "trace") "を参照）と、"
     (CODE1 "time") "マクロによる出力によって印字されるストリームです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-output-to-string (*error-output*)"
      "  (warn \"this string is sent to *error-output*\"))"
      "=>  \"Warning: this string is sent to *error-output*"
      "\" ;The exact format of this string is implementation-dependent." NIL
      "(with-input-from-string (*standard-input* \"1001\")"
      "   (+ 990 (read))) =>  1991                       " NIL
      "(progn (setq out (with-output-to-string (*standard-output*)"
      "                    (print \"print and format t send things to\")"
      "                    (format t \"*standard-output* now going to a string\")))"
      "       :done)" "=>  :DONE" "out" "=>  \""
      "\\\"print and format t send things to\\\" *standard-output* now going to a string\""
      NIL "(defun fact (n) (if (< n 2) 1 (* n (fact (- n 1)))))" "=>  FACT"
      "(trace fact)" "=>  (FACT)" ";; もちろん、トレースの出力の書式は実装依存です。"
      "(with-output-to-string (*trace-output*)" "  (fact 3)) " "=>  \"" "1 Enter FACT 3"
      "| 2 Enter FACT 2" "|   3 Enter FACT 1" "|   3 Exit FACT 1" "| 2 Exit FACT 2"
      "1 Exit FACT 6\""))
    (CHAPTER ("## 参考") 2 (CODE1 "*terminal-io*") "," (CODE1 "synonym-stream") ","
     (CODE1 "time") "," (CODE1 "trace") "," "9. コンディション," "23. リーダー," "22. プリンター")
    (CHAPTER ("## 備考") 2 "I/Oカスタマイズ変数の初期値に対する制限の意図は、" "実装の柔軟性を過度に制限することなく、"
     "これらの変数を別のI/Oカスタマイズ変数の値に束縛と代入することが" "常に安全であることを保証ためです。" EOL2 (CODE1 "*debug-io*")
     "と" (CODE1 "*query-io*") "の初期値を同じストリームに、" (CODE1 "*error-output*") "と"
     (CODE1 "*standard-output*") "の初期値を同じストリームにするような" "実装が一般的です。" EOL2 (CODE1 "y-or-n-p")
     "と" (CODE1 "yes-or-no-p") "関数は、" "入出力にクエリ―I/Oを使用します。" EOL2 "通常の"
     (CODE1 "Lisp read-eval-print-loop") "では、入力は標準入力から行います。" "多くの入力関数について、"
     (CODE1 "read") "と" (CODE1 "read-char") "を含む関数は、" "引数のデフォルトに標準入力のストリームを取ります。" EOL2
     "通常の" (CODE1 "Lisp read-eval-print-loop") "では、出力は標準出力から行います。" "多くの出力関数について、"
     (CODE1 "print") "と" (CODE1 "write-char") "を含む関数は、" "引数のデフォルトに標準出力のストリームを取ります。" EOL2
     "例えば、あるプログラムは出力をファイルに対して行いたいときは" (CODE1 "*standard-output*") "を束縛することによって実施するべきです。"
     "そうすることによって" "（" (CODE1 "*error-output*") "が" (CODE1 "*terminal-io*")
     "に束縛されているときは）、" (CODE1 "*error-output*") "に送信されたエラーメッセージは、" "通常望まれる形で、"
     (CODE1 "*terminal-io*") "を経由してユーザーに届きます。")))
(setf (gethash '("*TRACE-OUTPUT*" . "VARIABLE") *table*) (gethash "*TRACE-OUTPUT*" *table*))
(setf (gethash "ABORT" *table*)
  '("ABORT FUNCTION" EOL1 "ABORT RESTART" EOL1))
(setf (gethash '("ABORT" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ABORT") ", " (CODE1 "CONTINUE") ", "
     (CODE1 "MUFFLE-WARNING") ", " (CODE1 "STORE-VALUE") ", " (CODE1 "USE-VALUE"))
    (CHAPTER ("## 構文") 2 (CODE1 "abort") " " (CODE1 "&optional") " " (STRONG "condition")
     " => " (CODE1 "|") EOL1 (CODE1 "continue") " " (CODE1 "&optional") " "
     (STRONG "condition") " => " (CODE1 "nil") EOL1 (CODE1 "muffle-warning") " "
     (CODE1 "&optional") " " (STRONG "condition") " => " (CODE1 "|") EOL1
     (CODE1 "store-value") " " (STRONG "value") " " (CODE1 "&optional") " "
     (STRONG "condition") " => " (CODE1 "nil") EOL1 (CODE1 "use-value") " "
     (STRONG "value") " " (CODE1 "&optional") " " (STRONG "condition") " => "
     (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "value") " - オブジェクト" EOL1 (STRONG "condition")
     " - コンディションオブジェクトか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "もっとも最近確立された適用可能な" (CODE1 "restart") "のうち、"
     "関数と同じ名前を持つものへ制御が遷移されます。" "つまり、" (CODE1 "abort") "関数は" "適用可能な" (CODE1 "abort") " "
     (CODE1 "restart") "を探し、" (CODE1 "continue") "関数は" "適用可能な" (CODE1 "continue") " "
     (CODE1 "restart") "を探し、" "他も同様です。" EOL2 "もしそのような" (CODE1 "restart") "が存在しないときは、"
     (CODE1 "continue") ", " (CODE1 "store-value") "," (CODE1 "use-value") "は"
     (CODE1 "nil") "を返却し、" (CODE1 "abort") "と" (CODE1 "muffle-warning") "は" "型"
     (CODE1 "control-error") "のエラーを発生します。" EOL2 "もし" (STRONG "condition") "が"
     (CODE1 "nil") "ではないときは、" "それらの" (CODE1 "restart") "は、明に" (STRONG "condition")
     "と関連付けられているものか、" "あるいはどのコンディションにも関連付けられてないものかの" "どちらかのみが集められます。" "これは、排他された"
     (CODE1 "restart") "というのは、" "関連付けられたコンディションの集合が空ではなく、" "その要素に指定した"
     (STRONG "condition") "が含まれていないということです。" "もし" (STRONG "condition") "が" (CODE1 "nil")
     "のときは、" "全ての" (CODE1 "restart") "が集められます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";;; ABORT restartの例" NIL
      "(defmacro abort-on-error (&body forms)" "  `(handler-bind ((error #'abort))"
      "     ,@forms)) =>  ABORT-ON-ERROR" "(abort-on-error (+ 3 5)) =>  8"
      "(abort-on-error (error \"You lose.\"))" ">>  Returned to Lisp Top Level." NIL
      ";;; CONTINUE restartの例" NIL "(defun real-sqrt (n)" "  (when (minusp n)"
      "    (setq n (- n))"
      "    (cerror \"Return sqrt(~D) instead.\" \"Tried to take sqrt(-~D).\" n))"
      "  (sqrt n))" NIL "(real-sqrt 4) =>  2" "(real-sqrt -9)"
      ">>  Error: Tried to take sqrt(-9)."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Return sqrt(9) instead." ">>   2: Return to Lisp Toplevel."
      ">>  Debug> (continue)" ">>  Return sqrt(9) instead." "=>  3" " "
      " (handler-bind ((error #'(lambda (c) (continue))))" "   (real-sqrt -9)) =>  3" NIL
      ";;; MUFFLE-WARNING restartの例" NIL "(defun count-down (x)"
      "  (do ((counter x (1- counter)))" "      ((= counter 0) 'done)"
      "    (when (= counter 1)" "      (warn \"Almost done\"))"
      "    (format t \"~&~D~%\" counter)))" "=>  COUNT-DOWN" "(count-down 3)" ">>  3"
      ">>  2" ">>  Warning: Almost done" ">>  1" "=>  DONE"
      "(defun ignore-warnings-while-counting (x)"
      "  (handler-bind ((warning #'ignore-warning))" "    (count-down x)))"
      "=>  IGNORE-WARNINGS-WHILE-COUNTING" "(defun ignore-warning (condition)"
      "  (declare (ignore condition))" "  (muffle-warning))" "=>  IGNORE-WARNING"
      " (ignore-warnings-while-counting 3)" ">>  3" ">>  2" ">>  1" "=>  DONE" NIL
      ";;; STORE-VALUE restartとUSE-VALUE restartの例" NIL
      "(defun careful-symbol-value (symbol)" "  (check-type symbol symbol)"
      "  (restart-case (if (boundp symbol)"
      "                    (return-from careful-symbol-value "
      "                                 (symbol-value symbol))"
      "                    (error 'unbound-variable"
      "                           :name symbol))" "    (use-value (value)"
      "      :report \"Specify a value to use this time.\"" "      value)"
      "    (store-value (value)"
      "      :report \"Specify a value to store and use in the future.\""
      "      (setf (symbol-value symbol) value))))" "(setq a 1234) =>  1234"
      "(careful-symbol-value 'a) =>  1234" "(makunbound 'a) =>  A"
      "(careful-symbol-value 'a)" ">>  Error: A is not bound."
      ">>  To continue, type :CONTINUE followed by an option number."
      ">>   1: Specify a value to use this time."
      ">>   2: Specify a value to store and use in the future."
      ">>   3: Return to Lisp Toplevel." ">>  Debug> (use-value 12)" "=>  12"
      "(careful-symbol-value 'a)" ">>  Error: A is not bound."
      ">>  To continue, type :CONTINUE followed by an option number."
      ">>    1: Specify a value to use this time."
      ">>    2: Specify a value to store and use in the future."
      ">>    3: Return to Lisp Toplevel." ">>  Debug> (store-value 24)" "=>  24"
      " (careful-symbol-value 'a)" "=>  24" NIL ";;; USE-VALUE restartの例" NIL
      "(defun add-symbols-with-default (default &rest symbols)"
      "  (handler-bind ((sys:unbound-symbol" "                   #'(lambda (c)"
      "                       (declare (ignore c)) "
      "                       (use-value default))))"
      "    (apply #'+ (mapcar #'careful-symbol-value symbols))))"
      "=>  ADD-SYMBOLS-WITH-DEFAULT" "(setq x 1 y 2) =>  2"
      "(add-symbols-with-default 3 'x 'y 'z) =>  6"))
    (CHAPTER ("## 副作用") 2 "適用可能な" (CODE1 "restart") "が使用可能なときに" "制御の遷移が起こるかもしれませんし、"
     "あるいは（" (CODE1 "abort") "関数か" (CODE1 "muffle-warning") "関数の場合は）" "実行が停止するかもしれません。")
    (CHAPTER ("## 影響") 2 "もし適用可能な" (CODE1 "abort") " " (CODE1 "restart") "が" "利用不可の状態で"
     (CODE1 "abort") "関数が実行されれたときか、" "適用可能な" (CODE1 "muffle-warning") " "
     (CODE1 "restart") "が" "利用不可の状態で" (CODE1 "muffle-warning") "関数が実行されれたときは、" "型"
     (CODE1 "control-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "invoke-restart") "," "9.1.4.2. " (CODE1 "restart") ","
     "9.1.4.2.2. " (CODE1 "restart") "のインターフェイス," (CODE1 "assert") "," (CODE1 "ccase")
     "," (CODE1 "cerror") "," (CODE1 "check-type") "," (CODE1 "ctypecase") ","
     (CODE1 "use-value") "," (CODE1 "warn"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(abort condition) ==  (invoke-restart 'abort)"
      "(muffle-warning)  ==  (invoke-restart 'muffle-warning)"
      "(continue)        ==  (let ((r (find-restart 'continue))) (if r (invoke-restart r)))"
      "(use-value x) ==  (let ((r (find-restart 'use-value))) (if r (invoke-restart r x)))"
      "(store-value x) ==  (let ((r (find-restart 'store-value))) (if r (invoke-restart r x)))")
     EOL2 "この仕様書で" (CODE1 "use-value") " " (CODE1 "restart") "の提供に" "要求される関数定義はありません。")))
(setf (gethash '("ABORT" . "RESTART") *table*)
  '((CHAPTER NIL 0 "Restart " (CODE1 "ABORT")) (CHAPTER ("## 要求される引数のデータ") 2 "なし。")
    (CHAPTER ("## 定義") 2 (CODE1 "abort") " " (CODE1 "restart") "の意味は、"
     "もっとも内側の「コマンドレベル」に戻ることを許すことです。" "実装者は、どんなユーザーコードでも" "常に" (CODE1 "abort") "という名前の"
     (CODE1 "restart") "で" "囲むことを確実に推奨します。" "なぜなら、ユーザーコードではいつでも" (CODE1 "abort")
     "を呼ぶことができ、" "合理的な何かが起こることを期待することができます。" "正確に何が合理的なことなのかは多少変わるかもしれません。" EOL2
     "通常、対話型で処理しているときは、" (CODE1 "abort") "を実行すると" "Lispの" (CODE1 "read-eval-print")
     "ループのLisp readerフェーズに戻りますが、" "バッチ処理やマルチプロセス処理では、" "実行中のプロセスを" (CODE1 "kill")
     "させる方が適切な場合があります。")
    (CHAPTER ("## 参考") 2 "9.1.4.2. " (CODE1 "restart") "," "9.1.4.2.2. "
     (CODE1 "restart") "のインターフェイス," (CODE1 "invoke-restart") "," (CODE1 "abort") "（関数）")))
(setf (gethash "ACONS" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ACONS"))
    (CHAPTER ("## 構文") 2 (CODE1 "acons") " " (STRONG "key") " " (STRONG "datum") " "
     (STRONG "alist") " => " (STRONG "new-alist"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "key") " - オブジェクト" EOL1 (STRONG "datum") " - オブジェクト"
     EOL1 (STRONG "alist") " - 連想リスト" EOL1 (STRONG "new-alist") " - 連想リスト")
    (CHAPTER ("## 定義") 2 "新しいコンスを作成し、その" (CODE1 "cdr") "が" (STRONG "alist") "、"
     (CODE1 "car") "が別の新しいコンスであり、" "その" (CODE1 "car") "が" (STRONG "key") "、"
     (CODE1 "cdr") "が" (STRONG "datum") "です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq alist '()) =>  NIL"
      "(acons 1 \"one\" alist) =>  ((1 . \"one\"))" "alist =>  NIL"
      "(setq alist (acons 1 \"one\" (acons 2 \"two\" alist))) =>  ((1 . \"one\") (2 . \"two\"))"
      "(assoc 1 alist) =>  (1 . \"one\")"
      "(setq alist (acons 1 \"uno\" alist)) =>  ((1 . \"uno\") (1 . \"one\") (2 . \"two\"))"
      "(assoc 1 alist) =>  (1 . \"uno\")"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "assoc") "," (CODE1 "pairlis"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(acons key datum alist) ==  (cons (cons key datum) alist)"))))
(setf (gethash '("ACONS" . "FUNCTION") *table*) (gethash "ACONS" *table*))
(setf (gethash "ADD-METHOD" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "ADD-METHOD"))
    (CHAPTER ("## 構文") 2 (CODE1 "add-method") " " (STRONG "generic-function") " "
     (STRONG "method") " => " (STRONG "generic-function"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "add-method") " (" (STRONG "generic-function") " "
     (CODE1 "standard-generic-function") ")" " (" (STRONG "method") " " (CODE1 "method")
     ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "generic-function") " - ジェネリック関数オブジェクト" EOL1
     (STRONG "method") " - メソッドオブジェクト")
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "add-method") "は、ジェネリック関数にメソッドを追加します。" EOL2
     "もし" (STRONG "method") "が、ジェネリック関数の既存のメソッドと" "特定パラメータおよび修飾子で合致する場合は、"
     "既存のメソッドが置き換えられます。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "method") "のラムダリストは、" (STRONG "generic-generic")
     "のラムダリストと一致する必要があり、" "そうでない場合は型" (CODE1 "error") "のエラーが発生します。" EOL2 "もし"
     (STRONG "method") "が他のジェネリック関数のメソッドオブジェクトであるとき、" "型" (CODE1 "error") "のエラーが発生します。")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("ADD-METHOD" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "ADD-METHOD" *table*))
(setf (gethash "ADJOIN" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ADJOIN"))
    (CHAPTER ("## 構文") 2 (CODE1 "adjoin") " " (STRONG "item") " " (STRONG "list")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "new-list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "list") " - 通常のリスト"
     EOL1 (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test-not") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "new-list") " - リスト")
    (CHAPTER ("## 定義") 2 (STRONG "item") "と同じものが、" (STRONG "list")
     "の既存の要素にあるかどうかをテストします。" "もし" (STRONG "item") "が既存の要素に存在しないときは、" (CODE1 "adjoin")
     "は、" (CODE1 "cons") "によって" (STRONG "list") "に追加したあと、" "その結果を返却します。"
     "存在するときは、何も加えないまま元の" (STRONG "list") "を返却します。" EOL2 (STRONG "test") ", "
     (STRONG "test-not") "と" (STRONG "key") "は、" (STRONG "list") "の要素と" (STRONG "item")
     "が" "同じかどうかをどのように決めるかに影響します。" "詳しい説明は17.2.1. 2つの引数のテストをご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq slist '()) =>  NIL " "(adjoin 'a slist) =>  (A) "
      "slist =>  NIL " "(setq slist (adjoin '(test-item 1) slist)) =>  ((TEST-ITEM 1)) "
      "(adjoin '(test-item 1) slist) =>  ((TEST-ITEM 1) (TEST-ITEM 1)) "
      "(adjoin '(test-item 1) slist :test 'equal) =>  ((TEST-ITEM 1)) "
      "(adjoin '(new-test-item 1) slist :key #'cadr) =>  ((TEST-ITEM 1)) "
      "(adjoin '(new-test-item 1) slist) =>  ((NEW-TEST-ITEM 1) (TEST-ITEM 1)) "))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list") "が通常のリストではないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "pushnew") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。"
     (CODE3 "```lisp" "```" "(adjoin item list :key fn)"
      "  ==  (if (member (fn item) list :key fn) list (cons item list))"))))
(setf (gethash '("ADJOIN" . "FUNCTION") *table*) (gethash "ADJOIN" *table*))
(setf (gethash "ADJUST-ARRAY" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ADJUST-ARRAY"))
    (CHAPTER ("## 構文") 2 (CODE1 "adjust-array") " " (STRONG "array") " "
     (STRONG "new-dimensions") " " (CODE1 "&key") " " (STRONG "element-type") " "
     (STRONG "initial-element") " " (STRONG "initial-contents") "  "
     (STRONG "fill-pointer") " " (STRONG "displaced-to") " "
     (STRONG "displaced-index-offset") " => " (STRONG "adjusted-array"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "array") " - 配列" EOL1 (STRONG "new-dimensions")
     " - 有効な配列の大きさか、" "有効な配列の大きさのリストの指定子" EOL1 (STRONG "element-type") " - 型指定子" EOL1
     (STRONG "initial-element") " - オブジェクト。" "もし" (STRONG "initial-contents") "か"
     (STRONG "displaced-to") "が指定されたときは、" (STRONG "initial-element") "は指定してはいけません。" EOL1
     (STRONG "initial-contents") " - オブジェクト。" "もし" (STRONG "array") "のランクがゼロより大きいときは、"
     (STRONG "initial-contents") "はシーケンスのネストによって構成されたものであり、" "その深さは" (STRONG "array")
     "のランクと等しくなければなりません。" "それ以外のときは、" (STRONG "array") "はゼロ次元であり"
     (STRONG "initial-contents") "はひとつの要素を指定します。" "もし" (STRONG "initial-element") "か"
     (STRONG "displaced-to") "が与えられたときは、" (STRONG "initial-contents") "を指定してはいけません。" EOL1
     (STRONG "fill-pointer") " - 作成される配列の有効なfill-pointerか、" (CODE1 "t") "か、"
     (CODE1 "nil") "。" "デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "displaced-to") " - 配列か、"
     (CODE1 "nil") "。" "デフォルトは" (CODE1 "nil") "。" "もし" (STRONG "displaced-to") "が指定されたら、"
     (STRONG "initial-element") "と" (STRONG "initial-contents") "は指定できません。" EOL1
     (STRONG "displaced-index-offset") " - 型" (CODE1 "(fixnum 0 n)") "のオブジェクトであり、"
     (CODE1 "n") "は" (CODE1 "(array-total-size displaced-to)") "で表されます。" "もし"
     (STRONG "displaced-to") "が指定されたときのみ、" (STRONG "displaced-index-offset") "を指定できます。"
     EOL1 "adjusted-array - 配列")
    (CHAPTER ("## 定義") 2 (CODE1 "adjust-array") "は" (STRONG "array") "の次元か要素を変更します。"
     "その返却値は" (STRONG "array") "と同じ型とランクの配列であり、" (STRONG "array")
     "が修正されたものか新しく生成された配列のいずれかであり、" "また" (STRONG "array") "を" (CODE1 "displaced")
     "にできますし、" "与えられた" (STRONG "new-dimensions") "を持つようにもできます。" EOL2
     (STRONG "new-dimensions") "は" (STRONG "array") "の各次元のサイズです。" EOL2
     (STRONG "element-type") "は結果の配列の要素の型を指定します。" "もし" (STRONG "element-type")
     "が指定されたとき、" (STRONG "array") "の実際の配列の要素の型と" (STRONG "element-type")
     "のアップグレードされた配列の要素の型が" "等しくないときの結果は未定義です。" EOL2 "もし" (STRONG "initial-contents")
     "が指定されたとき、" "それは" (CODE1 "make-array") "と同じように扱われます。" "このような場合、" (STRONG "array")
     "の元の内容は結果の配列には現れません。" EOL2 "もし" (STRONG "fill-pointer") "が整数のとき、"
     "それは結果の配列のfill-pointerになります。" "もし" (STRONG "fill-pointer") "がシンボルの" (CODE1 "t")
     "のとき、" "それは結果の配列のサイズがfill-pointerとして使われるべきことを示します。" "もし" (STRONG "fill-pointer") "が"
     (CODE1 "nil") "のときは、" "それはfill-pointerではなくなることを示します。" EOL2 "もし"
     (STRONG "displaced-to") "が" (CODE1 "nil") "ではないとき、" (CODE1 "displaced")
     "の配列が生成されます。" "結果の配列は" (STRONG "displaced-to") "によって与えられた配列の内容を共有します。" "結果の配列は"
     (CODE1 "displaced-to") "の配列よりも多い要素を含むことができません。" "もし" (STRONG "displaced-to")
     "が指定されなかったか、あるいは" (CODE1 "nil") "のとき、" "結果の配列は" (CODE1 "displaced") "の配列ではありません。"
     "もし配列" (CODE1 "A") "が配列" (CODE1 "B") "を" (CODE1 "displaced") "として生成され、" "続いて配列"
     (CODE1 "B") "が" (CODE1 "adjust-array") "に与えられたら、" (CODE1 "A") "はまだ配列" (CODE1 "B")
     "を" (CODE1 "displaced") "しています。" (STRONG "array") "が" (CODE1 "displaced")
     "の配列であっても、" (STRONG "displaced-to") "が指定されないか、" "あるいは" (CODE1 "nil") "がしていされたときは、"
     "結果の配列は" (CODE1 "displaced") "の配列ではありません。" "この" (CODE1 "adjust-array") "と"
     (CODE1 "displaced") "の配列の相互作用は、" "下記の3つの配列、" (CODE1 "A") ", " (CODE1 "B") ", "
     (CODE1 "C") "によって与えられます。" EOL2 "- " (CODE1 "A") "は呼び出し前と呼び出し後に" (CODE1 "displaced")
     "ではない" "  - " (CODE1 "(adjust-array A ...)") EOL1 "    " (CODE1 "A")
     "の次元は変更され、内容は適切に変更されます。" "    加えて" (CODE1 "A") "の要素は" (STRONG "initial-element")
     "のものを取ります。" "    " (STRONG "initial-contents") "が使われると全ての古い内容が削除されます。"
     "    <br><br>" EOL2 "- " (CODE1 "A") "は呼び出し前は" (CODE1 "displaced") "ではないが、呼び出し後は"
     (CODE1 "C") "の" (CODE1 "displaced") "  - "
     (CODE1 "(adjust-array A ... :displaced-to C)") EOL1 "    " (CODE1 "A") "の元の内容がその後の"
     (CODE1 "A") "に現れることはありません。" "    " (CODE1 "A") "は今は" (CODE1 "C") "の内容を含んでおり、"
     (CODE1 "C") "にはどんな変更も生じません。" "    <br><br>" EOL2 "- " (CODE1 "A") "は呼び出し前は"
     (CODE1 "B") "の" (CODE1 "displaced") "だが、呼び出し後は" (CODE1 "C") "の" (CODE1 "displaced")
     "  - " (CODE1 "(adjust-array A ... :displaced-to B)") EOL1 "    "
     (CODE1 "(adjust-array A ... :displaced-to C)") EOL1 "    " (CODE1 "B") "と"
     (CODE1 "C") "は同じかもしれません。" "    その後のAの内容は、" (CODE1 "B") "にたまたま" (CODE1 "C")
     "の内容があるのではない限り、" "    " (CODE1 "B") "の内容は現れません。" "    もし" (CODE1 "adjust-array")
     "の呼び出しで" "    " (STRONG "displaceed-index-offset") "が与えられなかったときは、" "    デフォルトで"
     (CODE1 "0") "となり、" (CODE1 "B") "への古いオフセットは保持されません。" "    <br><br>" EOL2 "- "
     (CODE1 "A") "は呼び出し前は" (CODE1 "B") "の" (CODE1 "displaced") "であり、その後は"
     (CODE1 "displaced") "ではない" "  - (adjust-array A ... :displaced-to B)" EOL1
     "    (adjust-array A ... :displaced-to nil)" EOL1 "    " (CODE1 "A")
     "は新しい「データ領域」を手に入れ、" "    " (CODE1 "B") "の内容は既存の古い内容を維持するように適切にコピーされます。" "    "
     (CODE1 "A") "の追加の要素は、もし指定があるならば" (STRONG "initial-element") "から取得します。" "    しかし"
     (STRONG "initial-contents") "が使われると全ての古い内容が削除されます。" "    <br><br>" EOL2 "もし"
     (STRONG "displaced-index-offset") "が指定されたとき、" "それは" (CODE1 "displaced")
     "の配列の開始位置からの" "結果の配列のオフセットとして指定します。" "もし" (STRONG "displaced-index-offset")
     "が指定されなかったとき、オフセットは" (CODE1 "0") "です。" "結果の配列のサイズとオフセットを加算した値は、" (CODE1 "displaced")
     "の配列のサイズを越えることはできません。" EOL2 "もし" (STRONG "new-dimensions") "と"
     (STRONG "initial-element") "の引数のみが与えられたとき、" "それらの" (STRONG "array")
     "の要素は、まだ結果の配列の境界内に現れます。" "配列の境界内にはない結果の配列の要素は、" (STRONG "initial-element")
     "によって初期化されます。" "もし" (STRONG "initial-element") "が指定されなかったとき、" (STRONG "new-array")
     "が初期化される前にそのような新しい要素を" "あとで読み込んだときの結果は未定義です。" EOL2 "もし" (STRONG "initial-contents")
     "か" (STRONG "displaced-to") "が指定されたとき、" (STRONG "array") "の元の内容は新しい配列には現れません。" EOL2
     "もし" (STRONG "fill-pointer") "の引数を指定せずに" (STRONG "array")
     "をそのfill-pointerをより小さいサイズに調整し、" "ある処理においてfill-pointerが" "適切に調整されたときの結果は不定です。" EOL2
     "もし" (CODE1 "A") "が" (CODE1 "B") "の" (CODE1 "displaced") "の配列であり、" "もし" (CODE1 "B")
     "が" (CODE1 "A") "にとって十分な要素を満たさないような方法で" "調整されたときの結果は不定です。" EOL2 "もし"
     (CODE1 "adjust-array") "を実際に" (CODE1 "adjustable") "な配列に対して適用したとき、" "返却される配列は"
     (STRONG "array") "と同一です。" "もし" (CODE1 "adjust-array") "によって返却される配列が"
     (STRONG "array") "と同一ではないときは、" "引数の" (STRONG "array") "は変更されません。" EOL2 "もし配列"
     (CODE1 "A") "が別の配列" (CODE1 "B") "を" (CODE1 "displaced") "として指定しており、" "配列"
     (CODE1 "B") "が別の配列" (CODE1 "C") "を" (CODE1 "displaced") "として指定しているとき、" (CODE1 "B")
     "が" (CODE1 "adjust-array") "によって変更されたときは、" (CODE1 "A") "はその時点で修正された" (CODE1 "B")
     "の内容を参照する" "必要があることに注意してください。" "これは、実装は" (CODE1 "A") "の参照を直接" (CODE1 "C") "に結び付けて、"
     (CODE1 "B") "の参照を通すことを無視するような" "破綻した修正をしてはいけないという意味です。" "しかし、ここで示された意味を守るようにした"
     "キャッシュの実装は許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(adjustable-array-p" " (setq ada (adjust-array"
      "             (make-array '(2 3)" "                         :adjustable t"
      "                         :initial-contents '((a b c) (1 2 3)))"
      "             '(4 6)))) =>  T " "(array-dimensions ada) =>  (4 6) "
      "(aref ada 1 1) =>  2 " "(setq beta (make-array '(2 3) :adjustable t))"
      "=>  #2A((NIL NIL NIL) (NIL NIL NIL)) "
      "(adjust-array beta '(4 6) :displaced-to ada)" "=>  #2A((A B C NIL NIL NIL)"
      "      (1 2 3 NIL NIL NIL)" "      (NIL NIL NIL NIL NIL NIL) "
      "      (NIL NIL NIL NIL NIL NIL))" "(array-dimensions beta) =>  (4 6)"
      "(aref beta 1 1) =>  2 ")
     EOL2 "4×4の配列である" (CODE1 "m") "は下記のようになると仮定します。"
     (CODE3 "```lisp" "```" "#2A(( alpha     beta      gamma     delta )"
      "    ( epsilon   zeta      eta       theta )"
      "    ( iota      kappa     lambda    mu    )"
      "    ( nu        xi        omicron   pi    ))")
     EOL2 "このとき、次に文を考えます。"
     (CODE3 "```lisp" "```" "(adjust-array m '(3 5) :initial-element 'baz)") EOL2
     "結果は3×5の配列になり、内容は次の通り。"
     (CODE3 "```lisp" "```" "#2A(( alpha     beta      gamma     delta     baz )"
      "    ( epsilon   zeta      eta       theta     baz )"
      "    ( iota      kappa     lambda    mu        baz ))"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "fill-pointer") "が" (CODE1 "nil") "で指定されたにもかかわらず、"
     (STRONG "array") "がfill-pointerを持たないときは、" "型" (CODE1 "error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "adjustable-array-p") "," (CODE1 "make-array") ","
     (CODE1 "array-dimension-limit") "," (CODE1 "array-total-size-limit") ","
     (CODE1 "array"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("ADJUST-ARRAY" . "FUNCTION") *table*) (gethash "ADJUST-ARRAY" *table*))
(setf (gethash "ADJUSTABLE-ARRAY-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ADJUSTABLE-ARRAY-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "adjustable-array-p") " " (STRONG "array") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "array") " - 配列" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "adjust-array") "がその最初の引数として与えられた配列" (STRONG "array") "と"
     "同一の値を返却できる場合にのみ、" (STRONG "true") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(adjustable-array-p " "  (make-array 5"
      "              :element-type 'character " "              :adjustable t "
      "              :fill-pointer 3)) =>  true"
      "(adjustable-array-p (make-array 4)) =>  implementation-dependent"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし引数が配列でないときは型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "adjust-array") "," (CODE1 "make-array"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("ADJUSTABLE-ARRAY-P" . "FUNCTION") *table*) (gethash "ADJUSTABLE-ARRAY-P" *table*))
(setf (gethash "ALLOCATE-INSTANCE" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "ALLOCATE-INSTANCE"))
    (CHAPTER ("## 構文") 2 (CODE1 "allocate-instance") " " (STRONG "class") " &rest "
     (STRONG "initargs") " &key &allow-other-keys => " (STRONG "new-instance"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "allocate-instance") " (" (STRONG "class") " "
     (CODE1 "standard-class") ") &rest " (STRONG "initargs") EOL1
     (CODE1 "allocate-instance") " (" (STRONG "class") " " (CODE1 "structure-class")
     ") &rest " (STRONG "initargs"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "class") " - クラス" EOL1 (STRONG "initargs")
     " - keyword/valueのペアのリスト（初期化引数の名前と値）" EOL1 (STRONG "new-instance") " - クラスが"
     (STRONG "class") "のオブジェクト")
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "allocate-instance") "は、" (STRONG "class")
     "の新しいインスタンスを作成し、初期化せずに返却します。" "もし" (STRONG "class") "が" (CODE1 "standard-class")
     "のクラスのときは、" "スロットが" (CODE1 "unbound") "になるという意味です。" "あるいは、" (STRONG "class") "が"
     (CODE1 "structure-class") "のクラスのときは、" "スロットの値は規定されていません。" EOL2
     (CODE1 "allocate-instance") "の呼び出し側は、" "初期化引数がすでにチェックされていることを期待しています。" EOL2
     "ジェネリック関数" (CODE1 "allocate-instance") "は、" (CODE1 "make-instance") "によって呼ばれます。"
     "7.1. オブジェクトの作成と初期化に定義されています。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "defclass") "," (CODE1 "make-instance") ","
     (CODE1 "class-of") "," "7.1. オブジェクトの作成と初期化")
    (CHAPTER ("## 備考") 2 (CODE1 "allocate-instance") "へメソッドを追加した結果は規定されていません。"
     "この機能は、Metaobject Protocolによって追加されるかもしれません。")))
(setf (gethash '("ALLOCATE-INSTANCE" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "ALLOCATE-INSTANCE" *table*))
(setf (gethash "ALPHA-CHAR-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ALPHA-CHAR-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "alpha-char-p") " " (STRONG "character")
     " => generalized-boolean")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " - 文字" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "character") "がアルファベット文字であったら" (STRONG "true") "、それ以外は"
     (STRONG "false") "。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(alpha-char-p #\\a) =>  true"
      "(alpha-char-p #\\5) =>  false" "(alpha-char-p #\\Newline) =>  false"
      ";; 次の例では、#\\<ALPHA>という文字が定義されている処理系を前提にしている。"
      "(alpha-char-p #\\<ALPHA>) => 処理系依存 "))
    (CHAPTER ("## 影響") 2 "なし。" "（この関数の結果は、現在のreadtableで有効になっているかもしれない" "特別な構文に依存しません。）")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "character") "が文字ではなかったら、型" (CODE1 "type-error")
     "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 (CODE1 "alphanumericp") ", 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("ALPHA-CHAR-P" . "FUNCTION") *table*) (gethash "ALPHA-CHAR-P" *table*))
(setf (gethash "ALPHANUMERICP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ALPHANUMERICP"))
    (CHAPTER ("## 構文") 2 (CODE1 "alphanumericp") " " (STRONG "character") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " - 文字" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "character") "がアルファベット文字か数字であったら" (STRONG "true") "、"
     "それ以外は" (STRONG "false") "。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(alphanumericp #\\Z) =>  true"
      "(alphanumericp #\\9) =>  true" "(alphanumericp #\\Newline) =>  false"
      "(alphanumericp #\\#) =>  false"))
    (CHAPTER ("## 影響") 2 "なし。" "（この関数の結果は、現在のreadtableで有効になっているかもしれない" "特別な構文に依存しません。）")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "character") "が文字ではなかったら、型" (CODE1 "type-error")
     "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 (CODE1 "alphanumericp") ", 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "英数字は、" (CODE1 "graphic-char-p") "で定義される図形文字です。"
     "英数字は、図形文字のサブセットです。" "標準文字の" (CODE1 "A") "～" (CODE1 "Z") "、" (CODE1 "a") "～"
     (CODE1 "z") "、" (CODE1 "0") "～" (CODE1 "9") "は英数字です。"
     (CODE3 "```lisp" "```" "(alphanumericp x)"
      "  == (or (alpha-char-p x) (not (null (digit-char-p x))))"))))
(setf (gethash '("ALPHANUMERICP" . "FUNCTION") *table*) (gethash "ALPHANUMERICP" *table*))
(setf (gethash "AND" *table*)
  '("AND MACRO" EOL1 "AND TYPE-SPECIFIER" EOL1))
(setf (gethash '("AND" . "MACRO") *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "AND"))
    (CHAPTER ("## 構文") 2 (CODE1 "and") " " (STRONG "form\\*") " => "
     (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "form") " - フォーム" EOL1 (STRONG "result") " - 最後の"
     (STRONG "form") "の評価の結果の値か、" "シンボルの" (CODE1 "nil") "か" (CODE1 "t") "。")
    (CHAPTER ("## 定義") 2 "マクロ" (CODE1 "and") "は、各" (STRONG "form") "を左から右へひとつずつ評価します。"
     "どれかの" (STRONG "form") "の評価が" (CODE1 "nil") "を返却したとき、" (CODE1 "and") "は残りの"
     (STRONG "form") "を評価せず" "すぐに" (CODE1 "nil") "を返却します。" "もし最後以外の全ての" (STRONG "form")
     "が" (STRONG "true") "の値であれば、" (CODE1 "and") "は、最後の" (STRONG "form")
     "の評価によって生成された結果を返却します。" EOL2 (STRONG "form") "がないときは、" (CODE1 "(and)") "は"
     (CODE1 "t") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(if (and (>= n 0)" "         (< n (length a-simple-vector))"
      "         (eq (elt a-simple-vector n) 'foo))" "    (princ \"Foo!\"))")
     EOL2 "上記の式は、もし提供された" (CODE1 "n") "が" (CODE1 "a-simple-vector") "への有効なインデックスであり、"
     "かつ" (CODE1 "a-simple-vector") "の要素" (CODE1 "n") "がシンボル" (CODE1 "foo") "のときは"
     (CODE1 "Foo!") "が印字されます。" (CODE1 "and") "は、その部分が左から右へテストされることが保証されているので、" "もし"
     (CODE1 "n") "が範囲外のときは" (CODE1 "elt") "が呼び出されません。"
     (CODE3 "```lisp" "```" "(setq temp1 1 temp2 1 temp3 1) =>  1 "
      "(and (incf temp1) (incf temp2) (incf temp3)) =>  2 "
      "(and (eql 2 temp1) (eql 2 temp2) (eql 2 temp3)) =>  true" "(decf temp3) =>  1 "
      "(and (decf temp1) (decf temp2) (eq temp3 'nil) (decf temp3)) =>  NIL "
      "(and (eql temp1 temp2) (eql temp2 temp3)) =>  true" "(and) =>  T "))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "cond") "," (CODE1 "every") "," (CODE1 "if") ","
     (CODE1 "or") "," (CODE1 "when"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(and form) == (let () form)"
      "(and form1 form2 ...) == (when form1 (and form2 ...))"))))
(setf (gethash '("AND" . "TYPE-SPECIFIER") *table*)
  '((CHAPTER NIL 0 "Type Specifier " (CODE1 "AND")) (CHAPTER ("## 型指定子の種類") 2 "結合")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "and") " " (STRONG "typespec\\*"))
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "typespec") " - 型指定子")
    (CHAPTER ("## 型指定子の定義") 2 "型" (STRONG "typespec") "の共通部分によって決定される型の"
     "全てのオブジェクトの集合を示します。" EOL2 "引数にシンボル" (CODE1 "*") "は許されません。" EOL2 "型指定子"
     (CODE1 "(and)") "は" (CODE1 "t") "と同等です。" "シンボルとしての" (CODE1 "and")
     "は、有効な型指定子ではありませんし、" "とくに" (CODE1 "(and)") "の省略形ではありません。")))
(setf (gethash "APPEND" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "APPEND"))
    (CHAPTER ("## 構文") 2 (CODE1 "append") " &rest " (STRONG "lists") " => "
     (STRONG "result"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "lists") " - 最後以外の各要素は通常のリストであり、"
     "最後の要素はどんなオブジェクトでも可能です。" EOL1 (STRONG "result") " - オブジェクト。" (STRONG "lists")
     "の最後の要素がリストではなく、" "前のリストがすべて" (CODE1 "null") "という引数ではない限り、" "リストになります。")
    (CHAPTER ("## 定義") 2 (CODE1 "append") "は、コピーを連結させた新しい" (STRONG "lists") "を返却します。"
     (STRONG "lists") "は変更されません。" (STRONG "lists") "の最後以外の各リスト構造をコピーします。"
     "最後の要素はコピーされません。" "それは、先行して結合された" (STRONG "lists") "の" "最後のドットペアの" (CODE1 "cdr")
     "部になるか、" "あるいは" (STRONG "lists") "の先行した要素に" "空ではないリストが存在しなかったときは、" "直接その値が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(append '(a b c) '(d e f) '() '(g)) =>  (A B C D E F G)"
      "(append '(a b c) 'd) =>  (A B C . D)" "(setq lst '(a b c)) =>  (A B C)"
      "(append lst '(d)) =>  (A B C D)" "lst =>  (A B C)" "(append) =>  NIL"
      "(append 'a) =>  A"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "nconc") "," (CODE1 "concatenate"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("APPEND" . "FUNCTION") *table*) (gethash "APPEND" *table*))
(setf (gethash "APPLY" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "APPLY"))
    (CHAPTER ("## 構文") 2 (CODE1 "apply") " " (STRONG "function") " &rest "
     (STRONG "args+") " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function") " - 関数指定子" EOL1 (STRONG "args")
     " - 広げられる引数リスト指定子" EOL1 (STRONG "result") " - " (STRONG "function") "の返却値")
    (CHAPTER ("## 定義") 2 (STRONG "function") "を" (STRONG "args") "で実行します。" EOL2
     (STRONG "function") "が" (CODE1 "&rest") "経由で引数を受け取るとき、" "実装は" (CODE1 "rest")
     "パラメーターに、" (CODE1 "apply") "の最後の引数で共有されている構造のオブジェクトを、" "束縛することが許されています"
     "（ただし要求されているわけではありません）。" "関数はそれが" (CODE1 "apply") "経由か、" "あるいは" (CODE1 "apply")
     "の最後の引数が定数で呼び出されかどうかを" "検出できないため、" "適合するプログラムは、" (CODE1 "rest")
     "のリスト構造が新しいコンスであることに頼ってはいけませんし、" "またそのリスト構造を修正してもいけません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq f '+) =>  +" "(apply f '(1 2)) =>  3"
      "(setq f #'-) =>  #<FUNCTION ->" "(apply f '(1 2)) =>  -1"
      "(apply #'max 3 5 '(2 7 3)) =>  7" "(apply 'cons '((+ 2 3) 4)) =>  ((+ 2 3) . 4)"
      "(apply #'+ '()) =>  0" NIL "(defparameter *some-list* '(a b c))"
      "(defun strange-test (&rest x) (eq x *some-list*))"
      "(apply #'strange-test *some-list*) =>  implementation-dependent" NIL
      "(defun bad-boy (&rest x) (rplacd x 'y))"
      "(bad-boy 'a 'b 'c) has undefined consequences."
      "(apply #'bad-boy *some-list*) has undefined consequences."
      "(defun foo (size &rest keys &key double &allow-other-keys)"
      "  (let ((v (apply #'make-array size :allow-other-keys t keys)))"
      "    (if double (concatenate (type-of v) v v) v)))"
      "(foo 4 :initial-contents '(a b c d) :double t)" "   =>  #(A B C D A B C D)"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "funcall") "," (CODE1 "fdefinition") ","
     (CODE1 "function") "," "3.1. 評価," "5.1.2.5. APPLYの" (CODE1 "place") "フォーム")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("APPLY" . "FUNCTION") *table*) (gethash "APPLY" *table*))
(setf (gethash "AREF" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "AREF"))
    (CHAPTER ("## 構文") 2 (CODE1 "aref") " " (STRONG "array") " " (CODE1 "&rest") " "
     (STRONG "subscripts") " => " (STRONG "element") EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "aref") " " (STRONG "array") " " (CODE1 "&rest") " " (STRONG "subscripts")
     ") " (STRONG "new-element") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "array") " - 配列" EOL1 (STRONG "subscripts") " - "
     (STRONG "array") "の有効な配列のインデックスのリスト" EOL1 (STRONG "element") ", "
     (STRONG "new-element") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "subscripts") "によって指定された" (STRONG "array")
     "の要素にアクセスします。" "もし" (STRONG "subscripts") "が指定されず、" (STRONG "array") "がゼロランクのときは、"
     (CODE1 "aref") "は" (STRONG "array") "の唯一の要素にアクセスします。" EOL2 (CODE1 "aref")
     "はfill-pointerを無視します。" (CODE1 "aref") "はアクティブかそうでないかに関わらず、" (STRONG "array")
     "の要素にアクセスするときに使用できます。")
    (CHAPTER ("## 例文") 2 "もし変数" (CODE1 "foo") "が3×5の配列に束縛されているとき、" "最初のインデックスは"
     (CODE1 "0") ", " (CODE1 "1") ", " (CODE1 "2") "を指定でき、" "2番目のインデックスは" (CODE1 "0")
     ", " (CODE1 "1") ", " (CODE1 "2") ", " (CODE1 "3") ", " (CODE1 "4") "を指定できます。"
     "この配列の要素は" (CODE1 "aref") "関数を使用することによって参照できます。" "例えば" (CODE1 "(aref foo 2 1)") "は、"
     (CODE1 "(2, 1)") "の配列の要素を参照します。"
     (CODE3 "```lisp" "```"
      "(aref (setq alpha (make-array 4)) 3) =>  implementation-dependent"
      "(setf (aref alpha 3) 'sirens) =>  SIRENS" "(aref alpha 3) =>  SIRENS"
      "(aref (setq beta (make-array '(2 4) "
      "                   :element-type '(unsigned-byte 2)"
      "                   :initial-contents '((0 1 2 3) (3 2 1 0))))" "       1 2) =>  1"
      "(setq gamma '(0 2))" "(apply #'aref beta gamma) =>  2"
      "(setf (apply #'aref beta gamma) 3) =>  3" "(apply #'aref beta gamma) =>  3"
      "(aref beta 0 2) =>  3"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "bit") "," (CODE1 "char") "," (CODE1 "elt") ","
     (CODE1 "row-major-aref") "," (CODE1 "svref") "," "3.2.1. コンパイラーの用語")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("AREF" . "ACCESSOR") *table*) (gethash "AREF" *table*))
(setf (gethash "ARRAY" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "ARRAY"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "array") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "配列はオブジェクトを直交座標系にしたがって配置されたものを含みます。" "配列は、" (CODE1 "fixnum")
     "の集合である" (CODE1 "{i0, i1, ..., ir-1}") "と" "対応する配列の要素のマッピングを提供します。" "ただし"
     (CODE1 "0 <= ij < dj") "であり、" (CODE1 "r") "は配列のランク、" (CODE1 "dj") "は配列の大きさ"
     (CODE1 "j") "のサイズです。" EOL2 "配列が作成されたとき、プログラムはその生成の要求として、"
     "表現された配列の要素の型と呼ばれる全ての要素に対する特定の型を" "宣言することができます。" "実装はこの表現された配列の要素の型を生成するために、"
     "型をアップグレードすることが許されており、" "実際に配列の要素の型は特定化されます。" (CODE1 "upgraded-array-element-type")
     "関数をご確認ください。")
    (CHAPTER ("## 型指定子の種類") 2 "特定化")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "array") " [" (CODE1 "{") (STRONG "element-type")
     " " (CODE1 "|") " \\*" (CODE1 "}") " [" (STRONG "dimension-spec") "]]"
     (CODE3 "```" "```" "dimension-spec::= rank | * | ({dimension | *}*) "))
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "dimension") " - 有効な配列の大きさ" EOL1
     (STRONG "element-type") " - 型指定子" EOL1 (STRONG "rank") " - 非負の" (CODE1 "fixnum"))
    (CHAPTER ("## 型指定子の定義") 2 "これは要素の型、ランク、大きさが" "それぞれ" (STRONG "element-type") "、"
     (STRONG "rank") "、" (STRONG "dimension") "にマッチするような" "配列の集合を意味します。" EOL2 "もし"
     (STRONG "element-type") "がシンボルの" (CODE1 "*") "のとき、" "配列は要素の型に基づいて排他しません。"
     "そうでないときは、配列は" (STRONG "element-type") "をアップグレードした結果の" "実際の配列の要素の型だけを含みます。"
     "15.1.2.1. 配列のアップグレードをご確認ください。" EOL2 "もし" (STRONG "dimension-spec") "が"
     (STRONG "rank") "のときは、" "集合はただランクが" (STRONG "rank") "である配列のみを含みます。" "もし"
     (STRONG "dimension-spec") "が" (STRONG "dimension") "のリストのときは、" "集合はただランクが"
     (STRONG "dimension") "のリストの長さであり、" (STRONG "dimension") "のリストで指定された大きさを持つものを含みます。"
     "この場合、" (CODE1 "*") "は対応する大きさのどんな値にもマッチします。" "もし" (STRONG "dimension-spec") "がシンボルの"
     (CODE1 "*") "のときは、" "集合はランクと大きさに基づいて制限しません。")
    (CHAPTER ("## 参考") 2 (CODE1 "*print-array*") "," (CODE1 "aref") ","
     (CODE1 "make-array") "," (CODE1 "vector") "," "2.4.8.12. シャープサイン A,"
     "22.1.3.8. 他の配列の印字")
    (CHAPTER ("## 備考") 2 "型" (CODE1 "(array t)") "は、" (CODE1 "(array *)")
     "の正しいサブタイプであることに注意してください。" "この理由は、型" (CODE1 "(array t)") "は"
     "どんなオブジェクトでも格納できる配列の集合だからです" "（要素は型" (CODE1 "t") "であり、全てのオブジェクトが含まれます）。" "一方、型"
     (CODE1 "(array *)") "は何でもいい全ての配列の集合であり、" "それは例えば文字のみを格納できる配列が含まれます。" "型"
     (CODE1 "(array character)") "は、型" (CODE1 "(array t)") "のサブタイプではありません。"
     "それらの2つの集合は互いに素であり、" "なぜなら型" (CODE1 "(array character)") "は文字を格納できる全ての集合ではなく、"
     "厳密に文字を格納できてその他のオブジェクトは格納できないという" "特定化された配列の集合だからです。")))
(setf (gethash '("ARRAY" . "SYSTEM-CLASS") *table*) (gethash "ARRAY" *table*))
(setf (gethash "ARRAY-DIMENSION" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ARRAY-DIMENSION"))
    (CHAPTER ("## 構文") 2 (CODE1 "array-dimension") " " (STRONG "array") " "
     (STRONG "axis-number") " => " (STRONG "dimension"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "array") " - 配列" EOL1 (STRONG "axis-number")
     " - 0以上かつ" (STRONG "array") "のランク未満の整数" EOL1 (STRONG "dimension") " - 非負の整数")
    (CHAPTER ("## 定義") 2 (CODE1 "array-dimension") "は、" (STRONG "array") "の"
     (STRONG "axis-number") "の次元を返却します" "(fill-pointerは無視されます）。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(array-dimension (make-array 4) 0) =>  4"
      "(array-dimension (make-array '(2 3)) 1) =>  3"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "array-dimensions") "," (CODE1 "length"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```"
      "(array-dimension array n) == (nth n (array-dimensions array))"))))
(setf (gethash '("ARRAY-DIMENSION" . "FUNCTION") *table*) (gethash "ARRAY-DIMENSION" *table*))
(setf (gethash "ARRAY-DIMENSION-LIMIT" *table*)
  '((CHAPTER NIL 0 "Constant Variable " (CODE1 "ARRAY-DIMENSION-LIMIT"))
    (CHAPTER ("## 定数値") 2 "正の" (CODE1 "fixmun") "であり、" "正確な値は実装依存ですが、" (CODE1 "1024")
     "より小さい値ではありません。")
    (CHAPTER ("## 定義") 2 "配列の各個別の要素の排他的上限値です。") (CHAPTER ("## 例文") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-array")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("ARRAY-DIMENSION-LIMIT" . "CONSTANT-VARIABLE") *table*) (gethash "ARRAY-DIMENSION-LIMIT" *table*))
(setf (gethash "ARRAY-DIMENSIONS" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ARRAY-DIMENSIONS"))
    (CHAPTER ("## 構文") 2 (CODE1 "array-dimensions") " " (STRONG "array") " => "
     (STRONG "dimensions"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "array") " - 配列" EOL1 (STRONG "dimensions")
     " - 整数の配列")
    (CHAPTER ("## 定義") 2 (STRONG "array") "の次元のリストを返却します" "（もし" (STRONG "array")
     "がfill-pointerを持った" (CODE1 "vector") "のときは、" "そのfill-pointerは無視されます）。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(array-dimensions (make-array 4)) =>  (4)"
      "(array-dimensions (make-array '(2 3))) =>  (2 3)"
      "(array-dimensions (make-array 4 :fill-pointer 2)) =>  (4)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし引数が配列ではなかったとき、型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "array-dimension")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("ARRAY-DIMENSIONS" . "FUNCTION") *table*) (gethash "ARRAY-DIMENSIONS" *table*))
(setf (gethash "ARRAY-DISPLACEMENT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ARRAY-DISPLACEMENT"))
    (CHAPTER ("## 構文") 2 (CODE1 "array-displacement") " " (STRONG "array") " => "
     (STRONG "displaced-to") ", " (STRONG "displaced-index-offset"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "array") " - 配列" EOL1 (STRONG "displaced-to")
     " - 配列か、" (CODE1 "nil") EOL1 (STRONG "displaced-index-offset") " - 非負の"
     (CODE1 "fixnum"))
    (CHAPTER ("## 定義") 2 "もし" (STRONG "array") "が" (CODE1 "displaced") "の配列のとき、" "その配列の"
     (CODE1 ":displaced-to") "と" (CODE1 ":displaced-index-offset") "オプションのものが返却されます"
     "（関数" (CODE1 "make-array") "と" (CODE1 "adjust-array") "をご確認ください）。" "もし"
     (STRONG "array") "が" (CODE1 "displaced") "の配列ではないとき、" (CODE1 "nil") "と" (CODE1 "0")
     "が返却されます。" EOL2 "もし" (CODE1 "array-displacement") "が" (CODE1 "make-array") "か"
     (CODE1 "adjust-array") "の" (CODE1 ":displaced-to") "引数として" (CODE1 "nil") "ではない"
     "オブジェクトが指定された" (STRONG "array") "で呼ばれたとき、" "それは最初の値にそのオブジェクトを返却しなければなりません。"
     (CODE1 "array-displacement") "が" (STRONG "array") "以外の何かに対して、" (CODE1 "nil")
     "ではない主値を返却するかどうかは" "実装依存です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq a1 (make-array 5)) =>  #<ARRAY 5 simple 46115576>"
      "(setq a2 (make-array 4 :displaced-to a1"
      "                       :displaced-index-offset 1))"
      "=>  #<ARRAY 4 indirect 46117134>" "(array-displacement a2)"
      "=>  #<ARRAY 5 simple 46115576>, 1" "(setq a3 (make-array 2 :displaced-to a2"
      "                       :displaced-index-offset 2))"
      "=>  #<ARRAY 2 indirect 46122527>" "(array-displacement a3)"
      "=>  #<ARRAY 4 indirect 46117134>, 2"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "array") "が配列ではないとき、型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-array")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("ARRAY-DISPLACEMENT" . "FUNCTION") *table*) (gethash "ARRAY-DISPLACEMENT" *table*))
(setf (gethash "ARRAY-ELEMENT-TYPE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ARRAY-ELEMENT-TYPE"))
    (CHAPTER ("## 構文") 2 (CODE1 "array-element-type") " " (STRONG "array") " => "
     (STRONG "typespec"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "array") " - 配列" EOL1 (STRONG "typespec") " - 型指定子")
    (CHAPTER ("## 定義") 2 (STRONG "array") "が格納できるようなオブジェクトの集合を表す、"
     "配列の実際の配列の要素の型として表現された" "型指定子を返却します" "（配列はアップグレードするので、" "いくつかの場合において" "型指定子は"
     (STRONG "array") "の表現された配列の要素の型の" "スーパータイプを表すことができます）。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(array-element-type (make-array 4)) =>  T"
      "(array-element-type (make-array 12 :element-type '(unsigned-byte 8))) "
      "=>  implementation-dependent"
      "(array-element-type (make-array 12 :element-type '(unsigned-byte 5)))"
      "=>  implementation-dependent")
     EOL2 "下記の返却値について、"
     (CODE3 "```" "```" "(array-element-type (make-array 5 :element-type '(mod 5)))")
     EOL2 "これは" (CODE1 "(mod 5)") "か、" (CODE1 "(mod 8)") "か、" (CODE1 "fixnum") "か、"
     (CODE1 "t") "か、" "その他の" (CODE1 "(mod 5)") "のサブタイプの型になります。")
    (CHAPTER ("## 影響") 2 "実装。")
    (CHAPTER ("## 例外") 2 "もし引数が配列ではなかったとき、型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "array") "," (CODE1 "make-array") "," (CODE1 "subtypep")
     "," (CODE1 "upgraded-array-element-type"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("ARRAY-ELEMENT-TYPE" . "FUNCTION") *table*) (gethash "ARRAY-ELEMENT-TYPE" *table*))
(setf (gethash "ARRAY-HAS-FILL-POINTER-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ARRAY-HAS-FILL-POINTER-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "array-has-fill-pointer-p") " " (STRONG "array") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "array") " - 配列" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "array") "がfill-pointerを持つとき" (STRONG "true") "を、それ以外は"
     (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(array-has-fill-pointer-p (make-array 4)) =>  implementation-dependent"
      "(array-has-fill-pointer-p (make-array '(2 3))) =>  false"
      "(array-has-fill-pointer-p" "  (make-array 8 " "              :fill-pointer 2 "
      "              :initial-element 'filler)) =>  true"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし引数が配列ではなかったとき、型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-array") "," (CODE1 "fill-pointer"))
    (CHAPTER ("## 備考") 2 "配列のランクが" (CODE1 "1") "以外のときはfill-pointerを持つことができないため、"
     "引数がそのような配列であったときは、" (CODE1 "array-has-fill-pointer-p") "は常に" (CODE1 "nil")
     "を返却します。")))
(setf (gethash '("ARRAY-HAS-FILL-POINTER-P" . "FUNCTION") *table*) (gethash "ARRAY-HAS-FILL-POINTER-P" *table*))
(setf (gethash "ARRAY-IN-BOUNDS-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ARRAY-IN-BOUNDS-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "array-in-bounds-p") " " (STRONG "array") " "
     (CODE1 "&rest") " " (STRONG "subscripts") " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "array") " - 配列" EOL1 (STRONG "subscripts")
     " - 配列のランクと等しい長さの整数のリスト" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "もし" (STRONG "subscripts") "が全て" (STRONG "array") "の境界内のときは"
     (STRONG "true") "を、" "それ以外のときは" (STRONG "false") "を返却します" "（もし" (STRONG "array")
     "がfill-pointerを持つ" (CODE1 "vector") "のとき、" "そのfill-pointerは無視されます）。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq a (make-array '(7 11) :element-type 'string-char))"
      "(array-in-bounds-p a 0  0) =>  true" "(array-in-bounds-p a 6 10) =>  true"
      "(array-in-bounds-p a 0 -1) =>  false" "(array-in-bounds-p a 0 11) =>  false"
      "(array-in-bounds-p a 7  0) =>  false"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "array-dimensions"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(array-in-bounds-p array subscripts)   "
      "==  (and (not (some #'minusp (list subscripts)))"
      "        (every #'< (list subscripts) (array-dimensions array)))"))))
(setf (gethash '("ARRAY-IN-BOUNDS-P" . "FUNCTION") *table*) (gethash "ARRAY-IN-BOUNDS-P" *table*))
(setf (gethash "ARRAY-RANK" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ARRAY-RANK"))
    (CHAPTER ("## 構文") 2 (CODE1 "array-rank") " " (STRONG "array") " => "
     (STRONG "rank"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "array") " - 配列" EOL1 (STRONG "rank") " - 非負の整数")
    (CHAPTER ("## 定義") 2 (STRONG "array") "の次元数を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(array-rank (make-array '())) =>  0"
      "(array-rank (make-array 4)) =>  1" "(array-rank (make-array '(4))) =>  1"
      "(array-rank (make-array '(2 3))) =>  2"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし引数が配列ではなかったとき、型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "array-rank-limit") "," (CODE1 "make-array"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("ARRAY-RANK" . "FUNCTION") *table*) (gethash "ARRAY-RANK" *table*))
(setf (gethash "ARRAY-RANK-LIMIT" *table*)
  '((CHAPTER NIL 0 "Constant Variable " (CODE1 "ARRAY-RANK-LIMIT"))
    (CHAPTER ("## 定数値") 2 "正の" (CODE1 "fixmun") "であり、" "正確な値は実装依存ですが、" (CODE1 "8")
     "より小さい値ではありません。" EOL2 "Description:" EOL2 "配列のランクの排他的上限値です。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "make-array"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("ARRAY-RANK-LIMIT" . "CONSTANT-VARIABLE") *table*) (gethash "ARRAY-RANK-LIMIT" *table*))
(setf (gethash "ARRAY-ROW-MAJOR-INDEX" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ARRAY-ROW-MAJOR-INDEX"))
    (CHAPTER ("## 構文") 2 (CODE1 "array-row-major-index") " " (STRONG "array") " "
     (CODE1 "&rest") " " (STRONG "subscripts") " => " (STRONG "index"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "array") " - 配列" EOL1 (STRONG "subscripts") " - "
     (STRONG "array") "の有効な配列のインデックスのリスト" EOL1 (STRONG "index") " - " (STRONG "array")
     "の有効な配列の" (CODE1 "row-major") "インデックス")
    (CHAPTER ("## 定義") 2 (STRONG "subscripts") "によって指定された" (STRONG "array") "の要素に対して"
     (CODE1 "row-major") "の順序に従った位置を計算し、" (STRONG "array") "の最初の位置から計算された"
     "その要素のオフセットを返却します。" EOL2 (STRONG "array") "が一次元配列のとき、"
     (CODE1 "array-row-major-index") "の返却値はは" (STRONG "subscript") "と同じです。" EOL2
     (CODE1 "array-row-major-index") "はfill-pointerを無視します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq a (make-array '(4 7) :element-type '(unsigned-byte 8)))"
      "(array-row-major-index a 1 2) =>  9" "(array-row-major-index "
      "   (make-array '(2 3 4) " "               :element-type '(unsigned-byte 8)"
      "               :displaced-to a" "               :displaced-index-offset 4)"
      "   0 2 1) =>  9"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 (CODE1 "array-row-major-index") "の定義は、"
     "エラーチェックをなしにすれば次のように表現することができます"
     (CODE3 "```lisp" "```" " (defun array-row-major-index (a &rest subscripts)"
      "   (apply #'+ (maplist #'(lambda (x y)"
      "                            (* (car x) (apply #'* (cdr y))))"
      "                       subscripts"
      "                       (array-dimensions a))))"))))
(setf (gethash '("ARRAY-ROW-MAJOR-INDEX" . "FUNCTION") *table*) (gethash "ARRAY-ROW-MAJOR-INDEX" *table*))
(setf (gethash "ARRAY-TOTAL-SIZE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ARRAY-TOTAL-SIZE"))
    (CHAPTER ("## 構文") 2 (CODE1 "array-total-size") " " (STRONG "array") " => "
     (STRONG "size"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "array") " - 配列" EOL1 (STRONG "size") " - 非負の整数")
    (CHAPTER ("## 定義") 2 (STRONG "array") "の配列の全てのサイズを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(array-total-size (make-array 4)) =>  4"
      "(array-total-size (make-array 4 :fill-pointer 2)) =>  4"
      "(array-total-size (make-array 0)) =>  0"
      "(array-total-size (make-array '(4 2))) =>  8"
      "(array-total-size (make-array '(4 0))) =>  0"
      "(array-total-size (make-array '())) =>  1"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし引数が配列ではなかったとき、型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-array") "," (CODE1 "array-dimensions"))
    (CHAPTER ("## 備考") 2 "もし" (STRONG "array") "がfill-pointerを持つ" (CODE1 "vector") "のとき、"
     "配列の全てのサイズを計算するときにfill-pointerは無視されます。" EOL2 "引数が存在せず積が" (CODE1 "1") "のとき、"
     "ゼロ次元の配列に対する配列の全てのサイズは" (CODE1 "1") "です。"
     (CODE3 "```lisp" "```" "(array-total-size x)"
      "   ==  (apply #'* (array-dimensions x))"
      "   ==  (reduce #'* (array-dimensions x))"))))
(setf (gethash '("ARRAY-TOTAL-SIZE" . "FUNCTION") *table*) (gethash "ARRAY-TOTAL-SIZE" *table*))
(setf (gethash "ARRAY-TOTAL-SIZE-LIMIT" *table*)
  '((CHAPTER NIL 0 "Constant Variable " (CODE1 "ARRAY-TOTAL-SIZE-LIMIT"))
    (CHAPTER ("## 定数値") 2 "正の" (CODE1 "fixmun") "であり、" "正確な値は実装依存ですが、" (CODE1 "1024")
     "より小さい値ではありません。" EOL2 "Description:" EOL2 "配列に対する、配列の全てのサイズの排他的上限値です。" EOL2
     "配列の全てのサイズの実際の制限値は、" "実装によっては配列の要素の型によって変化するかもしれません。" "このような場合、"
     (CODE1 "array-total-size-limit") "の値は、" "それらの可能な制限値の最も小さいものになります。")
    (CHAPTER ("## 例文") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-array") "," (CODE1 "array-element-type"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("ARRAY-TOTAL-SIZE-LIMIT" . "CONSTANT-VARIABLE") *table*) (gethash "ARRAY-TOTAL-SIZE-LIMIT" *table*))
(setf (gethash "ARRAYP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ARRAYP"))
    (CHAPTER ("## 構文") 2 (CODE1 "arrayp") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が型" (CODE1 "array") "のときは" (STRONG "true")
     "を、それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(arrayp (make-array '(2 3 4) :adjustable t)) =>  true"
      "(arrayp (make-array 6)) =>  true" "(arrayp #*1011) =>  true"
      "(arrayp \"hi\") =>  true" "(arrayp 'hi) =>  false" "(arrayp 12) =>  false"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "typep"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(arrayp object) ==  (typep object 'array)"))))
(setf (gethash '("ARRAYP" . "FUNCTION") *table*) (gethash "ARRAYP" *table*))
(setf (gethash "ASSERT" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "ASSERT"))
    (CHAPTER ("## 構文") 2 (CODE1 "assert") " " (STRONG "test-form") " [("
     (STRONG "place\\*") ") [" (STRONG "datum-form") " " (STRONG "argument-form\\*") "]]"
     EOL1 "=> " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "test-form") " - フォーム。常に評価されます。" EOL1
     (STRONG "place") " - " (CODE1 "place") "。もしエラーが通知されたら評価されます。" EOL1
     (STRONG "datum-form") " - フォームであり評価したものを" (STRONG "datum") "とします。"
     "評価はエラーが通知されたたびに行われ、" "もしエラーが通知されなかったら行われません。" EOL1 (STRONG "argument-form")
     " - フォームであり評価したものを" (STRONG "argument") "とします。" "評価はエラーが通知されたたびに行われ、"
     "もしエラーが通知されなかったら行われません。" EOL1 (STRONG "datum") ", " (STRONG "argument")
     " - コンディション指定子であり、" "デフォルトが型" (CODE1 "error") "。" "（これらの指定子は" (STRONG "datum-form")
     "と各" (STRONG "argument-form") "が" "評価された結果です）")
    (CHAPTER ("## 定義") 2 (CODE1 "assert") "は" (STRONG "test-form") "が" (STRONG "true")
     "に評価されることを保証します。" "もし" (STRONG "test-form") "が" (STRONG "false") "に評価されたときは、"
     (CODE1 "assert") "は修正可能なエラー（" (STRONG "datum") "と各" (STRONG "argument")
     "による）を通知します。" (CODE1 "continue") " " (CODE1 "restart") "を使用してエラーの継続を行うときは、"
     (CODE1 "assert") "が" (STRONG "test-form") "を再評価する前に、" "ユーザーが" (STRONG "place")
     "の値を変更することで実現します。" "もし" (STRONG "test-form") "の値が" (CODE1 "nil") "ではなかったときは、"
     (CODE1 "assert") "は" (CODE1 "nil") "を返却します。" EOL2 (STRONG "place") "は"
     (STRONG "test-form") "に依存したデータへの一般化された参照であり、" "その値はユーザーがエラーを修正することによって変更することができます。"
     (STRONG "place") "のサブフォームは、エラーが通知されたときのみ評価され、" "エラーが再通知されたときにも再評価されます"
     "（再通知は実際のエラーが修正されずに継続した後に発生します）。" (STRONG "place") "の評価順序は指定されていません。" "5.1.1.1. "
     (CODE1 "place") "のサブフォームの評価をご確認ください。" "もし" (STRONG "place")
     "フォームが保存変数より多い値を生成して供給されたとき、" "余分の値は無視されます。" "もし指定したフォームが保存変数より少ない値を生成したとき、"
     "不足した値は" (CODE1 "nil") "がセットされます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq x (make-array '(3 5) :initial-element 3))"
      "=>  #2A((3 3 3 3 3) (3 3 3 3 3) (3 3 3 3 3))"
      "(setq y (make-array '(3 5) :initial-element 7))"
      "=>  #2A((7 7 7 7 7) (7 7 7 7 7) (7 7 7 7 7))" "(defun matrix-multiply (a b)"
      "  (let ((*print-array* nil))"
      "    (assert (and (= (array-rank a) (array-rank b) 2)"
      "                 (= (array-dimension a 1) (array-dimension b 0)))"
      "            (a b)" "            \"Cannot multiply ~S by ~S.\" a b)"
      "           (really-matrix-multiply a b))) =>  MATRIX-MULTIPLY"
      "(matrix-multiply x y)" ">>  Correctable error in MATRIX-MULTIPLY: "
      ">>  Cannot multiply #<ARRAY ...> by #<ARRAY ...>." ">>  Restart options:"
      ">>   1: You will be prompted for one or more new values." ">>   2: Top level."
      ">>  Debug> :continue 1" ">>  Value for A: x"
      ">>  Value for B: (make-array '(5 3) :initial-element 6)"
      "=>  #2A((54 54 54 54 54)" "       (54 54 54 54 54)" "       (54 54 54 54 54)"
      "       (54 54 54 54 54)" "       (54 54 54 54 54))"
      "(defun double-safely (x) (assert (numberp x) (x)) (+ x x))" "(double-safely 4) "
      "=>  8" " " "(double-safely t)"
      ">>  Correctable error in DOUBLE-SAFELY: The value of (NUMBERP X) must be non-NIL."
      ">>  Restart options:" ">>   1: You will be prompted for one or more new values."
      ">>   2: Top level." ">>  Debug> :continue 1" ">>  Value for X: 7" "=>  14"))
    (CHAPTER ("## 影響") 2 (CODE1 "*break-on-signals*") EOL2 "アクティブなコンディションハンドラーの集合")
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "check-type") "," (CODE1 "error") "," "5.1. 一般化された参照")
    (CHAPTER ("## 備考") 2 "デバッガーはエラーメッセージに" (STRONG "test-form") "を含める必要はなく、"
     (STRONG "place") "はメッセージに含めるべきではありませんが、" "利用可能なユーザーの情報はしっかりと見ておく必要があります。" "もしユーザーが"
     (CODE1 "continue") "コマンドを提供していたら、" "参照されているどんな値も変更できます。"
     "この詳細は実装のユーザーインターフェイスのスタイルに依存します。")))
(setf (gethash '("ASSERT" . "MACRO") *table*) (gethash "ASSERT" *table*))
(setf (gethash "ASSOC" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ASSOC") ", " (CODE1 "ASSOC-IF") ", "
     (CODE1 "ASSOC-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "assoc") " " (STRONG "item") " " (STRONG "alist")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "entry") EOL1 (CODE1 "assoc-if") " " (STRONG "predicate") " "
     (STRONG "alist") " &key " (STRONG "key") " => " (STRONG "entry") EOL1
     (CODE1 "assoc-if-not") " " (STRONG "predicate") " " (STRONG "alist") " &key "
     (STRONG "key") " => " (STRONG "entry"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "alist") " - 連想リスト"
     EOL1 (STRONG "predicate") " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "entry") " - " (STRONG "alist")
     "の要素であるコンスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "assoc") ", " (CODE1 "assoc-if") ", "
     (CODE1 "assoc-if-not") "は、" (STRONG "alist") "に" (CODE1 "car") "が" (STRONG "test")
     "を満たすようなコンスがあれば返却し、" "そのようなコンスが見つからないときは" (CODE1 "nil") "を返却します。" EOL2
     (CODE1 "assoc") ", " (CODE1 "assoc-if") ", " (CODE1 "assoc-if-not") "は、" "もし"
     (STRONG "alist") "のペアが現れる場所に" (CODE1 "nil") "あったとは無視します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq values '((x . 100) (y . 200) (z . 50))) =>  ((X . 100) (Y . 200) (Z . 50))"
      "(assoc 'y values) =>  (Y . 200)" "(rplacd (assoc 'y values) 201) =>  (Y . 201)"
      "(assoc 'y values) =>  (Y . 201)"
      "(setq alist '((1 . \"one\")(2 . \"two\")(3 . \"three\"))) "
      "=>  ((1 . \"one\") (2 . \"two\") (3 . \"three\"))"
      "(assoc 2 alist) =>  (2 . \"two\")" "(assoc-if #'evenp alist) =>  (2 . \"two\")"
      "(assoc-if-not #'(lambda(x) (< x 3)) alist) =>  (3 . \"three\")"
      "(setq alist '((\"one\" . 1)(\"two\" . 2))) =>  ((\"one\" . 1) (\"two\" . 2))"
      "(assoc \"one\" alist) =>  NIL"
      "(assoc \"one\" alist :test #'equalp) =>  (\"one\" . 1)"
      "(assoc \"two\" alist :key #'(lambda(x) (char x 2))) =>  NIL "
      "(assoc #\\o alist :key #'(lambda(x) (char x 2))) =>  (\"two\" . 2)"
      "(assoc 'r '((a . b) (c . d) (r . x) (s . y) (r . z))) =>   (R . X)"
      "(assoc 'goo '((foo . bar) (zoo . goo))) =>  NIL"
      "(assoc '2 '((1 a b c) (2 b c d) (-7 x y z))) =>  (2 B C D)"
      "(setq alist '((\"one\" . 1) (\"2\" . 2) (\"three\" . 3)))"
      "=>  ((\"one\" . 1) (\"2\" . 2) (\"three\" . 3))"
      "(assoc-if-not #'alpha-char-p alist"
      "              :key #'(lambda (x) (char x 0))) =>  (\"2\" . 2)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "alist") "が連想リストではないときは、" "型" (CODE1 "type-error")
     "を通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "rassoc") "," (CODE1 "find") "," (CODE1 "member") ","
     (CODE1 "position") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "は、非推奨です。" EOL2 "関数" (CODE1 "assoc-if-not")
     "は、非推奨です。" EOL2 (STRONG "alist") "を更新するために、" (CODE1 "assoc") "の結果が" (CODE1 "nil")
     "でなければ、" (CODE1 "rplacd") "を使うことができます。" EOL2 "次の2つの式"
     (CODE3 "```lisp" "```" "(assoc item list :test fn)"
      "(find item list :test fn :key #'car)")
     EOL2 "これらは、ひとつの例外を除いては同じ意味です。" "例外は、もし" (STRONG "alist") "のペアの場所で" (CODE1 "nil")
     "現れて、" "かつ" (STRONG "item") "が" (CODE1 "nil") "のとき、" (CODE1 "find") "の場合は、"
     (CODE1 "nil") "の" (CODE1 "car") "を計算し、" (STRONG "item") "と同じということで" (CODE1 "nil")
     "を返却しますが、" "一方" (CODE1 "assoc") "は、" (STRONG "alist") "の" (CODE1 "nil") "を無視するため、"
     "継続して" (CODE1 "car") "が" (CODE1 "nil") "である実際のコンスを探します。")))
(setf (gethash '("ASSOC" . "FUNCTION") *table*) (gethash "ASSOC" *table*))
(setf (gethash "ASSOC-IF" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ASSOC") ", " (CODE1 "ASSOC-IF") ", "
     (CODE1 "ASSOC-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "assoc") " " (STRONG "item") " " (STRONG "alist")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "entry") EOL1 (CODE1 "assoc-if") " " (STRONG "predicate") " "
     (STRONG "alist") " &key " (STRONG "key") " => " (STRONG "entry") EOL1
     (CODE1 "assoc-if-not") " " (STRONG "predicate") " " (STRONG "alist") " &key "
     (STRONG "key") " => " (STRONG "entry"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "alist") " - 連想リスト"
     EOL1 (STRONG "predicate") " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "entry") " - " (STRONG "alist")
     "の要素であるコンスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "assoc") ", " (CODE1 "assoc-if") ", "
     (CODE1 "assoc-if-not") "は、" (STRONG "alist") "に" (CODE1 "car") "が" (STRONG "test")
     "を満たすようなコンスがあれば返却し、" "そのようなコンスが見つからないときは" (CODE1 "nil") "を返却します。" EOL2
     (CODE1 "assoc") ", " (CODE1 "assoc-if") ", " (CODE1 "assoc-if-not") "は、" "もし"
     (STRONG "alist") "のペアが現れる場所に" (CODE1 "nil") "あったとは無視します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq values '((x . 100) (y . 200) (z . 50))) =>  ((X . 100) (Y . 200) (Z . 50))"
      "(assoc 'y values) =>  (Y . 200)" "(rplacd (assoc 'y values) 201) =>  (Y . 201)"
      "(assoc 'y values) =>  (Y . 201)"
      "(setq alist '((1 . \"one\")(2 . \"two\")(3 . \"three\"))) "
      "=>  ((1 . \"one\") (2 . \"two\") (3 . \"three\"))"
      "(assoc 2 alist) =>  (2 . \"two\")" "(assoc-if #'evenp alist) =>  (2 . \"two\")"
      "(assoc-if-not #'(lambda(x) (< x 3)) alist) =>  (3 . \"three\")"
      "(setq alist '((\"one\" . 1)(\"two\" . 2))) =>  ((\"one\" . 1) (\"two\" . 2))"
      "(assoc \"one\" alist) =>  NIL"
      "(assoc \"one\" alist :test #'equalp) =>  (\"one\" . 1)"
      "(assoc \"two\" alist :key #'(lambda(x) (char x 2))) =>  NIL "
      "(assoc #\\o alist :key #'(lambda(x) (char x 2))) =>  (\"two\" . 2)"
      "(assoc 'r '((a . b) (c . d) (r . x) (s . y) (r . z))) =>   (R . X)"
      "(assoc 'goo '((foo . bar) (zoo . goo))) =>  NIL"
      "(assoc '2 '((1 a b c) (2 b c d) (-7 x y z))) =>  (2 B C D)"
      "(setq alist '((\"one\" . 1) (\"2\" . 2) (\"three\" . 3)))"
      "=>  ((\"one\" . 1) (\"2\" . 2) (\"three\" . 3))"
      "(assoc-if-not #'alpha-char-p alist"
      "              :key #'(lambda (x) (char x 0))) =>  (\"2\" . 2)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "alist") "が連想リストではないときは、" "型" (CODE1 "type-error")
     "を通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "rassoc") "," (CODE1 "find") "," (CODE1 "member") ","
     (CODE1 "position") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "は、非推奨です。" EOL2 "関数" (CODE1 "assoc-if-not")
     "は、非推奨です。" EOL2 (STRONG "alist") "を更新するために、" (CODE1 "assoc") "の結果が" (CODE1 "nil")
     "でなければ、" (CODE1 "rplacd") "を使うことができます。" EOL2 "次の2つの式"
     (CODE3 "```lisp" "```" "(assoc item list :test fn)"
      "(find item list :test fn :key #'car)")
     EOL2 "これらは、ひとつの例外を除いては同じ意味です。" "例外は、もし" (STRONG "alist") "のペアの場所で" (CODE1 "nil")
     "現れて、" "かつ" (STRONG "item") "が" (CODE1 "nil") "のとき、" (CODE1 "find") "の場合は、"
     (CODE1 "nil") "の" (CODE1 "car") "を計算し、" (STRONG "item") "と同じということで" (CODE1 "nil")
     "を返却しますが、" "一方" (CODE1 "assoc") "は、" (STRONG "alist") "の" (CODE1 "nil") "を無視するため、"
     "継続して" (CODE1 "car") "が" (CODE1 "nil") "である実際のコンスを探します。")))
(setf (gethash '("ASSOC-IF" . "FUNCTION") *table*) (gethash "ASSOC-IF" *table*))
(setf (gethash "ASSOC-IF-NOT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ASSOC") ", " (CODE1 "ASSOC-IF") ", "
     (CODE1 "ASSOC-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "assoc") " " (STRONG "item") " " (STRONG "alist")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "entry") EOL1 (CODE1 "assoc-if") " " (STRONG "predicate") " "
     (STRONG "alist") " &key " (STRONG "key") " => " (STRONG "entry") EOL1
     (CODE1 "assoc-if-not") " " (STRONG "predicate") " " (STRONG "alist") " &key "
     (STRONG "key") " => " (STRONG "entry"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "alist") " - 連想リスト"
     EOL1 (STRONG "predicate") " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "entry") " - " (STRONG "alist")
     "の要素であるコンスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "assoc") ", " (CODE1 "assoc-if") ", "
     (CODE1 "assoc-if-not") "は、" (STRONG "alist") "に" (CODE1 "car") "が" (STRONG "test")
     "を満たすようなコンスがあれば返却し、" "そのようなコンスが見つからないときは" (CODE1 "nil") "を返却します。" EOL2
     (CODE1 "assoc") ", " (CODE1 "assoc-if") ", " (CODE1 "assoc-if-not") "は、" "もし"
     (STRONG "alist") "のペアが現れる場所に" (CODE1 "nil") "あったとは無視します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq values '((x . 100) (y . 200) (z . 50))) =>  ((X . 100) (Y . 200) (Z . 50))"
      "(assoc 'y values) =>  (Y . 200)" "(rplacd (assoc 'y values) 201) =>  (Y . 201)"
      "(assoc 'y values) =>  (Y . 201)"
      "(setq alist '((1 . \"one\")(2 . \"two\")(3 . \"three\"))) "
      "=>  ((1 . \"one\") (2 . \"two\") (3 . \"three\"))"
      "(assoc 2 alist) =>  (2 . \"two\")" "(assoc-if #'evenp alist) =>  (2 . \"two\")"
      "(assoc-if-not #'(lambda(x) (< x 3)) alist) =>  (3 . \"three\")"
      "(setq alist '((\"one\" . 1)(\"two\" . 2))) =>  ((\"one\" . 1) (\"two\" . 2))"
      "(assoc \"one\" alist) =>  NIL"
      "(assoc \"one\" alist :test #'equalp) =>  (\"one\" . 1)"
      "(assoc \"two\" alist :key #'(lambda(x) (char x 2))) =>  NIL "
      "(assoc #\\o alist :key #'(lambda(x) (char x 2))) =>  (\"two\" . 2)"
      "(assoc 'r '((a . b) (c . d) (r . x) (s . y) (r . z))) =>   (R . X)"
      "(assoc 'goo '((foo . bar) (zoo . goo))) =>  NIL"
      "(assoc '2 '((1 a b c) (2 b c d) (-7 x y z))) =>  (2 B C D)"
      "(setq alist '((\"one\" . 1) (\"2\" . 2) (\"three\" . 3)))"
      "=>  ((\"one\" . 1) (\"2\" . 2) (\"three\" . 3))"
      "(assoc-if-not #'alpha-char-p alist"
      "              :key #'(lambda (x) (char x 0))) =>  (\"2\" . 2)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "alist") "が連想リストではないときは、" "型" (CODE1 "type-error")
     "を通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "rassoc") "," (CODE1 "find") "," (CODE1 "member") ","
     (CODE1 "position") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "は、非推奨です。" EOL2 "関数" (CODE1 "assoc-if-not")
     "は、非推奨です。" EOL2 (STRONG "alist") "を更新するために、" (CODE1 "assoc") "の結果が" (CODE1 "nil")
     "でなければ、" (CODE1 "rplacd") "を使うことができます。" EOL2 "次の2つの式"
     (CODE3 "```lisp" "```" "(assoc item list :test fn)"
      "(find item list :test fn :key #'car)")
     EOL2 "これらは、ひとつの例外を除いては同じ意味です。" "例外は、もし" (STRONG "alist") "のペアの場所で" (CODE1 "nil")
     "現れて、" "かつ" (STRONG "item") "が" (CODE1 "nil") "のとき、" (CODE1 "find") "の場合は、"
     (CODE1 "nil") "の" (CODE1 "car") "を計算し、" (STRONG "item") "と同じということで" (CODE1 "nil")
     "を返却しますが、" "一方" (CODE1 "assoc") "は、" (STRONG "alist") "の" (CODE1 "nil") "を無視するため、"
     "継続して" (CODE1 "car") "が" (CODE1 "nil") "である実際のコンスを探します。")))
(setf (gethash '("ASSOC-IF-NOT" . "FUNCTION") *table*) (gethash "ASSOC-IF-NOT" *table*))
(setf (gethash "ATOM" *table*)
  '("ATOM FUNCTION" EOL1 "ATOM TYPE" EOL1))
(setf (gethash '("ATOM" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ATOM"))
    (CHAPTER ("## 構文") 2 (CODE1 "atom") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が型" (CODE1 "atom") "なら" (STRONG "true") "を、"
     "それ以外なら" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(atom 'sss) =>  true" "(atom (cons 1 2)) =>  false"
      "(atom nil) =>  true" "(atom '()) =>  true" "(atom 3) =>  true"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```"
      "(atom object) ==  (typep object 'atom) ==  (not (consp object))"
      "==  (not (typep object 'cons)) ==  (typep object '(not cons))"))))
(setf (gethash '("ATOM" . "TYPE") *table*)
  '((CHAPTER NIL 0 "Type " (CODE1 "ATOM"))
    (CHAPTER ("## スーパータイプ") 2 (CODE1 "atom") ", " (CODE1 "t"))
    (CHAPTER ("## 定義") 2 (CODE1 "(not cons)") "と同じです。")))
(setf (gethash "BASE-CHAR" *table*)
  '((CHAPTER NIL 0 "Type " (CODE1 "BASE-CHAR"))
    (CHAPTER ("## スーパータイプ") 2 (CODE1 "base-char") ", " (CODE1 "character") ", "
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "base-char") "は、" (CODE1 "standard-char") "の"
     "アップグレードされた配列の要素の型として定義されています。" "実装者は、型" (CODE1 "character") "のサブタイプの型について、"
     "標準以外のものを追加することができます。" "その追加する型は、型" (CODE1 "base-char") "がスーパータイプになっていても、"
     "いなくてもどちらでも構いません。" "また実装者は、型" (CODE1 "base-char") "と型" (CODE1 "character") "を"
     "同じ型として定義することもできます。" EOL2 "基本文字(base characters)は、次のように区別されます。" EOL2 "1. 型"
     (CODE1 "standard-char") "は、型" (CODE1 "base-char") "の中に含まれます。"
     "2. 基本文字の中の標準文字(standard characters)以外の文字は実装依存です。" "3. 型" (CODE1 "base-char")
     "のオブジェクトだけが、基本文字列の構成要素になれます。" "4. " (CODE1 "base-char") "の文字数の上限は無く、サイズは実装依存です。"
     "文字数の下限は" (CODE1 "standard-char") "の文字数である" (CODE1 "96") "です。" EOL2 "ある文字が"
     (CODE1 "base-char") "であるかどうかは、" "文字列を表現する実装方法に依存しますが、"
     "その他の実装の特性や、ホストオペレーティングシステムには依存しません。" EOL2 "例えば、ある実装では全ての文字列を16bitの文字として表現しているとします。"
     "また別の実装では、8bitエンコーディングと16bitエンコーディングの" "2種類の文字列を扱うシステムであるとします。" "最初の実装では、型"
     (CODE1 "base-char") "と型" (CODE1 "character") "は同じに実装されます。" "なぜなら文字の種類が一つしか無いからです。"
     "2つ目の実装では、" (CODE1 "base-char") "は8bitの文字を格納できるようにするかもしれません。" "このような実装では、型"
     (CODE1 "base-char") "は型" (CODE1 "character") "のサブタイプとなります。" EOL2 "型"
     (CODE1 "standard-char") "は、型" (CODE1 "base-char") "のサブタイプとなります。")))
(setf (gethash '("BASE-CHAR" . "TYPE") *table*) (gethash "BASE-CHAR" *table*))
(setf (gethash "BASE-STRING" *table*)
  '((CHAPTER NIL 0 "Type " (CODE1 "BASE-STRING"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "base-string") ", " (CODE1 "string") ", "
     (CODE1 "vector") "," (CODE1 "array") ", " (CODE1 "sequence") ", " (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "base-string") "は、" (CODE1 "(vector base-char)")
     "と同一です。" "基本文字列(base-string)とは、" "任意の標準文字の列を最も効率よく格納できる" "文字列の表現です。")
    (CHAPTER ("## 型指定子の種類") 2 "省略。")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "base-string") " " (STRONG "[size]"))
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "size") " - 非負の" (CODE1 "fixnum") "か、シンボル"
     (CODE1 "*"))
    (CHAPTER ("## 型指定子の定義") 2 "型" (CODE1 "(vector base-char size)") "と同一です。" "このとき、"
     (STRONG "size") "は基本文字列の集合のサイズです。")))
(setf (gethash '("BASE-STRING" . "TYPE") *table*) (gethash "BASE-STRING" *table*))
(setf (gethash "BIT" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "BIT") ", " (CODE1 "SBIT"))
    (CHAPTER ("## 構文") 2 (CODE1 "bit") " " (STRONG "bit-array") " " (CODE1 "&rest") " "
     (STRONG "subscripts") " => " (STRONG "bit") EOL1 (CODE1 "sbit") " "
     (STRONG "bit-array") " " (CODE1 "&rest") " " (STRONG "subscripts") " => "
     (STRONG "bit") EOL1 "(" (CODE1 "setf") " (" (CODE1 "bit") " " (STRONG "bit-array")
     " " (CODE1 "&rest") " " (STRONG "subscripts") ") " (STRONG "new-bit") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "sbit") " " (STRONG "bit-array") " " (CODE1 "&rest") " "
     (STRONG "subscripts") ") " (STRONG "new-bit") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "bit-array") " - " (CODE1 "bit") "はビット配列であり、"
     (CODE1 "sbit") "は" (CODE1 "simple") "なビット配列" EOL1 (STRONG "subscripts")
     " - ビット配列への有効な配列のインデックスのリスト" EOL1 (STRONG "bit") " - ビット")
    (CHAPTER ("## 定義") 2 (CODE1 "bit") "と" (CODE1 "sbit") "は、" (STRONG "subscripts")
     "によって指定された" "ビット配列の要素にアクセスします。" EOL2 "これらの関数は、要素にアクセスするときにfill-pointerを無視します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(bit (setq ba (make-array 8 "
      "                           :element-type 'bit "
      "                           :initial-element 1))" "      3) =>  1"
      "(setf (bit ba 3) 0) =>  0" "(bit ba 3) =>  0" "(sbit ba 5) =>  1"
      "(setf (sbit ba 5) 1) =>  1" "(sbit ba 5) =>  1"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "aref") "," "3.2.1. コンパイラーの用語")
    (CHAPTER ("## 備考") 2 (CODE1 "bit") "と" (CODE1 "sbit") "は" (CODE1 "aref") "に似ていますが、"
     (STRONG "array") "がそれぞれビット配列と" (CODE1 "simple") "のビット配列であることを" "要求することが違っています。" EOL2
     (CODE1 "bit") "と" (CODE1 "sbit") "は" (CODE1 "char") "と" (CODE1 "schar") "とは似ておらず、"
     "最初の引数はどんなランクの配列でも許されます。")))
(setf (gethash '("BIT" . "ACCESSOR") *table*) (gethash "BIT" *table*))
(setf (gethash "BIT-AND" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BIT-AND") ", " (CODE1 "BIT-ANDC1") ", "
     (CODE1 "BIT-ANDC2") ", " (CODE1 "BIT-EQV") "," (CODE1 "BIT-IOR") ", "
     (CODE1 "BIT-NAND") ", " (CODE1 "BIT-NOR") ", " (CODE1 "BIT-NOT") ","
     (CODE1 "BIT-ORC1") ", " (CODE1 "BIT-ORC2") ", " (CODE1 "BIT-XOR"))
    (CHAPTER ("## 構文") 2 (CODE1 "bit-and") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc1") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc2") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-eqv") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-ior") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nand") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc1") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc2") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-xor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-not") " " (STRONG "bit-array") " "
     (CODE1 "&optional") " " (STRONG "opt-arg") " => " (STRONG "resulting-bit-array"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "bit-array") ", " (STRONG "bit-array1") ", "
     (STRONG "bit-array2") " - ビット配列" EOL1 (STRONG "opt-arg") " - ビット配列か、" (CODE1 "t")
     "か、" (CODE1 "nil") "。" "デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "bit-array") ", "
     (STRONG "bit-array1") ", " (STRONG "bit-array2") ", " (STRONG "opt-arg")
     "（もし配列なら）は、" "全て同じランクと大きさでなければなりません。" EOL1 (STRONG "resulting-bit-array")
     " - ビット配列")
    (CHAPTER ("## 定義") 2 "これらの関数は、" (STRONG "bit-array1") "と" (STRONG "bit-array2")
     "のビット単位の論理操作を行い、" "その結果の任意のビットが各引数の対応するビットを操作することによって"
     "生成されるような、ランクと次元が一致する配列を返します。" EOL2 (CODE1 "bit-not") "の場合は、" (STRONG "bit-array")
     "にランクと次元が一致する配列が返却され、" "その配列には" (STRONG "bit-array") "の全てのビットが逆転したもののコピーが含まれます。"
     EOL2 "もし" (STRONG "opt-arg") "が型" (CODE1 "(array bit)") "であれば、" "返却される内容は"
     (STRONG "opt-arg") "の中に破壊的に配置されます。" "もし" (STRONG "opt-arg") "がシンボル" (CODE1 "t")
     "のとき、" (STRONG "bit-array") "か" (STRONG "bit-array1") "が結果に置き換えられます。" "もし"
     (STRONG "opt-arg") "が" (CODE1 "nil") "か省略されたときは、" "結果を格納した新しい配列が作成されます。" EOL2
     "次の図は各関数によって処理される論理操作を示します。" EOL2
     "|関数             |処理                                   |"
     "|-----------------|---------------------------------------|" "|" (CODE1 "bit-and")
     "   | and                                   |" "|" (CODE1 "bit-eqv")
     "   | 同値（排他的nor)                      |" "|" (CODE1 "bit-not")
     "   | 補数                                  |" "|" (CODE1 "bit-ior")
     "   | 内包的or                              |" "|" (CODE1 "bit-xor")
     "   | 排他的or                              |" "|" (CODE1 "bit-nand") "  | ("
     (STRONG "bit-array1") " and " (STRONG "bit-array2") ")の補数 |" "|" (CODE1 "bit-nor")
     "   | (" (STRONG "bit-array1") " or " (STRONG "bit-array2") ")の補数  |" "|"
     (CODE1 "bit-andc1") " | (" (STRONG "bit-array1") "の補数) and " (STRONG "bit-array2")
     " |" "|" (CODE1 "bit-andc2") " | " (STRONG "bit-array1") " and ("
     (STRONG "bit-array2") "の補数) |" "|" (CODE1 "bit-orc1") "  | (" (STRONG "bit-array1")
     "の補数) or " (STRONG "bit-array2") "  |" "|" (CODE1 "bit-orc2") "  | "
     (STRONG "bit-array1") " or (" (STRONG "bit-array2") "の補数)  |" EOL2
     "Figure 15-4. ビット配列上のビット単位の論理演算")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(bit-and (setq ba #*11101010) #*01101011) =>  #*01101010"
      "(bit-and #*1100 #*1010) =>  #*1000      " "(bit-andc1 #*1100 #*1010) =>  #*0010"
      "(setq rba (bit-andc2 ba #*00110011 t)) =>  #*11001000" "(eq rba ba) =>  true"
      "(bit-not (setq ba #*11101010)) =>  #*00010101" "(setq rba (bit-not ba "
      "                    (setq tba (make-array 8 "
      "                                          :element-type 'bit))))" "=>  #*00010101"
      "(equal rba tba) =>  true" "(bit-xor #*1100 #*1010) =>  #*0110"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "lognot") "," (CODE1 "logand"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("BIT-AND" . "FUNCTION") *table*) (gethash "BIT-AND" *table*))
(setf (gethash "BIT-ANDC1" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BIT-AND") ", " (CODE1 "BIT-ANDC1") ", "
     (CODE1 "BIT-ANDC2") ", " (CODE1 "BIT-EQV") "," (CODE1 "BIT-IOR") ", "
     (CODE1 "BIT-NAND") ", " (CODE1 "BIT-NOR") ", " (CODE1 "BIT-NOT") ","
     (CODE1 "BIT-ORC1") ", " (CODE1 "BIT-ORC2") ", " (CODE1 "BIT-XOR"))
    (CHAPTER ("## 構文") 2 (CODE1 "bit-and") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc1") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc2") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-eqv") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-ior") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nand") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc1") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc2") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-xor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-not") " " (STRONG "bit-array") " "
     (CODE1 "&optional") " " (STRONG "opt-arg") " => " (STRONG "resulting-bit-array"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "bit-array") ", " (STRONG "bit-array1") ", "
     (STRONG "bit-array2") " - ビット配列" EOL1 (STRONG "opt-arg") " - ビット配列か、" (CODE1 "t")
     "か、" (CODE1 "nil") "。" "デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "bit-array") ", "
     (STRONG "bit-array1") ", " (STRONG "bit-array2") ", " (STRONG "opt-arg")
     "（もし配列なら）は、" "全て同じランクと大きさでなければなりません。" EOL1 (STRONG "resulting-bit-array")
     " - ビット配列")
    (CHAPTER ("## 定義") 2 "これらの関数は、" (STRONG "bit-array1") "と" (STRONG "bit-array2")
     "のビット単位の論理操作を行い、" "その結果の任意のビットが各引数の対応するビットを操作することによって"
     "生成されるような、ランクと次元が一致する配列を返します。" EOL2 (CODE1 "bit-not") "の場合は、" (STRONG "bit-array")
     "にランクと次元が一致する配列が返却され、" "その配列には" (STRONG "bit-array") "の全てのビットが逆転したもののコピーが含まれます。"
     EOL2 "もし" (STRONG "opt-arg") "が型" (CODE1 "(array bit)") "であれば、" "返却される内容は"
     (STRONG "opt-arg") "の中に破壊的に配置されます。" "もし" (STRONG "opt-arg") "がシンボル" (CODE1 "t")
     "のとき、" (STRONG "bit-array") "か" (STRONG "bit-array1") "が結果に置き換えられます。" "もし"
     (STRONG "opt-arg") "が" (CODE1 "nil") "か省略されたときは、" "結果を格納した新しい配列が作成されます。" EOL2
     "次の図は各関数によって処理される論理操作を示します。" EOL2
     "|関数             |処理                                   |"
     "|-----------------|---------------------------------------|" "|" (CODE1 "bit-and")
     "   | and                                   |" "|" (CODE1 "bit-eqv")
     "   | 同値（排他的nor)                      |" "|" (CODE1 "bit-not")
     "   | 補数                                  |" "|" (CODE1 "bit-ior")
     "   | 内包的or                              |" "|" (CODE1 "bit-xor")
     "   | 排他的or                              |" "|" (CODE1 "bit-nand") "  | ("
     (STRONG "bit-array1") " and " (STRONG "bit-array2") ")の補数 |" "|" (CODE1 "bit-nor")
     "   | (" (STRONG "bit-array1") " or " (STRONG "bit-array2") ")の補数  |" "|"
     (CODE1 "bit-andc1") " | (" (STRONG "bit-array1") "の補数) and " (STRONG "bit-array2")
     " |" "|" (CODE1 "bit-andc2") " | " (STRONG "bit-array1") " and ("
     (STRONG "bit-array2") "の補数) |" "|" (CODE1 "bit-orc1") "  | (" (STRONG "bit-array1")
     "の補数) or " (STRONG "bit-array2") "  |" "|" (CODE1 "bit-orc2") "  | "
     (STRONG "bit-array1") " or (" (STRONG "bit-array2") "の補数)  |" EOL2
     "Figure 15-4. ビット配列上のビット単位の論理演算")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(bit-and (setq ba #*11101010) #*01101011) =>  #*01101010"
      "(bit-and #*1100 #*1010) =>  #*1000      " "(bit-andc1 #*1100 #*1010) =>  #*0010"
      "(setq rba (bit-andc2 ba #*00110011 t)) =>  #*11001000" "(eq rba ba) =>  true"
      "(bit-not (setq ba #*11101010)) =>  #*00010101" "(setq rba (bit-not ba "
      "                    (setq tba (make-array 8 "
      "                                          :element-type 'bit))))" "=>  #*00010101"
      "(equal rba tba) =>  true" "(bit-xor #*1100 #*1010) =>  #*0110"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "lognot") "," (CODE1 "logand"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("BIT-ANDC1" . "FUNCTION") *table*) (gethash "BIT-ANDC1" *table*))
(setf (gethash "BIT-ANDC2" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BIT-AND") ", " (CODE1 "BIT-ANDC1") ", "
     (CODE1 "BIT-ANDC2") ", " (CODE1 "BIT-EQV") "," (CODE1 "BIT-IOR") ", "
     (CODE1 "BIT-NAND") ", " (CODE1 "BIT-NOR") ", " (CODE1 "BIT-NOT") ","
     (CODE1 "BIT-ORC1") ", " (CODE1 "BIT-ORC2") ", " (CODE1 "BIT-XOR"))
    (CHAPTER ("## 構文") 2 (CODE1 "bit-and") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc1") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc2") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-eqv") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-ior") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nand") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc1") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc2") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-xor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-not") " " (STRONG "bit-array") " "
     (CODE1 "&optional") " " (STRONG "opt-arg") " => " (STRONG "resulting-bit-array"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "bit-array") ", " (STRONG "bit-array1") ", "
     (STRONG "bit-array2") " - ビット配列" EOL1 (STRONG "opt-arg") " - ビット配列か、" (CODE1 "t")
     "か、" (CODE1 "nil") "。" "デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "bit-array") ", "
     (STRONG "bit-array1") ", " (STRONG "bit-array2") ", " (STRONG "opt-arg")
     "（もし配列なら）は、" "全て同じランクと大きさでなければなりません。" EOL1 (STRONG "resulting-bit-array")
     " - ビット配列")
    (CHAPTER ("## 定義") 2 "これらの関数は、" (STRONG "bit-array1") "と" (STRONG "bit-array2")
     "のビット単位の論理操作を行い、" "その結果の任意のビットが各引数の対応するビットを操作することによって"
     "生成されるような、ランクと次元が一致する配列を返します。" EOL2 (CODE1 "bit-not") "の場合は、" (STRONG "bit-array")
     "にランクと次元が一致する配列が返却され、" "その配列には" (STRONG "bit-array") "の全てのビットが逆転したもののコピーが含まれます。"
     EOL2 "もし" (STRONG "opt-arg") "が型" (CODE1 "(array bit)") "であれば、" "返却される内容は"
     (STRONG "opt-arg") "の中に破壊的に配置されます。" "もし" (STRONG "opt-arg") "がシンボル" (CODE1 "t")
     "のとき、" (STRONG "bit-array") "か" (STRONG "bit-array1") "が結果に置き換えられます。" "もし"
     (STRONG "opt-arg") "が" (CODE1 "nil") "か省略されたときは、" "結果を格納した新しい配列が作成されます。" EOL2
     "次の図は各関数によって処理される論理操作を示します。" EOL2
     "|関数             |処理                                   |"
     "|-----------------|---------------------------------------|" "|" (CODE1 "bit-and")
     "   | and                                   |" "|" (CODE1 "bit-eqv")
     "   | 同値（排他的nor)                      |" "|" (CODE1 "bit-not")
     "   | 補数                                  |" "|" (CODE1 "bit-ior")
     "   | 内包的or                              |" "|" (CODE1 "bit-xor")
     "   | 排他的or                              |" "|" (CODE1 "bit-nand") "  | ("
     (STRONG "bit-array1") " and " (STRONG "bit-array2") ")の補数 |" "|" (CODE1 "bit-nor")
     "   | (" (STRONG "bit-array1") " or " (STRONG "bit-array2") ")の補数  |" "|"
     (CODE1 "bit-andc1") " | (" (STRONG "bit-array1") "の補数) and " (STRONG "bit-array2")
     " |" "|" (CODE1 "bit-andc2") " | " (STRONG "bit-array1") " and ("
     (STRONG "bit-array2") "の補数) |" "|" (CODE1 "bit-orc1") "  | (" (STRONG "bit-array1")
     "の補数) or " (STRONG "bit-array2") "  |" "|" (CODE1 "bit-orc2") "  | "
     (STRONG "bit-array1") " or (" (STRONG "bit-array2") "の補数)  |" EOL2
     "Figure 15-4. ビット配列上のビット単位の論理演算")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(bit-and (setq ba #*11101010) #*01101011) =>  #*01101010"
      "(bit-and #*1100 #*1010) =>  #*1000      " "(bit-andc1 #*1100 #*1010) =>  #*0010"
      "(setq rba (bit-andc2 ba #*00110011 t)) =>  #*11001000" "(eq rba ba) =>  true"
      "(bit-not (setq ba #*11101010)) =>  #*00010101" "(setq rba (bit-not ba "
      "                    (setq tba (make-array 8 "
      "                                          :element-type 'bit))))" "=>  #*00010101"
      "(equal rba tba) =>  true" "(bit-xor #*1100 #*1010) =>  #*0110"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "lognot") "," (CODE1 "logand"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("BIT-ANDC2" . "FUNCTION") *table*) (gethash "BIT-ANDC2" *table*))
(setf (gethash "BIT-EQV" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BIT-AND") ", " (CODE1 "BIT-ANDC1") ", "
     (CODE1 "BIT-ANDC2") ", " (CODE1 "BIT-EQV") "," (CODE1 "BIT-IOR") ", "
     (CODE1 "BIT-NAND") ", " (CODE1 "BIT-NOR") ", " (CODE1 "BIT-NOT") ","
     (CODE1 "BIT-ORC1") ", " (CODE1 "BIT-ORC2") ", " (CODE1 "BIT-XOR"))
    (CHAPTER ("## 構文") 2 (CODE1 "bit-and") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc1") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc2") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-eqv") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-ior") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nand") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc1") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc2") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-xor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-not") " " (STRONG "bit-array") " "
     (CODE1 "&optional") " " (STRONG "opt-arg") " => " (STRONG "resulting-bit-array"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "bit-array") ", " (STRONG "bit-array1") ", "
     (STRONG "bit-array2") " - ビット配列" EOL1 (STRONG "opt-arg") " - ビット配列か、" (CODE1 "t")
     "か、" (CODE1 "nil") "。" "デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "bit-array") ", "
     (STRONG "bit-array1") ", " (STRONG "bit-array2") ", " (STRONG "opt-arg")
     "（もし配列なら）は、" "全て同じランクと大きさでなければなりません。" EOL1 (STRONG "resulting-bit-array")
     " - ビット配列")
    (CHAPTER ("## 定義") 2 "これらの関数は、" (STRONG "bit-array1") "と" (STRONG "bit-array2")
     "のビット単位の論理操作を行い、" "その結果の任意のビットが各引数の対応するビットを操作することによって"
     "生成されるような、ランクと次元が一致する配列を返します。" EOL2 (CODE1 "bit-not") "の場合は、" (STRONG "bit-array")
     "にランクと次元が一致する配列が返却され、" "その配列には" (STRONG "bit-array") "の全てのビットが逆転したもののコピーが含まれます。"
     EOL2 "もし" (STRONG "opt-arg") "が型" (CODE1 "(array bit)") "であれば、" "返却される内容は"
     (STRONG "opt-arg") "の中に破壊的に配置されます。" "もし" (STRONG "opt-arg") "がシンボル" (CODE1 "t")
     "のとき、" (STRONG "bit-array") "か" (STRONG "bit-array1") "が結果に置き換えられます。" "もし"
     (STRONG "opt-arg") "が" (CODE1 "nil") "か省略されたときは、" "結果を格納した新しい配列が作成されます。" EOL2
     "次の図は各関数によって処理される論理操作を示します。" EOL2
     "|関数             |処理                                   |"
     "|-----------------|---------------------------------------|" "|" (CODE1 "bit-and")
     "   | and                                   |" "|" (CODE1 "bit-eqv")
     "   | 同値（排他的nor)                      |" "|" (CODE1 "bit-not")
     "   | 補数                                  |" "|" (CODE1 "bit-ior")
     "   | 内包的or                              |" "|" (CODE1 "bit-xor")
     "   | 排他的or                              |" "|" (CODE1 "bit-nand") "  | ("
     (STRONG "bit-array1") " and " (STRONG "bit-array2") ")の補数 |" "|" (CODE1 "bit-nor")
     "   | (" (STRONG "bit-array1") " or " (STRONG "bit-array2") ")の補数  |" "|"
     (CODE1 "bit-andc1") " | (" (STRONG "bit-array1") "の補数) and " (STRONG "bit-array2")
     " |" "|" (CODE1 "bit-andc2") " | " (STRONG "bit-array1") " and ("
     (STRONG "bit-array2") "の補数) |" "|" (CODE1 "bit-orc1") "  | (" (STRONG "bit-array1")
     "の補数) or " (STRONG "bit-array2") "  |" "|" (CODE1 "bit-orc2") "  | "
     (STRONG "bit-array1") " or (" (STRONG "bit-array2") "の補数)  |" EOL2
     "Figure 15-4. ビット配列上のビット単位の論理演算")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(bit-and (setq ba #*11101010) #*01101011) =>  #*01101010"
      "(bit-and #*1100 #*1010) =>  #*1000      " "(bit-andc1 #*1100 #*1010) =>  #*0010"
      "(setq rba (bit-andc2 ba #*00110011 t)) =>  #*11001000" "(eq rba ba) =>  true"
      "(bit-not (setq ba #*11101010)) =>  #*00010101" "(setq rba (bit-not ba "
      "                    (setq tba (make-array 8 "
      "                                          :element-type 'bit))))" "=>  #*00010101"
      "(equal rba tba) =>  true" "(bit-xor #*1100 #*1010) =>  #*0110"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "lognot") "," (CODE1 "logand"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("BIT-EQV" . "FUNCTION") *table*) (gethash "BIT-EQV" *table*))
(setf (gethash "BIT-IOR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BIT-AND") ", " (CODE1 "BIT-ANDC1") ", "
     (CODE1 "BIT-ANDC2") ", " (CODE1 "BIT-EQV") "," (CODE1 "BIT-IOR") ", "
     (CODE1 "BIT-NAND") ", " (CODE1 "BIT-NOR") ", " (CODE1 "BIT-NOT") ","
     (CODE1 "BIT-ORC1") ", " (CODE1 "BIT-ORC2") ", " (CODE1 "BIT-XOR"))
    (CHAPTER ("## 構文") 2 (CODE1 "bit-and") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc1") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc2") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-eqv") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-ior") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nand") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc1") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc2") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-xor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-not") " " (STRONG "bit-array") " "
     (CODE1 "&optional") " " (STRONG "opt-arg") " => " (STRONG "resulting-bit-array"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "bit-array") ", " (STRONG "bit-array1") ", "
     (STRONG "bit-array2") " - ビット配列" EOL1 (STRONG "opt-arg") " - ビット配列か、" (CODE1 "t")
     "か、" (CODE1 "nil") "。" "デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "bit-array") ", "
     (STRONG "bit-array1") ", " (STRONG "bit-array2") ", " (STRONG "opt-arg")
     "（もし配列なら）は、" "全て同じランクと大きさでなければなりません。" EOL1 (STRONG "resulting-bit-array")
     " - ビット配列")
    (CHAPTER ("## 定義") 2 "これらの関数は、" (STRONG "bit-array1") "と" (STRONG "bit-array2")
     "のビット単位の論理操作を行い、" "その結果の任意のビットが各引数の対応するビットを操作することによって"
     "生成されるような、ランクと次元が一致する配列を返します。" EOL2 (CODE1 "bit-not") "の場合は、" (STRONG "bit-array")
     "にランクと次元が一致する配列が返却され、" "その配列には" (STRONG "bit-array") "の全てのビットが逆転したもののコピーが含まれます。"
     EOL2 "もし" (STRONG "opt-arg") "が型" (CODE1 "(array bit)") "であれば、" "返却される内容は"
     (STRONG "opt-arg") "の中に破壊的に配置されます。" "もし" (STRONG "opt-arg") "がシンボル" (CODE1 "t")
     "のとき、" (STRONG "bit-array") "か" (STRONG "bit-array1") "が結果に置き換えられます。" "もし"
     (STRONG "opt-arg") "が" (CODE1 "nil") "か省略されたときは、" "結果を格納した新しい配列が作成されます。" EOL2
     "次の図は各関数によって処理される論理操作を示します。" EOL2
     "|関数             |処理                                   |"
     "|-----------------|---------------------------------------|" "|" (CODE1 "bit-and")
     "   | and                                   |" "|" (CODE1 "bit-eqv")
     "   | 同値（排他的nor)                      |" "|" (CODE1 "bit-not")
     "   | 補数                                  |" "|" (CODE1 "bit-ior")
     "   | 内包的or                              |" "|" (CODE1 "bit-xor")
     "   | 排他的or                              |" "|" (CODE1 "bit-nand") "  | ("
     (STRONG "bit-array1") " and " (STRONG "bit-array2") ")の補数 |" "|" (CODE1 "bit-nor")
     "   | (" (STRONG "bit-array1") " or " (STRONG "bit-array2") ")の補数  |" "|"
     (CODE1 "bit-andc1") " | (" (STRONG "bit-array1") "の補数) and " (STRONG "bit-array2")
     " |" "|" (CODE1 "bit-andc2") " | " (STRONG "bit-array1") " and ("
     (STRONG "bit-array2") "の補数) |" "|" (CODE1 "bit-orc1") "  | (" (STRONG "bit-array1")
     "の補数) or " (STRONG "bit-array2") "  |" "|" (CODE1 "bit-orc2") "  | "
     (STRONG "bit-array1") " or (" (STRONG "bit-array2") "の補数)  |" EOL2
     "Figure 15-4. ビット配列上のビット単位の論理演算")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(bit-and (setq ba #*11101010) #*01101011) =>  #*01101010"
      "(bit-and #*1100 #*1010) =>  #*1000      " "(bit-andc1 #*1100 #*1010) =>  #*0010"
      "(setq rba (bit-andc2 ba #*00110011 t)) =>  #*11001000" "(eq rba ba) =>  true"
      "(bit-not (setq ba #*11101010)) =>  #*00010101" "(setq rba (bit-not ba "
      "                    (setq tba (make-array 8 "
      "                                          :element-type 'bit))))" "=>  #*00010101"
      "(equal rba tba) =>  true" "(bit-xor #*1100 #*1010) =>  #*0110"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "lognot") "," (CODE1 "logand"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("BIT-IOR" . "FUNCTION") *table*) (gethash "BIT-IOR" *table*))
(setf (gethash "BIT-NAND" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BIT-AND") ", " (CODE1 "BIT-ANDC1") ", "
     (CODE1 "BIT-ANDC2") ", " (CODE1 "BIT-EQV") "," (CODE1 "BIT-IOR") ", "
     (CODE1 "BIT-NAND") ", " (CODE1 "BIT-NOR") ", " (CODE1 "BIT-NOT") ","
     (CODE1 "BIT-ORC1") ", " (CODE1 "BIT-ORC2") ", " (CODE1 "BIT-XOR"))
    (CHAPTER ("## 構文") 2 (CODE1 "bit-and") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc1") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc2") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-eqv") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-ior") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nand") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc1") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc2") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-xor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-not") " " (STRONG "bit-array") " "
     (CODE1 "&optional") " " (STRONG "opt-arg") " => " (STRONG "resulting-bit-array"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "bit-array") ", " (STRONG "bit-array1") ", "
     (STRONG "bit-array2") " - ビット配列" EOL1 (STRONG "opt-arg") " - ビット配列か、" (CODE1 "t")
     "か、" (CODE1 "nil") "。" "デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "bit-array") ", "
     (STRONG "bit-array1") ", " (STRONG "bit-array2") ", " (STRONG "opt-arg")
     "（もし配列なら）は、" "全て同じランクと大きさでなければなりません。" EOL1 (STRONG "resulting-bit-array")
     " - ビット配列")
    (CHAPTER ("## 定義") 2 "これらの関数は、" (STRONG "bit-array1") "と" (STRONG "bit-array2")
     "のビット単位の論理操作を行い、" "その結果の任意のビットが各引数の対応するビットを操作することによって"
     "生成されるような、ランクと次元が一致する配列を返します。" EOL2 (CODE1 "bit-not") "の場合は、" (STRONG "bit-array")
     "にランクと次元が一致する配列が返却され、" "その配列には" (STRONG "bit-array") "の全てのビットが逆転したもののコピーが含まれます。"
     EOL2 "もし" (STRONG "opt-arg") "が型" (CODE1 "(array bit)") "であれば、" "返却される内容は"
     (STRONG "opt-arg") "の中に破壊的に配置されます。" "もし" (STRONG "opt-arg") "がシンボル" (CODE1 "t")
     "のとき、" (STRONG "bit-array") "か" (STRONG "bit-array1") "が結果に置き換えられます。" "もし"
     (STRONG "opt-arg") "が" (CODE1 "nil") "か省略されたときは、" "結果を格納した新しい配列が作成されます。" EOL2
     "次の図は各関数によって処理される論理操作を示します。" EOL2
     "|関数             |処理                                   |"
     "|-----------------|---------------------------------------|" "|" (CODE1 "bit-and")
     "   | and                                   |" "|" (CODE1 "bit-eqv")
     "   | 同値（排他的nor)                      |" "|" (CODE1 "bit-not")
     "   | 補数                                  |" "|" (CODE1 "bit-ior")
     "   | 内包的or                              |" "|" (CODE1 "bit-xor")
     "   | 排他的or                              |" "|" (CODE1 "bit-nand") "  | ("
     (STRONG "bit-array1") " and " (STRONG "bit-array2") ")の補数 |" "|" (CODE1 "bit-nor")
     "   | (" (STRONG "bit-array1") " or " (STRONG "bit-array2") ")の補数  |" "|"
     (CODE1 "bit-andc1") " | (" (STRONG "bit-array1") "の補数) and " (STRONG "bit-array2")
     " |" "|" (CODE1 "bit-andc2") " | " (STRONG "bit-array1") " and ("
     (STRONG "bit-array2") "の補数) |" "|" (CODE1 "bit-orc1") "  | (" (STRONG "bit-array1")
     "の補数) or " (STRONG "bit-array2") "  |" "|" (CODE1 "bit-orc2") "  | "
     (STRONG "bit-array1") " or (" (STRONG "bit-array2") "の補数)  |" EOL2
     "Figure 15-4. ビット配列上のビット単位の論理演算")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(bit-and (setq ba #*11101010) #*01101011) =>  #*01101010"
      "(bit-and #*1100 #*1010) =>  #*1000      " "(bit-andc1 #*1100 #*1010) =>  #*0010"
      "(setq rba (bit-andc2 ba #*00110011 t)) =>  #*11001000" "(eq rba ba) =>  true"
      "(bit-not (setq ba #*11101010)) =>  #*00010101" "(setq rba (bit-not ba "
      "                    (setq tba (make-array 8 "
      "                                          :element-type 'bit))))" "=>  #*00010101"
      "(equal rba tba) =>  true" "(bit-xor #*1100 #*1010) =>  #*0110"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "lognot") "," (CODE1 "logand"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("BIT-NAND" . "FUNCTION") *table*) (gethash "BIT-NAND" *table*))
(setf (gethash "BIT-NOR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BIT-AND") ", " (CODE1 "BIT-ANDC1") ", "
     (CODE1 "BIT-ANDC2") ", " (CODE1 "BIT-EQV") "," (CODE1 "BIT-IOR") ", "
     (CODE1 "BIT-NAND") ", " (CODE1 "BIT-NOR") ", " (CODE1 "BIT-NOT") ","
     (CODE1 "BIT-ORC1") ", " (CODE1 "BIT-ORC2") ", " (CODE1 "BIT-XOR"))
    (CHAPTER ("## 構文") 2 (CODE1 "bit-and") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc1") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc2") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-eqv") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-ior") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nand") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc1") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc2") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-xor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-not") " " (STRONG "bit-array") " "
     (CODE1 "&optional") " " (STRONG "opt-arg") " => " (STRONG "resulting-bit-array"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "bit-array") ", " (STRONG "bit-array1") ", "
     (STRONG "bit-array2") " - ビット配列" EOL1 (STRONG "opt-arg") " - ビット配列か、" (CODE1 "t")
     "か、" (CODE1 "nil") "。" "デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "bit-array") ", "
     (STRONG "bit-array1") ", " (STRONG "bit-array2") ", " (STRONG "opt-arg")
     "（もし配列なら）は、" "全て同じランクと大きさでなければなりません。" EOL1 (STRONG "resulting-bit-array")
     " - ビット配列")
    (CHAPTER ("## 定義") 2 "これらの関数は、" (STRONG "bit-array1") "と" (STRONG "bit-array2")
     "のビット単位の論理操作を行い、" "その結果の任意のビットが各引数の対応するビットを操作することによって"
     "生成されるような、ランクと次元が一致する配列を返します。" EOL2 (CODE1 "bit-not") "の場合は、" (STRONG "bit-array")
     "にランクと次元が一致する配列が返却され、" "その配列には" (STRONG "bit-array") "の全てのビットが逆転したもののコピーが含まれます。"
     EOL2 "もし" (STRONG "opt-arg") "が型" (CODE1 "(array bit)") "であれば、" "返却される内容は"
     (STRONG "opt-arg") "の中に破壊的に配置されます。" "もし" (STRONG "opt-arg") "がシンボル" (CODE1 "t")
     "のとき、" (STRONG "bit-array") "か" (STRONG "bit-array1") "が結果に置き換えられます。" "もし"
     (STRONG "opt-arg") "が" (CODE1 "nil") "か省略されたときは、" "結果を格納した新しい配列が作成されます。" EOL2
     "次の図は各関数によって処理される論理操作を示します。" EOL2
     "|関数             |処理                                   |"
     "|-----------------|---------------------------------------|" "|" (CODE1 "bit-and")
     "   | and                                   |" "|" (CODE1 "bit-eqv")
     "   | 同値（排他的nor)                      |" "|" (CODE1 "bit-not")
     "   | 補数                                  |" "|" (CODE1 "bit-ior")
     "   | 内包的or                              |" "|" (CODE1 "bit-xor")
     "   | 排他的or                              |" "|" (CODE1 "bit-nand") "  | ("
     (STRONG "bit-array1") " and " (STRONG "bit-array2") ")の補数 |" "|" (CODE1 "bit-nor")
     "   | (" (STRONG "bit-array1") " or " (STRONG "bit-array2") ")の補数  |" "|"
     (CODE1 "bit-andc1") " | (" (STRONG "bit-array1") "の補数) and " (STRONG "bit-array2")
     " |" "|" (CODE1 "bit-andc2") " | " (STRONG "bit-array1") " and ("
     (STRONG "bit-array2") "の補数) |" "|" (CODE1 "bit-orc1") "  | (" (STRONG "bit-array1")
     "の補数) or " (STRONG "bit-array2") "  |" "|" (CODE1 "bit-orc2") "  | "
     (STRONG "bit-array1") " or (" (STRONG "bit-array2") "の補数)  |" EOL2
     "Figure 15-4. ビット配列上のビット単位の論理演算")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(bit-and (setq ba #*11101010) #*01101011) =>  #*01101010"
      "(bit-and #*1100 #*1010) =>  #*1000      " "(bit-andc1 #*1100 #*1010) =>  #*0010"
      "(setq rba (bit-andc2 ba #*00110011 t)) =>  #*11001000" "(eq rba ba) =>  true"
      "(bit-not (setq ba #*11101010)) =>  #*00010101" "(setq rba (bit-not ba "
      "                    (setq tba (make-array 8 "
      "                                          :element-type 'bit))))" "=>  #*00010101"
      "(equal rba tba) =>  true" "(bit-xor #*1100 #*1010) =>  #*0110"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "lognot") "," (CODE1 "logand"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("BIT-NOR" . "FUNCTION") *table*) (gethash "BIT-NOR" *table*))
(setf (gethash "BIT-NOT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BIT-AND") ", " (CODE1 "BIT-ANDC1") ", "
     (CODE1 "BIT-ANDC2") ", " (CODE1 "BIT-EQV") "," (CODE1 "BIT-IOR") ", "
     (CODE1 "BIT-NAND") ", " (CODE1 "BIT-NOR") ", " (CODE1 "BIT-NOT") ","
     (CODE1 "BIT-ORC1") ", " (CODE1 "BIT-ORC2") ", " (CODE1 "BIT-XOR"))
    (CHAPTER ("## 構文") 2 (CODE1 "bit-and") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc1") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc2") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-eqv") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-ior") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nand") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc1") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc2") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-xor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-not") " " (STRONG "bit-array") " "
     (CODE1 "&optional") " " (STRONG "opt-arg") " => " (STRONG "resulting-bit-array"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "bit-array") ", " (STRONG "bit-array1") ", "
     (STRONG "bit-array2") " - ビット配列" EOL1 (STRONG "opt-arg") " - ビット配列か、" (CODE1 "t")
     "か、" (CODE1 "nil") "。" "デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "bit-array") ", "
     (STRONG "bit-array1") ", " (STRONG "bit-array2") ", " (STRONG "opt-arg")
     "（もし配列なら）は、" "全て同じランクと大きさでなければなりません。" EOL1 (STRONG "resulting-bit-array")
     " - ビット配列")
    (CHAPTER ("## 定義") 2 "これらの関数は、" (STRONG "bit-array1") "と" (STRONG "bit-array2")
     "のビット単位の論理操作を行い、" "その結果の任意のビットが各引数の対応するビットを操作することによって"
     "生成されるような、ランクと次元が一致する配列を返します。" EOL2 (CODE1 "bit-not") "の場合は、" (STRONG "bit-array")
     "にランクと次元が一致する配列が返却され、" "その配列には" (STRONG "bit-array") "の全てのビットが逆転したもののコピーが含まれます。"
     EOL2 "もし" (STRONG "opt-arg") "が型" (CODE1 "(array bit)") "であれば、" "返却される内容は"
     (STRONG "opt-arg") "の中に破壊的に配置されます。" "もし" (STRONG "opt-arg") "がシンボル" (CODE1 "t")
     "のとき、" (STRONG "bit-array") "か" (STRONG "bit-array1") "が結果に置き換えられます。" "もし"
     (STRONG "opt-arg") "が" (CODE1 "nil") "か省略されたときは、" "結果を格納した新しい配列が作成されます。" EOL2
     "次の図は各関数によって処理される論理操作を示します。" EOL2
     "|関数             |処理                                   |"
     "|-----------------|---------------------------------------|" "|" (CODE1 "bit-and")
     "   | and                                   |" "|" (CODE1 "bit-eqv")
     "   | 同値（排他的nor)                      |" "|" (CODE1 "bit-not")
     "   | 補数                                  |" "|" (CODE1 "bit-ior")
     "   | 内包的or                              |" "|" (CODE1 "bit-xor")
     "   | 排他的or                              |" "|" (CODE1 "bit-nand") "  | ("
     (STRONG "bit-array1") " and " (STRONG "bit-array2") ")の補数 |" "|" (CODE1 "bit-nor")
     "   | (" (STRONG "bit-array1") " or " (STRONG "bit-array2") ")の補数  |" "|"
     (CODE1 "bit-andc1") " | (" (STRONG "bit-array1") "の補数) and " (STRONG "bit-array2")
     " |" "|" (CODE1 "bit-andc2") " | " (STRONG "bit-array1") " and ("
     (STRONG "bit-array2") "の補数) |" "|" (CODE1 "bit-orc1") "  | (" (STRONG "bit-array1")
     "の補数) or " (STRONG "bit-array2") "  |" "|" (CODE1 "bit-orc2") "  | "
     (STRONG "bit-array1") " or (" (STRONG "bit-array2") "の補数)  |" EOL2
     "Figure 15-4. ビット配列上のビット単位の論理演算")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(bit-and (setq ba #*11101010) #*01101011) =>  #*01101010"
      "(bit-and #*1100 #*1010) =>  #*1000      " "(bit-andc1 #*1100 #*1010) =>  #*0010"
      "(setq rba (bit-andc2 ba #*00110011 t)) =>  #*11001000" "(eq rba ba) =>  true"
      "(bit-not (setq ba #*11101010)) =>  #*00010101" "(setq rba (bit-not ba "
      "                    (setq tba (make-array 8 "
      "                                          :element-type 'bit))))" "=>  #*00010101"
      "(equal rba tba) =>  true" "(bit-xor #*1100 #*1010) =>  #*0110"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "lognot") "," (CODE1 "logand"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("BIT-NOT" . "FUNCTION") *table*) (gethash "BIT-NOT" *table*))
(setf (gethash "BIT-ORC1" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BIT-AND") ", " (CODE1 "BIT-ANDC1") ", "
     (CODE1 "BIT-ANDC2") ", " (CODE1 "BIT-EQV") "," (CODE1 "BIT-IOR") ", "
     (CODE1 "BIT-NAND") ", " (CODE1 "BIT-NOR") ", " (CODE1 "BIT-NOT") ","
     (CODE1 "BIT-ORC1") ", " (CODE1 "BIT-ORC2") ", " (CODE1 "BIT-XOR"))
    (CHAPTER ("## 構文") 2 (CODE1 "bit-and") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc1") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc2") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-eqv") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-ior") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nand") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc1") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc2") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-xor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-not") " " (STRONG "bit-array") " "
     (CODE1 "&optional") " " (STRONG "opt-arg") " => " (STRONG "resulting-bit-array"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "bit-array") ", " (STRONG "bit-array1") ", "
     (STRONG "bit-array2") " - ビット配列" EOL1 (STRONG "opt-arg") " - ビット配列か、" (CODE1 "t")
     "か、" (CODE1 "nil") "。" "デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "bit-array") ", "
     (STRONG "bit-array1") ", " (STRONG "bit-array2") ", " (STRONG "opt-arg")
     "（もし配列なら）は、" "全て同じランクと大きさでなければなりません。" EOL1 (STRONG "resulting-bit-array")
     " - ビット配列")
    (CHAPTER ("## 定義") 2 "これらの関数は、" (STRONG "bit-array1") "と" (STRONG "bit-array2")
     "のビット単位の論理操作を行い、" "その結果の任意のビットが各引数の対応するビットを操作することによって"
     "生成されるような、ランクと次元が一致する配列を返します。" EOL2 (CODE1 "bit-not") "の場合は、" (STRONG "bit-array")
     "にランクと次元が一致する配列が返却され、" "その配列には" (STRONG "bit-array") "の全てのビットが逆転したもののコピーが含まれます。"
     EOL2 "もし" (STRONG "opt-arg") "が型" (CODE1 "(array bit)") "であれば、" "返却される内容は"
     (STRONG "opt-arg") "の中に破壊的に配置されます。" "もし" (STRONG "opt-arg") "がシンボル" (CODE1 "t")
     "のとき、" (STRONG "bit-array") "か" (STRONG "bit-array1") "が結果に置き換えられます。" "もし"
     (STRONG "opt-arg") "が" (CODE1 "nil") "か省略されたときは、" "結果を格納した新しい配列が作成されます。" EOL2
     "次の図は各関数によって処理される論理操作を示します。" EOL2
     "|関数             |処理                                   |"
     "|-----------------|---------------------------------------|" "|" (CODE1 "bit-and")
     "   | and                                   |" "|" (CODE1 "bit-eqv")
     "   | 同値（排他的nor)                      |" "|" (CODE1 "bit-not")
     "   | 補数                                  |" "|" (CODE1 "bit-ior")
     "   | 内包的or                              |" "|" (CODE1 "bit-xor")
     "   | 排他的or                              |" "|" (CODE1 "bit-nand") "  | ("
     (STRONG "bit-array1") " and " (STRONG "bit-array2") ")の補数 |" "|" (CODE1 "bit-nor")
     "   | (" (STRONG "bit-array1") " or " (STRONG "bit-array2") ")の補数  |" "|"
     (CODE1 "bit-andc1") " | (" (STRONG "bit-array1") "の補数) and " (STRONG "bit-array2")
     " |" "|" (CODE1 "bit-andc2") " | " (STRONG "bit-array1") " and ("
     (STRONG "bit-array2") "の補数) |" "|" (CODE1 "bit-orc1") "  | (" (STRONG "bit-array1")
     "の補数) or " (STRONG "bit-array2") "  |" "|" (CODE1 "bit-orc2") "  | "
     (STRONG "bit-array1") " or (" (STRONG "bit-array2") "の補数)  |" EOL2
     "Figure 15-4. ビット配列上のビット単位の論理演算")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(bit-and (setq ba #*11101010) #*01101011) =>  #*01101010"
      "(bit-and #*1100 #*1010) =>  #*1000      " "(bit-andc1 #*1100 #*1010) =>  #*0010"
      "(setq rba (bit-andc2 ba #*00110011 t)) =>  #*11001000" "(eq rba ba) =>  true"
      "(bit-not (setq ba #*11101010)) =>  #*00010101" "(setq rba (bit-not ba "
      "                    (setq tba (make-array 8 "
      "                                          :element-type 'bit))))" "=>  #*00010101"
      "(equal rba tba) =>  true" "(bit-xor #*1100 #*1010) =>  #*0110"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "lognot") "," (CODE1 "logand"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("BIT-ORC1" . "FUNCTION") *table*) (gethash "BIT-ORC1" *table*))
(setf (gethash "BIT-ORC2" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BIT-AND") ", " (CODE1 "BIT-ANDC1") ", "
     (CODE1 "BIT-ANDC2") ", " (CODE1 "BIT-EQV") "," (CODE1 "BIT-IOR") ", "
     (CODE1 "BIT-NAND") ", " (CODE1 "BIT-NOR") ", " (CODE1 "BIT-NOT") ","
     (CODE1 "BIT-ORC1") ", " (CODE1 "BIT-ORC2") ", " (CODE1 "BIT-XOR"))
    (CHAPTER ("## 構文") 2 (CODE1 "bit-and") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc1") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc2") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-eqv") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-ior") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nand") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc1") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc2") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-xor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-not") " " (STRONG "bit-array") " "
     (CODE1 "&optional") " " (STRONG "opt-arg") " => " (STRONG "resulting-bit-array"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "bit-array") ", " (STRONG "bit-array1") ", "
     (STRONG "bit-array2") " - ビット配列" EOL1 (STRONG "opt-arg") " - ビット配列か、" (CODE1 "t")
     "か、" (CODE1 "nil") "。" "デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "bit-array") ", "
     (STRONG "bit-array1") ", " (STRONG "bit-array2") ", " (STRONG "opt-arg")
     "（もし配列なら）は、" "全て同じランクと大きさでなければなりません。" EOL1 (STRONG "resulting-bit-array")
     " - ビット配列")
    (CHAPTER ("## 定義") 2 "これらの関数は、" (STRONG "bit-array1") "と" (STRONG "bit-array2")
     "のビット単位の論理操作を行い、" "その結果の任意のビットが各引数の対応するビットを操作することによって"
     "生成されるような、ランクと次元が一致する配列を返します。" EOL2 (CODE1 "bit-not") "の場合は、" (STRONG "bit-array")
     "にランクと次元が一致する配列が返却され、" "その配列には" (STRONG "bit-array") "の全てのビットが逆転したもののコピーが含まれます。"
     EOL2 "もし" (STRONG "opt-arg") "が型" (CODE1 "(array bit)") "であれば、" "返却される内容は"
     (STRONG "opt-arg") "の中に破壊的に配置されます。" "もし" (STRONG "opt-arg") "がシンボル" (CODE1 "t")
     "のとき、" (STRONG "bit-array") "か" (STRONG "bit-array1") "が結果に置き換えられます。" "もし"
     (STRONG "opt-arg") "が" (CODE1 "nil") "か省略されたときは、" "結果を格納した新しい配列が作成されます。" EOL2
     "次の図は各関数によって処理される論理操作を示します。" EOL2
     "|関数             |処理                                   |"
     "|-----------------|---------------------------------------|" "|" (CODE1 "bit-and")
     "   | and                                   |" "|" (CODE1 "bit-eqv")
     "   | 同値（排他的nor)                      |" "|" (CODE1 "bit-not")
     "   | 補数                                  |" "|" (CODE1 "bit-ior")
     "   | 内包的or                              |" "|" (CODE1 "bit-xor")
     "   | 排他的or                              |" "|" (CODE1 "bit-nand") "  | ("
     (STRONG "bit-array1") " and " (STRONG "bit-array2") ")の補数 |" "|" (CODE1 "bit-nor")
     "   | (" (STRONG "bit-array1") " or " (STRONG "bit-array2") ")の補数  |" "|"
     (CODE1 "bit-andc1") " | (" (STRONG "bit-array1") "の補数) and " (STRONG "bit-array2")
     " |" "|" (CODE1 "bit-andc2") " | " (STRONG "bit-array1") " and ("
     (STRONG "bit-array2") "の補数) |" "|" (CODE1 "bit-orc1") "  | (" (STRONG "bit-array1")
     "の補数) or " (STRONG "bit-array2") "  |" "|" (CODE1 "bit-orc2") "  | "
     (STRONG "bit-array1") " or (" (STRONG "bit-array2") "の補数)  |" EOL2
     "Figure 15-4. ビット配列上のビット単位の論理演算")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(bit-and (setq ba #*11101010) #*01101011) =>  #*01101010"
      "(bit-and #*1100 #*1010) =>  #*1000      " "(bit-andc1 #*1100 #*1010) =>  #*0010"
      "(setq rba (bit-andc2 ba #*00110011 t)) =>  #*11001000" "(eq rba ba) =>  true"
      "(bit-not (setq ba #*11101010)) =>  #*00010101" "(setq rba (bit-not ba "
      "                    (setq tba (make-array 8 "
      "                                          :element-type 'bit))))" "=>  #*00010101"
      "(equal rba tba) =>  true" "(bit-xor #*1100 #*1010) =>  #*0110"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "lognot") "," (CODE1 "logand"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("BIT-ORC2" . "FUNCTION") *table*) (gethash "BIT-ORC2" *table*))
(setf (gethash "BIT-VECTOR" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "BIT-VECTOR"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "bit-vector") "," (CODE1 "vector") ","
     (CODE1 "array") "," (CODE1 "sequence") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 (CODE1 "bit-vector") "は、要素の型が" (CODE1 "bit") "の"
     (CODE1 "vector") "です。" EOL2 "型" (CODE1 "bit-vector") "は、型" (CODE1 "vector")
     "のサブタイプであり、" (CODE1 "bit-vector") "は" (CODE1 "(vector bit)") "を意味します。")
    (CHAPTER ("## 型指定子の種類") 2 "省略形")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "bit-vector") " [" (STRONG "size") "]")
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "size") " - 非負の" (CODE1 "fixnum") "か、シンボル"
     (CODE1 "*") "。")
    (CHAPTER ("## 型指定子の定義") 2 "これは型" (CODE1 "(array bit (size))") "と同じであり、" "つまりサイズが"
     (STRONG "size") "の" (CODE1 "bit-vector") "の集合です。")
    (CHAPTER ("## 参考") 2 "2.4.8.4. シャープサイン アスタリスク," "22.1.3.6. Bit-Vectorの印字,"
     "15.1.2.2. 特定化された配列の種類の要求")))
(setf (gethash '("BIT-VECTOR" . "SYSTEM-CLASS") *table*) (gethash "BIT-VECTOR" *table*))
(setf (gethash "BIT-VECTOR-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BIT-VECTOR-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "bit-vector-p") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が型" (CODE1 "bit-vector") "のときは"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(bit-vector-p (make-array 6 "
      "                          :element-type 'bit "
      "                          :fill-pointer t)) =>  true" "(bit-vector-p #*) =>  true"
      "(bit-vector-p (make-array 6)) =>  false"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "typep"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(bit-vector-p object) == (typep object 'bit-vector)"))))
(setf (gethash '("BIT-VECTOR-P" . "FUNCTION") *table*) (gethash "BIT-VECTOR-P" *table*))
(setf (gethash "BIT-XOR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BIT-AND") ", " (CODE1 "BIT-ANDC1") ", "
     (CODE1 "BIT-ANDC2") ", " (CODE1 "BIT-EQV") "," (CODE1 "BIT-IOR") ", "
     (CODE1 "BIT-NAND") ", " (CODE1 "BIT-NOR") ", " (CODE1 "BIT-NOT") ","
     (CODE1 "BIT-ORC1") ", " (CODE1 "BIT-ORC2") ", " (CODE1 "BIT-XOR"))
    (CHAPTER ("## 構文") 2 (CODE1 "bit-and") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc1") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-andc2") " " (STRONG "bit-array1")
     " " (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-eqv") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-ior") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nand") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-nor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc1") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-orc2") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-xor") " " (STRONG "bit-array1") " "
     (STRONG "bit-array2") " " (CODE1 "&optional") " " (STRONG "opt-arg") " => "
     (STRONG "resulting-bit-array") EOL1 (CODE1 "bit-not") " " (STRONG "bit-array") " "
     (CODE1 "&optional") " " (STRONG "opt-arg") " => " (STRONG "resulting-bit-array"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "bit-array") ", " (STRONG "bit-array1") ", "
     (STRONG "bit-array2") " - ビット配列" EOL1 (STRONG "opt-arg") " - ビット配列か、" (CODE1 "t")
     "か、" (CODE1 "nil") "。" "デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "bit-array") ", "
     (STRONG "bit-array1") ", " (STRONG "bit-array2") ", " (STRONG "opt-arg")
     "（もし配列なら）は、" "全て同じランクと大きさでなければなりません。" EOL1 (STRONG "resulting-bit-array")
     " - ビット配列")
    (CHAPTER ("## 定義") 2 "これらの関数は、" (STRONG "bit-array1") "と" (STRONG "bit-array2")
     "のビット単位の論理操作を行い、" "その結果の任意のビットが各引数の対応するビットを操作することによって"
     "生成されるような、ランクと次元が一致する配列を返します。" EOL2 (CODE1 "bit-not") "の場合は、" (STRONG "bit-array")
     "にランクと次元が一致する配列が返却され、" "その配列には" (STRONG "bit-array") "の全てのビットが逆転したもののコピーが含まれます。"
     EOL2 "もし" (STRONG "opt-arg") "が型" (CODE1 "(array bit)") "であれば、" "返却される内容は"
     (STRONG "opt-arg") "の中に破壊的に配置されます。" "もし" (STRONG "opt-arg") "がシンボル" (CODE1 "t")
     "のとき、" (STRONG "bit-array") "か" (STRONG "bit-array1") "が結果に置き換えられます。" "もし"
     (STRONG "opt-arg") "が" (CODE1 "nil") "か省略されたときは、" "結果を格納した新しい配列が作成されます。" EOL2
     "次の図は各関数によって処理される論理操作を示します。" EOL2
     "|関数             |処理                                   |"
     "|-----------------|---------------------------------------|" "|" (CODE1 "bit-and")
     "   | and                                   |" "|" (CODE1 "bit-eqv")
     "   | 同値（排他的nor)                      |" "|" (CODE1 "bit-not")
     "   | 補数                                  |" "|" (CODE1 "bit-ior")
     "   | 内包的or                              |" "|" (CODE1 "bit-xor")
     "   | 排他的or                              |" "|" (CODE1 "bit-nand") "  | ("
     (STRONG "bit-array1") " and " (STRONG "bit-array2") ")の補数 |" "|" (CODE1 "bit-nor")
     "   | (" (STRONG "bit-array1") " or " (STRONG "bit-array2") ")の補数  |" "|"
     (CODE1 "bit-andc1") " | (" (STRONG "bit-array1") "の補数) and " (STRONG "bit-array2")
     " |" "|" (CODE1 "bit-andc2") " | " (STRONG "bit-array1") " and ("
     (STRONG "bit-array2") "の補数) |" "|" (CODE1 "bit-orc1") "  | (" (STRONG "bit-array1")
     "の補数) or " (STRONG "bit-array2") "  |" "|" (CODE1 "bit-orc2") "  | "
     (STRONG "bit-array1") " or (" (STRONG "bit-array2") "の補数)  |" EOL2
     "Figure 15-4. ビット配列上のビット単位の論理演算")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(bit-and (setq ba #*11101010) #*01101011) =>  #*01101010"
      "(bit-and #*1100 #*1010) =>  #*1000      " "(bit-andc1 #*1100 #*1010) =>  #*0010"
      "(setq rba (bit-andc2 ba #*00110011 t)) =>  #*11001000" "(eq rba ba) =>  true"
      "(bit-not (setq ba #*11101010)) =>  #*00010101" "(setq rba (bit-not ba "
      "                    (setq tba (make-array 8 "
      "                                          :element-type 'bit))))" "=>  #*00010101"
      "(equal rba tba) =>  true" "(bit-xor #*1100 #*1010) =>  #*0110"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "lognot") "," (CODE1 "logand"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("BIT-XOR" . "FUNCTION") *table*) (gethash "BIT-XOR" *table*))
(setf (gethash "BLOCK" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "BLOCK"))
    (CHAPTER ("## 構文") 2 (CODE1 "block") " " (STRONG "name") " " (STRONG "form\\*")
     " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - シンボル" EOL1 (STRONG "form") " - フォーム"
     EOL1 (STRONG "result") " - もし通常の返却の場合はフォームの値が返却値が、" "明示的な返却（" (CODE1 "return-from")
     "によるもの）の場合はその値が渡されます。")
    (CHAPTER ("## 定義") 2 (CODE1 "block") "は、" (STRONG "name") "という" (CODE1 "block")
     "が確立され、" "そのあと暗黙のprognとして" (STRONG "form") "が評価されます。" EOL2 "特殊オペレーターの"
     (CODE1 "block") "と" (CODE1 "return-from") "は一緒に動作し、" "構造的で、レキシカルで、非局所的な退出機能を提供します。"
     EOL2 "レキシカルに囲まれた" (STRONG "form") "の任意の場所で、" (CODE1 "return-from") "の引数に"
     (STRONG "name") "を与えることで" (CODE1 "block") "のフォームから制御と値を返却することができます。" "ただし、同じ名前の"
     (CODE1 "block") "がはさまって確立しているときは、" "外側の" (CODE1 "block") "は内側のものに隠蔽されます。" EOL2
     (CODE1 "block") "の名前は、レキシカルスコープと動的エクステントを持ちます。" EOL2 "いったん確立すれば、" (CODE1 "block")
     "は通常の返却か、明示的な返却の" "どちらかひとつで終了するでしょう。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(block empty) =>  NIL"
      "(block whocares (values 1 2) (values 3 4)) =>  3, 4" "(let ((x 1)) "
      "  (block stop (setq x 2) (return-from stop) (setq x 3))" "  x) =>  2"
      "(block early (return-from early (values 1 2)) (values 3 4)) =>  1, 2"
      "(block outer (block inner (return-from outer 1)) 2) =>  1"
      "(block twin (block twin (return-from twin 1)) 2) =>  2"
      ";; Contrast behavior of this example with corresponding example of CATCH."
      "(block b" "  (flet ((b1 () (return-from b 1)))"
      "    (block b (b1) (print 'unreachable))" "    2)) =>  1"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "return") "," (CODE1 "return-from") "," "3.1. 評価")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("BLOCK" . "SPECIAL-OPERATOR") *table*) (gethash "BLOCK" *table*))
(setf (gethash "BOOLEAN" *table*)
  '((CHAPTER NIL 0 "Type " (CODE1 "BOOLEAN"))
    (CHAPTER ("## スーパータイプ") 2 (CODE1 "boolean") "," (CODE1 "symbol") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "boolean") "は、それぞれ" (STRONG "true") "と"
     (STRONG "false") "を表現するシンボル" (CODE1 "t") "と" (CODE1 "nil") "を含みます。")
    (CHAPTER ("## 参考") 2 (CODE1 "t") "（定数変数）," (CODE1 "nil") "（定数変数）," (CODE1 "if") ","
     (CODE1 "not") "," (CODE1 "complement"))
    (CHAPTER ("## 備考") 2 (CODE1 "if") "のような条件付き演算子は、" (CODE1 "boolean") "（ブール値）ではなく"
     "generalized-booleanの使用が許されます。" "generalized-booleanでは" (CODE1 "t") "だけではなく、"
     (CODE1 "nil") "以外の値が" (STRONG "true") "と見なされます。" EOL2 "しかし慣例としてシンボル" (CODE1 "t") "は"
     "generalized-booleanであっても、" "他に良い選択肢がない場合に使用する標準的な値であるとしています。")))
(setf (gethash '("BOOLEAN" . "TYPE") *table*) (gethash "BOOLEAN" *table*))
(setf (gethash "BOTH-CASE-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "UPPER-CASE-P") ", " (CODE1 "LOWER-CASE-P") ", "
     (CODE1 "BOTH-CASE-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "upper-case-p") " " (STRONG "character") " => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "lower-case-p") " " (STRONG "character")
     " => " (STRONG "generalized-boolean") EOL1 (CODE1 "both-case-p") " "
     (STRONG "character") " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " - 文字" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は、" (STRONG "character") "のケースをテストします。" EOL2
     (CODE1 "upper-case-p") "は、" (STRONG "character") "が大文字の場合は" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 (CODE1 "lower-case-p") "は、"
     (STRONG "character") "が小文字の場合は" (STRONG "true") "を、" "それ以外は" (STRONG "false")
     "を返却します。" EOL2 (CODE1 "both-case-p") "は、" (STRONG "character") "にケースがある場合は"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(upper-case-p #\\A) =>  true"
      "(upper-case-p #\\a) =>  false" "(both-case-p #\\a) =>  true"
      "(both-case-p #\\5) =>  false" "(lower-case-p #\\5) =>  false"
      "(upper-case-p #\\5) =>  false" ";; 次の例では、#\\Bellという文字が定義されている処理系を前提にしている。"
      "(lower-case-p #\\Bell) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "character") "が文字ではなかったら、型" (CODE1 "type-error")
     "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 (CODE1 "char-upcase") ", " (CODE1 "char-downcase")
     ", 13.1.4.3. 文字のケース, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("BOTH-CASE-P" . "FUNCTION") *table*) (gethash "BOTH-CASE-P" *table*))
(setf (gethash "BOUNDP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BOUNDP"))
    (CHAPTER ("## 構文") 2 (CODE1 "boundp") " " (STRONG "symbol") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - シンボル" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "もし" (STRONG "symbol") "が" (CODE1 "bound") "なら" (STRONG "true")
     "を、それ以外なら" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq x 1) =>  1" "(boundp 'x) =>  true"
      "(makunbound 'x) =>  X" "(boundp 'x) =>  false"
      "(let ((x 2)) (boundp 'x)) =>  false"
      "(let ((x 2)) (declare (special x)) (boundp 'x)) =>  true"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "symbol") "がシンボルではないとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "set") "," (CODE1 "setq") "," (CODE1 "symbol-value") ","
     (CODE1 "makunbound"))
    (CHAPTER ("## 備考") 2 "関数" (CODE1 "boundp") "はグローバル環境下において"
     "シンボルが値を持っているかどうかのみを決定します。" "レキシカルな束縛は無視されます。")))
(setf (gethash '("BOUNDP" . "FUNCTION") *table*) (gethash "BOUNDP" *table*))
(setf (gethash "BREAK" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BREAK"))
    (CHAPTER ("## 構文") 2 (CODE1 "break") " " (CODE1 "&optional") " "
     (STRONG "format-control") " " (CODE1 "&rest") " " (STRONG "format-arguments") " => "
     (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "format-control") " - format-control。デフォルトは実装依存。"
     EOL1 (STRONG "format-arguments") " - format-arguments")
    (CHAPTER ("## 定義") 2 (CODE1 "break") "は、" (STRONG "format-control") "と"
     (STRONG "format-arguments") "を" (CODE1 "format") "で出力し、" "そのあとプログラムによるエラー捕捉の機能による"
     "割り込みの可能性を一切許さずに" "直接デバッガーに入ります。" EOL2 "もし" (CODE1 "continue") " " (CODE1 "restart")
     "がデバッガー内で使用されたときは、" "何の異常状態の回復処理を行わずに" (CODE1 "break") "は即座に" (CODE1 "nil")
     "を返却します。" EOL2 (CODE1 "break") "はデバッガーに入ろうとする前に" (CODE1 "*debugger-hook*") "に"
     (CODE1 "nil") "を束縛します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(break \"You got here with arguments: ~:S.\" '(FOO 37 A))"
      ">>  BREAK: You got here with these arguments: FOO, 37, A."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Return from BREAK." ">>   2: Top level." ">>  Debug> :CONTINUE 1"
      ">>  Return from BREAK." "=>  NIL")
     EOL2 " ")
    (CHAPTER ("## 副作用") 2 "デバッガーに入ります。") (CHAPTER ("## 影響") 2 (CODE1 "*debug-io*"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "error") "," (CODE1 "invoke-debugger"))
    (CHAPTER ("## 備考") 2 (CODE1 "break") "は、エラーの通知を使用せず、" "プログラムの「ブレークポイント」として"
     "一時的にデバッグに入りたいときに使われます。" "このような理由から、" (CODE1 "break") "は" (CODE1 "cerror") "が取るような"
     (STRONG "continue-format-control") "引数を受け取りません。"
     "この点と、コンディションの捕捉によって割り込みが生じるという可能性がない点が、" (CODE1 "break") "と" (CODE1 "cerror")
     "間のプログラムに見える違いです。" EOL2 (CODE1 "break") "と" (CODE1 "cerror") "のユーザーインターフェイスの外観は、"
     "実装が必要とするインターフェイスにしたがって、" "より大きく変えてしまっても許されます。" "例えば、" (CODE1 "break")
     "は従来のデバッガーではなく" "Lispのread-eval-print loopに入ってしまっても許されます。" EOL2 (CODE1 "break")
     "は下記のように定義できます。"
     (CODE3 "```lisp" "```"
      "(defun break (&optional (format-control \"Break\") &rest format-arguments)"
      "  (with-simple-restart (continue \"Return from BREAK.\")"
      "    (let ((*debugger-hook* nil))" "      (invoke-debugger"
      "          (make-condition 'simple-condition"
      "                          :format-control format-control"
      "                          :format-arguments format-arguments))))" "  nil)"))))
(setf (gethash '("BREAK" . "FUNCTION") *table*) (gethash "BREAK" *table*))
(setf (gethash "BROADCAST-STREAM" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "BROADCAST-STREAM"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "broadcast-stream") "," (CODE1 "stream") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 (CODE1 "broadcast") "ストリームは出力ストリームであり、"
     "ゼロか複数の出力ストリームの集合を関連付けたものです。" (CODE1 "broadcast") "ストリームにはどのような出力も送ることでき、"
     "関連付けられたそれぞれの出力ストリームに対する出力として転送されます" "（もし" (CODE1 "broadcast")
     "ストリームが何のストリームも持っていなかったときは、" "全ての" (CODE1 "broadcast") "ストリームへの出力は切り捨てられます）。" EOL2
     (CODE1 "broadcast") "ストリームで実行できる処理の集合は、" "関連付けられた出力ストリームの共通部分です。" EOL2
     "いくつかの出力処理（例えば" (CODE1 "fresh-line") "）は、" "その処理時のストリームの状態による値を返却します。"
     "各ストリームの要素が違った返却値であるとき、" "次のように特定した値を返却するように定義する必要があります。" EOL2 "- "
     (CODE1 "stream-element-type") "は、最後の要素のストリームの値を返却し、" "  もしストリームの要素が無いときは"
     (CODE1 "t") "を返却します。" EOL2 "- " (CODE1 "fresh-line") "は、最後の要素のストリームの値を返却し、"
     "  もしストリームの要素が無いときは" (CODE1 "nil") "を返却します。" EOL2 "- " (CODE1 "file-length") ", "
     (CODE1 "file-position") "," "  " (CODE1 "file-string-length") ", "
     (CODE1 "stream-external-format") "は" "  最後の要素のストリームの値を返却します。" "  もしストリームの要素が無いときは、"
     "  " (CODE1 "file-length") "と" (CODE1 "file-position") "は" (CODE1 "0") "を返却し、" "  "
     (CODE1 "file-string-length") "は" (CODE1 "1") "を返却、" "  "
     (CODE1 "stream-external-format") "は" (CODE1 ":default") "を返却します。" EOL2 "- "
     (CODE1 "streamp") "と" (CODE1 "output-stream-p") "は、" "  " (CODE1 "broadcast")
     "ストリームに対しては常に" (STRONG "true") "を返却します。" EOL2 "- " (CODE1 "open-stream-p") "は"
     (CODE1 "broadcast") "ストリームが開いているかどうかをテストします。" "  保有しているストリーム要素に対して"
     "  開いているかどうかをテストするわけではありません。" EOL2 "- " (CODE1 "input-stream-p") "と"
     (CODE1 "interactive-stream-p") "は実装定義ですが、" "  generalized-booleanを返却します。" EOL2
     "- 入力処理である" (CODE1 "clear-input") ", " (CODE1 "peek-char") ", " (CODE1 "read-byte")
     "," "  " (CODE1 "read-char-no-hang") ", " (CODE1 "read-char") "," "  "
     (CODE1 "read-line") ", " (CODE1 "unread-char") "は、" "  もしこれらの処理が実行されたときの結果は未定義です。"
     "  しかし実装は、実装依存の拡張による" "  振る舞いを定義することが許されています。" EOL2 "上記かまたは本文書の他の箇所で"
     "戻り値が明確に指定されていない出力操作については、" "その操作による返却値は、" "そのストリームの要素の最後のものに対して操作を実行した"
     "結果の返却値であると定義されます。" "それ以前のストリームに対して行った操作の全ての結果の値は破棄されます。" "もしストリームの要素が存在しないときは、"
     "返却値は実装依存です。")
    (CHAPTER ("## 参考") 2 (CODE1 "broadcast-stream-streams") ","
     (CODE1 "make-broadcast-stream"))))
(setf (gethash '("BROADCAST-STREAM" . "SYSTEM-CLASS") *table*) (gethash "BROADCAST-STREAM" *table*))
(setf (gethash "BROADCAST-STREAM-STREAMS" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BROADCAST-STREAM-STREAMS"))
    (CHAPTER ("## 構文") 2 (CODE1 "broadcast-stream-streams") " "
     (STRONG "broadcast-stream") " => " (STRONG "streams"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "broadcast-stream") " - " (CODE1 "broadcast")
     "ストリーム" EOL1 (STRONG "streams") " - ストリームのリスト")
    (CHAPTER ("## 定義") 2 (STRONG "broadcast-stream") "がブロードキャストする全てのストリームの成分である"
     "出力ストリームのリストを返却します。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("BROADCAST-STREAM-STREAMS" . "FUNCTION") *table*) (gethash "BROADCAST-STREAM-STREAMS" *table*))
(setf (gethash "BUILT-IN-CLASS" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "BUILT-IN-CLASS"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "built-in-class") "," (CODE1 "class") ","
     (CODE1 "standard-object") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "組み込みクラス" (CODE1 "built-in-class") "は、"
     "機能に制限があるか、あるいは特別な表現を持った" "インスタンスを表すのクラスです。" (CODE1 "defclass")
     "によって組み込みクラスのサブクラスを定義しようとしたときは、" "型" (CODE1 "error") "のエラーが発生します。"
     (CODE1 "make-instance") "を呼び出して" "組み込みクラスのインスタンスを作成しようとしたときは、" "型" (CODE1 "error")
     "のエラーが発生します。" "組み込みクラスのインスタンスに" (CODE1 "slot-value") "を呼び出したときは、" "型"
     (CODE1 "error") "のエラーが発生します。" "組み込みクラスを再定義するか、" "組み込みクラスのインスタンスのクラスを"
     (CODE1 "change-class") "によって変更しようとしたときは、" "型" (CODE1 "error") "のエラーが発生します。"
     "しかし、組み込みクラスはメソッドの特定パラメーターに使用できます。")))
(setf (gethash '("BUILT-IN-CLASS" . "SYSTEM-CLASS") *table*) (gethash "BUILT-IN-CLASS" *table*))
(setf (gethash "BUTLAST" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BUTLAST") ", " (CODE1 "NBUTLAST"))
    (CHAPTER ("## 構文") 2 (CODE1 "butlast") " " (STRONG "list") " &optional " (STRONG "n")
     " => " (STRONG "result-list") EOL1 (CODE1 "nbutlast") " " (STRONG "list")
     " &optional " (STRONG "n") " => " (STRONG "result-list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト。ドットリストは受け付けますが、循環リストは受け付けません。" EOL1
     (STRONG "n") " - 非負の整数" EOL1 (STRONG "result-list") " - リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "butlast") "は、最後の" (STRONG "n") "個のコンスを無視した"
     (STRONG "list") "のコピーを返却します。" (STRONG "n") "が省略されたときの値は" (CODE1 "1") "です。" "もし"
     (STRONG "list") "内に" (STRONG "n") "個もコンスがなかったときは、" (CODE1 "nil") "が返却され、"
     (CODE1 "nbutlast") "のときは" (STRONG "list") "は修正されません。" EOL2 (CODE1 "nbutlast") "は、"
     (CODE1 "butlast") "と似てますが、" (CODE1 "nbutlast") "は" (STRONG "list") "を修正するかもしれません。"
     "それは、" (STRONG "list") "の終わりから" (STRONG "n") "+1個のコンスの" (CODE1 "cdr") "を"
     (CODE1 "nil") "に修正します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst '(1 2 3 4 5 6 7 8 9)) =>  (1 2 3 4 5 6 7 8 9)"
      "(butlast lst) =>  (1 2 3 4 5 6 7 8)" "(butlast lst 5) =>  (1 2 3 4)"
      "(butlast lst (+ 5 5)) =>  NIL" "lst =>  (1 2 3 4 5 6 7 8 9)"
      "(nbutlast lst 3) =>  (1 2 3 4 5 6)" "lst =>  (1 2 3 4 5 6)"
      "(nbutlast lst 99) =>  NIL" "lst =>  (1 2 3 4 5 6)"
      "(butlast '(a b c d)) =>  (A B C)" "(butlast '((a b) (c d))) =>  ((A B))"
      "(butlast '(a)) =>  NIL" "(butlast nil) =>  NIL"
      "(setq foo (list 'a 'b 'c 'd)) =>  (A B C D)" "(nbutlast foo) =>  (A B C)"
      "foo =>  (A B C)" "(nbutlast (list 'a)) =>  NIL" "(nbutlast '()) =>  NIL"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list") "が通常のリストではないか、" "ドットリストではないとき、" "型"
     (CODE1 "type-error") "のエラーが生じます。" (STRONG "n") "が非負の整数ではないとき、" "型"
     (CODE1 "type-error") "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(butlast list n) == (ldiff list (last list n))"))))
(setf (gethash '("BUTLAST" . "FUNCTION") *table*) (gethash "BUTLAST" *table*))
(setf (gethash "CAAAAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CAAAAR" . "ACCESSOR") *table*) (gethash "CAAAAR" *table*))
(setf (gethash "CAAADR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CAAADR" . "ACCESSOR") *table*) (gethash "CAAADR" *table*))
(setf (gethash "CAAAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CAAAR" . "ACCESSOR") *table*) (gethash "CAAAR" *table*))
(setf (gethash "CAADAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CAADAR" . "ACCESSOR") *table*) (gethash "CAADAR" *table*))
(setf (gethash "CAADDR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CAADDR" . "ACCESSOR") *table*) (gethash "CAADDR" *table*))
(setf (gethash "CAADR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CAADR" . "ACCESSOR") *table*) (gethash "CAADR" *table*))
(setf (gethash "CAAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CAAR" . "ACCESSOR") *table*) (gethash "CAAR" *table*))
(setf (gethash "CADAAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CADAAR" . "ACCESSOR") *table*) (gethash "CADAAR" *table*))
(setf (gethash "CADADR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CADADR" . "ACCESSOR") *table*) (gethash "CADADR" *table*))
(setf (gethash "CADAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CADAR" . "ACCESSOR") *table*) (gethash "CADAR" *table*))
(setf (gethash "CADDAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CADDAR" . "ACCESSOR") *table*) (gethash "CADDAR" *table*))
(setf (gethash "CADDDR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CADDDR" . "ACCESSOR") *table*) (gethash "CADDDR" *table*))
(setf (gethash "CADDR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CADDR" . "ACCESSOR") *table*) (gethash "CADDR" *table*))
(setf (gethash "CADR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CADR" . "ACCESSOR") *table*) (gethash "CADR" *table*))
(setf (gethash "CALL-ARGUMENTS-LIMIT" *table*)
  '((CHAPTER NIL 0 "Constant Variable " (CODE1 "CALL-ARGUMENTS-LIMIT"))
    (CHAPTER ("## 定数値") 2 "整数であり、" (CODE1 "50") "より小さくはなく、" "少なくとも"
     (CODE1 "lambda-parameters-limit") "の値よりも大きい値であり、" "正確な値は実装依存です。")
    (CHAPTER ("## 定義") 2 "関数に渡すことができる引数の排他的上限数。") (CHAPTER ("## 例文") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "lambda-parameters-limit") ","
     (CODE1 "multiple-values-limit"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("CALL-ARGUMENTS-LIMIT" . "CONSTANT-VARIABLE") *table*) (gethash "CALL-ARGUMENTS-LIMIT" *table*))
(setf (gethash "CALL-METHOD" *table*)
  '((CHAPTER NIL 0 "Local Macro " (CODE1 "CALL-METHOD") ", " (CODE1 "MAKE-METHOD"))
    (CHAPTER ("## 構文") 2 (CODE1 "call-method") " " (STRONG "method") " &optional "
     (STRONG "next-method-list") " => " (STRONG "result\\*") EOL1 (CODE1 "make-method")
     " " (STRONG "form") " => " (STRONG "method-object"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "method") " - メソッドオブジェクトか、リスト（下記参照）。評価はされません。" EOL1
     (STRONG "method-object") " - メソッドオブジェクト" EOL1 (STRONG "next-method-list")
     " - メソッドオブジェクトのリスト。評価はされません。" EOL1 (STRONG "results") " - メソッドの実行による返却値")
    (CHAPTER ("## 定義") 2 "マクロ" (CODE1 "call-method") "は、method-combination内で使用されます。"
     "メソッドがどのように呼ばれるかという詳細を" "実装依存で隠蔽することができます。" "マクロ" (CODE1 "call-method")
     "はレキシカルスコープを持っており、" "有効なメソッドフォーム内でのみ使用することができます。" EOL2 "グローバル環境下で、"
     (CODE1 "call-method") "が" (CODE1 "fbound") "かどうかは実装依存です。" "しかし、再定義と"
     (CODE1 "call-method") "のシャドウについての制限は、" (CODE1 "COMMON-LISP") "パッケージにある、"
     "グローバル環境下において" (CODE1 "fbound") "であるシンボルと同じです。" (CODE1 "call-method")
     "を有効なメソッド定義フォームの外で" "使おうとしたときの結果は未定義です。" EOL2 "マクロ" (CODE1 "call-method")
     "は、指定されたメソッド実行し、" "その際に引数と" (CODE1 "call-next-method") "、" (CODE1 "next-method-p")
     "の定義を与えます。" "もし" (CODE1 "call-method") "の実行が文脈的に" (CODE1 "make-method") "の内側であったとき、"
     "引数はメソッドに指定されたものになります。" "そうでなければ、引数はジェネリック関数に指定されたものです。" (CODE1 "call-next-method")
     "、" (CODE1 "next-method-p") "の定義は、" "指定された" (STRONG "next-method-list") "に依存します。"
     EOL2 "もし" (STRONG "method") "がリストの場合、" "リストの最初の要素はシンボル" (CODE1 "make-method") "、"
     "2番目の要素はフォームでなければなりません。" "このようなリストは、与えられたフォームが" "メソッド関数のボディ部であるようなメソッドオブジェクトを意味します。"
     EOL2 (STRONG "next-method-list") "は、メソッドオブジェクトか、" "あるいは最初の要素はシンボル"
     (CODE1 "make-method") "であり" "2番目の要素がフォームであるようなリストを含むことができます。" EOL2
     (CODE1 "make-method") "が使えるのは、この2か所だけです。" (CODE1 "make-method") "を使用したフォームは、"
     (CODE1 "null") "のレキシカルな環境から" "加えてローカルマクロ" (CODE1 "call-method") "の定義と、"
     (CODE1 "COMMON-LISP-USER") "パッケージからアクセスできないシンボル名の束縛で" "拡張された環境下で評価されます。" EOL2
     "メソッドで使用できる" (CODE1 "call-next-method") "関数は、" (STRONG "next-method-list")
     "の最初のメソッドを呼び出します。" "そのメソッドで使用できる" (CODE1 "call-next-method") "関数は、" "次に"
     (STRONG "next-method-list") "の2番目のメソッドを呼び出し、" "次のメソッドのリストを使い果たすまでこれを繰り返します。" EOL2
     (STRONG "next-method-list") "が与えられないときは、" "メソッドで使用できる" (CODE1 "call-next-method")
     "関数は" "型" (CODE1 "control-error") "のエラーを通知し、" "メソッドで使用できる" (CODE1 "next-method-p")
     "関数は" (CODE1 "nil") "を返します。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "call-next-method") ","
     (CODE1 "define-method-combination") "," (CODE1 "next-method-p"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("CALL-METHOD" . "LOCAL-MACRO") *table*) (gethash "CALL-METHOD" *table*))
(setf (gethash "CALL-NEXT-METHOD" *table*)
  '((CHAPTER NIL 0 "Local Function " (CODE1 "CALL-NEXT-METHOD"))
    (CHAPTER ("## 構文") 2 (CODE1 "call-next-method") " &rest " (STRONG "args") " => "
     (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "args") " - オブジェクト" EOL1 (STRONG "result")
     " - 呼び出したメソッドの返却値")
    (CHAPTER ("## 定義") 2 "関数" (CODE1 "call-next-method") "は、" "メソッド定義フォームで定義された"
     "ボディフォーム内（ただしラムダリストは除く）で、" "次のメソッドを呼び出すために使用することができます。" EOL2 "もし次のメソッドがないときは、"
     "ジェネリック関数" (CODE1 "no-next-method") "が呼ばれます。" EOL2 "使用するmethod-combinationのタイプによって、"
     (CODE1 "call-next-method") "を実行できるメソッドが決まります。" (CODE1 "standard")
     " method-combinationタイプは、" "プライマリメソッドと" (CODE1 "around") "メソッドの中で"
     (CODE1 "call-next-method") "の使用が許されます。" (CODE1 "define-method-combination")
     "の短縮形によって定義された" "method-combinationを使用したジェネリック関数の場合は、" (CODE1 "call-next-method")
     "は" (CODE1 "around") "メソッドでのみ使うことができます。" EOL2 (CODE1 "call-next-method")
     "が引数なしで呼ばれたとき、" "現在のメソッドのもともとの引数が次のメソッドの渡されます。" "引数のデフォルト値、" (CODE1 "setq") "の使用、"
     "メソッドのパラメーターと同名の変数への再束縛の、" "いずれの動作も" (CODE1 "call-next-method") "が呼び出す"
     "メソッドへ渡す値に影響しません。" EOL2 (CODE1 "call-next-method") "が引数とともに呼び出されたとき、"
     "次のメソッドはそれらの引数とともに呼ばれます。" EOL2 (CODE1 "call-next-method") "が引数とともに呼び出され、"
     "しかしオプション引数が省略されていた場合は、" "次のメソッドは、それらのデフォルトの引数で呼ばれます。" EOL2 "関数"
     (CODE1 "call-next-method") "は、" "次のメソッドから返却されたどのような値でも返却します。" EOL2 "関数"
     (CODE1 "call-next-method") "は、" "レキシカルスコープと不定範囲を持っており、" "メソッド定義フォームによって定義された"
     "メソッドのボディ部の中でのみ使うことができます。" EOL2 "グローバル環境下で、" (CODE1 "call-next-method") "が"
     (CODE1 "fbound") "かどうかは実装依存です。" "しかし、再定義と" (CODE1 "call-next-method")
     "のシャドウについての制限は、" (CODE1 "COMMON-LISP") "パッケージにある、" "グローバル環境下において" (CODE1 "fbound")
     "であるシンボルと同じです。" (CODE1 "call-next-method") "をメソッド定義フォームの外で" "使おうとしたときの結果は未定義です。")
    (CHAPTER ("## 例文") 2 "なし。")
    (CHAPTER ("## 影響") 2 (CODE1 "defmethod") "," (CODE1 "call-method") ","
     (CODE1 "define-method-combination"))
    (CHAPTER ("## 例外") 2 (CODE1 "call-next-method") "に引数が与えられたとき、" "次の規則を満たさないときは型"
     (CODE1 "error") "のエラーが生じます。" (CODE1 "call-next-method") "によって引数が変更されたとき、"
     "その変更された引数の集合による適用可能なメソッドの集合の順番が、" "元のジェネリック関数の引数による適用可能なメソッドの集合の順番と"
     "同一でなければなりません。" "最適化によるエラーチェックは可能ですが、" "しかし" (CODE1 "call-next-method")
     "の意味を変えてはいけません。")
    (CHAPTER ("## 参考") 2 (CODE1 "define-method-combination") "," (CODE1 "defmethod") ","
     (CODE1 "next-method-p") "," (CODE1 "no-next-method") "," (CODE1 "call-method") ","
     "7.6.6. メソッドの選択とコンビネーション," "7.6.6.2. Standard Method-Combination,"
     "7.6.6.4. 組み込みのMethod-Combination,")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("CALL-NEXT-METHOD" . "LOCAL-FUNCTION") *table*) (gethash "CALL-NEXT-METHOD" *table*))
(setf (gethash "CAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CAR" . "ACCESSOR") *table*) (gethash "CAR" *table*))
(setf (gethash "CASE" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "CASE") ", " (CODE1 "CCASE") ", " (CODE1 "ECASE"))
    (CHAPTER ("## 構文") 2 (CODE1 "case") " " (STRONG "keyform") " " (CODE1 "{")
     (STRONG "normal-clause") (CODE1 "}") "\\* [" (STRONG "otherwise-clause") "] => "
     (STRONG "result\\*") EOL1 (CODE1 "ccase") " " (STRONG "keyplace") " " (CODE1 "{")
     (STRONG "normal-clause") (CODE1 "}") "\\* => " (STRONG "result\\*") EOL1
     (CODE1 "ecase") " " (STRONG "keyform") " " (CODE1 "{") (STRONG "normal-clause")
     (CODE1 "}") "\\* => " (STRONG "result\\*")
     (CODE3 "```" "```" "normal-clause ::= (keys form*) "
      "otherwise-clause ::= ({otherwise | t} form*) "
      "clause ::= normal-clause | otherwise-clause "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "keyform") " - フォーム。評価され" (STRONG "test-key")
     "を返却します。" EOL1 (STRONG "keyplace") " - フォーム。評価されて最初に" (STRONG "test-key") "を返却します。"
     EOL1 "もしキーにマッチしなかったときは、可能であれば後で" (CODE1 "place") "としても使われます。" EOL1
     (STRONG "test-key") " - " (STRONG "keyform") "か" (STRONG "keyplace")
     "が評価されることによって返却されるオブジェクト。" EOL1 (STRONG "keys") " - オブジェクトのリストの指定子。" (CODE1 "case")
     "の場合、シンボル" (CODE1 "t") "と" (CODE1 "otherwise") "は" "キー指定子として使用することができません。"
     "キーとしてそれらのシンボルを使用したいときは、" "それぞれ" (CODE1 "(t)") "、" (CODE1 "(otherwise)")
     "をかわりに使わなければいけません。" EOL1 (STRONG "form") " - 暗黙のprogn" EOL1 (STRONG "result")
     " - マッチした" (STRONG "clause") "の" (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 "これらのマクロは、" (STRONG "test-key") "とのマッチによって選択された"
     (STRONG "clause") "内の" (STRONG "form") "のボディを条件付きで実行します。" EOL2 (STRONG "keyform")
     "と" (STRONG "keyplace") "が評価されて、" (STRONG "test-key") "が生成されます。" EOL2 "そのあと各"
     (STRONG "normal-clause") "が順番に考慮されます。" "もし" (STRONG "test-key") "が"
     (STRONG "clause") "のどれかのキーと同じであれば、" "その" (STRONG "clause") "内の" (STRONG "form")
     "が暗黙のprognとして評価され、" (CODE1 "case") "、" (CODE1 "ccase") "、" (CODE1 "ecase")
     "フォームの返却値として" "その多値が返却されます。" EOL2 "これらのマクロは、もし" (STRONG "normal-clause")
     "がマッチしなかったときにだけ、" "動作が違っています。" "違いを下記に示します。" EOL2 "- " (CODE1 "case") "  - もしマッチする"
     (STRONG "normal-clause") "が存在せず" (STRONG "otherwise-clause") "があるときは、" "    自動的に"
     (STRONG "otherwise-clause") "がマッチします。" "    その" (STRONG "clause") "にある"
     (STRONG "form") "は暗黙のprognとして評価され、" "    その" (STRONG "clause") "内の" (STRONG "form")
     "は暗黙のprognとして評価され、" "    " (CODE1 "case") "フォームの返却値としてその多値が返却されます。" "    <br><br>"
     "    もし" (STRONG "otherwise-clause") "がないときは、" "    " (CODE1 "case") "は"
     (CODE1 "nil") "を返却します。" "    <br><br>" EOL2 "- " (CODE1 "ccase") "  - もしマッチする"
     (STRONG "normal-clause") "が存在しないときは、" "    型" (CODE1 "type-error")
     "の修正可能なエラーが発生します。" "    問題の" (CODE1 "datum") "は" (STRONG "test-key") "であり、" "    "
     (CODE1 "expected type") "は" (CODE1 "(member key1 key2 ...)") "と同等の型です。" "    "
     (CODE1 "store-value") " " (CODE1 "restart") "をエラーの修正に使うことができます。" "    <br><br>"
     "    もし" (CODE1 "store-value") " " (CODE1 "restart") "が起動されたら、" "    その引数は新しい"
     (STRONG "test-key") "であり、" "    " (STRONG "keyplace") "への保存は"
     (CODE1 "(setf keyplace test-key)") "のように行われます。" "    それから" (CODE1 "ccase")
     "は最初から始められ、" "    各" (STRONG "clause") "が新しく評価されます。" "    <br><br>"
     "    いずれのケースも成立しない場合、" "    " (STRONG "keyplace") "のサブフォームは再度評価されるかもしれません。"
     "    <br><br>" EOL2 "- " (CODE1 "ecase") "  - もしマッチする" (STRONG "normal-clause")
     "が存在しないときは、" "    型" (CODE1 "type-error") "の修正不可能なエラーが発生します。" "    問題の"
     (CODE1 "datum") "は" (STRONG "test-key") "であり、" "    " (CODE1 "expected type") "は"
     (CODE1 "(member key1 key2 ...)") "と同等の型です。" "    <br><br>" "    " (CODE1 "ccase")
     "とは対照的に" (CODE1 "ecase") "の使用者は、" "    もし" (STRONG "normal-clause") "がマッチしなかったら"
     "    " (CODE1 "ecase") "は戻ってこないという事実に頼っています。" "    <br><br>")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(dolist (k '(1 2 3 :four #\\v () t 'other))"
      "   (format t \"~S \"" "      (case k ((1 2) 'clause1)"
      "              (3 'clause2)" "              (nil 'no-keys-so-never-seen)"
      "              ((nil) 'nilslot)" "              ((:four #\\v) 'clause4)"
      "              ((t) 'tslot)" "              (otherwise 'others)))) "
      ">>  CLAUSE1 CLAUSE1 CLAUSE2 CLAUSE4 CLAUSE4 NILSLOT TSLOT OTHERS " "=>  NIL"
      "(defun add-em (x) (apply #'+ (mapcar #'decode x)))" "=>  ADD-EM"
      "(defun decode (x)" "  (ccase x" "    ((i uno) 1)" "    ((ii dos) 2)"
      "    ((iii tres) 3)" "    ((iv cuatro) 4)))" "=>  DECODE"
      "(add-em '(uno iii)) =>  4" "(add-em '(uno iiii))"
      ">>  Error: The value of X, IIII, is not I, UNO, II, DOS, III,"
      ">>         TRES, IV, or CUATRO." ">>   1: Supply a value to use instead."
      ">>   2: Return to Lisp Toplevel." ">>  Debug> :CONTINUE 1"
      ">>  Value to evaluate and use for X: 'IV" "=>  5"))
    (CHAPTER ("## 副作用") 2 "デバッガーに入るかもしれません。" "もし" (CODE1 "store-value") " "
     (CODE1 "restart") "が実行されたとき、" (STRONG "keyplace") "の値は変更されるかもしれません。")
    (CHAPTER ("## 影響") 2 (CODE1 "ccase") "と" (CODE1 "ecase") "がエラーを通知したときは、" "既存の"
     (CODE1 "handler") "と" (CODE1 "*debug-io*") "に影響を及ぼす可能性があります。")
    (CHAPTER ("## 例外") 2 (STRONG "normal-clause") "にマッチしなかったときは、" (CODE1 "ccase") "と"
     (CODE1 "ecase") "は" "型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "cond") "," (CODE1 "typecase") "," (CODE1 "setf") ","
     "5.1. 一般化された参照")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(case test-key" "  {((key*) form*)}*)" "== "
      "(let ((#1=#:g0001 test-key))" "  (cond {((member #1# '(key*)) form*)}*))")
     EOL2 (CODE1 "ecase") "と" (CODE1 "ccase") "によって使われる特定のエラーメッセージは、" "実装によって変わります。"
     "そんな中で、エラーメッセージの特定の単語の制御が必要なときは、" (CODE1 "case") "の" (STRONG "otherwise-clause") "で"
     "明示的に適切なエラーメッセージを発生させるのが良いでしょう。")))
(setf (gethash '("CASE" . "MACRO") *table*) (gethash "CASE" *table*))
(setf (gethash "CATCH" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "CATCH"))
    (CHAPTER ("## 構文") 2 (CODE1 "catch") " " (STRONG "tag") " " (STRONG "form\\*") " => "
     (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "tag") " - " (CODE1 "catch") "のタグ、評価されます。" EOL1
     (STRONG "form") " - 暗黙のprogn" EOL1 (STRONG "result") " - もし" (STRONG "form")
     "が普通に終了したときは" (STRONG "form") "の返却値が、" "もし" (STRONG "tag") "への" (CODE1 "throw")
     "が発生した時は" (CODE1 "throw") "の値が返却されます。")
    (CHAPTER ("## 定義") 2 (CODE1 "catch") "は、" (CODE1 "throw") "による非局所的な制御の転送先として使われます。"
     (STRONG "tag") "は" (CODE1 "throw") "が制御の転送するときに、" (CODE1 "catch") "を探すときに使われます。"
     (CODE1 "(catch 'foo form)") "は" (CODE1 "(throw 'foo form)") "に補足されますが、"
     (CODE1 "(throw 'bar form)") "では捕捉されません。" EOL2 (CODE1 "catch") "はの実行の順番は次のとおりです。"
     EOL2 "1. " (STRONG "tag") "が評価されます。" "それは" (CODE1 "catch") "の名前として保存されます。" EOL2
     "2. それから" (STRONG "form") "が暗黙のprognとして評価されます。" "もし" (CODE1 "throw") "が発生しなかったら、最後の"
     (STRONG "form") "の値が返却されます。" EOL2 "3. もし" (CODE1 "throw") "が" (STRONG "form")
     "のどれかの実行中に発生したとき、" (CODE1 "throw") "の引数のタグと" (CODE1 "eq") "で一致する、" "もっとも近くで確立した"
     (STRONG "tag") "の" (CODE1 "catch") "に制御が転送されます。" "それ以上の" (STRONG "form")
     "の評価は生じません。" EOL2 "4. " (CODE1 "catch") "によって確立されたタグは、" "結果が返される直前に解除されます。" EOL2
     "もし" (STRONG "form") "のどれかの実行中に、" (CODE1 "catch") "タグと" (CODE1 "eq") "で一致するタグを持つ"
     (CODE1 "throw") "が実行されたとき、" (CODE1 "throw") "で指定された値がそのタグを持つ動的にもっとも近くで確立された"
     (CODE1 "catch") "フォームの結果として返されます。" EOL2 (CODE1 "catch") "と" (CODE1 "throw") "の仕組みは、"
     (CODE1 "throw") "が" (CODE1 "catch") "のレキシカルスコープの中にいなくても動作します。" (CODE1 "throw")
     "は、対応する" (STRONG "tag") "を持つ" (CODE1 "catch") "のボディ部の評価の"
     "動的エクステント内で実行されなければなりません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(catch 'dummy-tag 1 2 (throw 'dummy-tag 3) 4) =>  3"
      "(catch 'dummy-tag 1 2 3 4) =>  4"
      "(defun throw-back (tag) (throw tag t)) =>  THROW-BACK"
      "(catch 'dummy-tag (throw-back 'dummy-tag) 2) =>  T" NIL
      ";; このサンプルは対応するBLOCKのサンプルの対比です" "(catch 'c" "  (flet ((c1 () (throw 'c 1)))"
      "    (catch 'c (c1) (print 'unreachable))" "    2)) =>  2"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "適切な" (CODE1 "catch") "の" (STRONG "tag") "がないときに"
     (CODE1 "throw") "が実行されたときは、" "型" (CODE1 "control-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "throw") "," "3.1. 評価")
    (CHAPTER ("## 備考") 2 "慣例として" (STRONG "tag") "にはシンボルが使われますが、どんなオブジェクトで許されます。"
     "しかし比較には" (CODE1 "eq") "が用いられますので、数は使うべきではありません。" EOL2 (CODE1 "catch") "と"
     (CODE1 "block") "の違いは、" (CODE1 "catch") "のタグは動的スコープであるのに対して、" (CODE1 "block")
     "の名前はレキシカルスコープです。")))
(setf (gethash '("CATCH" . "SPECIAL-OPERATOR") *table*) (gethash "CATCH" *table*))
(setf (gethash "CCASE" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "CASE") ", " (CODE1 "CCASE") ", " (CODE1 "ECASE"))
    (CHAPTER ("## 構文") 2 (CODE1 "case") " " (STRONG "keyform") " " (CODE1 "{")
     (STRONG "normal-clause") (CODE1 "}") "\\* [" (STRONG "otherwise-clause") "] => "
     (STRONG "result\\*") EOL1 (CODE1 "ccase") " " (STRONG "keyplace") " " (CODE1 "{")
     (STRONG "normal-clause") (CODE1 "}") "\\* => " (STRONG "result\\*") EOL1
     (CODE1 "ecase") " " (STRONG "keyform") " " (CODE1 "{") (STRONG "normal-clause")
     (CODE1 "}") "\\* => " (STRONG "result\\*")
     (CODE3 "```" "```" "normal-clause ::= (keys form*) "
      "otherwise-clause ::= ({otherwise | t} form*) "
      "clause ::= normal-clause | otherwise-clause "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "keyform") " - フォーム。評価され" (STRONG "test-key")
     "を返却します。" EOL1 (STRONG "keyplace") " - フォーム。評価されて最初に" (STRONG "test-key") "を返却します。"
     EOL1 "もしキーにマッチしなかったときは、可能であれば後で" (CODE1 "place") "としても使われます。" EOL1
     (STRONG "test-key") " - " (STRONG "keyform") "か" (STRONG "keyplace")
     "が評価されることによって返却されるオブジェクト。" EOL1 (STRONG "keys") " - オブジェクトのリストの指定子。" (CODE1 "case")
     "の場合、シンボル" (CODE1 "t") "と" (CODE1 "otherwise") "は" "キー指定子として使用することができません。"
     "キーとしてそれらのシンボルを使用したいときは、" "それぞれ" (CODE1 "(t)") "、" (CODE1 "(otherwise)")
     "をかわりに使わなければいけません。" EOL1 (STRONG "form") " - 暗黙のprogn" EOL1 (STRONG "result")
     " - マッチした" (STRONG "clause") "の" (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 "これらのマクロは、" (STRONG "test-key") "とのマッチによって選択された"
     (STRONG "clause") "内の" (STRONG "form") "のボディを条件付きで実行します。" EOL2 (STRONG "keyform")
     "と" (STRONG "keyplace") "が評価されて、" (STRONG "test-key") "が生成されます。" EOL2 "そのあと各"
     (STRONG "normal-clause") "が順番に考慮されます。" "もし" (STRONG "test-key") "が"
     (STRONG "clause") "のどれかのキーと同じであれば、" "その" (STRONG "clause") "内の" (STRONG "form")
     "が暗黙のprognとして評価され、" (CODE1 "case") "、" (CODE1 "ccase") "、" (CODE1 "ecase")
     "フォームの返却値として" "その多値が返却されます。" EOL2 "これらのマクロは、もし" (STRONG "normal-clause")
     "がマッチしなかったときにだけ、" "動作が違っています。" "違いを下記に示します。" EOL2 "- " (CODE1 "case") "  - もしマッチする"
     (STRONG "normal-clause") "が存在せず" (STRONG "otherwise-clause") "があるときは、" "    自動的に"
     (STRONG "otherwise-clause") "がマッチします。" "    その" (STRONG "clause") "にある"
     (STRONG "form") "は暗黙のprognとして評価され、" "    その" (STRONG "clause") "内の" (STRONG "form")
     "は暗黙のprognとして評価され、" "    " (CODE1 "case") "フォームの返却値としてその多値が返却されます。" "    <br><br>"
     "    もし" (STRONG "otherwise-clause") "がないときは、" "    " (CODE1 "case") "は"
     (CODE1 "nil") "を返却します。" "    <br><br>" EOL2 "- " (CODE1 "ccase") "  - もしマッチする"
     (STRONG "normal-clause") "が存在しないときは、" "    型" (CODE1 "type-error")
     "の修正可能なエラーが発生します。" "    問題の" (CODE1 "datum") "は" (STRONG "test-key") "であり、" "    "
     (CODE1 "expected type") "は" (CODE1 "(member key1 key2 ...)") "と同等の型です。" "    "
     (CODE1 "store-value") " " (CODE1 "restart") "をエラーの修正に使うことができます。" "    <br><br>"
     "    もし" (CODE1 "store-value") " " (CODE1 "restart") "が起動されたら、" "    その引数は新しい"
     (STRONG "test-key") "であり、" "    " (STRONG "keyplace") "への保存は"
     (CODE1 "(setf keyplace test-key)") "のように行われます。" "    それから" (CODE1 "ccase")
     "は最初から始められ、" "    各" (STRONG "clause") "が新しく評価されます。" "    <br><br>"
     "    いずれのケースも成立しない場合、" "    " (STRONG "keyplace") "のサブフォームは再度評価されるかもしれません。"
     "    <br><br>" EOL2 "- " (CODE1 "ecase") "  - もしマッチする" (STRONG "normal-clause")
     "が存在しないときは、" "    型" (CODE1 "type-error") "の修正不可能なエラーが発生します。" "    問題の"
     (CODE1 "datum") "は" (STRONG "test-key") "であり、" "    " (CODE1 "expected type") "は"
     (CODE1 "(member key1 key2 ...)") "と同等の型です。" "    <br><br>" "    " (CODE1 "ccase")
     "とは対照的に" (CODE1 "ecase") "の使用者は、" "    もし" (STRONG "normal-clause") "がマッチしなかったら"
     "    " (CODE1 "ecase") "は戻ってこないという事実に頼っています。" "    <br><br>")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(dolist (k '(1 2 3 :four #\\v () t 'other))"
      "   (format t \"~S \"" "      (case k ((1 2) 'clause1)"
      "              (3 'clause2)" "              (nil 'no-keys-so-never-seen)"
      "              ((nil) 'nilslot)" "              ((:four #\\v) 'clause4)"
      "              ((t) 'tslot)" "              (otherwise 'others)))) "
      ">>  CLAUSE1 CLAUSE1 CLAUSE2 CLAUSE4 CLAUSE4 NILSLOT TSLOT OTHERS " "=>  NIL"
      "(defun add-em (x) (apply #'+ (mapcar #'decode x)))" "=>  ADD-EM"
      "(defun decode (x)" "  (ccase x" "    ((i uno) 1)" "    ((ii dos) 2)"
      "    ((iii tres) 3)" "    ((iv cuatro) 4)))" "=>  DECODE"
      "(add-em '(uno iii)) =>  4" "(add-em '(uno iiii))"
      ">>  Error: The value of X, IIII, is not I, UNO, II, DOS, III,"
      ">>         TRES, IV, or CUATRO." ">>   1: Supply a value to use instead."
      ">>   2: Return to Lisp Toplevel." ">>  Debug> :CONTINUE 1"
      ">>  Value to evaluate and use for X: 'IV" "=>  5"))
    (CHAPTER ("## 副作用") 2 "デバッガーに入るかもしれません。" "もし" (CODE1 "store-value") " "
     (CODE1 "restart") "が実行されたとき、" (STRONG "keyplace") "の値は変更されるかもしれません。")
    (CHAPTER ("## 影響") 2 (CODE1 "ccase") "と" (CODE1 "ecase") "がエラーを通知したときは、" "既存の"
     (CODE1 "handler") "と" (CODE1 "*debug-io*") "に影響を及ぼす可能性があります。")
    (CHAPTER ("## 例外") 2 (STRONG "normal-clause") "にマッチしなかったときは、" (CODE1 "ccase") "と"
     (CODE1 "ecase") "は" "型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "cond") "," (CODE1 "typecase") "," (CODE1 "setf") ","
     "5.1. 一般化された参照")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(case test-key" "  {((key*) form*)}*)" "== "
      "(let ((#1=#:g0001 test-key))" "  (cond {((member #1# '(key*)) form*)}*))")
     EOL2 (CODE1 "ecase") "と" (CODE1 "ccase") "によって使われる特定のエラーメッセージは、" "実装によって変わります。"
     "そんな中で、エラーメッセージの特定の単語の制御が必要なときは、" (CODE1 "case") "の" (STRONG "otherwise-clause") "で"
     "明示的に適切なエラーメッセージを発生させるのが良いでしょう。")))
(setf (gethash '("CCASE" . "MACRO") *table*) (gethash "CCASE" *table*))
(setf (gethash "CDAAAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CDAAAR" . "ACCESSOR") *table*) (gethash "CDAAAR" *table*))
(setf (gethash "CDAADR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CDAADR" . "ACCESSOR") *table*) (gethash "CDAADR" *table*))
(setf (gethash "CDAAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CDAAR" . "ACCESSOR") *table*) (gethash "CDAAR" *table*))
(setf (gethash "CDADAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CDADAR" . "ACCESSOR") *table*) (gethash "CDADAR" *table*))
(setf (gethash "CDADDR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CDADDR" . "ACCESSOR") *table*) (gethash "CDADDR" *table*))
(setf (gethash "CDADR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CDADR" . "ACCESSOR") *table*) (gethash "CDADR" *table*))
(setf (gethash "CDAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CDAR" . "ACCESSOR") *table*) (gethash "CDAR" *table*))
(setf (gethash "CDDAAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CDDAAR" . "ACCESSOR") *table*) (gethash "CDDAAR" *table*))
(setf (gethash "CDDADR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CDDADR" . "ACCESSOR") *table*) (gethash "CDDADR" *table*))
(setf (gethash "CDDAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CDDAR" . "ACCESSOR") *table*) (gethash "CDDAR" *table*))
(setf (gethash "CDDDAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CDDDAR" . "ACCESSOR") *table*) (gethash "CDDDAR" *table*))
(setf (gethash "CDDDDR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CDDDDR" . "ACCESSOR") *table*) (gethash "CDDDDR" *table*))
(setf (gethash "CDDDR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CDDDR" . "ACCESSOR") *table*) (gethash "CDDDR" *table*))
(setf (gethash "CDDR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CDDR" . "ACCESSOR") *table*) (gethash "CDDR" *table*))
(setf (gethash "CDR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CAR") ", " (CODE1 "CDR") "," (CODE1 "CAAR") ", "
     (CODE1 "CADR") ", " (CODE1 "CDAR") ", " (CODE1 "CDDR") "," (CODE1 "CAAAR") ", "
     (CODE1 "CAADR") ", " (CODE1 "CADAR") ", " (CODE1 "CADDR") "," (CODE1 "CDAAR") ", "
     (CODE1 "CDADR") ", " (CODE1 "CDDAR") ", " (CODE1 "CDDDR") "," (CODE1 "CAAAAR") ", "
     (CODE1 "CAAADR") ", " (CODE1 "CAADAR") ", " (CODE1 "CAADDR") "," (CODE1 "CADAAR")
     ", " (CODE1 "CADADR") ", " (CODE1 "CADDAR") ", " (CODE1 "CADDDR") ","
     (CODE1 "CDAAAR") ", " (CODE1 "CDAADR") ", " (CODE1 "CDADAR") ", " (CODE1 "CDADDR")
     "," (CODE1 "CDDAAR") ", " (CODE1 "CDDADR") ", " (CODE1 "CDDDAR") ", "
     (CODE1 "CDDDDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "car") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaar")
     " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdadr") " " (STRONG "x")
     " => " (STRONG "object") EOL1 (CODE1 "cddar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "caaaar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caaadr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caadar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "caaddr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cadaar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cadadr") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "caddar") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cadddr") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cdaaar") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdaadr") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cdadar") " " (STRONG "x") " => " (STRONG "object") EOL1
     (CODE1 "cdaddr") " " (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddaar") " "
     (STRONG "x") " => " (STRONG "object") EOL1 (CODE1 "cddadr") " " (STRONG "x") " => "
     (STRONG "object") EOL1 (CODE1 "cdddar") " " (STRONG "x") " => " (STRONG "object")
     EOL1 (CODE1 "cddddr") " " (STRONG "x") " => " (STRONG "object") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "car") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "caaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "caaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cadadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "caddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cadddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cdaadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdadar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cdaddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddaar") " "
     (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "cddadr") " " (STRONG "x") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "cdddar") " " (STRONG "x") ") " (STRONG "new-object") ")"
     EOL1 "(" (CODE1 "setf") " (" (CODE1 "cddddr") " " (STRONG "x") ") "
     (STRONG "new-object") ")")
    (CHAPTER ("## 発音") 2 (CODE1 "cadr") ": ['ka,duhr]" EOL1 (CODE1 "caddr")
     ": ['kaduh,duhr] or ['ka,dduhr]" EOL1 (CODE1 "cdr") ": ['k,duhr]" EOL1
     (CODE1 "cddr") ": ['kduh,duhr] or ['kuh,dduhr]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - リスト" EOL1 (STRONG "object") " - オブジェクト"
     EOL1 (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "x") "がコンスなら、" (CODE1 "car") "は" (STRONG "cons") "の"
     (CODE1 "car") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "car") "は"
     (CODE1 "nil") "を返します。" EOL2 (STRONG "x") "がコンスなら、" (CODE1 "cdr") "は" (STRONG "cons")
     "の" (CODE1 "cdr") "を返します。" (STRONG "x") "が" (CODE1 "nil") "なら、 " (CODE1 "cdr") "は"
     (CODE1 "nil") "を返します。" EOL2 "最大4つの" (CODE1 "car") "と" (CODE1 "cdr")
     "の組み合わせを行う関数が用意されています。" "これらの名前は、" (CODE1 "C") "に続き、2つか3つか4つの" (CODE1 "A") "か"
     (CODE1 "D") "が現れ、" "最後の" (CODE1 "R") "で構成されます。" "各関数の名前にある" (CODE1 "A") "と"
     (CODE1 "D") "の並びは、" "その関数によって実行される一連の" (CODE1 "car") ", " (CODE1 "cdr") "のオペレーションの"
     "識別を意味しています。" (CODE1 "A") "と" (CODE1 "D") "の順序は、対応するオペレーションの実行順序とは逆に現れます。"
     "次の図は、その関係を正確に定義したものです。"
     (CODE3 "```lisp" "```" "これは、        ここと等価です"
      "-----------------------------------------" "(caar x)        (car (car x))"
      "(cadr x)        (car (cdr x))" "(cdar x)        (cdr (car x))"
      "(cddr x)        (cdr (cdr x))" "(caaar x)       (car (car (car x)))"
      "(caadr x)       (car (car (cdr x)))" "(cadar x)       (car (cdr (car x)))"
      "(caddr x)       (car (cdr (cdr x)))" "(cdaar x)       (cdr (car (car x)))"
      "(cdadr x)       (cdr (car (cdr x)))" "(cddar x)       (cdr (cdr (car x)))"
      "(cdddr x)       (cdr (cdr (cdr x)))" "(caaaar x)      (car (car (car (car x))))"
      "(caaadr x)      (car (car (car (cdr x))))"
      "(caadar x)      (car (car (cdr (car x))))"
      "(caaddr x)      (car (car (cdr (cdr x))))"
      "(cadaar x)      (car (cdr (car (car x))))"
      "(cadadr x)      (car (cdr (car (cdr x))))"
      "(caddar x)      (car (cdr (cdr (car x))))"
      "(cadddr x)      (car (cdr (cdr (cdr x))))"
      "(cdaaar x)      (cdr (car (car (car x))))"
      "(cdaadr x)      (cdr (car (car (cdr x))))"
      "(cdadar x)      (cdr (car (cdr (car x))))"
      "(cdaddr x)      (cdr (car (cdr (cdr x))))"
      "(cddaar x)      (cdr (cdr (car (car x))))"
      "(cddadr x)      (cdr (cdr (car (cdr x))))"
      "(cdddar x)      (cdr (cdr (cdr (car x))))"
      "(cddddr x)      (cdr (cdr (cdr (cdr x))))" NIL "Figure 14-6. CARとCDRの対応")
     EOL2 (CODE1 "setf") "は、これらの関数とともに使用することで" (STRONG "x") "の既存の要素を変更することもできますが、"
     (CODE1 "setf") "は新しい要素を作成しません。" "よって、例えば" (CODE1 "setf") "と" (CODE1 "car") "はコンスの"
     (CODE1 "car") "を変更できますが、" "しかし" (CODE1 "setf") "と" (CODE1 "car") "では、" (CODE1 "nil")
     "の" (CODE1 "car") "を変更できません。" "同じように、" (CODE1 "setf") "の" (CODE1 "caar") "は、"
     (CODE1 "car") "がコンスであるコンスに対しては、" "コンスの" (CODE1 "car") "の" (CODE1 "car") "を変更できますが、"
     "しかし" (CODE1 "setf") "の" (CODE1 "caar") "では、" (CODE1 "nil") "や、" (CODE1 "car") "が"
     (CODE1 "nil") "のコンスは、" "どちらも変更できません。" EOL2 "引数" (STRONG "x")
     "は、ドットリストと循環リストが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (car nil) =>  NIL  " " (cdr '(1 . 2)) =>  2"
      " (cdr '(1 2)) =>  (2)" " (cadr '(1 2)) =>  2 " " (car '(a b c)) =>  A"
      " (cdr '(a b c)) =>  (B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "関数" (CODE1 "car") "と" (CODE1 "cdr") "は、" "引数がリストではないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" "その他の関数（" (CODE1 "caar") ", " (CODE1 "cadr")
     ", ..., " (CODE1 "cddddr") "）は、" "エラーチェックのために、" (CODE1 "car") "と" (CODE1 "cdr")
     "が定義されているように" "適切に呼び出されたかのようにふるまう必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "rplaca") "," (CODE1 "first") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "コンスの" (CODE1 "car") "は" (CODE1 "rplaca") "を使うことによって変更できます。"
     "コンスの" (CODE1 "cdr") "は" (CODE1 "rplacd") "を使うことによって変更できます。"
     (CODE3 "```lisp" "```" "(car x)    ==  (first x)"
      "(cadr x)   ==  (second x) ==  (car (cdr x))"
      "(caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))"
      "(cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))"))))
(setf (gethash '("CDR" . "ACCESSOR") *table*) (gethash "CDR" *table*))
(setf (gethash "CELL-ERROR" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "CELL-ERROR"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "cell-error") "," (CODE1 "error") ","
     (CODE1 "serious-condition") "," (CODE1 "condition") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "cell-error") "は、位置へアクセスする際に生じた" "エラーのコンディションを含みます。"
     "問題のセルの名前は、" (CODE1 "make-condition") "の" "初期化引数" (CODE1 ":name") "によって初期化され、"
     (CODE1 "cell-error-name") "関数によってアクセスできます。")
    (CHAPTER ("## 参考") 2 (CODE1 "cell-error-name"))))
(setf (gethash '("CELL-ERROR" . "CONDITION-TYPE") *table*) (gethash "CELL-ERROR" *table*))
(setf (gethash "CELL-ERROR-NAME" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CELL-ERROR-NAME"))
    (CHAPTER ("## 構文") 2 (CODE1 "cell-error-name") " " (STRONG "condition") " => "
     (STRONG "name"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "condition") " - 型" (CODE1 "cell-error") "のコンディション"
     EOL1 (STRONG "name") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "condition") "によって表現された状況で生じた" "問題のセルの名前が返却されます。" EOL2
     "この結果の意味は指定した" (STRONG "condition") "の型に依存します。" "例えば" (STRONG "condition") "が型"
     (CODE1 "unbound-variable") "のときは、" "この結果はアクセスしようとした" (CODE1 "unbound") "変数の名前であり、"
     (STRONG "condition") "が型" (CODE1 "undefined-function") "であれば、"
     "結果はアクセスしようとした未定義の関数の名前であり、" (STRONG "condition") "が型" (CODE1 "unbound-slot")
     "であれば、" "結果はアクセスしようとしたスロットの名前です。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "cell-error") "," (CODE1 "unbound-slot") ","
     (CODE1 "unbound-variable") "," (CODE1 "undefined-function") ","
     "9.1. コンディションシステムの説明")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("CELL-ERROR-NAME" . "FUNCTION") *table*) (gethash "CELL-ERROR-NAME" *table*))
(setf (gethash "CERROR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CERROR"))
    (CHAPTER ("## 構文") 2 (CODE1 "cerror") " " (STRONG "continue-format-control") " "
     (STRONG "datum") " " (CODE1 "&rest") " " (STRONG "arguments") " => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "continue-format-control") " - format-control" EOL1
     (STRONG "datum") ", " (STRONG "arguments") " - コンディション指定子であり、標準の型は"
     (CODE1 "simple-error") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "cerror") "は、" (STRONG "datum") "によって指定されたコンディションを"
     "効果的に" (CODE1 "error") "で実行します。" EOL2 "どこかの関数で暗黙的に" (CODE1 "error") "が呼ばれたとき、"
     "もしそのコンディションが捕捉されなかったときは、" (CODE1 "(invoke-debugger condition)") "が実行されます。"
     "シグナルが通知され、" "そしてデバッガーに到達したとき、" (CODE1 "continue") " " (CODE1 "restart") "を使うことで"
     "コードの実行を継続することができます" "（例えば" (CODE1 "cerror") "から戻ります）。" EOL2 "もし" (STRONG "datum")
     "がコンディションなら" (STRONG "arguments") "を指定できますが、" "それは"
     (STRONG "continue-format-control") "との組み合わせでのみ使用されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun real-sqrt (n)" "  (when (minusp n)"
      "    (setq n (- n))"
      "    (cerror \"Return sqrt(~D) instead.\" \"Tried to take sqrt(-~D).\" n))"
      "  (sqrt n))" NIL "(real-sqrt 4)" "=>  2.0" NIL "(real-sqrt -9)"
      ">>  Correctable error in REAL-SQRT: Tried to take sqrt(-9)."
      ">>  Restart options:" ">>   1: Return sqrt(9) instead." ">>   2: Top level."
      ">>  Debug> :continue 1" "=>  3.0" NIL "(define-condition not-a-number (error)"
      "  ((argument :reader not-a-number-argument :initarg :argument))"
      "  (:report (lambda (condition stream)"
      "             (format stream \"~S is not a number.\" "
      "                     (not-a-number-argument condition)))))" NIL
      "(defun assure-number (n)" "  (loop (when (numberp n) (return n))"
      "        (cerror \"Enter a number.\"" "                'not-a-number :argument n)"
      "        (format t \"~&Type a number: \")" "        (setq n (read))"
      "        (fresh-line)))" NIL "(assure-number 'a)"
      ">>  Correctable error in ASSURE-NUMBER: A is not a number." ">>  Restart options:"
      ">>   1: Enter a number." ">>   2: Top level." ">>  Debug> :continue 1"
      ">>  Type a number: 1/2" "=>  1/2" NIL "(defun assure-large-number (n)"
      "  (loop (when (and (numberp n) (> n 73)) (return n))"
      "        (cerror \"Enter a number~:[~; a bit larger than ~D~].\""
      "                \"~*~A is not a large number.\" " "                (numberp n) n)"
      "        (format t \"~&Type a large number: \")" "        (setq n (read))"
      "        (fresh-line)))" NIL "(assure-large-number 10000)" "=>  10000" NIL
      "(assure-large-number 'a)"
      ">>  Correctable error in ASSURE-LARGE-NUMBER: A is not a large number."
      ">>  Restart options:" ">>   1: Enter a number." ">>   2: Top level."
      ">>  Debug> :continue 1" ">>  Type a large number: 88" "=>  88" NIL
      "(assure-large-number 37)"
      ">>  Correctable error in ASSURE-LARGE-NUMBER: 37 is not a large number."
      ">>  Restart options:" ">>   1: Enter a number a bit larger than 37."
      ">>   2: Top level." ">>  Debug> :continue 1" ">>  Type a large number: 259"
      "=>  259" " " "(define-condition not-a-large-number (error)"
      "  ((argument :reader not-a-large-number-argument :initarg :argument))"
      "  (:report (lambda (condition stream)"
      "             (format stream \"~S is not a large number.\" "
      "                     (not-a-large-number-argument condition)))))" NIL
      "(defun assure-large-number (n)"
      "  (loop (when (and (numberp n) (> n 73)) (return n))"
      "        (cerror \"Enter a number~3*~:[~; a bit larger than ~*~D~].\""
      "                'not-a-large-number" "                :argument n "
      "                :ignore (numberp n)" "                :ignore n"
      "                :allow-other-keys t)"
      "        (format t \"~&Type a large number: \")" "        (setq n (read))"
      "        (fresh-line)))" NIL NIL "(assure-large-number 'a)"
      ">>  Correctable error in ASSURE-LARGE-NUMBER: A is not a large number."
      ">>  Restart options:" ">>   1: Enter a number." ">>   2: Top level."
      ">>  Debug> :continue 1" ">>  Type a large number: 88" "=>  88" " "
      "(assure-large-number 37)"
      ">>  Correctable error in ASSURE-LARGE-NUMBER: A is not a large number."
      ">>  Restart options:" ">>   1: Enter a number a bit larger than 37."
      ">>   2: Top level." ">>  Debug> :continue 1" ">>  Type a large number: 259"
      "=>  259"))
    (CHAPTER ("## 影響") 2 (CODE1 "*break-on-signals*") EOL2 "存在するハンドラーの束縛")
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "error") "," (CODE1 "format") "," (CODE1 "handler-bind")
     "," (CODE1 "*break-on-signals*") "," (CODE1 "simple-type-error"))
    (CHAPTER ("## 備考") 2 "もし" (STRONG "datum") "が文字列ではなくコンディションの型のときは、" (CODE1 "format")
     "の命令である" (CODE1 "~*") "が" (STRONG "continue-format-control") "内で"
     "初期化引数リストのキーワードを無視するためには特に有効です。" "例えば下記の通り。"
     (CODE3 "```lisp" "```" "(cerror \"enter a new value to replace ~*~s\" "
      "        'not-a-number" "        :argument a)"))))
(setf (gethash '("CERROR" . "FUNCTION") *table*) (gethash "CERROR" *table*))
(setf (gethash "CHANGE-CLASS" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "CHANGE-CLASS"))
    (CHAPTER ("## 構文") 2 (CODE1 "change-class") " " (STRONG "instance") " "
     (STRONG "new-class") " &key &allow-other-keys => " (STRONG "instance"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "change-class") " (" (STRONG "instance") " "
     (CODE1 "standard-object") ")" "(" (STRONG "new-class") " " (CODE1 "standard-class")
     ") &rest " (STRONG "initargs") EOL1 (CODE1 "change-class") " (" (STRONG "instance")
     " " (CODE1 "t") ")" "(" (STRONG "new-class") " " (CODE1 "symbol") ") &rest "
     (STRONG "initargs"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "instance") " - オブジェクト" EOL1 (STRONG "new-class")
     " - クラス指定子" EOL1 (STRONG "initargs") " - 初期化引数リスト")
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "change-class") "は、" (STRONG "instance")
     "のクラスを" (STRONG "new-class") "に変更します。" "変更は破壊的な修正を行い、" (STRONG "instance") "を返却します。"
     "もし元のクラスに、" (STRONG "new-class") "の局所スロットと" "同じ名前のスロットが存在する場合は、" "そのスロットの値は保持されます。"
     "これは、もしスロットに値があるとき、" (CODE1 "change-class") "実行後の" (CODE1 "slot-value") "の返却値と、"
     (CODE1 "change-class") "実行前の" (CODE1 "slot-value") "の返却値は、" (CODE1 "eql")
     "であるという意味です。" "同様に、スロットが" (CODE1 "unbound") "のときは、" (CODE1 "unbound") "が保持されます。"
     "他のスロットは、7.2. インスタンスのクラスの変更で記載されたように初期化されます。" EOL2 "他の全ての動作が完了した後で、"
     (CODE1 "change-class") "は" (CODE1 "update-instance-for-different-class") "を実行します。"
     "ジェネリック関数" (CODE1 "update-instance-for-different-class") "は、" "変更された"
     (STRONG "instance") "のスロットに値を割り当てるときに使用できます。" "7.2.2. 新しく追加された局所スロットの初期化を確認ください。"
     EOL2 "もし、上記のメソッドの2番目が選ばれたとき、" "そのメソッドは" (CODE1 "change-class") "の引数を、"
     (STRONG "instance") "、" (CODE1 "(find-class new-class)") "、" (STRONG "initargs")
     "で起動します。")
    (CHAPTER ("## 例文") 2 " "
     (CODE3 "```lisp" "```" "(defclass position () ())" " "
      "(defclass x-y-position (position)" "    ((x :initform 0 :initarg :x)"
      "     (y :initform 0 :initarg :y)))" " " "(defclass rho-theta-position (position)"
      "    ((rho :initform 0)" "     (theta :initform 0)))" " "
      "(defmethod update-instance-for-different-class :before ((old x-y-position) "
      "                                                        (new rho-theta-position)"
      "                                                        &key)"
      "  ;; 位置情報をoldからnewへコピーします。" "  ;; 新しく作成されるrho-theta-positionは古い位置と同じです"
      "  (let ((x (slot-value old 'x))" "        (y (slot-value old 'y)))"
      "    (setf (slot-value new 'rho) (sqrt (+ (* x x) (* y y)))"
      "          (slot-value new 'theta) (atan y x))))" " "
      ";;; この時点で、クラスx-y-positionのインスタンスは"
      ";;; chage-classでクラスrho-theta-positionのインスタンスに変更できます" " "
      "(setq p1 (make-instance 'x-y-position :x 2 :y 0))" " "
      "(change-class p1 'rho-theta-position)" "  "
      ";;; 結果p1のインスタンスはrho-theta-positionクラスのインスタンスとなりました。"
      ";;; update-instance-for-different-class メソッドは、"
      ";;; 古いインスタンスが保持していたxとyのスロットの値に基づいて" ";;; rhoとthetaのスロットの初期化しました。")
     EOL2 " ")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "update-instance-for-different-class")
     ", 7.2. インスタンスのクラスの変更")
    (CHAPTER ("## 備考") 2 "ジェネリック関数" (CODE1 "change-class") "は、" "いくつか意味として難しいことがあります。"
     "第一に、これは破壊的なオペレーションであり、" "あるメソッドの選択に使われたインスタンスに対して、" "そのメソッド内で実行できるという点があげられます。"
     "メソッドが結合されているときに複数のメソッドが巻き込まれると、" "現在実行されているメソッドやこれから実行されるメソッドが" "適用できなくなることがあります。"
     "第二に、処理系によってはスロットアクセスに" "コンパイラの最適化を用いている場合があり、" "インスタンスのクラスが変更されると"
     "コンパイラの想定に反してしまう可能性があります。" "これは、プログラマがメソッド内部で" (CODE1 "change-class") "を"
     "使ってはいけないということを意味しており、" "もしそのジェネリック関数のメソッドが" "何らかのスロットにアクセスすれば、結果は未定義になります。")))
(setf (gethash '("CHANGE-CLASS" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "CHANGE-CLASS" *table*))
(setf (gethash "CHAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CHAR") ", " (CODE1 "SCHAR"))
    (CHAPTER ("## 構文") 2 (CODE1 "char") " " (STRONG "string") " " (STRONG "index") " => "
     (STRONG "character") EOL1 (CODE1 "schar") " " (STRONG "string") " " (STRONG "index")
     " => " (STRONG "character") EOL1 "(setf (" (CODE1 "char") " " (STRONG "string") " "
     (STRONG "index") ") " (STRONG "new-character") ")" EOL1 "(setf (" (CODE1 "schar")
     " " (STRONG "string") " " (STRONG "index") ") " (STRONG "new-character") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string") " - " (CODE1 "char") "の場合は文字列、"
     (CODE1 "schar") "の場合はsimple-string" EOL1 (STRONG "index") " - 文字列の有効な配列のインデックス" EOL1
     (STRONG "character") ", " (STRONG "new-character") " - 文字")
    (CHAPTER ("## 定義") 2 (CODE1 "char") "と" (CODE1 "schar") "は、" (STRONG "index")
     "で指定された文字列の要素にアクセスします。" EOL2 (CODE1 "char") "は要素にアクセスする際にfill-pointerを無視します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq my-simple-string (make-string 6 :initial-element #\\A)) =>  \"AAAAAA\""
      "(schar my-simple-string 4) =>  #\\A"
      "(setf (schar my-simple-string 4) #\\B) =>  #\\B" "my-simple-string =>  \"AAAABA\""
      "(setq my-filled-string" "      (make-array 6 :element-type 'character"
      "                    :fill-pointer 5"
      "                    :initial-contents my-simple-string))" "=>  \"AAAAB\""
      "(char my-filled-string 4) =>  #\\B" "(char my-filled-string 5) =>  #\\A"
      "(setf (char my-filled-string 3) #\\C) =>  #\\C"
      "(setf (char my-filled-string 5) #\\D) =>  #\\D"
      "(setf (fill-pointer my-filled-string) 6) =>  6"
      "my-filled-string =>  \"AAACBD\""))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "aref") ", " (CODE1 "elt") ", 3.2.1. コンパイラーの用語")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(char s j) ==  (aref (the string s) j)"))))
(setf (gethash '("CHAR" . "ACCESSOR") *table*) (gethash "CHAR" *table*))
(setf (gethash "CHAR-CODE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR-CODE"))
    (CHAPTER ("## 構文") 2 (CODE1 "char-code") " " (STRONG "character") " => "
     (STRONG "code"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " - 文字" EOL1 (STRONG "code")
     " - 文字コード")
    (CHAPTER ("## 定義") 2 (CODE1 "char-code") "は、文字のコード属性を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; ASCII文字コードを使っている処理系は次の値を返却するでしょう"
      "(char-code #\\$) =>  36" "(char-code #\\a) =>  97"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "character") "が文字ではなかったら、型" (CODE1 "type-error")
     "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 (CODE1 "char-code-limit")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("CHAR-CODE" . "FUNCTION") *table*) (gethash "CHAR-CODE" *table*))
(setf (gethash "CHAR-CODE-LIMIT" *table*)
  '((CHAPTER NIL 0 "Constant Variable " (CODE1 "CHAR-CODE-LIMIT"))
    (CHAPTER ("## 定数値") 2 "非負の整数であり、処理系依存です。" "ただし96(標準文字の個数)以上です。")
    (CHAPTER ("## 定義") 2 "関数" (CODE1 "char-code") "の返却値の排他的上限値。" EOL2
     "追記：排他的上限値とは、上限値に1を加算した値のことです。" "例えば" (CODE1 "char-code") "の上限が255だとすれば、"
     (CODE1 "char-code-limit") "の値は256になります。")
    (CHAPTER ("## 参考") 2 (CODE1 "char-code"))
    (CHAPTER ("## 備考") 2 (CODE1 "char-code-limit") "の値は、"
     "実際に処理系がサポートしている文字の総数より大きいでしょう。")))
(setf (gethash '("CHAR-CODE-LIMIT" . "CONSTANT-VARIABLE") *table*) (gethash "CHAR-CODE-LIMIT" *table*))
(setf (gethash "CHAR-DOWNCASE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR-UPCASE") ", " (CODE1 "CHAR-DOWNCASE"))
    (CHAPTER ("## 構文") 2 (CODE1 "char-upcase") " " (STRONG "character") " => "
     (STRONG "corresponding-character") EOL1 (CODE1 "char-downcase") " "
     (STRONG "character") " => " (STRONG "corresponding-character"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") ", " (STRONG "corresponding-character")
     " - 文字")
    (CHAPTER ("## 定義") 2 (STRONG "character") "が小文字なら、" (CODE1 "char-upcase")
     "は大文字を返却します。" "それ以外はただ引数の文字をそのまま返却します。" EOL2 (STRONG "character") "が大文字なら、"
     (CODE1 "char-downcase") "は小文字を返却します。" "それ以外はただ引数の文字をそのまま返却します。" EOL2
     (STRONG "character") "と返却値では、ただ文字コードの属性のみが違っており、" "その他のすべての実装定義の属性は保存されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(char-upcase #\\a) =>  #\\A" "(char-upcase #\\A) =>  #\\A"
      "(char-downcase #\\a) =>  #\\a" "(char-downcase #\\A) =>  #\\a"
      "(char-upcase #\\9) =>  #\\9" "(char-downcase #\\9) =>  #\\9"
      "(char-upcase #\\@) =>  #\\@" "(char-downcase #\\@) =>  #\\@" NIL
      ";; 注意：次の例文は、もしCHAR-CODE-LIMITの値が非常に大きい実装の場合は、" ";;       おそらく非常に長い時間かかるだろう。"
      "(dotimes (code char-code-limit)" "  (let ((char (code-char code)))"
      "    (when char"
      "      (unless (cond ((upper-case-p char) (char= (char-upcase (char-downcase char)) char))"
      "                    ((lower-case-p char) (char= (char-downcase (char-upcase char)) char))"
      "                     (t (and (char= (char-upcase (char-downcase char)) char)"
      "                             (char= (char-downcase (char-upcase char)) char))))"
      "        (return char)))))" "=>  NIL"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "character") "が文字ではなかったら、型" (CODE1 "type-error")
     "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 (CODE1 "upper-case-p") ", " (CODE1 "alpha-char-p")
     ", 13.1.4.3. 文字のケース, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "corresponding-character") "が" (STRONG "character")
     "と違う場合は、" (STRONG "corresponding-character") "と" (STRONG "character") "両方に"
     "ケース(大文字と小文字のこと)があるということになります。" EOL2 (CODE1 "char-equal") "は文字の比較の際にケースを無視するため、"
     (STRONG "corresponding-character") "は" (STRONG "character") "と" (CODE1 "char-equal")
     "での" "比較においては常に等しいです。")))
(setf (gethash '("CHAR-DOWNCASE" . "FUNCTION") *table*) (gethash "CHAR-DOWNCASE" *table*))
(setf (gethash "CHAR-EQUAL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR=") ", " (CODE1 "CHAR/=") ", " (CODE1 "CHAR<")
     ", " (CODE1 "CHAR>") ", " (CODE1 "CHAR<=") ", " (CODE1 "CHAR>=") ","
     (CODE1 "CHAR-EQUAL") ", " (CODE1 "CHAR-NOT-EQUAL") "," (CODE1 "CHAR-LESSP") ", "
     (CODE1 "CHAR-GREATERP") "," (CODE1 "CHAR-NOT-GREATERP") ", "
     (CODE1 "CHAR-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "char=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char/=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char<") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char>")
     " &rest " (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char<=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char>=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char-equal") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-equal") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-lessp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-greaterp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-not-greaterp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-lessp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " -- 文字" EOL1
     (STRONG "generalized-boolean") " -- generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は文字を比較します。" EOL2 (CODE1 "char=") "は、全ての文字が同じなら"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の何らかの属性が違うときは"
     (CODE1 "char=") "ではありません。" EOL2 (CODE1 "char/=") "は、全ての文字が違うとき" (STRONG "true")
     "を、それ以外は" (STRONG "false") "を返却します。" EOL2 (CODE1 "char<") "は、文字が単調増加のとき"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、"
     (CODE1 "char<") "の順序は文字コードを数値として" (CODE1 "<") "で比較したものと同じです。" EOL2 (CODE1 "char>")
     "は、文字が単調減少の場合は" (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。"
     "もし2つの文字の属性が等しいとき、" (CODE1 "char>") "の順序は文字コードを数値として" (CODE1 ">") "で比較したものと同じです。"
     EOL2 (CODE1 "char<=") "は、文字が単調非減少のとき" (STRONG "true") "を、それ以外は" (STRONG "false")
     "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char<=") "の順序は文字コードを数値として" (CODE1 "<=")
     "で比較したものと同じです。" EOL2 (CODE1 "char>=") "は、文字が単調非増加の場合は" (STRONG "true") "を、それ以外は"
     (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char>=") "の順序は文字コードを数値として"
     (CODE1 ">=") "で比較したものと同じです。" EOL2 (CODE1 "char-equal") ", " (CODE1 "char-not-equal")
     "," (CODE1 "char-lessp") ", " (CODE1 "char-greaterp") ","
     (CODE1 "char-not-greaterp") ", " (CODE1 "char-not-lessp") "は、" "順に" (CODE1 "char=")
     ", " (CODE1 "char/=") ", " (CODE1 "char<") ", " (CODE1 "char>") "," (CODE1 "char<=")
     ", " (CODE1 "char>=") "と似ていますが、" "大文字小文字を無視します。"
     "もし文字が単純ではない場合（文字の属性がある場合。13.1.3. 文字の属性を参照）" "結果は実装で定義された動作になります。" "例えば、ある実装では"
     (CODE1 "char-equal") "などの関数では、" "属性を明確に無視するように定義しているかもしれません。" "属性に何らかの効果がある場合は、"
     "これらの比較関数の属性を定義する個所で規定しておく必要があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(char= #\\d #\\d) → true" "(char= #\\A #\\a) → false"
      "(char= #\\d #\\x) → false" "(char= #\\d #\\D) → false"
      "(char/= #\\d #\\d) → false" "(char/= #\\d #\\x) → true"
      "(char/= #\\d #\\D) → true" "(char= #\\d #\\d #\\d #\\d) → true"
      "(char/= #\\d #\\d #\\d #\\d) → false" "(char= #\\d #\\d #\\x #\\d) → false"
      "(char/= #\\d #\\d #\\x #\\d) → false" "(char= #\\d #\\y #\\x #\\c) → false"
      "(char/= #\\d #\\y #\\x #\\c) → true" "(char= #\\d #\\c #\\d) → false"
      "(char/= #\\d #\\c #\\d) → false" "(char< #\\d #\\x) → true"
      "(char<= #\\d #\\x) → true" "(char< #\\d #\\d) → false" "(char<= #\\d #\\d) → true"
      "(char< #\\a #\\e #\\y #\\z) → true" "(char<= #\\a #\\e #\\y #\\z) → true"
      "(char< #\\a #\\e #\\e #\\y) → false" "(char<= #\\a #\\e #\\e #\\y) → true"
      "(char> #\\e #\\d) → true" "(char>= #\\e #\\d) → true"
      "(char> #\\d #\\c #\\b #\\a) → true" "(char>= #\\d #\\c #\\b #\\a) → true"
      "(char> #\\d #\\d #\\c #\\a) → false" "(char>= #\\d #\\d #\\c #\\a) → true"
      "(char> #\\e #\\d #\\b #\\c #\\a) → false"
      "(char>= #\\e #\\d #\\b #\\c #\\a) → false"
      "(char> #\\z #\\A) → implementation-dependent"
      "(char> #\\Z #\\a) → implementation-dependent" "(char-equal #\\A #\\a) → true"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char-lessp)"
      "→ (#\\A #\\a #\\b #\\B #\\c #\\C)"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char<)"
      "→ (#\\A #\\B #\\C #\\a #\\b #\\c) ;実装A" "→ (#\\a #\\b #\\c #\\A #\\B #\\C) ;実装B"
      "→ (#\\a #\\A #\\b #\\B #\\c #\\C) ;実装C" "→ (#\\A #\\a #\\B #\\b #\\C #\\c) ;実装D"
      "→ (#\\A #\\B #\\a #\\b #\\C #\\c) ;実装E"))
    (CHAPTER ("## 例外") 2 "もし少なくとも1文字も与えられなかった場合は、" "型" (CODE1 "program-error")
     "のエラーが発せられます。")
    (CHAPTER ("## 参考") 2 "2.1. 文字の構文, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "文字がコードの属性かあるいは実装定義の属性で異なる場合、" (CODE1 "char=")
     "によって異なるものとしてみなされます。" EOL2 (CODE1 "(char= c1 c2)") "が" (STRONG "true") "のときに、"
     (CODE1 "(eq c1 c2)") "が" (STRONG "true") "である必要はありません。" (CODE1 "eq") "は、"
     (CODE1 "char=") "が区別できないような2つの文字を区別できますが、" "それは文字として区別しているのではなく、"
     "低レベルの実装の特性に基づいて行われています。" "もし" (CODE1 "(eq c1 c2)") "が" (STRONG "true") "のときは、"
     (CODE1 "(char= c1 c2)") "もまた" (STRONG "true") "です。" "文字の" (CODE1 "eql") "と"
     (CODE1 "equal") "の比較は、" (CODE1 "char=") "と同じ方法で行われます。" EOL2 "関数"
     (CODE1 "char-equal") "," (CODE1 "char-not-equal") "," (CODE1 "char-lessp") ","
     (CODE1 "char-greaterp") "," (CODE1 "char-not-greaterp") "," (CODE1 "char-not-lessp")
     "において、" (CODE1 "standard-char") "の大文字小文字の比較は、" "暗に標準文字の" (CODE1 "A=a") ", "
     (CODE1 "B=b") ", " (CODE1 "...") ", " (CODE1 "Z=z") "、" "さらに、" (CODE1 "9<A")
     "か、あるいは" (CODE1 "Z<0") "の" "どちらかで順序付けされることを意味します。")))
(setf (gethash '("CHAR-EQUAL" . "FUNCTION") *table*) (gethash "CHAR-EQUAL" *table*))
(setf (gethash "CHAR-GREATERP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR=") ", " (CODE1 "CHAR/=") ", " (CODE1 "CHAR<")
     ", " (CODE1 "CHAR>") ", " (CODE1 "CHAR<=") ", " (CODE1 "CHAR>=") ","
     (CODE1 "CHAR-EQUAL") ", " (CODE1 "CHAR-NOT-EQUAL") "," (CODE1 "CHAR-LESSP") ", "
     (CODE1 "CHAR-GREATERP") "," (CODE1 "CHAR-NOT-GREATERP") ", "
     (CODE1 "CHAR-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "char=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char/=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char<") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char>")
     " &rest " (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char<=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char>=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char-equal") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-equal") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-lessp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-greaterp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-not-greaterp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-lessp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " -- 文字" EOL1
     (STRONG "generalized-boolean") " -- generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は文字を比較します。" EOL2 (CODE1 "char=") "は、全ての文字が同じなら"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の何らかの属性が違うときは"
     (CODE1 "char=") "ではありません。" EOL2 (CODE1 "char/=") "は、全ての文字が違うとき" (STRONG "true")
     "を、それ以外は" (STRONG "false") "を返却します。" EOL2 (CODE1 "char<") "は、文字が単調増加のとき"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、"
     (CODE1 "char<") "の順序は文字コードを数値として" (CODE1 "<") "で比較したものと同じです。" EOL2 (CODE1 "char>")
     "は、文字が単調減少の場合は" (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。"
     "もし2つの文字の属性が等しいとき、" (CODE1 "char>") "の順序は文字コードを数値として" (CODE1 ">") "で比較したものと同じです。"
     EOL2 (CODE1 "char<=") "は、文字が単調非減少のとき" (STRONG "true") "を、それ以外は" (STRONG "false")
     "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char<=") "の順序は文字コードを数値として" (CODE1 "<=")
     "で比較したものと同じです。" EOL2 (CODE1 "char>=") "は、文字が単調非増加の場合は" (STRONG "true") "を、それ以外は"
     (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char>=") "の順序は文字コードを数値として"
     (CODE1 ">=") "で比較したものと同じです。" EOL2 (CODE1 "char-equal") ", " (CODE1 "char-not-equal")
     "," (CODE1 "char-lessp") ", " (CODE1 "char-greaterp") ","
     (CODE1 "char-not-greaterp") ", " (CODE1 "char-not-lessp") "は、" "順に" (CODE1 "char=")
     ", " (CODE1 "char/=") ", " (CODE1 "char<") ", " (CODE1 "char>") "," (CODE1 "char<=")
     ", " (CODE1 "char>=") "と似ていますが、" "大文字小文字を無視します。"
     "もし文字が単純ではない場合（文字の属性がある場合。13.1.3. 文字の属性を参照）" "結果は実装で定義された動作になります。" "例えば、ある実装では"
     (CODE1 "char-equal") "などの関数では、" "属性を明確に無視するように定義しているかもしれません。" "属性に何らかの効果がある場合は、"
     "これらの比較関数の属性を定義する個所で規定しておく必要があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(char= #\\d #\\d) → true" "(char= #\\A #\\a) → false"
      "(char= #\\d #\\x) → false" "(char= #\\d #\\D) → false"
      "(char/= #\\d #\\d) → false" "(char/= #\\d #\\x) → true"
      "(char/= #\\d #\\D) → true" "(char= #\\d #\\d #\\d #\\d) → true"
      "(char/= #\\d #\\d #\\d #\\d) → false" "(char= #\\d #\\d #\\x #\\d) → false"
      "(char/= #\\d #\\d #\\x #\\d) → false" "(char= #\\d #\\y #\\x #\\c) → false"
      "(char/= #\\d #\\y #\\x #\\c) → true" "(char= #\\d #\\c #\\d) → false"
      "(char/= #\\d #\\c #\\d) → false" "(char< #\\d #\\x) → true"
      "(char<= #\\d #\\x) → true" "(char< #\\d #\\d) → false" "(char<= #\\d #\\d) → true"
      "(char< #\\a #\\e #\\y #\\z) → true" "(char<= #\\a #\\e #\\y #\\z) → true"
      "(char< #\\a #\\e #\\e #\\y) → false" "(char<= #\\a #\\e #\\e #\\y) → true"
      "(char> #\\e #\\d) → true" "(char>= #\\e #\\d) → true"
      "(char> #\\d #\\c #\\b #\\a) → true" "(char>= #\\d #\\c #\\b #\\a) → true"
      "(char> #\\d #\\d #\\c #\\a) → false" "(char>= #\\d #\\d #\\c #\\a) → true"
      "(char> #\\e #\\d #\\b #\\c #\\a) → false"
      "(char>= #\\e #\\d #\\b #\\c #\\a) → false"
      "(char> #\\z #\\A) → implementation-dependent"
      "(char> #\\Z #\\a) → implementation-dependent" "(char-equal #\\A #\\a) → true"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char-lessp)"
      "→ (#\\A #\\a #\\b #\\B #\\c #\\C)"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char<)"
      "→ (#\\A #\\B #\\C #\\a #\\b #\\c) ;実装A" "→ (#\\a #\\b #\\c #\\A #\\B #\\C) ;実装B"
      "→ (#\\a #\\A #\\b #\\B #\\c #\\C) ;実装C" "→ (#\\A #\\a #\\B #\\b #\\C #\\c) ;実装D"
      "→ (#\\A #\\B #\\a #\\b #\\C #\\c) ;実装E"))
    (CHAPTER ("## 例外") 2 "もし少なくとも1文字も与えられなかった場合は、" "型" (CODE1 "program-error")
     "のエラーが発せられます。")
    (CHAPTER ("## 参考") 2 "2.1. 文字の構文, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "文字がコードの属性かあるいは実装定義の属性で異なる場合、" (CODE1 "char=")
     "によって異なるものとしてみなされます。" EOL2 (CODE1 "(char= c1 c2)") "が" (STRONG "true") "のときに、"
     (CODE1 "(eq c1 c2)") "が" (STRONG "true") "である必要はありません。" (CODE1 "eq") "は、"
     (CODE1 "char=") "が区別できないような2つの文字を区別できますが、" "それは文字として区別しているのではなく、"
     "低レベルの実装の特性に基づいて行われています。" "もし" (CODE1 "(eq c1 c2)") "が" (STRONG "true") "のときは、"
     (CODE1 "(char= c1 c2)") "もまた" (STRONG "true") "です。" "文字の" (CODE1 "eql") "と"
     (CODE1 "equal") "の比較は、" (CODE1 "char=") "と同じ方法で行われます。" EOL2 "関数"
     (CODE1 "char-equal") "," (CODE1 "char-not-equal") "," (CODE1 "char-lessp") ","
     (CODE1 "char-greaterp") "," (CODE1 "char-not-greaterp") "," (CODE1 "char-not-lessp")
     "において、" (CODE1 "standard-char") "の大文字小文字の比較は、" "暗に標準文字の" (CODE1 "A=a") ", "
     (CODE1 "B=b") ", " (CODE1 "...") ", " (CODE1 "Z=z") "、" "さらに、" (CODE1 "9<A")
     "か、あるいは" (CODE1 "Z<0") "の" "どちらかで順序付けされることを意味します。")))
(setf (gethash '("CHAR-GREATERP" . "FUNCTION") *table*) (gethash "CHAR-GREATERP" *table*))
(setf (gethash "CHAR-INT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR-INT"))
    (CHAPTER ("## 構文") 2 (CODE1 "char-int") " " (STRONG "character") " => "
     (STRONG "integer"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " - 文字" EOL1 (STRONG "integer")
     " - 非負の整数")
    (CHAPTER ("## 定義") 2 "文字オブジェクトを符号化した非負の整数を返却します。" "整数の算出方法は処理系依存です。" (CODE1 "sxhash")
     "とは対照的に、" "結果は特定のLispイメージに依存しないことが保証されません。" EOL2 "もし" (STRONG "character")
     "が処理系依存の属性を持っていないとき、" (CODE1 "char-int") "と" (CODE1 "char-code") "の結果は同じです。" EOL2
     (CODE1 "c1") "と" (CODE1 "c2") "が文字のとき、下記が成り立ちます。"
     (CODE3 "```lisp" "```" "(char= c1 c2) ==  (= (char-int c1) (char-int c2))"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(char-int #\\A) =>  65       ; 処理系A"
      "(char-int #\\A) =>  577      ; 処理系B" "(char-int #\\A) =>  262145   ; 処理系C"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "character") "が文字ではなかったら、型" (CODE1 "type-error")
     "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 (CODE1 "char-code")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("CHAR-INT" . "FUNCTION") *table*) (gethash "CHAR-INT" *table*))
(setf (gethash "CHAR-LESSP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR=") ", " (CODE1 "CHAR/=") ", " (CODE1 "CHAR<")
     ", " (CODE1 "CHAR>") ", " (CODE1 "CHAR<=") ", " (CODE1 "CHAR>=") ","
     (CODE1 "CHAR-EQUAL") ", " (CODE1 "CHAR-NOT-EQUAL") "," (CODE1 "CHAR-LESSP") ", "
     (CODE1 "CHAR-GREATERP") "," (CODE1 "CHAR-NOT-GREATERP") ", "
     (CODE1 "CHAR-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "char=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char/=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char<") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char>")
     " &rest " (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char<=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char>=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char-equal") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-equal") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-lessp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-greaterp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-not-greaterp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-lessp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " -- 文字" EOL1
     (STRONG "generalized-boolean") " -- generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は文字を比較します。" EOL2 (CODE1 "char=") "は、全ての文字が同じなら"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の何らかの属性が違うときは"
     (CODE1 "char=") "ではありません。" EOL2 (CODE1 "char/=") "は、全ての文字が違うとき" (STRONG "true")
     "を、それ以外は" (STRONG "false") "を返却します。" EOL2 (CODE1 "char<") "は、文字が単調増加のとき"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、"
     (CODE1 "char<") "の順序は文字コードを数値として" (CODE1 "<") "で比較したものと同じです。" EOL2 (CODE1 "char>")
     "は、文字が単調減少の場合は" (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。"
     "もし2つの文字の属性が等しいとき、" (CODE1 "char>") "の順序は文字コードを数値として" (CODE1 ">") "で比較したものと同じです。"
     EOL2 (CODE1 "char<=") "は、文字が単調非減少のとき" (STRONG "true") "を、それ以外は" (STRONG "false")
     "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char<=") "の順序は文字コードを数値として" (CODE1 "<=")
     "で比較したものと同じです。" EOL2 (CODE1 "char>=") "は、文字が単調非増加の場合は" (STRONG "true") "を、それ以外は"
     (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char>=") "の順序は文字コードを数値として"
     (CODE1 ">=") "で比較したものと同じです。" EOL2 (CODE1 "char-equal") ", " (CODE1 "char-not-equal")
     "," (CODE1 "char-lessp") ", " (CODE1 "char-greaterp") ","
     (CODE1 "char-not-greaterp") ", " (CODE1 "char-not-lessp") "は、" "順に" (CODE1 "char=")
     ", " (CODE1 "char/=") ", " (CODE1 "char<") ", " (CODE1 "char>") "," (CODE1 "char<=")
     ", " (CODE1 "char>=") "と似ていますが、" "大文字小文字を無視します。"
     "もし文字が単純ではない場合（文字の属性がある場合。13.1.3. 文字の属性を参照）" "結果は実装で定義された動作になります。" "例えば、ある実装では"
     (CODE1 "char-equal") "などの関数では、" "属性を明確に無視するように定義しているかもしれません。" "属性に何らかの効果がある場合は、"
     "これらの比較関数の属性を定義する個所で規定しておく必要があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(char= #\\d #\\d) → true" "(char= #\\A #\\a) → false"
      "(char= #\\d #\\x) → false" "(char= #\\d #\\D) → false"
      "(char/= #\\d #\\d) → false" "(char/= #\\d #\\x) → true"
      "(char/= #\\d #\\D) → true" "(char= #\\d #\\d #\\d #\\d) → true"
      "(char/= #\\d #\\d #\\d #\\d) → false" "(char= #\\d #\\d #\\x #\\d) → false"
      "(char/= #\\d #\\d #\\x #\\d) → false" "(char= #\\d #\\y #\\x #\\c) → false"
      "(char/= #\\d #\\y #\\x #\\c) → true" "(char= #\\d #\\c #\\d) → false"
      "(char/= #\\d #\\c #\\d) → false" "(char< #\\d #\\x) → true"
      "(char<= #\\d #\\x) → true" "(char< #\\d #\\d) → false" "(char<= #\\d #\\d) → true"
      "(char< #\\a #\\e #\\y #\\z) → true" "(char<= #\\a #\\e #\\y #\\z) → true"
      "(char< #\\a #\\e #\\e #\\y) → false" "(char<= #\\a #\\e #\\e #\\y) → true"
      "(char> #\\e #\\d) → true" "(char>= #\\e #\\d) → true"
      "(char> #\\d #\\c #\\b #\\a) → true" "(char>= #\\d #\\c #\\b #\\a) → true"
      "(char> #\\d #\\d #\\c #\\a) → false" "(char>= #\\d #\\d #\\c #\\a) → true"
      "(char> #\\e #\\d #\\b #\\c #\\a) → false"
      "(char>= #\\e #\\d #\\b #\\c #\\a) → false"
      "(char> #\\z #\\A) → implementation-dependent"
      "(char> #\\Z #\\a) → implementation-dependent" "(char-equal #\\A #\\a) → true"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char-lessp)"
      "→ (#\\A #\\a #\\b #\\B #\\c #\\C)"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char<)"
      "→ (#\\A #\\B #\\C #\\a #\\b #\\c) ;実装A" "→ (#\\a #\\b #\\c #\\A #\\B #\\C) ;実装B"
      "→ (#\\a #\\A #\\b #\\B #\\c #\\C) ;実装C" "→ (#\\A #\\a #\\B #\\b #\\C #\\c) ;実装D"
      "→ (#\\A #\\B #\\a #\\b #\\C #\\c) ;実装E"))
    (CHAPTER ("## 例外") 2 "もし少なくとも1文字も与えられなかった場合は、" "型" (CODE1 "program-error")
     "のエラーが発せられます。")
    (CHAPTER ("## 参考") 2 "2.1. 文字の構文, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "文字がコードの属性かあるいは実装定義の属性で異なる場合、" (CODE1 "char=")
     "によって異なるものとしてみなされます。" EOL2 (CODE1 "(char= c1 c2)") "が" (STRONG "true") "のときに、"
     (CODE1 "(eq c1 c2)") "が" (STRONG "true") "である必要はありません。" (CODE1 "eq") "は、"
     (CODE1 "char=") "が区別できないような2つの文字を区別できますが、" "それは文字として区別しているのではなく、"
     "低レベルの実装の特性に基づいて行われています。" "もし" (CODE1 "(eq c1 c2)") "が" (STRONG "true") "のときは、"
     (CODE1 "(char= c1 c2)") "もまた" (STRONG "true") "です。" "文字の" (CODE1 "eql") "と"
     (CODE1 "equal") "の比較は、" (CODE1 "char=") "と同じ方法で行われます。" EOL2 "関数"
     (CODE1 "char-equal") "," (CODE1 "char-not-equal") "," (CODE1 "char-lessp") ","
     (CODE1 "char-greaterp") "," (CODE1 "char-not-greaterp") "," (CODE1 "char-not-lessp")
     "において、" (CODE1 "standard-char") "の大文字小文字の比較は、" "暗に標準文字の" (CODE1 "A=a") ", "
     (CODE1 "B=b") ", " (CODE1 "...") ", " (CODE1 "Z=z") "、" "さらに、" (CODE1 "9<A")
     "か、あるいは" (CODE1 "Z<0") "の" "どちらかで順序付けされることを意味します。")))
(setf (gethash '("CHAR-LESSP" . "FUNCTION") *table*) (gethash "CHAR-LESSP" *table*))
(setf (gethash "CHAR-NAME" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR-NAME"))
    (CHAPTER ("## 構文") 2 (CODE1 "char-name") " " (STRONG "character") " => "
     (STRONG "name"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " - 文字" EOL1 (STRONG "name") " - 文字列か"
     (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "文字の名前を文字列で返却します。" "もし文字に名前がないときは" (CODE1 "nil") "です。" EOL2
     "全ての非図形文字文字は、" (CODE1 "nil") "でない何らかの実装定義属性を持たない限り、" "名前を持つことが要求されます。"
     "他の文字が名前を持つかどうかは処理系依存です。" EOL2 "標準文字の" (CODE1 "<Newline>") "と" (CODE1 "<Space>")
     "は、" "それぞれ" (CODE1 "\"Newline\"") ", " (CODE1 "\"Space\"") "という名前を持っています。" "準標準文字の"
     (CODE1 "<Tab>") ", " (CODE1 "<Page>") ", " (CODE1 "<Rubout>") ", "
     (CODE1 "<Linefeed>") ", " (CODE1 "<Return>") ", " (CODE1 "<Backspace>") "は、"
     "（もし処理系がサポートしているのであれば）" "それぞれ" (CODE1 "\"Tab\"") ", " (CODE1 "\"Page\"") ", "
     (CODE1 "\"Rubout\"") ", " (CODE1 "\"Linefeed\"") ", " (CODE1 "\"Return\"") ", "
     (CODE1 "\"Backspace\"") "という名前を持ちます。" "（これらの場合は、" (CODE1 "#\\") "による名前の検索や、" "関数"
     (CODE1 "name-char") "の場合あっても、大文字小文字は区別されません。）")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(char-name #\\ ) =>  \"Space\""
      "(char-name #\\Space) =>  \"Space\"" "(char-name #\\Page) =>  \"Page\"" NIL
      "(char-name #\\a)" "=>  NIL" "OR=>  \"LOWERCASE-a\"" "OR=>  \"Small-A\""
      "OR=>  \"LA01\"" NIL "(char-name #\\A)" "=>  NIL" "OR=>  \"UPPERCASE-A\""
      "OR=>  \"Capital-A\"" "OR=>  \"LA02\"" NIL
      ";; CHAR-NAMEの返却値が変わっても、#\\Aは#\\Aとして印刷されます。"
      "(prin1-to-string (read-from-string (format nil \"#\\\\~A\" (or (char-name #\\A) \"A\"))))"
      "=>  \"#\\\\A\""))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "character") "が文字ではなかったら、型" (CODE1 "type-error")
     "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 (CODE1 "name-char") ", 22.1.3.2. 文字の印字")
    (CHAPTER ("## 備考") 2 "非図形文字が名前を持っている場合は、" "Lispプリンターが" (CODE1 "#\\") "に続けて名前を出力します。"
     "22.1.3.2. 文字の印字を参照。")))
(setf (gethash '("CHAR-NAME" . "FUNCTION") *table*) (gethash "CHAR-NAME" *table*))
(setf (gethash "CHAR-NOT-EQUAL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR=") ", " (CODE1 "CHAR/=") ", " (CODE1 "CHAR<")
     ", " (CODE1 "CHAR>") ", " (CODE1 "CHAR<=") ", " (CODE1 "CHAR>=") ","
     (CODE1 "CHAR-EQUAL") ", " (CODE1 "CHAR-NOT-EQUAL") "," (CODE1 "CHAR-LESSP") ", "
     (CODE1 "CHAR-GREATERP") "," (CODE1 "CHAR-NOT-GREATERP") ", "
     (CODE1 "CHAR-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "char=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char/=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char<") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char>")
     " &rest " (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char<=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char>=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char-equal") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-equal") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-lessp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-greaterp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-not-greaterp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-lessp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " -- 文字" EOL1
     (STRONG "generalized-boolean") " -- generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は文字を比較します。" EOL2 (CODE1 "char=") "は、全ての文字が同じなら"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の何らかの属性が違うときは"
     (CODE1 "char=") "ではありません。" EOL2 (CODE1 "char/=") "は、全ての文字が違うとき" (STRONG "true")
     "を、それ以外は" (STRONG "false") "を返却します。" EOL2 (CODE1 "char<") "は、文字が単調増加のとき"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、"
     (CODE1 "char<") "の順序は文字コードを数値として" (CODE1 "<") "で比較したものと同じです。" EOL2 (CODE1 "char>")
     "は、文字が単調減少の場合は" (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。"
     "もし2つの文字の属性が等しいとき、" (CODE1 "char>") "の順序は文字コードを数値として" (CODE1 ">") "で比較したものと同じです。"
     EOL2 (CODE1 "char<=") "は、文字が単調非減少のとき" (STRONG "true") "を、それ以外は" (STRONG "false")
     "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char<=") "の順序は文字コードを数値として" (CODE1 "<=")
     "で比較したものと同じです。" EOL2 (CODE1 "char>=") "は、文字が単調非増加の場合は" (STRONG "true") "を、それ以外は"
     (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char>=") "の順序は文字コードを数値として"
     (CODE1 ">=") "で比較したものと同じです。" EOL2 (CODE1 "char-equal") ", " (CODE1 "char-not-equal")
     "," (CODE1 "char-lessp") ", " (CODE1 "char-greaterp") ","
     (CODE1 "char-not-greaterp") ", " (CODE1 "char-not-lessp") "は、" "順に" (CODE1 "char=")
     ", " (CODE1 "char/=") ", " (CODE1 "char<") ", " (CODE1 "char>") "," (CODE1 "char<=")
     ", " (CODE1 "char>=") "と似ていますが、" "大文字小文字を無視します。"
     "もし文字が単純ではない場合（文字の属性がある場合。13.1.3. 文字の属性を参照）" "結果は実装で定義された動作になります。" "例えば、ある実装では"
     (CODE1 "char-equal") "などの関数では、" "属性を明確に無視するように定義しているかもしれません。" "属性に何らかの効果がある場合は、"
     "これらの比較関数の属性を定義する個所で規定しておく必要があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(char= #\\d #\\d) → true" "(char= #\\A #\\a) → false"
      "(char= #\\d #\\x) → false" "(char= #\\d #\\D) → false"
      "(char/= #\\d #\\d) → false" "(char/= #\\d #\\x) → true"
      "(char/= #\\d #\\D) → true" "(char= #\\d #\\d #\\d #\\d) → true"
      "(char/= #\\d #\\d #\\d #\\d) → false" "(char= #\\d #\\d #\\x #\\d) → false"
      "(char/= #\\d #\\d #\\x #\\d) → false" "(char= #\\d #\\y #\\x #\\c) → false"
      "(char/= #\\d #\\y #\\x #\\c) → true" "(char= #\\d #\\c #\\d) → false"
      "(char/= #\\d #\\c #\\d) → false" "(char< #\\d #\\x) → true"
      "(char<= #\\d #\\x) → true" "(char< #\\d #\\d) → false" "(char<= #\\d #\\d) → true"
      "(char< #\\a #\\e #\\y #\\z) → true" "(char<= #\\a #\\e #\\y #\\z) → true"
      "(char< #\\a #\\e #\\e #\\y) → false" "(char<= #\\a #\\e #\\e #\\y) → true"
      "(char> #\\e #\\d) → true" "(char>= #\\e #\\d) → true"
      "(char> #\\d #\\c #\\b #\\a) → true" "(char>= #\\d #\\c #\\b #\\a) → true"
      "(char> #\\d #\\d #\\c #\\a) → false" "(char>= #\\d #\\d #\\c #\\a) → true"
      "(char> #\\e #\\d #\\b #\\c #\\a) → false"
      "(char>= #\\e #\\d #\\b #\\c #\\a) → false"
      "(char> #\\z #\\A) → implementation-dependent"
      "(char> #\\Z #\\a) → implementation-dependent" "(char-equal #\\A #\\a) → true"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char-lessp)"
      "→ (#\\A #\\a #\\b #\\B #\\c #\\C)"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char<)"
      "→ (#\\A #\\B #\\C #\\a #\\b #\\c) ;実装A" "→ (#\\a #\\b #\\c #\\A #\\B #\\C) ;実装B"
      "→ (#\\a #\\A #\\b #\\B #\\c #\\C) ;実装C" "→ (#\\A #\\a #\\B #\\b #\\C #\\c) ;実装D"
      "→ (#\\A #\\B #\\a #\\b #\\C #\\c) ;実装E"))
    (CHAPTER ("## 例外") 2 "もし少なくとも1文字も与えられなかった場合は、" "型" (CODE1 "program-error")
     "のエラーが発せられます。")
    (CHAPTER ("## 参考") 2 "2.1. 文字の構文, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "文字がコードの属性かあるいは実装定義の属性で異なる場合、" (CODE1 "char=")
     "によって異なるものとしてみなされます。" EOL2 (CODE1 "(char= c1 c2)") "が" (STRONG "true") "のときに、"
     (CODE1 "(eq c1 c2)") "が" (STRONG "true") "である必要はありません。" (CODE1 "eq") "は、"
     (CODE1 "char=") "が区別できないような2つの文字を区別できますが、" "それは文字として区別しているのではなく、"
     "低レベルの実装の特性に基づいて行われています。" "もし" (CODE1 "(eq c1 c2)") "が" (STRONG "true") "のときは、"
     (CODE1 "(char= c1 c2)") "もまた" (STRONG "true") "です。" "文字の" (CODE1 "eql") "と"
     (CODE1 "equal") "の比較は、" (CODE1 "char=") "と同じ方法で行われます。" EOL2 "関数"
     (CODE1 "char-equal") "," (CODE1 "char-not-equal") "," (CODE1 "char-lessp") ","
     (CODE1 "char-greaterp") "," (CODE1 "char-not-greaterp") "," (CODE1 "char-not-lessp")
     "において、" (CODE1 "standard-char") "の大文字小文字の比較は、" "暗に標準文字の" (CODE1 "A=a") ", "
     (CODE1 "B=b") ", " (CODE1 "...") ", " (CODE1 "Z=z") "、" "さらに、" (CODE1 "9<A")
     "か、あるいは" (CODE1 "Z<0") "の" "どちらかで順序付けされることを意味します。")))
(setf (gethash '("CHAR-NOT-EQUAL" . "FUNCTION") *table*) (gethash "CHAR-NOT-EQUAL" *table*))
(setf (gethash "CHAR-NOT-GREATERP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR=") ", " (CODE1 "CHAR/=") ", " (CODE1 "CHAR<")
     ", " (CODE1 "CHAR>") ", " (CODE1 "CHAR<=") ", " (CODE1 "CHAR>=") ","
     (CODE1 "CHAR-EQUAL") ", " (CODE1 "CHAR-NOT-EQUAL") "," (CODE1 "CHAR-LESSP") ", "
     (CODE1 "CHAR-GREATERP") "," (CODE1 "CHAR-NOT-GREATERP") ", "
     (CODE1 "CHAR-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "char=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char/=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char<") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char>")
     " &rest " (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char<=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char>=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char-equal") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-equal") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-lessp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-greaterp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-not-greaterp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-lessp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " -- 文字" EOL1
     (STRONG "generalized-boolean") " -- generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は文字を比較します。" EOL2 (CODE1 "char=") "は、全ての文字が同じなら"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の何らかの属性が違うときは"
     (CODE1 "char=") "ではありません。" EOL2 (CODE1 "char/=") "は、全ての文字が違うとき" (STRONG "true")
     "を、それ以外は" (STRONG "false") "を返却します。" EOL2 (CODE1 "char<") "は、文字が単調増加のとき"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、"
     (CODE1 "char<") "の順序は文字コードを数値として" (CODE1 "<") "で比較したものと同じです。" EOL2 (CODE1 "char>")
     "は、文字が単調減少の場合は" (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。"
     "もし2つの文字の属性が等しいとき、" (CODE1 "char>") "の順序は文字コードを数値として" (CODE1 ">") "で比較したものと同じです。"
     EOL2 (CODE1 "char<=") "は、文字が単調非減少のとき" (STRONG "true") "を、それ以外は" (STRONG "false")
     "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char<=") "の順序は文字コードを数値として" (CODE1 "<=")
     "で比較したものと同じです。" EOL2 (CODE1 "char>=") "は、文字が単調非増加の場合は" (STRONG "true") "を、それ以外は"
     (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char>=") "の順序は文字コードを数値として"
     (CODE1 ">=") "で比較したものと同じです。" EOL2 (CODE1 "char-equal") ", " (CODE1 "char-not-equal")
     "," (CODE1 "char-lessp") ", " (CODE1 "char-greaterp") ","
     (CODE1 "char-not-greaterp") ", " (CODE1 "char-not-lessp") "は、" "順に" (CODE1 "char=")
     ", " (CODE1 "char/=") ", " (CODE1 "char<") ", " (CODE1 "char>") "," (CODE1 "char<=")
     ", " (CODE1 "char>=") "と似ていますが、" "大文字小文字を無視します。"
     "もし文字が単純ではない場合（文字の属性がある場合。13.1.3. 文字の属性を参照）" "結果は実装で定義された動作になります。" "例えば、ある実装では"
     (CODE1 "char-equal") "などの関数では、" "属性を明確に無視するように定義しているかもしれません。" "属性に何らかの効果がある場合は、"
     "これらの比較関数の属性を定義する個所で規定しておく必要があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(char= #\\d #\\d) → true" "(char= #\\A #\\a) → false"
      "(char= #\\d #\\x) → false" "(char= #\\d #\\D) → false"
      "(char/= #\\d #\\d) → false" "(char/= #\\d #\\x) → true"
      "(char/= #\\d #\\D) → true" "(char= #\\d #\\d #\\d #\\d) → true"
      "(char/= #\\d #\\d #\\d #\\d) → false" "(char= #\\d #\\d #\\x #\\d) → false"
      "(char/= #\\d #\\d #\\x #\\d) → false" "(char= #\\d #\\y #\\x #\\c) → false"
      "(char/= #\\d #\\y #\\x #\\c) → true" "(char= #\\d #\\c #\\d) → false"
      "(char/= #\\d #\\c #\\d) → false" "(char< #\\d #\\x) → true"
      "(char<= #\\d #\\x) → true" "(char< #\\d #\\d) → false" "(char<= #\\d #\\d) → true"
      "(char< #\\a #\\e #\\y #\\z) → true" "(char<= #\\a #\\e #\\y #\\z) → true"
      "(char< #\\a #\\e #\\e #\\y) → false" "(char<= #\\a #\\e #\\e #\\y) → true"
      "(char> #\\e #\\d) → true" "(char>= #\\e #\\d) → true"
      "(char> #\\d #\\c #\\b #\\a) → true" "(char>= #\\d #\\c #\\b #\\a) → true"
      "(char> #\\d #\\d #\\c #\\a) → false" "(char>= #\\d #\\d #\\c #\\a) → true"
      "(char> #\\e #\\d #\\b #\\c #\\a) → false"
      "(char>= #\\e #\\d #\\b #\\c #\\a) → false"
      "(char> #\\z #\\A) → implementation-dependent"
      "(char> #\\Z #\\a) → implementation-dependent" "(char-equal #\\A #\\a) → true"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char-lessp)"
      "→ (#\\A #\\a #\\b #\\B #\\c #\\C)"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char<)"
      "→ (#\\A #\\B #\\C #\\a #\\b #\\c) ;実装A" "→ (#\\a #\\b #\\c #\\A #\\B #\\C) ;実装B"
      "→ (#\\a #\\A #\\b #\\B #\\c #\\C) ;実装C" "→ (#\\A #\\a #\\B #\\b #\\C #\\c) ;実装D"
      "→ (#\\A #\\B #\\a #\\b #\\C #\\c) ;実装E"))
    (CHAPTER ("## 例外") 2 "もし少なくとも1文字も与えられなかった場合は、" "型" (CODE1 "program-error")
     "のエラーが発せられます。")
    (CHAPTER ("## 参考") 2 "2.1. 文字の構文, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "文字がコードの属性かあるいは実装定義の属性で異なる場合、" (CODE1 "char=")
     "によって異なるものとしてみなされます。" EOL2 (CODE1 "(char= c1 c2)") "が" (STRONG "true") "のときに、"
     (CODE1 "(eq c1 c2)") "が" (STRONG "true") "である必要はありません。" (CODE1 "eq") "は、"
     (CODE1 "char=") "が区別できないような2つの文字を区別できますが、" "それは文字として区別しているのではなく、"
     "低レベルの実装の特性に基づいて行われています。" "もし" (CODE1 "(eq c1 c2)") "が" (STRONG "true") "のときは、"
     (CODE1 "(char= c1 c2)") "もまた" (STRONG "true") "です。" "文字の" (CODE1 "eql") "と"
     (CODE1 "equal") "の比較は、" (CODE1 "char=") "と同じ方法で行われます。" EOL2 "関数"
     (CODE1 "char-equal") "," (CODE1 "char-not-equal") "," (CODE1 "char-lessp") ","
     (CODE1 "char-greaterp") "," (CODE1 "char-not-greaterp") "," (CODE1 "char-not-lessp")
     "において、" (CODE1 "standard-char") "の大文字小文字の比較は、" "暗に標準文字の" (CODE1 "A=a") ", "
     (CODE1 "B=b") ", " (CODE1 "...") ", " (CODE1 "Z=z") "、" "さらに、" (CODE1 "9<A")
     "か、あるいは" (CODE1 "Z<0") "の" "どちらかで順序付けされることを意味します。")))
(setf (gethash '("CHAR-NOT-GREATERP" . "FUNCTION") *table*) (gethash "CHAR-NOT-GREATERP" *table*))
(setf (gethash "CHAR-NOT-LESSP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR=") ", " (CODE1 "CHAR/=") ", " (CODE1 "CHAR<")
     ", " (CODE1 "CHAR>") ", " (CODE1 "CHAR<=") ", " (CODE1 "CHAR>=") ","
     (CODE1 "CHAR-EQUAL") ", " (CODE1 "CHAR-NOT-EQUAL") "," (CODE1 "CHAR-LESSP") ", "
     (CODE1 "CHAR-GREATERP") "," (CODE1 "CHAR-NOT-GREATERP") ", "
     (CODE1 "CHAR-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "char=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char/=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char<") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char>")
     " &rest " (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char<=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char>=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char-equal") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-equal") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-lessp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-greaterp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-not-greaterp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-lessp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " -- 文字" EOL1
     (STRONG "generalized-boolean") " -- generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は文字を比較します。" EOL2 (CODE1 "char=") "は、全ての文字が同じなら"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の何らかの属性が違うときは"
     (CODE1 "char=") "ではありません。" EOL2 (CODE1 "char/=") "は、全ての文字が違うとき" (STRONG "true")
     "を、それ以外は" (STRONG "false") "を返却します。" EOL2 (CODE1 "char<") "は、文字が単調増加のとき"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、"
     (CODE1 "char<") "の順序は文字コードを数値として" (CODE1 "<") "で比較したものと同じです。" EOL2 (CODE1 "char>")
     "は、文字が単調減少の場合は" (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。"
     "もし2つの文字の属性が等しいとき、" (CODE1 "char>") "の順序は文字コードを数値として" (CODE1 ">") "で比較したものと同じです。"
     EOL2 (CODE1 "char<=") "は、文字が単調非減少のとき" (STRONG "true") "を、それ以外は" (STRONG "false")
     "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char<=") "の順序は文字コードを数値として" (CODE1 "<=")
     "で比較したものと同じです。" EOL2 (CODE1 "char>=") "は、文字が単調非増加の場合は" (STRONG "true") "を、それ以外は"
     (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char>=") "の順序は文字コードを数値として"
     (CODE1 ">=") "で比較したものと同じです。" EOL2 (CODE1 "char-equal") ", " (CODE1 "char-not-equal")
     "," (CODE1 "char-lessp") ", " (CODE1 "char-greaterp") ","
     (CODE1 "char-not-greaterp") ", " (CODE1 "char-not-lessp") "は、" "順に" (CODE1 "char=")
     ", " (CODE1 "char/=") ", " (CODE1 "char<") ", " (CODE1 "char>") "," (CODE1 "char<=")
     ", " (CODE1 "char>=") "と似ていますが、" "大文字小文字を無視します。"
     "もし文字が単純ではない場合（文字の属性がある場合。13.1.3. 文字の属性を参照）" "結果は実装で定義された動作になります。" "例えば、ある実装では"
     (CODE1 "char-equal") "などの関数では、" "属性を明確に無視するように定義しているかもしれません。" "属性に何らかの効果がある場合は、"
     "これらの比較関数の属性を定義する個所で規定しておく必要があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(char= #\\d #\\d) → true" "(char= #\\A #\\a) → false"
      "(char= #\\d #\\x) → false" "(char= #\\d #\\D) → false"
      "(char/= #\\d #\\d) → false" "(char/= #\\d #\\x) → true"
      "(char/= #\\d #\\D) → true" "(char= #\\d #\\d #\\d #\\d) → true"
      "(char/= #\\d #\\d #\\d #\\d) → false" "(char= #\\d #\\d #\\x #\\d) → false"
      "(char/= #\\d #\\d #\\x #\\d) → false" "(char= #\\d #\\y #\\x #\\c) → false"
      "(char/= #\\d #\\y #\\x #\\c) → true" "(char= #\\d #\\c #\\d) → false"
      "(char/= #\\d #\\c #\\d) → false" "(char< #\\d #\\x) → true"
      "(char<= #\\d #\\x) → true" "(char< #\\d #\\d) → false" "(char<= #\\d #\\d) → true"
      "(char< #\\a #\\e #\\y #\\z) → true" "(char<= #\\a #\\e #\\y #\\z) → true"
      "(char< #\\a #\\e #\\e #\\y) → false" "(char<= #\\a #\\e #\\e #\\y) → true"
      "(char> #\\e #\\d) → true" "(char>= #\\e #\\d) → true"
      "(char> #\\d #\\c #\\b #\\a) → true" "(char>= #\\d #\\c #\\b #\\a) → true"
      "(char> #\\d #\\d #\\c #\\a) → false" "(char>= #\\d #\\d #\\c #\\a) → true"
      "(char> #\\e #\\d #\\b #\\c #\\a) → false"
      "(char>= #\\e #\\d #\\b #\\c #\\a) → false"
      "(char> #\\z #\\A) → implementation-dependent"
      "(char> #\\Z #\\a) → implementation-dependent" "(char-equal #\\A #\\a) → true"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char-lessp)"
      "→ (#\\A #\\a #\\b #\\B #\\c #\\C)"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char<)"
      "→ (#\\A #\\B #\\C #\\a #\\b #\\c) ;実装A" "→ (#\\a #\\b #\\c #\\A #\\B #\\C) ;実装B"
      "→ (#\\a #\\A #\\b #\\B #\\c #\\C) ;実装C" "→ (#\\A #\\a #\\B #\\b #\\C #\\c) ;実装D"
      "→ (#\\A #\\B #\\a #\\b #\\C #\\c) ;実装E"))
    (CHAPTER ("## 例外") 2 "もし少なくとも1文字も与えられなかった場合は、" "型" (CODE1 "program-error")
     "のエラーが発せられます。")
    (CHAPTER ("## 参考") 2 "2.1. 文字の構文, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "文字がコードの属性かあるいは実装定義の属性で異なる場合、" (CODE1 "char=")
     "によって異なるものとしてみなされます。" EOL2 (CODE1 "(char= c1 c2)") "が" (STRONG "true") "のときに、"
     (CODE1 "(eq c1 c2)") "が" (STRONG "true") "である必要はありません。" (CODE1 "eq") "は、"
     (CODE1 "char=") "が区別できないような2つの文字を区別できますが、" "それは文字として区別しているのではなく、"
     "低レベルの実装の特性に基づいて行われています。" "もし" (CODE1 "(eq c1 c2)") "が" (STRONG "true") "のときは、"
     (CODE1 "(char= c1 c2)") "もまた" (STRONG "true") "です。" "文字の" (CODE1 "eql") "と"
     (CODE1 "equal") "の比較は、" (CODE1 "char=") "と同じ方法で行われます。" EOL2 "関数"
     (CODE1 "char-equal") "," (CODE1 "char-not-equal") "," (CODE1 "char-lessp") ","
     (CODE1 "char-greaterp") "," (CODE1 "char-not-greaterp") "," (CODE1 "char-not-lessp")
     "において、" (CODE1 "standard-char") "の大文字小文字の比較は、" "暗に標準文字の" (CODE1 "A=a") ", "
     (CODE1 "B=b") ", " (CODE1 "...") ", " (CODE1 "Z=z") "、" "さらに、" (CODE1 "9<A")
     "か、あるいは" (CODE1 "Z<0") "の" "どちらかで順序付けされることを意味します。")))
(setf (gethash '("CHAR-NOT-LESSP" . "FUNCTION") *table*) (gethash "CHAR-NOT-LESSP" *table*))
(setf (gethash "CHAR-UPCASE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR-UPCASE") ", " (CODE1 "CHAR-DOWNCASE"))
    (CHAPTER ("## 構文") 2 (CODE1 "char-upcase") " " (STRONG "character") " => "
     (STRONG "corresponding-character") EOL1 (CODE1 "char-downcase") " "
     (STRONG "character") " => " (STRONG "corresponding-character"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") ", " (STRONG "corresponding-character")
     " - 文字")
    (CHAPTER ("## 定義") 2 (STRONG "character") "が小文字なら、" (CODE1 "char-upcase")
     "は大文字を返却します。" "それ以外はただ引数の文字をそのまま返却します。" EOL2 (STRONG "character") "が大文字なら、"
     (CODE1 "char-downcase") "は小文字を返却します。" "それ以外はただ引数の文字をそのまま返却します。" EOL2
     (STRONG "character") "と返却値では、ただ文字コードの属性のみが違っており、" "その他のすべての実装定義の属性は保存されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(char-upcase #\\a) =>  #\\A" "(char-upcase #\\A) =>  #\\A"
      "(char-downcase #\\a) =>  #\\a" "(char-downcase #\\A) =>  #\\a"
      "(char-upcase #\\9) =>  #\\9" "(char-downcase #\\9) =>  #\\9"
      "(char-upcase #\\@) =>  #\\@" "(char-downcase #\\@) =>  #\\@" NIL
      ";; 注意：次の例文は、もしCHAR-CODE-LIMITの値が非常に大きい実装の場合は、" ";;       おそらく非常に長い時間かかるだろう。"
      "(dotimes (code char-code-limit)" "  (let ((char (code-char code)))"
      "    (when char"
      "      (unless (cond ((upper-case-p char) (char= (char-upcase (char-downcase char)) char))"
      "                    ((lower-case-p char) (char= (char-downcase (char-upcase char)) char))"
      "                     (t (and (char= (char-upcase (char-downcase char)) char)"
      "                             (char= (char-downcase (char-upcase char)) char))))"
      "        (return char)))))" "=>  NIL"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "character") "が文字ではなかったら、型" (CODE1 "type-error")
     "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 (CODE1 "upper-case-p") ", " (CODE1 "alpha-char-p")
     ", 13.1.4.3. 文字のケース, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "corresponding-character") "が" (STRONG "character")
     "と違う場合は、" (STRONG "corresponding-character") "と" (STRONG "character") "両方に"
     "ケース(大文字と小文字のこと)があるということになります。" EOL2 (CODE1 "char-equal") "は文字の比較の際にケースを無視するため、"
     (STRONG "corresponding-character") "は" (STRONG "character") "と" (CODE1 "char-equal")
     "での" "比較においては常に等しいです。")))
(setf (gethash '("CHAR-UPCASE" . "FUNCTION") *table*) (gethash "CHAR-UPCASE" *table*))
(setf (gethash "CHAR/=" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR=") ", " (CODE1 "CHAR/=") ", " (CODE1 "CHAR<")
     ", " (CODE1 "CHAR>") ", " (CODE1 "CHAR<=") ", " (CODE1 "CHAR>=") ","
     (CODE1 "CHAR-EQUAL") ", " (CODE1 "CHAR-NOT-EQUAL") "," (CODE1 "CHAR-LESSP") ", "
     (CODE1 "CHAR-GREATERP") "," (CODE1 "CHAR-NOT-GREATERP") ", "
     (CODE1 "CHAR-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "char=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char/=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char<") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char>")
     " &rest " (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char<=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char>=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char-equal") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-equal") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-lessp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-greaterp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-not-greaterp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-lessp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " -- 文字" EOL1
     (STRONG "generalized-boolean") " -- generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は文字を比較します。" EOL2 (CODE1 "char=") "は、全ての文字が同じなら"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の何らかの属性が違うときは"
     (CODE1 "char=") "ではありません。" EOL2 (CODE1 "char/=") "は、全ての文字が違うとき" (STRONG "true")
     "を、それ以外は" (STRONG "false") "を返却します。" EOL2 (CODE1 "char<") "は、文字が単調増加のとき"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、"
     (CODE1 "char<") "の順序は文字コードを数値として" (CODE1 "<") "で比較したものと同じです。" EOL2 (CODE1 "char>")
     "は、文字が単調減少の場合は" (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。"
     "もし2つの文字の属性が等しいとき、" (CODE1 "char>") "の順序は文字コードを数値として" (CODE1 ">") "で比較したものと同じです。"
     EOL2 (CODE1 "char<=") "は、文字が単調非減少のとき" (STRONG "true") "を、それ以外は" (STRONG "false")
     "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char<=") "の順序は文字コードを数値として" (CODE1 "<=")
     "で比較したものと同じです。" EOL2 (CODE1 "char>=") "は、文字が単調非増加の場合は" (STRONG "true") "を、それ以外は"
     (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char>=") "の順序は文字コードを数値として"
     (CODE1 ">=") "で比較したものと同じです。" EOL2 (CODE1 "char-equal") ", " (CODE1 "char-not-equal")
     "," (CODE1 "char-lessp") ", " (CODE1 "char-greaterp") ","
     (CODE1 "char-not-greaterp") ", " (CODE1 "char-not-lessp") "は、" "順に" (CODE1 "char=")
     ", " (CODE1 "char/=") ", " (CODE1 "char<") ", " (CODE1 "char>") "," (CODE1 "char<=")
     ", " (CODE1 "char>=") "と似ていますが、" "大文字小文字を無視します。"
     "もし文字が単純ではない場合（文字の属性がある場合。13.1.3. 文字の属性を参照）" "結果は実装で定義された動作になります。" "例えば、ある実装では"
     (CODE1 "char-equal") "などの関数では、" "属性を明確に無視するように定義しているかもしれません。" "属性に何らかの効果がある場合は、"
     "これらの比較関数の属性を定義する個所で規定しておく必要があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(char= #\\d #\\d) → true" "(char= #\\A #\\a) → false"
      "(char= #\\d #\\x) → false" "(char= #\\d #\\D) → false"
      "(char/= #\\d #\\d) → false" "(char/= #\\d #\\x) → true"
      "(char/= #\\d #\\D) → true" "(char= #\\d #\\d #\\d #\\d) → true"
      "(char/= #\\d #\\d #\\d #\\d) → false" "(char= #\\d #\\d #\\x #\\d) → false"
      "(char/= #\\d #\\d #\\x #\\d) → false" "(char= #\\d #\\y #\\x #\\c) → false"
      "(char/= #\\d #\\y #\\x #\\c) → true" "(char= #\\d #\\c #\\d) → false"
      "(char/= #\\d #\\c #\\d) → false" "(char< #\\d #\\x) → true"
      "(char<= #\\d #\\x) → true" "(char< #\\d #\\d) → false" "(char<= #\\d #\\d) → true"
      "(char< #\\a #\\e #\\y #\\z) → true" "(char<= #\\a #\\e #\\y #\\z) → true"
      "(char< #\\a #\\e #\\e #\\y) → false" "(char<= #\\a #\\e #\\e #\\y) → true"
      "(char> #\\e #\\d) → true" "(char>= #\\e #\\d) → true"
      "(char> #\\d #\\c #\\b #\\a) → true" "(char>= #\\d #\\c #\\b #\\a) → true"
      "(char> #\\d #\\d #\\c #\\a) → false" "(char>= #\\d #\\d #\\c #\\a) → true"
      "(char> #\\e #\\d #\\b #\\c #\\a) → false"
      "(char>= #\\e #\\d #\\b #\\c #\\a) → false"
      "(char> #\\z #\\A) → implementation-dependent"
      "(char> #\\Z #\\a) → implementation-dependent" "(char-equal #\\A #\\a) → true"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char-lessp)"
      "→ (#\\A #\\a #\\b #\\B #\\c #\\C)"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char<)"
      "→ (#\\A #\\B #\\C #\\a #\\b #\\c) ;実装A" "→ (#\\a #\\b #\\c #\\A #\\B #\\C) ;実装B"
      "→ (#\\a #\\A #\\b #\\B #\\c #\\C) ;実装C" "→ (#\\A #\\a #\\B #\\b #\\C #\\c) ;実装D"
      "→ (#\\A #\\B #\\a #\\b #\\C #\\c) ;実装E"))
    (CHAPTER ("## 例外") 2 "もし少なくとも1文字も与えられなかった場合は、" "型" (CODE1 "program-error")
     "のエラーが発せられます。")
    (CHAPTER ("## 参考") 2 "2.1. 文字の構文, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "文字がコードの属性かあるいは実装定義の属性で異なる場合、" (CODE1 "char=")
     "によって異なるものとしてみなされます。" EOL2 (CODE1 "(char= c1 c2)") "が" (STRONG "true") "のときに、"
     (CODE1 "(eq c1 c2)") "が" (STRONG "true") "である必要はありません。" (CODE1 "eq") "は、"
     (CODE1 "char=") "が区別できないような2つの文字を区別できますが、" "それは文字として区別しているのではなく、"
     "低レベルの実装の特性に基づいて行われています。" "もし" (CODE1 "(eq c1 c2)") "が" (STRONG "true") "のときは、"
     (CODE1 "(char= c1 c2)") "もまた" (STRONG "true") "です。" "文字の" (CODE1 "eql") "と"
     (CODE1 "equal") "の比較は、" (CODE1 "char=") "と同じ方法で行われます。" EOL2 "関数"
     (CODE1 "char-equal") "," (CODE1 "char-not-equal") "," (CODE1 "char-lessp") ","
     (CODE1 "char-greaterp") "," (CODE1 "char-not-greaterp") "," (CODE1 "char-not-lessp")
     "において、" (CODE1 "standard-char") "の大文字小文字の比較は、" "暗に標準文字の" (CODE1 "A=a") ", "
     (CODE1 "B=b") ", " (CODE1 "...") ", " (CODE1 "Z=z") "、" "さらに、" (CODE1 "9<A")
     "か、あるいは" (CODE1 "Z<0") "の" "どちらかで順序付けされることを意味します。")))
(setf (gethash '("CHAR/=" . "FUNCTION") *table*) (gethash "CHAR/=" *table*))
(setf (gethash "CHAR<" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR=") ", " (CODE1 "CHAR/=") ", " (CODE1 "CHAR<")
     ", " (CODE1 "CHAR>") ", " (CODE1 "CHAR<=") ", " (CODE1 "CHAR>=") ","
     (CODE1 "CHAR-EQUAL") ", " (CODE1 "CHAR-NOT-EQUAL") "," (CODE1 "CHAR-LESSP") ", "
     (CODE1 "CHAR-GREATERP") "," (CODE1 "CHAR-NOT-GREATERP") ", "
     (CODE1 "CHAR-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "char=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char/=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char<") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char>")
     " &rest " (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char<=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char>=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char-equal") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-equal") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-lessp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-greaterp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-not-greaterp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-lessp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " -- 文字" EOL1
     (STRONG "generalized-boolean") " -- generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は文字を比較します。" EOL2 (CODE1 "char=") "は、全ての文字が同じなら"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の何らかの属性が違うときは"
     (CODE1 "char=") "ではありません。" EOL2 (CODE1 "char/=") "は、全ての文字が違うとき" (STRONG "true")
     "を、それ以外は" (STRONG "false") "を返却します。" EOL2 (CODE1 "char<") "は、文字が単調増加のとき"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、"
     (CODE1 "char<") "の順序は文字コードを数値として" (CODE1 "<") "で比較したものと同じです。" EOL2 (CODE1 "char>")
     "は、文字が単調減少の場合は" (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。"
     "もし2つの文字の属性が等しいとき、" (CODE1 "char>") "の順序は文字コードを数値として" (CODE1 ">") "で比較したものと同じです。"
     EOL2 (CODE1 "char<=") "は、文字が単調非減少のとき" (STRONG "true") "を、それ以外は" (STRONG "false")
     "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char<=") "の順序は文字コードを数値として" (CODE1 "<=")
     "で比較したものと同じです。" EOL2 (CODE1 "char>=") "は、文字が単調非増加の場合は" (STRONG "true") "を、それ以外は"
     (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char>=") "の順序は文字コードを数値として"
     (CODE1 ">=") "で比較したものと同じです。" EOL2 (CODE1 "char-equal") ", " (CODE1 "char-not-equal")
     "," (CODE1 "char-lessp") ", " (CODE1 "char-greaterp") ","
     (CODE1 "char-not-greaterp") ", " (CODE1 "char-not-lessp") "は、" "順に" (CODE1 "char=")
     ", " (CODE1 "char/=") ", " (CODE1 "char<") ", " (CODE1 "char>") "," (CODE1 "char<=")
     ", " (CODE1 "char>=") "と似ていますが、" "大文字小文字を無視します。"
     "もし文字が単純ではない場合（文字の属性がある場合。13.1.3. 文字の属性を参照）" "結果は実装で定義された動作になります。" "例えば、ある実装では"
     (CODE1 "char-equal") "などの関数では、" "属性を明確に無視するように定義しているかもしれません。" "属性に何らかの効果がある場合は、"
     "これらの比較関数の属性を定義する個所で規定しておく必要があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(char= #\\d #\\d) → true" "(char= #\\A #\\a) → false"
      "(char= #\\d #\\x) → false" "(char= #\\d #\\D) → false"
      "(char/= #\\d #\\d) → false" "(char/= #\\d #\\x) → true"
      "(char/= #\\d #\\D) → true" "(char= #\\d #\\d #\\d #\\d) → true"
      "(char/= #\\d #\\d #\\d #\\d) → false" "(char= #\\d #\\d #\\x #\\d) → false"
      "(char/= #\\d #\\d #\\x #\\d) → false" "(char= #\\d #\\y #\\x #\\c) → false"
      "(char/= #\\d #\\y #\\x #\\c) → true" "(char= #\\d #\\c #\\d) → false"
      "(char/= #\\d #\\c #\\d) → false" "(char< #\\d #\\x) → true"
      "(char<= #\\d #\\x) → true" "(char< #\\d #\\d) → false" "(char<= #\\d #\\d) → true"
      "(char< #\\a #\\e #\\y #\\z) → true" "(char<= #\\a #\\e #\\y #\\z) → true"
      "(char< #\\a #\\e #\\e #\\y) → false" "(char<= #\\a #\\e #\\e #\\y) → true"
      "(char> #\\e #\\d) → true" "(char>= #\\e #\\d) → true"
      "(char> #\\d #\\c #\\b #\\a) → true" "(char>= #\\d #\\c #\\b #\\a) → true"
      "(char> #\\d #\\d #\\c #\\a) → false" "(char>= #\\d #\\d #\\c #\\a) → true"
      "(char> #\\e #\\d #\\b #\\c #\\a) → false"
      "(char>= #\\e #\\d #\\b #\\c #\\a) → false"
      "(char> #\\z #\\A) → implementation-dependent"
      "(char> #\\Z #\\a) → implementation-dependent" "(char-equal #\\A #\\a) → true"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char-lessp)"
      "→ (#\\A #\\a #\\b #\\B #\\c #\\C)"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char<)"
      "→ (#\\A #\\B #\\C #\\a #\\b #\\c) ;実装A" "→ (#\\a #\\b #\\c #\\A #\\B #\\C) ;実装B"
      "→ (#\\a #\\A #\\b #\\B #\\c #\\C) ;実装C" "→ (#\\A #\\a #\\B #\\b #\\C #\\c) ;実装D"
      "→ (#\\A #\\B #\\a #\\b #\\C #\\c) ;実装E"))
    (CHAPTER ("## 例外") 2 "もし少なくとも1文字も与えられなかった場合は、" "型" (CODE1 "program-error")
     "のエラーが発せられます。")
    (CHAPTER ("## 参考") 2 "2.1. 文字の構文, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "文字がコードの属性かあるいは実装定義の属性で異なる場合、" (CODE1 "char=")
     "によって異なるものとしてみなされます。" EOL2 (CODE1 "(char= c1 c2)") "が" (STRONG "true") "のときに、"
     (CODE1 "(eq c1 c2)") "が" (STRONG "true") "である必要はありません。" (CODE1 "eq") "は、"
     (CODE1 "char=") "が区別できないような2つの文字を区別できますが、" "それは文字として区別しているのではなく、"
     "低レベルの実装の特性に基づいて行われています。" "もし" (CODE1 "(eq c1 c2)") "が" (STRONG "true") "のときは、"
     (CODE1 "(char= c1 c2)") "もまた" (STRONG "true") "です。" "文字の" (CODE1 "eql") "と"
     (CODE1 "equal") "の比較は、" (CODE1 "char=") "と同じ方法で行われます。" EOL2 "関数"
     (CODE1 "char-equal") "," (CODE1 "char-not-equal") "," (CODE1 "char-lessp") ","
     (CODE1 "char-greaterp") "," (CODE1 "char-not-greaterp") "," (CODE1 "char-not-lessp")
     "において、" (CODE1 "standard-char") "の大文字小文字の比較は、" "暗に標準文字の" (CODE1 "A=a") ", "
     (CODE1 "B=b") ", " (CODE1 "...") ", " (CODE1 "Z=z") "、" "さらに、" (CODE1 "9<A")
     "か、あるいは" (CODE1 "Z<0") "の" "どちらかで順序付けされることを意味します。")))
(setf (gethash '("CHAR<" . "FUNCTION") *table*) (gethash "CHAR<" *table*))
(setf (gethash "CHAR<=" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR=") ", " (CODE1 "CHAR/=") ", " (CODE1 "CHAR<")
     ", " (CODE1 "CHAR>") ", " (CODE1 "CHAR<=") ", " (CODE1 "CHAR>=") ","
     (CODE1 "CHAR-EQUAL") ", " (CODE1 "CHAR-NOT-EQUAL") "," (CODE1 "CHAR-LESSP") ", "
     (CODE1 "CHAR-GREATERP") "," (CODE1 "CHAR-NOT-GREATERP") ", "
     (CODE1 "CHAR-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "char=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char/=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char<") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char>")
     " &rest " (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char<=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char>=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char-equal") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-equal") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-lessp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-greaterp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-not-greaterp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-lessp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " -- 文字" EOL1
     (STRONG "generalized-boolean") " -- generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は文字を比較します。" EOL2 (CODE1 "char=") "は、全ての文字が同じなら"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の何らかの属性が違うときは"
     (CODE1 "char=") "ではありません。" EOL2 (CODE1 "char/=") "は、全ての文字が違うとき" (STRONG "true")
     "を、それ以外は" (STRONG "false") "を返却します。" EOL2 (CODE1 "char<") "は、文字が単調増加のとき"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、"
     (CODE1 "char<") "の順序は文字コードを数値として" (CODE1 "<") "で比較したものと同じです。" EOL2 (CODE1 "char>")
     "は、文字が単調減少の場合は" (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。"
     "もし2つの文字の属性が等しいとき、" (CODE1 "char>") "の順序は文字コードを数値として" (CODE1 ">") "で比較したものと同じです。"
     EOL2 (CODE1 "char<=") "は、文字が単調非減少のとき" (STRONG "true") "を、それ以外は" (STRONG "false")
     "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char<=") "の順序は文字コードを数値として" (CODE1 "<=")
     "で比較したものと同じです。" EOL2 (CODE1 "char>=") "は、文字が単調非増加の場合は" (STRONG "true") "を、それ以外は"
     (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char>=") "の順序は文字コードを数値として"
     (CODE1 ">=") "で比較したものと同じです。" EOL2 (CODE1 "char-equal") ", " (CODE1 "char-not-equal")
     "," (CODE1 "char-lessp") ", " (CODE1 "char-greaterp") ","
     (CODE1 "char-not-greaterp") ", " (CODE1 "char-not-lessp") "は、" "順に" (CODE1 "char=")
     ", " (CODE1 "char/=") ", " (CODE1 "char<") ", " (CODE1 "char>") "," (CODE1 "char<=")
     ", " (CODE1 "char>=") "と似ていますが、" "大文字小文字を無視します。"
     "もし文字が単純ではない場合（文字の属性がある場合。13.1.3. 文字の属性を参照）" "結果は実装で定義された動作になります。" "例えば、ある実装では"
     (CODE1 "char-equal") "などの関数では、" "属性を明確に無視するように定義しているかもしれません。" "属性に何らかの効果がある場合は、"
     "これらの比較関数の属性を定義する個所で規定しておく必要があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(char= #\\d #\\d) → true" "(char= #\\A #\\a) → false"
      "(char= #\\d #\\x) → false" "(char= #\\d #\\D) → false"
      "(char/= #\\d #\\d) → false" "(char/= #\\d #\\x) → true"
      "(char/= #\\d #\\D) → true" "(char= #\\d #\\d #\\d #\\d) → true"
      "(char/= #\\d #\\d #\\d #\\d) → false" "(char= #\\d #\\d #\\x #\\d) → false"
      "(char/= #\\d #\\d #\\x #\\d) → false" "(char= #\\d #\\y #\\x #\\c) → false"
      "(char/= #\\d #\\y #\\x #\\c) → true" "(char= #\\d #\\c #\\d) → false"
      "(char/= #\\d #\\c #\\d) → false" "(char< #\\d #\\x) → true"
      "(char<= #\\d #\\x) → true" "(char< #\\d #\\d) → false" "(char<= #\\d #\\d) → true"
      "(char< #\\a #\\e #\\y #\\z) → true" "(char<= #\\a #\\e #\\y #\\z) → true"
      "(char< #\\a #\\e #\\e #\\y) → false" "(char<= #\\a #\\e #\\e #\\y) → true"
      "(char> #\\e #\\d) → true" "(char>= #\\e #\\d) → true"
      "(char> #\\d #\\c #\\b #\\a) → true" "(char>= #\\d #\\c #\\b #\\a) → true"
      "(char> #\\d #\\d #\\c #\\a) → false" "(char>= #\\d #\\d #\\c #\\a) → true"
      "(char> #\\e #\\d #\\b #\\c #\\a) → false"
      "(char>= #\\e #\\d #\\b #\\c #\\a) → false"
      "(char> #\\z #\\A) → implementation-dependent"
      "(char> #\\Z #\\a) → implementation-dependent" "(char-equal #\\A #\\a) → true"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char-lessp)"
      "→ (#\\A #\\a #\\b #\\B #\\c #\\C)"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char<)"
      "→ (#\\A #\\B #\\C #\\a #\\b #\\c) ;実装A" "→ (#\\a #\\b #\\c #\\A #\\B #\\C) ;実装B"
      "→ (#\\a #\\A #\\b #\\B #\\c #\\C) ;実装C" "→ (#\\A #\\a #\\B #\\b #\\C #\\c) ;実装D"
      "→ (#\\A #\\B #\\a #\\b #\\C #\\c) ;実装E"))
    (CHAPTER ("## 例外") 2 "もし少なくとも1文字も与えられなかった場合は、" "型" (CODE1 "program-error")
     "のエラーが発せられます。")
    (CHAPTER ("## 参考") 2 "2.1. 文字の構文, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "文字がコードの属性かあるいは実装定義の属性で異なる場合、" (CODE1 "char=")
     "によって異なるものとしてみなされます。" EOL2 (CODE1 "(char= c1 c2)") "が" (STRONG "true") "のときに、"
     (CODE1 "(eq c1 c2)") "が" (STRONG "true") "である必要はありません。" (CODE1 "eq") "は、"
     (CODE1 "char=") "が区別できないような2つの文字を区別できますが、" "それは文字として区別しているのではなく、"
     "低レベルの実装の特性に基づいて行われています。" "もし" (CODE1 "(eq c1 c2)") "が" (STRONG "true") "のときは、"
     (CODE1 "(char= c1 c2)") "もまた" (STRONG "true") "です。" "文字の" (CODE1 "eql") "と"
     (CODE1 "equal") "の比較は、" (CODE1 "char=") "と同じ方法で行われます。" EOL2 "関数"
     (CODE1 "char-equal") "," (CODE1 "char-not-equal") "," (CODE1 "char-lessp") ","
     (CODE1 "char-greaterp") "," (CODE1 "char-not-greaterp") "," (CODE1 "char-not-lessp")
     "において、" (CODE1 "standard-char") "の大文字小文字の比較は、" "暗に標準文字の" (CODE1 "A=a") ", "
     (CODE1 "B=b") ", " (CODE1 "...") ", " (CODE1 "Z=z") "、" "さらに、" (CODE1 "9<A")
     "か、あるいは" (CODE1 "Z<0") "の" "どちらかで順序付けされることを意味します。")))
(setf (gethash '("CHAR<=" . "FUNCTION") *table*) (gethash "CHAR<=" *table*))
(setf (gethash "CHAR=" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR=") ", " (CODE1 "CHAR/=") ", " (CODE1 "CHAR<")
     ", " (CODE1 "CHAR>") ", " (CODE1 "CHAR<=") ", " (CODE1 "CHAR>=") ","
     (CODE1 "CHAR-EQUAL") ", " (CODE1 "CHAR-NOT-EQUAL") "," (CODE1 "CHAR-LESSP") ", "
     (CODE1 "CHAR-GREATERP") "," (CODE1 "CHAR-NOT-GREATERP") ", "
     (CODE1 "CHAR-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "char=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char/=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char<") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char>")
     " &rest " (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char<=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char>=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char-equal") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-equal") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-lessp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-greaterp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-not-greaterp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-lessp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " -- 文字" EOL1
     (STRONG "generalized-boolean") " -- generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は文字を比較します。" EOL2 (CODE1 "char=") "は、全ての文字が同じなら"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の何らかの属性が違うときは"
     (CODE1 "char=") "ではありません。" EOL2 (CODE1 "char/=") "は、全ての文字が違うとき" (STRONG "true")
     "を、それ以外は" (STRONG "false") "を返却します。" EOL2 (CODE1 "char<") "は、文字が単調増加のとき"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、"
     (CODE1 "char<") "の順序は文字コードを数値として" (CODE1 "<") "で比較したものと同じです。" EOL2 (CODE1 "char>")
     "は、文字が単調減少の場合は" (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。"
     "もし2つの文字の属性が等しいとき、" (CODE1 "char>") "の順序は文字コードを数値として" (CODE1 ">") "で比較したものと同じです。"
     EOL2 (CODE1 "char<=") "は、文字が単調非減少のとき" (STRONG "true") "を、それ以外は" (STRONG "false")
     "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char<=") "の順序は文字コードを数値として" (CODE1 "<=")
     "で比較したものと同じです。" EOL2 (CODE1 "char>=") "は、文字が単調非増加の場合は" (STRONG "true") "を、それ以外は"
     (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char>=") "の順序は文字コードを数値として"
     (CODE1 ">=") "で比較したものと同じです。" EOL2 (CODE1 "char-equal") ", " (CODE1 "char-not-equal")
     "," (CODE1 "char-lessp") ", " (CODE1 "char-greaterp") ","
     (CODE1 "char-not-greaterp") ", " (CODE1 "char-not-lessp") "は、" "順に" (CODE1 "char=")
     ", " (CODE1 "char/=") ", " (CODE1 "char<") ", " (CODE1 "char>") "," (CODE1 "char<=")
     ", " (CODE1 "char>=") "と似ていますが、" "大文字小文字を無視します。"
     "もし文字が単純ではない場合（文字の属性がある場合。13.1.3. 文字の属性を参照）" "結果は実装で定義された動作になります。" "例えば、ある実装では"
     (CODE1 "char-equal") "などの関数では、" "属性を明確に無視するように定義しているかもしれません。" "属性に何らかの効果がある場合は、"
     "これらの比較関数の属性を定義する個所で規定しておく必要があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(char= #\\d #\\d) → true" "(char= #\\A #\\a) → false"
      "(char= #\\d #\\x) → false" "(char= #\\d #\\D) → false"
      "(char/= #\\d #\\d) → false" "(char/= #\\d #\\x) → true"
      "(char/= #\\d #\\D) → true" "(char= #\\d #\\d #\\d #\\d) → true"
      "(char/= #\\d #\\d #\\d #\\d) → false" "(char= #\\d #\\d #\\x #\\d) → false"
      "(char/= #\\d #\\d #\\x #\\d) → false" "(char= #\\d #\\y #\\x #\\c) → false"
      "(char/= #\\d #\\y #\\x #\\c) → true" "(char= #\\d #\\c #\\d) → false"
      "(char/= #\\d #\\c #\\d) → false" "(char< #\\d #\\x) → true"
      "(char<= #\\d #\\x) → true" "(char< #\\d #\\d) → false" "(char<= #\\d #\\d) → true"
      "(char< #\\a #\\e #\\y #\\z) → true" "(char<= #\\a #\\e #\\y #\\z) → true"
      "(char< #\\a #\\e #\\e #\\y) → false" "(char<= #\\a #\\e #\\e #\\y) → true"
      "(char> #\\e #\\d) → true" "(char>= #\\e #\\d) → true"
      "(char> #\\d #\\c #\\b #\\a) → true" "(char>= #\\d #\\c #\\b #\\a) → true"
      "(char> #\\d #\\d #\\c #\\a) → false" "(char>= #\\d #\\d #\\c #\\a) → true"
      "(char> #\\e #\\d #\\b #\\c #\\a) → false"
      "(char>= #\\e #\\d #\\b #\\c #\\a) → false"
      "(char> #\\z #\\A) → implementation-dependent"
      "(char> #\\Z #\\a) → implementation-dependent" "(char-equal #\\A #\\a) → true"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char-lessp)"
      "→ (#\\A #\\a #\\b #\\B #\\c #\\C)"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char<)"
      "→ (#\\A #\\B #\\C #\\a #\\b #\\c) ;実装A" "→ (#\\a #\\b #\\c #\\A #\\B #\\C) ;実装B"
      "→ (#\\a #\\A #\\b #\\B #\\c #\\C) ;実装C" "→ (#\\A #\\a #\\B #\\b #\\C #\\c) ;実装D"
      "→ (#\\A #\\B #\\a #\\b #\\C #\\c) ;実装E"))
    (CHAPTER ("## 例外") 2 "もし少なくとも1文字も与えられなかった場合は、" "型" (CODE1 "program-error")
     "のエラーが発せられます。")
    (CHAPTER ("## 参考") 2 "2.1. 文字の構文, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "文字がコードの属性かあるいは実装定義の属性で異なる場合、" (CODE1 "char=")
     "によって異なるものとしてみなされます。" EOL2 (CODE1 "(char= c1 c2)") "が" (STRONG "true") "のときに、"
     (CODE1 "(eq c1 c2)") "が" (STRONG "true") "である必要はありません。" (CODE1 "eq") "は、"
     (CODE1 "char=") "が区別できないような2つの文字を区別できますが、" "それは文字として区別しているのではなく、"
     "低レベルの実装の特性に基づいて行われています。" "もし" (CODE1 "(eq c1 c2)") "が" (STRONG "true") "のときは、"
     (CODE1 "(char= c1 c2)") "もまた" (STRONG "true") "です。" "文字の" (CODE1 "eql") "と"
     (CODE1 "equal") "の比較は、" (CODE1 "char=") "と同じ方法で行われます。" EOL2 "関数"
     (CODE1 "char-equal") "," (CODE1 "char-not-equal") "," (CODE1 "char-lessp") ","
     (CODE1 "char-greaterp") "," (CODE1 "char-not-greaterp") "," (CODE1 "char-not-lessp")
     "において、" (CODE1 "standard-char") "の大文字小文字の比較は、" "暗に標準文字の" (CODE1 "A=a") ", "
     (CODE1 "B=b") ", " (CODE1 "...") ", " (CODE1 "Z=z") "、" "さらに、" (CODE1 "9<A")
     "か、あるいは" (CODE1 "Z<0") "の" "どちらかで順序付けされることを意味します。")))
(setf (gethash '("CHAR=" . "FUNCTION") *table*) (gethash "CHAR=" *table*))
(setf (gethash "CHAR>" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR=") ", " (CODE1 "CHAR/=") ", " (CODE1 "CHAR<")
     ", " (CODE1 "CHAR>") ", " (CODE1 "CHAR<=") ", " (CODE1 "CHAR>=") ","
     (CODE1 "CHAR-EQUAL") ", " (CODE1 "CHAR-NOT-EQUAL") "," (CODE1 "CHAR-LESSP") ", "
     (CODE1 "CHAR-GREATERP") "," (CODE1 "CHAR-NOT-GREATERP") ", "
     (CODE1 "CHAR-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "char=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char/=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char<") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char>")
     " &rest " (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char<=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char>=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char-equal") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-equal") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-lessp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-greaterp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-not-greaterp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-lessp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " -- 文字" EOL1
     (STRONG "generalized-boolean") " -- generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は文字を比較します。" EOL2 (CODE1 "char=") "は、全ての文字が同じなら"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の何らかの属性が違うときは"
     (CODE1 "char=") "ではありません。" EOL2 (CODE1 "char/=") "は、全ての文字が違うとき" (STRONG "true")
     "を、それ以外は" (STRONG "false") "を返却します。" EOL2 (CODE1 "char<") "は、文字が単調増加のとき"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、"
     (CODE1 "char<") "の順序は文字コードを数値として" (CODE1 "<") "で比較したものと同じです。" EOL2 (CODE1 "char>")
     "は、文字が単調減少の場合は" (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。"
     "もし2つの文字の属性が等しいとき、" (CODE1 "char>") "の順序は文字コードを数値として" (CODE1 ">") "で比較したものと同じです。"
     EOL2 (CODE1 "char<=") "は、文字が単調非減少のとき" (STRONG "true") "を、それ以外は" (STRONG "false")
     "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char<=") "の順序は文字コードを数値として" (CODE1 "<=")
     "で比較したものと同じです。" EOL2 (CODE1 "char>=") "は、文字が単調非増加の場合は" (STRONG "true") "を、それ以外は"
     (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char>=") "の順序は文字コードを数値として"
     (CODE1 ">=") "で比較したものと同じです。" EOL2 (CODE1 "char-equal") ", " (CODE1 "char-not-equal")
     "," (CODE1 "char-lessp") ", " (CODE1 "char-greaterp") ","
     (CODE1 "char-not-greaterp") ", " (CODE1 "char-not-lessp") "は、" "順に" (CODE1 "char=")
     ", " (CODE1 "char/=") ", " (CODE1 "char<") ", " (CODE1 "char>") "," (CODE1 "char<=")
     ", " (CODE1 "char>=") "と似ていますが、" "大文字小文字を無視します。"
     "もし文字が単純ではない場合（文字の属性がある場合。13.1.3. 文字の属性を参照）" "結果は実装で定義された動作になります。" "例えば、ある実装では"
     (CODE1 "char-equal") "などの関数では、" "属性を明確に無視するように定義しているかもしれません。" "属性に何らかの効果がある場合は、"
     "これらの比較関数の属性を定義する個所で規定しておく必要があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(char= #\\d #\\d) → true" "(char= #\\A #\\a) → false"
      "(char= #\\d #\\x) → false" "(char= #\\d #\\D) → false"
      "(char/= #\\d #\\d) → false" "(char/= #\\d #\\x) → true"
      "(char/= #\\d #\\D) → true" "(char= #\\d #\\d #\\d #\\d) → true"
      "(char/= #\\d #\\d #\\d #\\d) → false" "(char= #\\d #\\d #\\x #\\d) → false"
      "(char/= #\\d #\\d #\\x #\\d) → false" "(char= #\\d #\\y #\\x #\\c) → false"
      "(char/= #\\d #\\y #\\x #\\c) → true" "(char= #\\d #\\c #\\d) → false"
      "(char/= #\\d #\\c #\\d) → false" "(char< #\\d #\\x) → true"
      "(char<= #\\d #\\x) → true" "(char< #\\d #\\d) → false" "(char<= #\\d #\\d) → true"
      "(char< #\\a #\\e #\\y #\\z) → true" "(char<= #\\a #\\e #\\y #\\z) → true"
      "(char< #\\a #\\e #\\e #\\y) → false" "(char<= #\\a #\\e #\\e #\\y) → true"
      "(char> #\\e #\\d) → true" "(char>= #\\e #\\d) → true"
      "(char> #\\d #\\c #\\b #\\a) → true" "(char>= #\\d #\\c #\\b #\\a) → true"
      "(char> #\\d #\\d #\\c #\\a) → false" "(char>= #\\d #\\d #\\c #\\a) → true"
      "(char> #\\e #\\d #\\b #\\c #\\a) → false"
      "(char>= #\\e #\\d #\\b #\\c #\\a) → false"
      "(char> #\\z #\\A) → implementation-dependent"
      "(char> #\\Z #\\a) → implementation-dependent" "(char-equal #\\A #\\a) → true"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char-lessp)"
      "→ (#\\A #\\a #\\b #\\B #\\c #\\C)"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char<)"
      "→ (#\\A #\\B #\\C #\\a #\\b #\\c) ;実装A" "→ (#\\a #\\b #\\c #\\A #\\B #\\C) ;実装B"
      "→ (#\\a #\\A #\\b #\\B #\\c #\\C) ;実装C" "→ (#\\A #\\a #\\B #\\b #\\C #\\c) ;実装D"
      "→ (#\\A #\\B #\\a #\\b #\\C #\\c) ;実装E"))
    (CHAPTER ("## 例外") 2 "もし少なくとも1文字も与えられなかった場合は、" "型" (CODE1 "program-error")
     "のエラーが発せられます。")
    (CHAPTER ("## 参考") 2 "2.1. 文字の構文, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "文字がコードの属性かあるいは実装定義の属性で異なる場合、" (CODE1 "char=")
     "によって異なるものとしてみなされます。" EOL2 (CODE1 "(char= c1 c2)") "が" (STRONG "true") "のときに、"
     (CODE1 "(eq c1 c2)") "が" (STRONG "true") "である必要はありません。" (CODE1 "eq") "は、"
     (CODE1 "char=") "が区別できないような2つの文字を区別できますが、" "それは文字として区別しているのではなく、"
     "低レベルの実装の特性に基づいて行われています。" "もし" (CODE1 "(eq c1 c2)") "が" (STRONG "true") "のときは、"
     (CODE1 "(char= c1 c2)") "もまた" (STRONG "true") "です。" "文字の" (CODE1 "eql") "と"
     (CODE1 "equal") "の比較は、" (CODE1 "char=") "と同じ方法で行われます。" EOL2 "関数"
     (CODE1 "char-equal") "," (CODE1 "char-not-equal") "," (CODE1 "char-lessp") ","
     (CODE1 "char-greaterp") "," (CODE1 "char-not-greaterp") "," (CODE1 "char-not-lessp")
     "において、" (CODE1 "standard-char") "の大文字小文字の比較は、" "暗に標準文字の" (CODE1 "A=a") ", "
     (CODE1 "B=b") ", " (CODE1 "...") ", " (CODE1 "Z=z") "、" "さらに、" (CODE1 "9<A")
     "か、あるいは" (CODE1 "Z<0") "の" "どちらかで順序付けされることを意味します。")))
(setf (gethash '("CHAR>" . "FUNCTION") *table*) (gethash "CHAR>" *table*))
(setf (gethash "CHAR>=" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHAR=") ", " (CODE1 "CHAR/=") ", " (CODE1 "CHAR<")
     ", " (CODE1 "CHAR>") ", " (CODE1 "CHAR<=") ", " (CODE1 "CHAR>=") ","
     (CODE1 "CHAR-EQUAL") ", " (CODE1 "CHAR-NOT-EQUAL") "," (CODE1 "CHAR-LESSP") ", "
     (CODE1 "CHAR-GREATERP") "," (CODE1 "CHAR-NOT-GREATERP") ", "
     (CODE1 "CHAR-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "char=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char/=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char<") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char>")
     " &rest " (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char<=") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char>=") " &rest " (STRONG "characters")
     "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "char-equal") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-equal") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-lessp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-greaterp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "char-not-greaterp") " &rest "
     (STRONG "characters") "+ => " (STRONG "generalized-boolean") EOL1
     (CODE1 "char-not-lessp") " &rest " (STRONG "characters") "+ => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " -- 文字" EOL1
     (STRONG "generalized-boolean") " -- generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は文字を比較します。" EOL2 (CODE1 "char=") "は、全ての文字が同じなら"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の何らかの属性が違うときは"
     (CODE1 "char=") "ではありません。" EOL2 (CODE1 "char/=") "は、全ての文字が違うとき" (STRONG "true")
     "を、それ以外は" (STRONG "false") "を返却します。" EOL2 (CODE1 "char<") "は、文字が単調増加のとき"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、"
     (CODE1 "char<") "の順序は文字コードを数値として" (CODE1 "<") "で比較したものと同じです。" EOL2 (CODE1 "char>")
     "は、文字が単調減少の場合は" (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。"
     "もし2つの文字の属性が等しいとき、" (CODE1 "char>") "の順序は文字コードを数値として" (CODE1 ">") "で比較したものと同じです。"
     EOL2 (CODE1 "char<=") "は、文字が単調非減少のとき" (STRONG "true") "を、それ以外は" (STRONG "false")
     "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char<=") "の順序は文字コードを数値として" (CODE1 "<=")
     "で比較したものと同じです。" EOL2 (CODE1 "char>=") "は、文字が単調非増加の場合は" (STRONG "true") "を、それ以外は"
     (STRONG "false") "を返却します。" "もし2つの文字の属性が等しいとき、" (CODE1 "char>=") "の順序は文字コードを数値として"
     (CODE1 ">=") "で比較したものと同じです。" EOL2 (CODE1 "char-equal") ", " (CODE1 "char-not-equal")
     "," (CODE1 "char-lessp") ", " (CODE1 "char-greaterp") ","
     (CODE1 "char-not-greaterp") ", " (CODE1 "char-not-lessp") "は、" "順に" (CODE1 "char=")
     ", " (CODE1 "char/=") ", " (CODE1 "char<") ", " (CODE1 "char>") "," (CODE1 "char<=")
     ", " (CODE1 "char>=") "と似ていますが、" "大文字小文字を無視します。"
     "もし文字が単純ではない場合（文字の属性がある場合。13.1.3. 文字の属性を参照）" "結果は実装で定義された動作になります。" "例えば、ある実装では"
     (CODE1 "char-equal") "などの関数では、" "属性を明確に無視するように定義しているかもしれません。" "属性に何らかの効果がある場合は、"
     "これらの比較関数の属性を定義する個所で規定しておく必要があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(char= #\\d #\\d) → true" "(char= #\\A #\\a) → false"
      "(char= #\\d #\\x) → false" "(char= #\\d #\\D) → false"
      "(char/= #\\d #\\d) → false" "(char/= #\\d #\\x) → true"
      "(char/= #\\d #\\D) → true" "(char= #\\d #\\d #\\d #\\d) → true"
      "(char/= #\\d #\\d #\\d #\\d) → false" "(char= #\\d #\\d #\\x #\\d) → false"
      "(char/= #\\d #\\d #\\x #\\d) → false" "(char= #\\d #\\y #\\x #\\c) → false"
      "(char/= #\\d #\\y #\\x #\\c) → true" "(char= #\\d #\\c #\\d) → false"
      "(char/= #\\d #\\c #\\d) → false" "(char< #\\d #\\x) → true"
      "(char<= #\\d #\\x) → true" "(char< #\\d #\\d) → false" "(char<= #\\d #\\d) → true"
      "(char< #\\a #\\e #\\y #\\z) → true" "(char<= #\\a #\\e #\\y #\\z) → true"
      "(char< #\\a #\\e #\\e #\\y) → false" "(char<= #\\a #\\e #\\e #\\y) → true"
      "(char> #\\e #\\d) → true" "(char>= #\\e #\\d) → true"
      "(char> #\\d #\\c #\\b #\\a) → true" "(char>= #\\d #\\c #\\b #\\a) → true"
      "(char> #\\d #\\d #\\c #\\a) → false" "(char>= #\\d #\\d #\\c #\\a) → true"
      "(char> #\\e #\\d #\\b #\\c #\\a) → false"
      "(char>= #\\e #\\d #\\b #\\c #\\a) → false"
      "(char> #\\z #\\A) → implementation-dependent"
      "(char> #\\Z #\\a) → implementation-dependent" "(char-equal #\\A #\\a) → true"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char-lessp)"
      "→ (#\\A #\\a #\\b #\\B #\\c #\\C)"
      "(stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char<)"
      "→ (#\\A #\\B #\\C #\\a #\\b #\\c) ;実装A" "→ (#\\a #\\b #\\c #\\A #\\B #\\C) ;実装B"
      "→ (#\\a #\\A #\\b #\\B #\\c #\\C) ;実装C" "→ (#\\A #\\a #\\B #\\b #\\C #\\c) ;実装D"
      "→ (#\\A #\\B #\\a #\\b #\\C #\\c) ;実装E"))
    (CHAPTER ("## 例外") 2 "もし少なくとも1文字も与えられなかった場合は、" "型" (CODE1 "program-error")
     "のエラーが発せられます。")
    (CHAPTER ("## 参考") 2 "2.1. 文字の構文, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "文字がコードの属性かあるいは実装定義の属性で異なる場合、" (CODE1 "char=")
     "によって異なるものとしてみなされます。" EOL2 (CODE1 "(char= c1 c2)") "が" (STRONG "true") "のときに、"
     (CODE1 "(eq c1 c2)") "が" (STRONG "true") "である必要はありません。" (CODE1 "eq") "は、"
     (CODE1 "char=") "が区別できないような2つの文字を区別できますが、" "それは文字として区別しているのではなく、"
     "低レベルの実装の特性に基づいて行われています。" "もし" (CODE1 "(eq c1 c2)") "が" (STRONG "true") "のときは、"
     (CODE1 "(char= c1 c2)") "もまた" (STRONG "true") "です。" "文字の" (CODE1 "eql") "と"
     (CODE1 "equal") "の比較は、" (CODE1 "char=") "と同じ方法で行われます。" EOL2 "関数"
     (CODE1 "char-equal") "," (CODE1 "char-not-equal") "," (CODE1 "char-lessp") ","
     (CODE1 "char-greaterp") "," (CODE1 "char-not-greaterp") "," (CODE1 "char-not-lessp")
     "において、" (CODE1 "standard-char") "の大文字小文字の比較は、" "暗に標準文字の" (CODE1 "A=a") ", "
     (CODE1 "B=b") ", " (CODE1 "...") ", " (CODE1 "Z=z") "、" "さらに、" (CODE1 "9<A")
     "か、あるいは" (CODE1 "Z<0") "の" "どちらかで順序付けされることを意味します。")))
(setf (gethash '("CHAR>=" . "FUNCTION") *table*) (gethash "CHAR>=" *table*))
(setf (gethash "CHARACTER" *table*)
  '("CHARACTER FUNCTION" EOL1 "CHARACTER SYSTEM-CLASS" EOL1))
(setf (gethash '("CHARACTER" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHARACTER"))
    (CHAPTER ("## 構文") 2 (CODE1 "charcter") " " (STRONG "character") " => "
     (STRONG "denoted-character"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " - character-designator" EOL1
     (STRONG "denoted-character") " - 文字")
    (CHAPTER ("## 定義") 2 "character-designatorによって示される文字が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(character #\\a) → #\\a" "(character \"a\") → #\\a"
      "(character 'a) → #\\A" "(character '\\a) → #\\a" "(character 65.) はエラー."
      "(character 'apple) はエラー."))
    (CHAPTER ("## 影響") 2 "なし")
    (CHAPTER ("## 例外") 2 "もし引数がcharacter-designatorではなかった場合は、" "型" (CODE1 "type-error")
     "が発せられます。")
    (CHAPTER ("## 参考") 2 (CODE1 "coerce"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(character object) == (coerce object 'character)"))))
(setf (gethash '("CHARACTER" . "SYSTEM-CLASS") *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "CHARACTER"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "character") ", " (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "文字(character)とは、" "テキストを構成する集合体の、単一の要素を表すオブジェクトです。"
     "13.1. 文字の説明を参照。" EOL1 "型" (CODE1 "base-char") "と型" (CODE1 "extended-char") "は、" "型"
     (CODE1 "character") "に含まれる要素です。")
    (CHAPTER ("## 参考") 2 "13.1. 文字の説明, 2.4.8.1. シャープサイン バックスラッシュ, 22.1.3.2. 文字の印字。")))
(setf (gethash "CHARACTERP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CHARACTERP"))
    (CHAPTER ("## 構文") 2 (CODE1 "characterp") " " (STRONG "object") " -> "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が型" (CODE1 "character") "であったら"
     (STRONG "true") "、それ以外は" (STRONG "false") "。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(characterp #\\a) → true" "(characterp 'a) → false"
      "(characterp \"a\") → false" "(characterp 65.) → false"
      "(characterp #\\Newline) → true" ";; 次の例は#\\Ruboutが実装定義の文字として実装されていることが要求されます。"
      "(characterp #\\Rubout) → true"))
    (CHAPTER ("## 影響") 2 "なし") (CHAPTER ("## 例外") 2 "なし")
    (CHAPTER ("## 参考") 2 "型" (CODE1 "character") "," "関数" (CODE1 "character") ","
     (CODE1 "typep"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(characterp object) == (typep object 'character)"))))
(setf (gethash '("CHARACTERP" . "FUNCTION") *table*) (gethash "CHARACTERP" *table*))
(setf (gethash "CHECK-TYPE" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "CHECK-TYPE"))
    (CHAPTER ("## 構文") 2 (CODE1 "check-type") " " (STRONG "place") " "
     (STRONG "typespec") " [" (STRONG "string") "] => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "place") " - " (CODE1 "place") EOL1
     (STRONG "typespec") " - 型指定子" EOL1 (STRONG "string") " - 文字列。評価されます。")
    (CHAPTER ("## 定義") 2 (CODE1 "check-type") "は、" (CODE1 "place") "の内容が型"
     (STRONG "typespec") "ではなかったときに、" "型" (CODE1 "type-error") "の修正可能なエラーを通知します。" EOL2
     (CODE1 "check-type") "は、ただ" (CODE1 "store-value") " " (CODE1 "restart") "が"
     "明示的に起動されたか、あるいはデバッガーのオプションによって" "暗に起動されたときのみ返却可能です。" "もし" (CODE1 "store-value") " "
     (CODE1 "restart") "が起動されたとき、" (CODE1 "check-type") "は実行された（あるいはデバッガーによって対話的に行われた）"
     (CODE1 "restart") "の引数の値を新しい値として" (STRONG "place") "に格納してから最初に戻り、"
     "新しい値がその型であるかどうかをチェックして、" "いまだに希望した型になっていないときは違うエラーが通知されます。" EOL2 "最初に"
     (STRONG "place") "が評価されたときは、" "その評価は通常の評価の規則によって行われます。" "そのあとは、もしチェックが失敗して"
     (CODE1 "store-value") " " (CODE1 "restart") "が使われたときに、" (STRONG "place")
     "として評価が行われます。" "5.1.1.1. " (CODE1 "place") "のサブフォームの評価をご確認ください。" EOL2
     (STRONG "string") "は、その型についての" "不定冠詞（" (CODE1 "\"a\"") "か" (CODE1 "\"an\"")
     "）で始まる英語の説明でなければなりません。" "もし" (STRONG "string") "が指定されなかったときは、" "それは"
     (STRONG "typespec") "から自動的に計算されます。" "自動的に計算されるメッセージは、" (STRONG "place")
     "と、その内容と、希望する型について言及します。" "実装は、" (CODE1 "check-type") "を呼び出した関数の引数のひとつなどを見て、"
     (STRONG "place") "が特定の形式であることを認識した場合は、" "多少異なる言葉でエラーメッセージを生成するかどうかを" "選ぶことができます。"
     (CODE1 "check-type") "の適用によっては、" (STRONG "typespec") "から自動的に生成するよりも"
     "何が要求されているのかをより具体的に" "記載することを求められることがあるため、" (STRONG "string") "の引数が用意されています。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq aardvarks '(sam harry fred))" "=>  (SAM HARRY FRED)"
      "(check-type aardvarks (array * (3)))"
      ">>  Error: The value of AARDVARKS, (SAM HARRY FRED),"
      ">>         is not a 3-long array."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Specify a value to use instead." ">>   2: Return to Lisp Toplevel."
      ">>  Debug> :CONTINUE 1" ">>  Use Value: #(SAM FRED HARRY)" "=>  NIL" "aardvarks"
      "=>  #<ARRAY-T-3 13571>" "(map 'list #'identity aardvarks)" "=>  (SAM FRED HARRY)"
      "(setq aardvark-count 'foo)" "=>  FOO"
      "(check-type aardvark-count (integer 0 *) \"A positive integer\")"
      ">>  Error: The value of AARDVARK-COUNT, FOO, is not a positive integer."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Specify a value to use instead." ">>   2: Top level."
      ">>  Debug> :CONTINUE 2" "(defmacro define-adder (name amount)"
      "  (check-type name (and symbol (not null)) \"a name for an adder function\")"
      "  (check-type amount integer)" "  `(defun ,name (x) (+ x ,amount)))" " "
      "(macroexpand '(define-adder add3 3))" "=>  (defun add3 (x) (+ x 3))" NIL
      "(macroexpand '(define-adder 7 7))"
      ">>  Error: The value of NAME, 7, is not a name for an adder function."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Specify a value to use instead." ">>   2: Top level."
      ">>  Debug> :Continue 1" ">>  Specify a value to use instead."
      ">>  Type a form to be evaluated and used instead: 'ADD7"
      "=>  (defun add7 (x) (+ x 7))" NIL "(macroexpand '(define-adder add5 something))"
      ">>  Error: The value of AMOUNT, SOMETHING, is not an integer."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Specify a value to use instead." ">>   2: Top level."
      ">>  Debug> :Continue 1" ">>  Type a form to be evaluated and used instead: 5"
      "=>  (defun add5 (x) (+ x 5))")
     " ")
    (CHAPTER ("## 副作用") 2 "制御がハンドラーに移行します。" EOL2 "デバッガーが起動されるかもしれません。")
    (CHAPTER ("## 影響") 2 (CODE1 "*break-on-signals*") EOL2 "実装。")
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 "9.1. コンディションシステムの説明")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(check-type place typespec)"
      "==  (assert (typep place 'typespec) (place)"
      "           'type-error :datum place :expected-type 'typespec)"))))
(setf (gethash '("CHECK-TYPE" . "MACRO") *table*) (gethash "CHECK-TYPE" *table*))
(setf (gethash "CLASS" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "CLASS"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "class") "," (CODE1 "standard-object") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "class") "は、インスタンスの構造と振る舞いを" "決めるオブジェクトの表現です。" "型"
     (CODE1 "class") "のオブジェクトは、" "クラスの非循環有向グラフである位置情報と、" "スロットと、オプションが記載された情報によって"
     "関連付けられます。")))
(setf (gethash '("CLASS" . "SYSTEM-CLASS") *table*) (gethash "CLASS" *table*))
(setf (gethash "CLASS-NAME" *table*)
  '("CLASS-NAME SETF" EOL1 "CLASS-NAME STANDARD-GENERIC-FUNCTION" EOL1))
(setf (gethash '("CLASS-NAME" . "SETF") *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "(SETF CLASS-NAME)"))
    (CHAPTER ("## 構文") 2 (CODE1 "(setf class-name)") " " (STRONG "new-value") " "
     (STRONG "class") " => " (STRONG "new-value"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "(setf class-name)") " " (STRONG "new-value") " ("
     (STRONG "class") " " (CODE1 "class") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "new-value") " - シンボル" EOL1 (STRONG "class")
     " - クラス")
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "setf-class-name") "は、" (STRONG "class")
     "オブジェクトの名前を設定します。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "find-class") "," "proper name（正しい名前）," "4.3. クラス")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("CLASS-NAME" . "STANDARD-GENERIC-FUNCTION") *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "CLASS-NAME"))
    (CHAPTER ("## 構文") 2 (CODE1 "class-name") " " (STRONG "class") " => "
     (STRONG "name"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "class-name") " (" (STRONG "class") " "
     (CODE1 "class") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "class") " - クラスオブジェクト" EOL1 (STRONG "name")
     " - シンボル")
    (CHAPTER ("## 定義") 2 "引数" (STRONG "class") "の名前を返却します。") (CHAPTER ("## 例文") 2 "なし。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "find-class") "," "4.3. クラス")
    (CHAPTER ("## 備考") 2 "もし" (CODE1 "S") "がシンボルで、" (CODE1 "S = (class-name C)") "かつ、"
     (CODE1 "C = (find-class S)") "のとき、" (CODE1 "S") "は" (CODE1 "C")
     "の正しい名前です。さらなる説明は、4.3. クラスをご確認ください。" EOL2 "匿名のクラスの名前は" (CODE1 "nil") "です。")))
(setf (gethash "CLASS-OF" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CLASS-OF"))
    (CHAPTER ("## 構文") 2 (CODE1 "class-of") " " (STRONG "object") " => "
     (STRONG "class"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "class")
     " - クラスオブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "object") "がdirect-instanceであるようなクラスを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(class-of 'fred) =>  #<BUILT-IN-CLASS SYMBOL 610327300>"
      "(class-of 2/3) =>  #<BUILT-IN-CLASS RATIO 610326642>" NIL
      "(defclass book () ()) =>  #<STANDARD-CLASS BOOK 33424745>"
      "(class-of (make-instance 'book)) =>  #<STANDARD-CLASS BOOK 33424745>" NIL
      "(defclass novel (book) ()) =>  #<STANDARD-CLASS NOVEL 33424764>"
      "(class-of (make-instance 'novel)) =>  #<STANDARD-CLASS NOVEL 33424764>" NIL
      "(defstruct kons kar kdr) =>  KONS"
      "(class-of (make-kons :kar 3 :kdr 4)) =>  #<STRUCTURE-CLASS KONS 250020317>"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-instance") "," (CODE1 "type-of"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("CLASS-OF" . "FUNCTION") *table*) (gethash "CLASS-OF" *table*))
(setf (gethash "CLEAR-INPUT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CLEAR-INPUT"))
    (CHAPTER ("## 構文") 2 (CODE1 "clear-input") " " (CODE1 "&optional") " "
     (STRONG "input-stream") " => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "input-stream") " - 入力ストリーム指定子。デフォルトは標準入力。")
    (CHAPTER ("## 定義") 2 (STRONG "input-stream") "から利用可能な全ての入力をクリアします。" EOL2 "もし"
     (CODE1 "clear-input") "が" (STRONG "input-stream") "から検出できなかったとき、"
     (CODE1 "clear-input") "は何もしません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; この例の正確なI/Oの振る舞いはおそらく実装の対話式の"
      ";; バッファの都合により実装依存が生じるため異なる可能性があります。" ";; （ここでのSLEEPの呼び出しは、行志向のバッファリングを行わないような"
      ";; 実装の差異を同じにするためのものです）" NIL
      "(defun read-sleepily (&optional (clear-p nil) (zzz 0))"
      "  (list (progn (print '>) (read))" "        ;; 最初のZZZ秒内に入力されたものは"
      "        ;; 削除される点に注意してください。" "        (progn (print '>) "
      "               (if zzz (sleep zzz))" "               (print '>>)"
      "               (if clear-p (clear-input))" "               (read))))" NIL
      "(read-sleepily)" ">>  > 10" ">>  >" ">>  >> 20" "=>  (10 20)" NIL
      "(read-sleepily t)" ">>  > 10" ">>  >" ">>  >> 20" "=>  (10 20)" NIL
      "(read-sleepily t 10)" ">>  > 10" ">>  > 20  ; ある実装ではここで入力がエコーされません。" ">>  >> 30"
      "=>  (10 30)"))
    (CHAPTER ("## 副作用") 2 (STRONG "input-stream") "は修正されます。")
    (CHAPTER ("## 影響") 2 (CODE1 "*standard-input*"))
    (CHAPTER ("## 例外") 2 (STRONG "input-stream") "がストリーム指定子ではなかったとき、" "型"
     (CODE1 "type-error") "のエラーが通知されるべきです。")
    (CHAPTER ("## 参考") 2 (CODE1 "clear-output")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("CLEAR-INPUT" . "FUNCTION") *table*) (gethash "CLEAR-INPUT" *table*))
(setf (gethash "CLEAR-OUTPUT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FINISH-OUTPUT") ", " (CODE1 "FORCE-OUTPUT") ", "
     (CODE1 "CLEAR-OUTPUT"))
    (CHAPTER ("## 構文") 2 (CODE1 "finish-output") " " (CODE1 "&optional") " "
     (STRONG "output-stream") " => " (CODE1 "nil") EOL1 (CODE1 "force-output") " "
     (CODE1 "&optional") " " (STRONG "output-stream") " => " (CODE1 "nil") EOL1
     (CODE1 "clear-output") " " (CODE1 "&optional") " " (STRONG "output-stream") " => "
     (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "output-stream") " - 出力ストリーム指定子。デフォルトは標準出力。")
    (CHAPTER ("## 定義") 2 (CODE1 "finish-output") ", " (CODE1 "force-output") ", "
     (CODE1 "clear-output") "は、" "バッファされた出力ストリームの内部状態を制御します。" EOL2
     (CODE1 "finish-output") "は、" "出力バッファの全てを" (STRONG "output-stream") "に送り、"
     "その宛先に届くことを確認しようと試み、" "それから返却が行われます。" EOL2 (CODE1 "force-output") "は、"
     "内部バッファの全てを空にしようと処理を開始しますが、" "完了を待たずに応答の返却を行います。" EOL2 (CODE1 "clear-output") "は、"
     "できるだけ少ない出力が宛先に届くようにするために、" "進行中の実施していない出力操作を中止しようとします。" EOL2 "もしこれらの操作のどれかが"
     (STRONG "output-stream") "に対して" "実施するものがないときは何もしません。" "これらの関数の詳しい動作は実装依存です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; 実装A" "(progn (princ \"am i seen?\") (clear-output))"
      "=>  NIL" NIL ";; 実装B" "(progn (princ \"am i seen?\") (clear-output))"
      ">>  am i seen?" "=>  NIL"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 (CODE1 "*standard-output*"))
    (CHAPTER ("## 例外") 2 (STRONG "output-stream") "がストリーム指定子ではなかったとき、" "型"
     (CODE1 "type-error") "のエラーが通知されるべきです。")
    (CHAPTER ("## 参考") 2 (CODE1 "clear-input")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("CLEAR-OUTPUT" . "FUNCTION") *table*) (gethash "CLEAR-OUTPUT" *table*))
(setf (gethash "CLOSE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CLOSE"))
    (CHAPTER ("## 構文") 2 (CODE1 "close") " " (STRONG "stream") " " (CODE1 "&key") " "
     (STRONG "abort") " => " (STRONG "result"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream") " - ストリーム（開いているか閉じているかのどちらか）" EOL1
     (STRONG "abort") " - generalized-boolean。デフォルトは" (STRONG "false") "。" EOL1
     (STRONG "result") " - 引数として受け取った時点で" (STRONG "stream") "が開いているときは" (CODE1 "t") "を、"
     "そうでないときは実装依存。")
    (CHAPTER ("## 定義") 2 (CODE1 "close") "は" (STRONG "stream") "をクローズします。"
     "ストリームのクローズとは、入出力操作を使わないようにする操作です。" "ファイルストリームのクローズの実行は、"
     "そのストリームと関連付けられたファイルの間の関係を終了させることであり、" "ファイルシステムのトランザクションは終了し、"
     "そのストリームの入出力をもう実施できなくなります。" EOL2 (STRONG "abort") "が" (STRONG "true") "のときは、"
     "作成された" (STRONG "stream") "から生じた全ての副作用に対して" "掃除処理を実施しようとします。" "もし" (STRONG "stream")
     "が生成されそのストリームがファイルの出力を行っていた場合、" "そのファイルは削除され、" "以前存在していたファイルが取って代わられるようなことはありません。"
     EOL2 "すでにクローズされているストリームをクローズすることは許されますが、" "このようなときは" (STRONG "result") "は実装依存です。"
     EOL2 (STRONG "stream") "がクローズされたあと、" "次の問い合わせ操作はまだストリームに対して実施することができます："
     (CODE1 "streamp") "," (CODE1 "pathname") "," (CODE1 "truename") ","
     (CODE1 "merge-pathnames") "," (CODE1 "pathname-host") "," (CODE1 "pathname-device")
     "," (CODE1 "pathname-directory") "," (CODE1 "pathname-type") ","
     (CODE1 "pathname-version") "," (CODE1 "namestring") "," (CODE1 "file-namestring")
     "," (CODE1 "directory-namestring") "," (CODE1 "host-namestring") ","
     (CODE1 "enough-namestring") "," (CODE1 "open") "," (CODE1 "probe-file") ","
     (CODE1 "directory") "。" EOL2 "構築されたストリームに対しての" (CODE1 "close") "の効果は引数の"
     (STRONG "stream") "だけです。" "複合ストリームの各成分についての効果はありません。" EOL2
     (CODE1 "make-string-output-stream") "によって作成されたストリームについて、" (CODE1 "close") "したあとの"
     (CODE1 "get-output-stream-string") "の結果は指定されていません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq s (make-broadcast-stream)) =>  #<BROADCAST-STREAM>"
      "(close s) =>  T" "(output-stream-p s) =>  true"))
    (CHAPTER ("## 副作用") 2 (STRONG "stream") "は（必要なら）クローズされます。" "もし" (STRONG "abort") "が"
     (STRONG "true") "であり" (STRONG "stream") "が出力ファイルストリームなら、"
     "関連付けられたファイルは削除されるかもしれません。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "open")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("CLOSE" . "FUNCTION") *table*) (gethash "CLOSE" *table*))
(setf (gethash "CLRHASH" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CLRHASH"))
    (CHAPTER ("## 構文") 2 (CODE1 "clrhash") " " (STRONG "hash-table") " => "
     (STRONG "hash-table"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "hash-table") " - ハッシュテーブル")
    (CHAPTER ("## 定義") 2 (STRONG "hash-table") "から全てのエントリーを削除し、" "その空のハッシュテーブルを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32004073>"
      "(dotimes (i 100) (setf (gethash i table) (format nil \"~R\" i))) =>  NIL"
      "(hash-table-count table) =>  100" "(gethash 57 table) =>  \"fifty-seven\", true"
      "(clrhash table) =>  #<HASH-TABLE EQL 0/120 32004073>"
      "(hash-table-count table) =>  0" "(gethash 57 table) =>  NIL, false"))
    (CHAPTER ("## 副作用") 2 (STRONG "hash-table") "は修正されます。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("CLRHASH" . "FUNCTION") *table*) (gethash "CLRHASH" *table*))
(setf (gethash "CODE-CHAR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CODE-CHAR"))
    (CHAPTER ("## 構文") 2 (CODE1 "code-char") " " (STRONG "code") " => "
     (STRONG "char-p"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "code") " - 文字コード" EOL1 (STRONG "char-p") " - 文字か"
     (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "コード属性が" (STRONG "code") "の文字を返却します。"
     "もしそのような文字が存在せず、作成もできない場合は" (CODE1 "nil") "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(code-char 65.) =>  #\\A  ; ASCIIコードを使用している処理系の場合"
      "(code-char (char-code #\\Space)) =>  #\\Space  ; どんな処理系でも"))
    (CHAPTER ("## 影響") 2 "処理系の文字コード") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char-code")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("CODE-CHAR" . "FUNCTION") *table*) (gethash "CODE-CHAR" *table*))
(setf (gethash "COERCE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "COERCE"))
    (CHAPTER ("## 構文") 2 (CODE1 "coerce") " " (STRONG "object") " "
     (STRONG "result-type") " => " (STRONG "result"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "result-type")
     " - 型指定子" EOL1 (STRONG "result") " - " (STRONG "result-type")
     "の型のオブジェクト。例外は状況は12.1.5.3. " (CODE1 "rational") "型の複素数の標準的な表現のルールをご確認ください。")
    (CHAPTER ("## 定義") 2 (STRONG "object") "を型" (STRONG "result-type") "に強制的に変換します。" EOL2
     "もし" (STRONG "object") "がすでに型" (STRONG "result-type") "であったときは、" "他の型のオブジェクトを"
     (STRONG "result-type") "に強制することが" "一般的に可能であったかどうかに関わらず、" (STRONG "object")
     "自身が返却されます。" EOL2 "それ以外のときは、" (STRONG "object") "は下記のルールに従って" (STRONG "result-type")
     "の型に強制されます。" EOL2 "- " (CODE1 "sequence") "  - もし" (STRONG "result-type") "が"
     (CODE1 "list") "の認識可能なサブタイプであり、" "    " (STRONG "object") "がシーケンスのときは、" "    "
     (STRONG "result") "は" (STRONG "object") "と同じ要素を持ったリストです。" "	<br><br>" "    もし"
     (STRONG "result-type") "が" (CODE1 "vector") "の認識可能なサブタイプであり、" "    "
     (STRONG "object") "がシーケンスのときは、" "    " (STRONG "result") "は" (STRONG "object")
     "と同じ要素を持った" (CODE1 "vector") "です。" "    もし" (STRONG "result-type") "が"
     (CODE1 "specialized") "の型のとき、" "    " (STRONG "result") "は要素の型の"
     (CODE1 "specialized") "の部分を格上げした結果の" "    実際の配列の要素の型の型を持ちます。"
     "    もし要素の型が指定されていないときは、" "    その要素の型はデフォルトの" (CODE1 "t") "になります。"
     "    実装が要素の型を決定できないときはエラーが発生します。" "    <br><br>" EOL2 "- " (CODE1 "character")
     "  - もし" (STRONG "result-type") "が" (CODE1 "character") "であり、" "    "
     (STRONG "object") "が文字指定子のときは、" "    " (STRONG "result") "は引数が示す文字になります。"
     "    <br><br>" EOL2 "- " (CODE1 "complex") "  - もし" (STRONG "result-type") "が"
     (CODE1 "complex") "であり" "    " (STRONG "object") "が実装のときは、 " (STRONG "result")
     "は実部が" (STRONG "object") "、" "    虚部が整数の" (CODE1 "0") "を" (STRONG "object") "の型で"
     (CODE1 "coerce") "したもので構築した" "    複素数になります" "    （しかし文字実部が" (CODE1 "rational")
     "のときは、" "    結果もまた複素数ではなく" (CODE1 "rational") "になります。" "    12.1.5.3. "
     (CODE1 "rational") "型の複素数の標準的な表現のルールをご確認ください。" "    よって例えば"
     (CODE1 "(coerce 3 'complex)") "は許されますが、" "    返却値は複素数ではなく" (CODE1 "3") "になります）。"
     "    <br><br>" EOL2 "- " (CODE1 "float") "  - もし" (STRONG "result-type") "が "
     (CODE1 "float") "," "    " (CODE1 "short-float") ", " (CODE1 "single-float") ","
     "    " (CODE1 "double-float") ", " (CODE1 "long-float") "のどれかであり" "    "
     (STRONG "object") "が実装のときは、" "    " (STRONG "result") "は、型が" (STRONG "result-type")
     "であり、" "    符号が" (STRONG "object") "と等しく、" "    その浮動小数の型が表現できる精度の大きさが" "    "
     (STRONG "object") "と等しいものになります" "    （もし" (STRONG "result-type") "が" (CODE1 "float")
     "で" "    " (STRONG "object") "が浮動小数ではないときは、" "    " (STRONG "result") "は"
     (CODE1 "single-float") "になります）。" "    <br><br>" EOL2 "- " (CODE1 "function")
     "  - もし" (STRONG "result-type") "が" (CODE1 "function") "で、" "    " (STRONG "object")
     "が" (CODE1 "fbound") "の関数名であり、" "    その関数名がグローバルなマクロ名でもなければ" "    特殊オペレーターでもないときは、"
     "    " (STRONG "result") "は" (STRONG "object") "の関数の値です。" "    <br><br>" "    もし"
     (STRONG "result-type") "が" (CODE1 "function") "で、" "    " (STRONG "object")
     "がラムダ式の場合は、" "    " (STRONG "result") "は" (CODE1 "null") "のレキシカルな環境の" "    "
     (STRONG "object") "のクロージャーです。" "    <br><br>" EOL2 "- " (CODE1 "t") "  - どんな"
     (STRONG "object") "でも型" (CODE1 "t") "へ強制できます" "    このような場合、" (STRONG "object")
     "が単純に返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(coerce '(a b c) 'vector) =>  #(A B C)"
      "(coerce 'a 'character) =>  #\\A" "(coerce 4.56 'complex) =>  #C(4.56 0.0)"
      "(coerce 4.5s0 'complex) =>  #C(4.5s0 0.0s0)" "(coerce 7/2 'complex) =>  7/2"
      "(coerce 0 'short-float) =>  0.0s0" "(coerce 3.5L0 'float) =>  3.5L0"
      "(coerce 7/2 'float) =>  3.5" "(coerce (cons 1 2) t) =>  (1 . 2)")
     EOL2 "下記の全てのフォームは、エラーが発生します。"
     (CODE3 "```lisp" "```" "(coerce '(a b c) '(vector * 4))"
      "(coerce #(a b c) '(vector * 4))" "(coerce '(a b c) '(vector * 2))"
      "(coerce #(a b c) '(vector * 2))" "(coerce \"foo\" '(string 2))"
      "(coerce #(#\\a #\\b #\\c) '(string 2))" "(coerce '(0 1) '(simple-bit-vector 3))"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし強制が不可能な時は、" "型" (CODE1 "type-error") "のエラーが発生します。" EOL2
     (CODE1 "(coerce x 'nil)") "は常に型" (CODE1 "type-error") "のエラーです。" EOL2
     (STRONG "result-type") "が" (CODE1 "function") "だが、" (STRONG "object") "が"
     (CODE1 "fbound") "ではないシンボルであったり、" "またはシンボル名がマクロか特殊オペレーターのときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" EOL2 (STRONG "result-type") "で指定された要素数と"
     (STRONG "object") "が違う長さでのときは、" "型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "rational") "," (CODE1 "floor") "," (CODE1 "char-code")
     "," (CODE1 "char-int"))
    (CHAPTER ("## 備考") 2 "浮動小数から" (CODE1 "rational") "への強制と、" "分数から浮動小数への強制は、"
     "丸め問題のため提供されません。" (CODE3 "```lisp" "```" "(coerce x 't) ==  (identity x) ==  x"))))
(setf (gethash '("COERCE" . "FUNCTION") *table*) (gethash "COERCE" *table*))
(setf (gethash "COMPILE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "COMPILE"))
    (CHAPTER ("## 構文") 2 (CODE1 "compile") " " (STRONG "name") " &optional "
     (STRONG "definition") " => " (STRONG "function") ", " (STRONG "warnings-p") ", "
     (STRONG "failure-p"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - 関数名か、" (CODE1 "nil") EOL1
     (STRONG "definition") " - ラムダ式か関数。" "デフォルトは、もし" (STRONG "name") "が関数名のときはその関数定義、"
     "マクロ関数の名前のときはマクロ関数です。" (STRONG "name") "が" (CODE1 "nil") "で" (STRONG "definition")
     "が与えられなかったときの結果は未定義です。" EOL1 (STRONG "function") " - 関数名か、コンパイルされた関数" EOL1
     (STRONG "warnings-p") " - generalized-boolean" EOL1 (STRONG "failure-p")
     " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "interpreted-function") "をコンパイルします。" EOL2
     (CODE1 "compile") "は、" (STRONG "definition") "からコンパイル関数を生成します。" "もし"
     (STRONG "definition") "がラムダ式のときは、それを強制的に関数へ変換します。" "もし" (STRONG "definition")
     "がすでにコンパイル関数のときは、" (CODE1 "compile") "は自分自身の関数（例えば同一の操作）か、" "同等の関数を生成します。" EOL2 "もし"
     (STRONG "name") "が" (CODE1 "nil") "のときは、" "コンパイル関数の返却は、主値に直接返却されます。" "もし"
     (STRONG "name") "の" (CODE1 "nil") "ではないときは、" "コンパイル関数は" (STRONG "name")
     "に定義されている既存の関数を置き換え、" (STRONG "name") "を主値に返却します。" "もし" (STRONG "name")
     "がマクロ名のシンボルのときはそのマクロ関数が更新され、" (STRONG "name") "を主値に返却します。" EOL2
     "コンパイル関数による処理でコードに現れたリテラルオブジェクトは、" "コピーも合体もされません。" (CODE1 "compile")
     "の実行により返却されたコードが" "参照しているオブジェクトは、" "ソースコード上の対応するオブジェクトと" (CODE1 "eql") "で一致します。"
     EOL2 (CODE1 "compile") "は、型" (CODE1 "error") "のコンディションへの" (CODE1 "handler")
     "を確立させることを許しますが、しかし必須ではありません。" "例えば、その" (CODE1 "handler") "は警告を発し、"
     "いくつかの実装依存の部分に対して" "手動で介入することなくコンパイルを再開することができます。" EOL2 "第二返却値の"
     (STRONG "warnings-p") "は、" "もしコンパイルによって型" (CODE1 "error") "か" (CODE1 "warning") "の"
     "コンディションが検出されなかったら" (STRONG "false") "に、それ以外は" (STRONG "true") "になります。" EOL2
     "第三返却値の" (STRONG "failer-p") "は、" "もしコンパイルによって型" (CODE1 "error") "か" "あるいは"
     (CODE1 "style-warning") "以外の" (CODE1 "warning") "の" "コンディションが検出されなかったら"
     (STRONG "false") "に、それ以外は" (STRONG "true") "になります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun foo () \"bar\") =>  FOO"
      "(compiled-function-p #'foo) =>  implementation-dependent"
      "(compile 'foo) =>  FOO " "(compiled-function-p #'foo) =>  true"
      "(setf (symbol-function 'foo)"
      "      (compile nil '(lambda () \"replaced\"))) =>  #<Compiled-Function>"
      "(foo) =>  \"replaced\""))
    (CHAPTER ("## 影響") 2 (CODE1 "*error-output*") "," (CODE1 "*macroexpand-hook*") EOL2
     "マクロの定義と宣言の存在。")
    (CHAPTER ("## 例外") 2 "もしレキシカルで囲まれた関数がコンパイルされ、" "その束縛にマクロとシンボルマクロと宣言以外ののもが"
     "含まれてたいときの結果は未定義です" EOL2 "コンパイル処理中のエラーの検出の情報については、" "3.2.5. コンパイラーの例外状況をご確認ください。")
    (CHAPTER ("## 参考") 2 (CODE1 "compile-file")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("COMPILE" . "FUNCTION") *table*) (gethash "COMPILE" *table*))
(setf (gethash "COMPILED-FUNCTION" *table*)
  '((CHAPTER NIL 0 "Type " (CODE1 "COMPILED-FUNCTION"))
    (CHAPTER ("## スーパータイプ") 2 (CODE1 "compiled-function") "," (CODE1 "function") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "関数が、実行時に展開される必要があるマクロの参照を含んでおらず、" "解決されていない"
     (CODE1 "load-time-value") "の参照も含んでいないとき、" "その関数は実装によってコンパイルされた関数であると考えられます。" EOL2
     (CODE1 "compile-file") "によってコンパイルされ、" (CODE1 "load") "によってロードされたファイル内で"
     "関数定義によってレキシカルに現れるものは" (CODE1 "compiled-function") "型です。" (CODE1 "compile")
     "関数によって生成された関数は" (CODE1 "compiled-function") "型です。" "他の関数も"
     (CODE1 "compiled-function") "型になるかもしれません。")))
(setf (gethash '("COMPILED-FUNCTION" . "TYPE") *table*) (gethash "COMPILED-FUNCTION" *table*))
(setf (gethash "COMPILED-FUNCTION-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "COMPILED-FUNCTION-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "compiled-function-p") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が型" (CODE1 "compiled-function") "なら"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun f (x) x) =>  F" "(compiled-function-p #'f)"
      "=>  false" "OR=>  true" "(compiled-function-p 'f) =>  false" "(compile 'f) =>  F"
      "(compiled-function-p #'f) =>  true" "(compiled-function-p 'f) =>  false"
      "(compiled-function-p (compile nil '(lambda (x) x)))" "=>  true"
      "(compiled-function-p #'(lambda (x) x))" "=>  false" "OR=>  true"
      "(compiled-function-p '(lambda (x) x)) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "compile") "," (CODE1 "compile-file") ","
     (CODE1 "compiled-function"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```"
      "(compiled-function-p object) == (typep object 'compiled-function)"))))
(setf (gethash '("COMPILED-FUNCTION-P" . "FUNCTION") *table*) (gethash "COMPILED-FUNCTION-P" *table*))
(setf (gethash "COMPILER-MACRO-FUNCTION" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "COMPILER-MACRO-FUNCTION"))
    (CHAPTER ("## 構文") 2 (CODE1 "compiler-macro-function") " " (STRONG "name")
     " &optional " (STRONG "environment") " => " (STRONG "function") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "compiler-macro-function") " " (STRONG "name")
     " &optional " (STRONG "environment") ") " (STRONG "new-function") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - 関数名" EOL1 (STRONG "environment")
     " - 環境オブジェクト" EOL1 (STRONG "function") ", " (STRONG "new-function")
     " - コンパイラーマクロ関数か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "もし指定されているなら" (STRONG "environment") "を考慮して、" (STRONG "name")
     "というコンパイラーマクロ関数にアクセスします。" EOL2 "値" (CODE1 "nil") "は、" (STRONG "name")
     "というコンパイラーマクロが存在しないことを示します。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "environment") "が非" (CODE1 "nil") "の状態で" (CODE1 "setf")
     "の" (CODE1 "compiler-macro-function") "を使用したときの" "結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "define-compiler-macro") "," "3.2.2.1. コンパイラーマクロ")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("COMPILER-MACRO-FUNCTION" . "ACCESSOR") *table*) (gethash "COMPILER-MACRO-FUNCTION" *table*))
(setf (gethash "COMPLEMENT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "COMPLEMENT"))
    (CHAPTER ("## 構文") 2 (CODE1 "complement") " " (STRONG "function") " => "
     (STRONG "complement-function"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function") " - 関数" EOL1
     (STRONG "complement-function") " - 関数")
    (CHAPTER ("## 定義") 2 (STRONG "function") "としていくつかの引数をとる関数を返却します。" "その関数は、"
     (STRONG "function") "として同じ副作用の動作をしますが" "ただひとつだけの値を返却します。"
     "返却値はgeneralized-booleanであり、" (STRONG "function") "の第一返却値として返却されただろうものの"
     "真偽値の反対を返却します。" "つまり、" (STRONG "function") "が" (STRONG "true") "を返却したとき"
     (STRONG "complement-function") "の第一返却値は" (STRONG "false") "であり、" (STRONG "function")
     "が" (STRONG "false") "を返却したとき" (STRONG "complement-function") "の第一返却値は"
     (STRONG "true") "です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(funcall (complement #'zerop) 1) =>  true"
      "(funcall (complement #'characterp) #\\A) =>  false"
      "(funcall (complement #'member) 'a '(a b c)) =>  false"
      "(funcall (complement #'member) 'd '(a b c)) =>  true"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "not"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```"
      "(complement x) == #'(lambda (&rest arguments) (not (apply x arguments)))")
     EOL2 "Common Lispでは、" "「" (CODE1 "xxx-if-not") "」のような名前を持つ関数は、" "「" (CODE1 "xxx-if")
     "」のような名前を持つ関数と、" "次のような関係があります。"
     (CODE3 "```lisp" "```"
      "(xxx-if-not f . arguments) == (xxx-if (complement f) . arguments)")
     EOL2 "例えば、次のようになります。"
     (CODE3 "```lisp" "```" "(find-if-not #'zerop '(0 0 3)) == "
      "(find-if (complement #'zerop) '(0 0 3)) =>  3")
     EOL2 "「" (CODE1 "xxx-if-not") "」のような関数と" (CODE1 ":test-not") "引数は非推奨です。" "「"
     (CODE1 "xxx-if") "」のような関数と" (CODE1 ":test") "引数を、" (CODE1 "complement")
     "と一緒に使うことが好まれます。")))
(setf (gethash '("COMPLEMENT" . "FUNCTION") *table*) (gethash "COMPLEMENT" *table*))
(setf (gethash "COMPUTE-APPLICABLE-METHODS" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "COMPUTE-APPLICABLE-METHODS"))
    (CHAPTER ("## 構文") 2 (CODE1 "compute-applicable-methods") " "
     (STRONG "generic-function") " " (STRONG "function-arguments") " => "
     (STRONG "methods"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "compute-applicable-methods") " ("
     (STRONG "generic-function") " " (CODE1 "standard-generic-function") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "generic-function") " - ジェネリック関数" EOL1
     (STRONG "function-arguments") " - ジェネリック関数の引数のリスト" EOL1 (STRONG "methods")
     " - メソッドのリスト")
    (CHAPTER ("## 定義") 2 (STRONG "generic-function") "と" (STRONG "function-arguments")
     "の集合が与えられると、" "関数" (CODE1 "compute-applicable-methods") "はこれらの引数によって、"
     "適用可能なメソッドの集合を優先順位に従ってソートして返却します。")
    (CHAPTER ("## 影響") 2 (CODE1 "defmethod")) (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "7.6.6. メソッドの選択とコンビネーション") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("COMPUTE-APPLICABLE-METHODS" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "COMPUTE-APPLICABLE-METHODS" *table*))
(setf (gethash "COMPUTE-RESTARTS" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "COMPUTE-RESTARTS"))
    (CHAPTER ("## 構文") 2 (CODE1 "compute-restarts") " " (CODE1 "&optional") " "
     (STRONG "condition") " => " (STRONG "restarts"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "condition") " - コンディションオブジェクトか、" (CODE1 "nil") EOL1
     (STRONG "restarts") " - " (CODE1 "restart") "のリスト")
    (CHAPTER ("## 定義") 2 (CODE1 "compute-restarts") "はそのプログラムの動的状態から" "現在有効の"
     (CODE1 "restart") "のリストを計算するときに使われます。" EOL2 "結果のリストには順番があり、" "もっとも内側（より最近確立されたもの）の"
     (CODE1 "restart") "が" "リストの先頭に近いものになります。" EOL2 "もし" (STRONG "condition") "が"
     (CODE1 "nil") "ではないときは、" "それらの" (CODE1 "restart") "は、明に" (STRONG "condition")
     "と関連付けられているものか、" "あるいはどのコンディションにも関連付けられてないものかの" "どちらかのみが集められます。" "これは、排他された"
     (CODE1 "restart") "というのは、" "関連付けられたコンディションの集合が空ではなく、" "その要素に指定した"
     (STRONG "condition") "が含まれていないということです。" "もし" (STRONG "condition") "が" (CODE1 "nil")
     "のときは、" "全ての" (CODE1 "restart") "が集められます。" EOL2 (CODE1 "compute-restarts")
     "は全ての適用可能な" (CODE1 "restart") "が返却され、" "それには匿名のものや、" "あるものが他のものと同じ名前のものも含まれるため、"
     "したがって" (CODE1 "find-restart") "の引数にシンボルを指定したものでは" "見つけることができないものも含まれます。" EOL2
     "実装は、同じ動的環境下で" (CODE1 "compute-restarts") "を繰り返し呼び出したときに、"
     "違うリストを返却することが許されますが、必須ではありません。" (CODE1 "compute-restarts") "によって返却されたリストを"
     "全て変更したときの結果は未定義です。" EOL2 "Examples:"
     (CODE3 "```lisp" "```" ";; ユーザーへrestartを表示させるような" ";; 対話式デバッガーのひとつの方法"
      "(defun invoke-a-restart ()" "  (let ((restarts (compute-restarts)))"
      "    (do ((i 0 (+ i 1)) (r restarts (cdr r))) ((null r))"
      "      (format t \"~&~D: ~A~%\" i (car r)))"
      "    (let ((n nil) (k (length restarts)))"
      "      (loop (when (and (typep n 'integer) (>= n 0) (< n k))"
      "              (return t))" "            (format t \"~&Option: \")"
      "            (setq n (read))" "            (fresh-line))"
      "      (invoke-restart-interactively (nth n restarts)))))" NIL
      "(restart-case (invoke-a-restart)" "  (one () 1)" "  (two () 2)"
      "  (nil () :report \"Who knows?\" 'anonymous)" "  (one () 'I)" "  (two () 'II))"
      ">>  0: ONE" ">>  1: TWO" ">>  2: Who knows?" ">>  3: ONE" ">>  4: TWO"
      ">>  5: Return to Lisp Toplevel." ">>  Option: 4" "=>  II" NIL
      ";; ユーザー定義のrestartを追加した地点では、COMPUTE-RESTARTは"
      ";; システムが用意したrestartの情報も返却してしまうことに注意してください。"
      ";; 例えば上記の\"Return to Lisp Toplevel\"がそうです。")
     EOL2 " ")
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "存在する" (CODE1 "restart"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "find-restart") "," (CODE1 "invoke-restart") ","
     (CODE1 "restart-bind"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("COMPUTE-RESTARTS" . "FUNCTION") *table*) (gethash "COMPUTE-RESTARTS" *table*))
(setf (gethash "CONCATENATE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CONCATENATE"))
    (CHAPTER ("## 構文") 2 (CODE1 "concatenate") " " (STRONG "result-type") " &rest "
     (STRONG "sequences") " => " (STRONG "result-sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "result-type") " - " (CODE1 "sequence") "の型指定子" EOL1
     (STRONG "sequences") " - シーケンス" EOL1 (STRONG "result-sequence") " - 型"
     (STRONG "result-type") "の正常なシーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "concatenate") "は、引数に指定された順番で、" "全" (STRONG "sequences")
     "の個々の全要素を含んだシーケンスを返却します。" "シーケンスは型" (STRONG "result-type") "であり、" "それは型"
     (CODE1 "sequence") "のサブタイプでなければなりません。" EOL2 "全ての" (STRONG "sequences") "はコピーされ、"
     "結果は、どの" (STRONG "sequences") "に対しても" "どのような構造でも共有されてはいけません。"
     "したがって、もしただひとつだけシーケンスが与えられ、" "その型が" (STRONG "result-type") "であったとき、"
     (CODE1 "concatenate") "は単純にそれを返却するのではなく、" (STRONG "sequences") "をコピーすることが要求されます。"
     EOL2 "もし" (STRONG "sequences") "のどの要素も、" "結果のシーケンスの要素になりえないときはエラーです。" "もし"
     (STRONG "result-type") "が" (CODE1 "list") "のサブタイプのときは、" "返却値はリストでしょう。" EOL2 "もし"
     (STRONG "result-type") "が" (CODE1 "vector") "のサブタイプの場合、" "実装が"
     (STRONG "result-type") "を要素の型として決めることができるのであれば、"
     "その要素の型をアップグレードした結果が返却値の配列の要素の型になります。" "しかし実装が要素の型を決定できないか、あるいは" (CODE1 "*") "のときは、"
     "返却値の配列の要素の型は" (CODE1 "t") "になります。" "その他の場合はエラーが発生します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(concatenate 'string \"all\" \" \" \"together\" \" \" \"now\") =>  \"all together now\""
      "(concatenate 'list \"ABC\" '(d e f) #(1 2 3) #*1011)"
      "=>  (#\\A #\\B #\\C D E F 1 2 3 1 0 1 1)" "(concatenate 'list) =>  NIL"
      "  (concatenate '(vector * 2) \"a\" \"bc\") should signal an error"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "result-type") "が、" (CODE1 "list") "のサブタイプでも、"
     (CODE1 "vector") "のサブタイプでもないとき、" "型" (CODE1 "type-error") "のエラーが発します。" EOL2
     (STRONG "result-type") "で指定した要素数と、" (STRONG "sequences") "の合計が違う場合は、" "型"
     (CODE1 "type-error") "のエラーが発します。")
    (CHAPTER ("## 参考") 2 (CODE1 "append")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("CONCATENATE" . "FUNCTION") *table*) (gethash "CONCATENATE" *table*))
(setf (gethash "CONCATENATED-STREAM" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "CONCATENATED-STREAM"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "concatenated-stream") "," (CODE1 "stream") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 (CODE1 "concatenated") "ストリームは入力ストリームであり、"
     "ゼロか複数の入力ストリームの集合を関連付けたものです。" (CODE1 "concatenated") "ストリームから読み込むことができるデータの列は、"
     "それぞれのストリームの要素から読み込むことができるデータの列を" "つなぎ合わせたものと同じになります。" EOL2 (CODE1 "concatenated")
     "ストリームからの入力は、" "最初に関連付けられた入力ストリームが" "ファイルの終わりに到達するまでのものが使われます。" "その後は最初のストリームが捨てられ、"
     "続く入力が次の入力ストリームとして使用され、くり返されます。" "関連付けられた入力ストリームのファイルの終わりは、" "常に"
     (CODE1 "concatenated") "ストリームによって目につかないように管理されますが、" "データの入力の試行により"
     "残りの入力ストリームが存在しない" (CODE1 "concatenated") "ストリームから" "データを入手しようとしたとき、"
     "唯一そのような状況のときにのみ" (CODE1 "concatenated") "ストリームの呼び出しもとにファイルの終わりを通知します。")
    (CHAPTER ("## 参考") 2 (CODE1 "concatenated-stream-streams") ","
     (CODE1 "make-concatenated-stream"))))
(setf (gethash '("CONCATENATED-STREAM" . "SYSTEM-CLASS") *table*) (gethash "CONCATENATED-STREAM" *table*))
(setf (gethash "CONCATENATED-STREAM-STREAMS" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CONCATENATED-STREAM-STREAMS"))
    (CHAPTER ("## 構文") 2 (CODE1 "concatenated-stream-streams") " "
     (STRONG "concatenated-stream") " => " (STRONG "streams"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "concatenated-stream") " - " (CODE1 "concatenated")
     "ストリーム" EOL1 (STRONG "streams") " - ストリームのリスト")
    (CHAPTER ("## 定義") 2 (STRONG "concatenated-stream") "がまだ読み込んでいない、"
     "現在の読み込むもの空始まる順序付けされたストリームの集合の成分である" "入力ストリームのリストを返却します。" EOL2 (STRONG "stream")
     "のリスト構造が後で修正されたときの結果は未定義です。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("CONCATENATED-STREAM-STREAMS" . "FUNCTION") *table*) (gethash "CONCATENATED-STREAM-STREAMS" *table*))
(setf (gethash "COND" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "COND"))
    (CHAPTER ("## 構文") 2 "cond " (CODE1 "{") (STRONG "clause") (CODE1 "}") "\\* => "
     (STRONG "result\\*") (CODE3 "```" "```" "clause ::= (test-form form*) "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "test-form") " - フォーム" EOL1 (STRONG "form")
     " - 暗黙のprogn" EOL1 (STRONG "result") " - " (STRONG "test-form") "が" (STRONG "true")
     "を返却した最初の" (STRONG "clause") "にある" (STRONG "form") "の値か、" (STRONG "form") "がない"
     (STRONG "clause") "の" (STRONG "test-form") "の第一返却値か、" "あるいは" (STRONG "test-form")
     "が" (STRONG "true") "を返却しなかったときは" (CODE1 "nil") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "cond") "は" (STRONG "test-form") "に依存した" (STRONG "form")
     "の実行を行います。" EOL2 (STRONG "test-form") "は、それが" (STRONG "true") "と評価されるものが見つかるまで、"
     "引数のリストを順番に一度だけ評価されます。" EOL2 "もし" (STRONG "clause") "に" (STRONG "form") "がないとき、"
     (STRONG "test-form") "の第一返却値が" (CODE1 "cond") "フォームの返却値になります。" "そうでなければ、"
     (STRONG "test-form") "に関連付けられた" (STRONG "form") "が" "左から右の順番に暗黙のprognとして評価され、" "最後の"
     (STRONG "form") "の返却値が" (CODE1 "cond") "フォームの返却値になります。" EOL2 "いったん"
     (STRONG "test-form") "が" (STRONG "true") "を返却したら、" "他の" (STRONG "test-form")
     "は評価されません。" "もしどの" (STRONG "test-form") "も" (STRONG "true") "を返却しないときは、"
     (CODE1 "nil") "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun select-options ()" "  (cond ((= a 1) (setq a 2))"
      "        ((= a 2) (setq a 3))" "        ((and (= a 3) (floor a 2)))"
      "        (t (floor a 3)))) =>  SELECT-OPTIONS" "(setq a 1) =>  1"
      "(select-options) =>  2" "a =>  2" "(select-options) =>  3" "a =>  3"
      "(select-options) =>  1" "(setq a 5) =>  5" "(select-options) =>  1, 2"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "if") "," (CODE1 "case")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("COND" . "MACRO") *table*) (gethash "COND" *table*))
(setf (gethash "CONDITION" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "CONDITION"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "condition") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "全てのコンディションの型は、" "エラーか非エラー関わらず、この型を継承しなければなりません。" EOL2
     "本文中で明示的に言及されている場合を除き、" "指定された型" (CODE1 "condition") "のサブタイプの間で"
     "追加のサブタイプの関係は許可されません。" "しかし実装であれば追加の型を導入することが許されており、" "これらの型のひとつは、" "任意の数の型"
     (CODE1 "condition") "のサブタイプの" "さらなるサブタイプであることができます。" EOL2
     "ユーザーで定義したコンディションの型が持つスロットを" (CODE1 "with-slots") "によってアクセスできるかどうかは" "実装依存です。"
     "さらに実装内にあるユーザー定義のコンディション型がスロットを持っているかどうか、" "またコンディション型のドキュメントにそのようなスロットが定義されているか、"
     "それらのスロットが名前を持っており実際に扱っているかどうかなどは、" "すべて実装依存です。" "移植可能なコードが参考にできるのは、"
     "ただ仕様書に記載されているリーダー関数のみです。" EOL2 "仕様に適合したコードはコンディションに関係する" "下記の制約に従わなければなりません。" EOL2
     "- 新しいコンディション型を定義するときは" (CODE1 "define-condition") "を使用しなければならず、" (CODE1 "defclass")
     "ではいけません。" EOL2 "- コンディションのオブジェクトを明に作成するときは、" (CODE1 "make-condition")
     "を使用しなければならず、" (CODE1 "make-instance") "ではいけません。" EOL2 "- コンディションの報告を定義するときは"
     (CODE1 "define-condition") "の" (CODE1 ":report") "オプションを使用しなければならず、"
     (CODE1 "print-object") "の" (CODE1 "defmethod") "を定義してはいけません。" EOL2 "- "
     (CODE1 "slot-value") ", " (CODE1 "slot-boundp") "," (CODE1 "slot-makunbound") ", "
     (CODE1 "with-slots") "は" "コンディションオブジェクトに使用してはいけません。" "かわりに（"
     (CODE1 "define-condition") "によって定義された）" "適切なアクセス関数を使用する必要があります。")))
(setf (gethash '("CONDITION" . "CONDITION-TYPE") *table*) (gethash "CONDITION" *table*))
(setf (gethash "CONS" *table*)
  '("CONS FUNCTION" EOL1 "CONS SYSTEM-CLASS" EOL1))
(setf (gethash '("CONS" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CONS"))
    (CHAPTER ("## 構文") 2 (CODE1 "cons") " " (STRONG "object-1") " " (STRONG "object-2")
     " => " (STRONG "cons"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object-1") " - オブジェクト" EOL1 (STRONG "object-2")
     " - オブジェクト" EOL1 (STRONG "cons") " - コンス")
    (CHAPTER ("## 定義") 2 (CODE1 "car") "が" (STRONG "object-1") "で、" (CODE1 "cdr") "が"
     (STRONG "object-2") "の" "新しいコンスを作成します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(cons 1 2) =>  (1 . 2)" "(cons 1 nil) =>  (1)"
      "(cons nil 2) =>  (NIL . 2)" "(cons nil nil) =>  (NIL)"
      "(cons 1 (cons 2 (cons 3 (cons 4 nil)))) =>  (1 2 3 4)" "(cons 'a 'b) =>  (A . B)"
      "(cons 'a (cons 'b (cons 'c '()))) =>  (A B C)"
      "(cons 'a '(b c d)) =>  (A B C D)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "list"))
    (CHAPTER ("## 備考") 2 "もし" (STRONG "object-2") "がリストなら、" (CODE1 "cons") "は、"
     (STRONG "object-1") "を先頭に追加したような新しいリストを生成すると" "考えることができます。")))
(setf (gethash '("CONS" . "SYSTEM-CLASS") *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "CONS"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "cons") "," (CODE1 "list") "," (CODE1 "sequence")
     "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "コンスは2つの構成要素" (CODE1 "car") "と" (CODE1 "cdr") "を持つ複合オブジェクトです。"
     "これらはドットペアで表現されます。" "各要素はどんなオブジェクトにもなれます。")
    (CHAPTER ("## 型指定子の種類") 2 "特定可能")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "cons") " [" (STRONG "car-typespec") " ["
     (STRONG "cdr-typespec") "]]")
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "car-typespec") " - 型指定子かシンボル" (CODE1 "*")
     "。デフォルトはシンボル" (CODE1 "*") "。" EOL1 (STRONG "cdr-typespec") " - 型指定子かシンボル"
     (CODE1 "*") "。デフォルトはシンボル" (CODE1 "*") "。")
    (CHAPTER ("## 型指定子の定義") 2 "これは、" (CODE1 "car") "が" (STRONG "car-typespec") "に、"
     (CODE1 "cdr") "が" (STRONG "cdr-typespec") "に制約されている" "コンスの集合を意味します。" "（もし、"
     (STRONG "car-typespec") "や" (STRONG "cdr-typespec") "が" (CODE1 "*") "であったときは、" "型"
     (CODE1 "t") "が指定されたのと同じです ）")
    (CHAPTER ("## 参考") 2 "2.4.1. 左括弧," "22.1.3.5. リストとコンスの印字")))
(setf (gethash "CONSP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CONSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "consp") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が型" (CODE1 "cons") "なら" (STRONG "true") "を、"
     "そうではないときは" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(consp nil) =>  false" "(consp (cons 1 2)) =>  true") EOL2
     "空のリストはコンスではないので、次の結果が成り立ちます。"
     (CODE3 "```lisp" "```" "(consp '()) == (consp 'nil) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "listp"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```"
      " (consp object) == (typep object 'cons) == (not (typep object 'atom)) == (typep object '(not atom))"))))
(setf (gethash '("CONSP" . "FUNCTION") *table*) (gethash "CONSP" *table*))
(setf (gethash "CONSTANTLY" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CONSTANTLY"))
    (CHAPTER ("## 構文") 2 (CODE1 "constantly") " " (STRONG "value") " => "
     (STRONG "function"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "value") " - オブジェクト" EOL1 (STRONG "function")
     " - 関数")
    (CHAPTER ("## 定義") 2 (CODE1 "constantly") "は、引数を何個でも受け付ける関数を返却し、" "その関数は副作用がなく常に"
     (STRONG "value") "を返却するというものです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(mapcar (constantly 3) '(a b c d)) =>  (3 3 3 3)"
      "(defmacro with-vars (vars &body forms)"
      "  `((lambda ,vars ,@forms) ,@(mapcar (constantly nil) vars)))" "=>  WITH-VARS"
      "(macroexpand '(with-vars (a b) (setq a 3 b (* a a)) (list a b)))"
      "=>  ((LAMBDA (A B) (SETQ A 3 B (* A A)) (LIST A B)) NIL NIL), true"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "identity"))
    (CHAPTER ("## 備考") 2 (CODE1 "constantly") "は次のように定義できます。"
     (CODE3 "```lisp" "```" "(defun constantly (object)"
      "  #'(lambda (&rest arguments) object))"))))
(setf (gethash '("CONSTANTLY" . "FUNCTION") *table*) (gethash "CONSTANTLY" *table*))
(setf (gethash "CONSTANTP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "CONSTANTP"))
    (CHAPTER ("## 構文") 2 (CODE1 "constantp") " " (STRONG "form") " &optional "
     (STRONG "environment") " => generalized-boolean")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "form") " - フォーム" EOL1 (STRONG "environment")
     " - 環境オブジェクト。デフォルトは" (CODE1 "nil") "です。" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "指定された" (STRONG "environment") "の下で、" (STRONG "form")
     "がその実装によって定数フォームであると決定できるとき、" (STRONG "true") "が返却されます。" "それ以外の、フォームが定数フォームではないか、"
     "あるいはフォームが定数かどうか決定できないかの、" "どちらかの場合には" (STRONG "false") "が返却されます。" EOL2
     "下記に定義された種類のフォームが定数フォームであると考えます。" EOL2 "- 自己評価オブジェクト（例えば数、文字、そして多種な配列）は、"
     "常に定数フォームであると考えられ、" (CODE1 "constantp") "によって認識されなければなりません。" EOL2 "- 定数変数、キーワード、"
     "Common Lispによって定義された定数シンボル" "（例えば" (CODE1 "nil") "、" (CODE1 "t") "、" (CODE1 "pi")
     "）、" "ユーザーが" (CODE1 "defconstant") "で" (STRONG "environment") "に定数として指定したシンボルは、"
     "常に定数フォームであると考えられ、" (CODE1 "constantp") "によって認識されなければなりません。" EOL2 "- "
     (CODE1 "quote") "フォームは" "常に定数フォームであると考えられ、" (CODE1 "constantp") "によって認識されなければなりません。"
     EOL2 "- 実装はさらに追加で定数フォームを" "検出することが許されますが、必須ではありません。" "もしそれを行うのであれば、"
     (STRONG "environment") "の情報を使用することができますが、" "必須ではありません。" (CODE1 "constantp") "によって"
     (STRONG "true") "かもしれないし" "そうではないかもしれない定数フォームの例として次のものが挙げられます" (CODE1 "(sqrt pi)")
     ", " (CODE1 "(+ 3 2)") ", " (CODE1 "(length '(a b c))") ", "
     (CODE1 "(let ((x 7)) (zerop x))") "。" EOL2 "もし実装が" (STRONG "environment")
     "の情報を使用するとしたとき、" "マクロ展開や関数の" (CODE1 "inline") "といった動作は許されますが、必須ではありません。"
     "しかしコンパイラーマクロの展開は許されません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(constantp 1) =>  true" "(constantp 'temp) =>  false"
      "(constantp ''temp)) =>  true"
      "(defconstant this-is-a-constant 'never-changing) =>  THIS-IS-A-CONSTANT "
      "(constantp 'this-is-a-constant) =>  true" "(constantp \"temp\") =>  true"
      "(setq a 6) =>  6 " "(constantp a) =>  true"
      "(constantp '(sin pi)) =>  implementation-dependent"
      "(constantp '(car '(x))) =>  implementation-dependent"
      "(constantp '(eql x x)) =>  implementation-dependent"
      "(constantp '(typep x 'nil)) =>  implementation-dependent"
      "(constantp '(typep x 't)) =>  implementation-dependent"
      "(constantp '(values this-is-a-constant)) =>  implementation-dependent"
      "(constantp '(values 'x 'y)) =>  implementation-dependent"
      "(constantp '(let ((a '(a b c))) (+ (length a) 6))) =>  implementation-dependent"))
    (CHAPTER ("## 副作用") 2 "なし。")
    (CHAPTER ("## 影響") 2 "グローバル環境の状態" "（例えば定数変数の名前として宣言されたシンボルなど）。")
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "defconstant"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("CONSTANTP" . "FUNCTION") *table*) (gethash "CONSTANTP" *table*))
(setf (gethash "CONTINUE" *table*)
  '("CONTINUE FUNCTION" EOL1 "CONTINUE RESTART" EOL1))
(setf (gethash '("CONTINUE" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ABORT") ", " (CODE1 "CONTINUE") ", "
     (CODE1 "MUFFLE-WARNING") ", " (CODE1 "STORE-VALUE") ", " (CODE1 "USE-VALUE"))
    (CHAPTER ("## 構文") 2 (CODE1 "abort") " " (CODE1 "&optional") " " (STRONG "condition")
     " => " (CODE1 "|") EOL1 (CODE1 "continue") " " (CODE1 "&optional") " "
     (STRONG "condition") " => " (CODE1 "nil") EOL1 (CODE1 "muffle-warning") " "
     (CODE1 "&optional") " " (STRONG "condition") " => " (CODE1 "|") EOL1
     (CODE1 "store-value") " " (STRONG "value") " " (CODE1 "&optional") " "
     (STRONG "condition") " => " (CODE1 "nil") EOL1 (CODE1 "use-value") " "
     (STRONG "value") " " (CODE1 "&optional") " " (STRONG "condition") " => "
     (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "value") " - オブジェクト" EOL1 (STRONG "condition")
     " - コンディションオブジェクトか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "もっとも最近確立された適用可能な" (CODE1 "restart") "のうち、"
     "関数と同じ名前を持つものへ制御が遷移されます。" "つまり、" (CODE1 "abort") "関数は" "適用可能な" (CODE1 "abort") " "
     (CODE1 "restart") "を探し、" (CODE1 "continue") "関数は" "適用可能な" (CODE1 "continue") " "
     (CODE1 "restart") "を探し、" "他も同様です。" EOL2 "もしそのような" (CODE1 "restart") "が存在しないときは、"
     (CODE1 "continue") ", " (CODE1 "store-value") "," (CODE1 "use-value") "は"
     (CODE1 "nil") "を返却し、" (CODE1 "abort") "と" (CODE1 "muffle-warning") "は" "型"
     (CODE1 "control-error") "のエラーを発生します。" EOL2 "もし" (STRONG "condition") "が"
     (CODE1 "nil") "ではないときは、" "それらの" (CODE1 "restart") "は、明に" (STRONG "condition")
     "と関連付けられているものか、" "あるいはどのコンディションにも関連付けられてないものかの" "どちらかのみが集められます。" "これは、排他された"
     (CODE1 "restart") "というのは、" "関連付けられたコンディションの集合が空ではなく、" "その要素に指定した"
     (STRONG "condition") "が含まれていないということです。" "もし" (STRONG "condition") "が" (CODE1 "nil")
     "のときは、" "全ての" (CODE1 "restart") "が集められます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";;; ABORT restartの例" NIL
      "(defmacro abort-on-error (&body forms)" "  `(handler-bind ((error #'abort))"
      "     ,@forms)) =>  ABORT-ON-ERROR" "(abort-on-error (+ 3 5)) =>  8"
      "(abort-on-error (error \"You lose.\"))" ">>  Returned to Lisp Top Level." NIL
      ";;; CONTINUE restartの例" NIL "(defun real-sqrt (n)" "  (when (minusp n)"
      "    (setq n (- n))"
      "    (cerror \"Return sqrt(~D) instead.\" \"Tried to take sqrt(-~D).\" n))"
      "  (sqrt n))" NIL "(real-sqrt 4) =>  2" "(real-sqrt -9)"
      ">>  Error: Tried to take sqrt(-9)."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Return sqrt(9) instead." ">>   2: Return to Lisp Toplevel."
      ">>  Debug> (continue)" ">>  Return sqrt(9) instead." "=>  3" " "
      " (handler-bind ((error #'(lambda (c) (continue))))" "   (real-sqrt -9)) =>  3" NIL
      ";;; MUFFLE-WARNING restartの例" NIL "(defun count-down (x)"
      "  (do ((counter x (1- counter)))" "      ((= counter 0) 'done)"
      "    (when (= counter 1)" "      (warn \"Almost done\"))"
      "    (format t \"~&~D~%\" counter)))" "=>  COUNT-DOWN" "(count-down 3)" ">>  3"
      ">>  2" ">>  Warning: Almost done" ">>  1" "=>  DONE"
      "(defun ignore-warnings-while-counting (x)"
      "  (handler-bind ((warning #'ignore-warning))" "    (count-down x)))"
      "=>  IGNORE-WARNINGS-WHILE-COUNTING" "(defun ignore-warning (condition)"
      "  (declare (ignore condition))" "  (muffle-warning))" "=>  IGNORE-WARNING"
      " (ignore-warnings-while-counting 3)" ">>  3" ">>  2" ">>  1" "=>  DONE" NIL
      ";;; STORE-VALUE restartとUSE-VALUE restartの例" NIL
      "(defun careful-symbol-value (symbol)" "  (check-type symbol symbol)"
      "  (restart-case (if (boundp symbol)"
      "                    (return-from careful-symbol-value "
      "                                 (symbol-value symbol))"
      "                    (error 'unbound-variable"
      "                           :name symbol))" "    (use-value (value)"
      "      :report \"Specify a value to use this time.\"" "      value)"
      "    (store-value (value)"
      "      :report \"Specify a value to store and use in the future.\""
      "      (setf (symbol-value symbol) value))))" "(setq a 1234) =>  1234"
      "(careful-symbol-value 'a) =>  1234" "(makunbound 'a) =>  A"
      "(careful-symbol-value 'a)" ">>  Error: A is not bound."
      ">>  To continue, type :CONTINUE followed by an option number."
      ">>   1: Specify a value to use this time."
      ">>   2: Specify a value to store and use in the future."
      ">>   3: Return to Lisp Toplevel." ">>  Debug> (use-value 12)" "=>  12"
      "(careful-symbol-value 'a)" ">>  Error: A is not bound."
      ">>  To continue, type :CONTINUE followed by an option number."
      ">>    1: Specify a value to use this time."
      ">>    2: Specify a value to store and use in the future."
      ">>    3: Return to Lisp Toplevel." ">>  Debug> (store-value 24)" "=>  24"
      " (careful-symbol-value 'a)" "=>  24" NIL ";;; USE-VALUE restartの例" NIL
      "(defun add-symbols-with-default (default &rest symbols)"
      "  (handler-bind ((sys:unbound-symbol" "                   #'(lambda (c)"
      "                       (declare (ignore c)) "
      "                       (use-value default))))"
      "    (apply #'+ (mapcar #'careful-symbol-value symbols))))"
      "=>  ADD-SYMBOLS-WITH-DEFAULT" "(setq x 1 y 2) =>  2"
      "(add-symbols-with-default 3 'x 'y 'z) =>  6"))
    (CHAPTER ("## 副作用") 2 "適用可能な" (CODE1 "restart") "が使用可能なときに" "制御の遷移が起こるかもしれませんし、"
     "あるいは（" (CODE1 "abort") "関数か" (CODE1 "muffle-warning") "関数の場合は）" "実行が停止するかもしれません。")
    (CHAPTER ("## 影響") 2 "もし適用可能な" (CODE1 "abort") " " (CODE1 "restart") "が" "利用不可の状態で"
     (CODE1 "abort") "関数が実行されれたときか、" "適用可能な" (CODE1 "muffle-warning") " "
     (CODE1 "restart") "が" "利用不可の状態で" (CODE1 "muffle-warning") "関数が実行されれたときは、" "型"
     (CODE1 "control-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "invoke-restart") "," "9.1.4.2. " (CODE1 "restart") ","
     "9.1.4.2.2. " (CODE1 "restart") "のインターフェイス," (CODE1 "assert") "," (CODE1 "ccase")
     "," (CODE1 "cerror") "," (CODE1 "check-type") "," (CODE1 "ctypecase") ","
     (CODE1 "use-value") "," (CODE1 "warn"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(abort condition) ==  (invoke-restart 'abort)"
      "(muffle-warning)  ==  (invoke-restart 'muffle-warning)"
      "(continue)        ==  (let ((r (find-restart 'continue))) (if r (invoke-restart r)))"
      "(use-value x) ==  (let ((r (find-restart 'use-value))) (if r (invoke-restart r x)))"
      "(store-value x) ==  (let ((r (find-restart 'store-value))) (if r (invoke-restart r x)))")
     EOL2 "この仕様書で" (CODE1 "use-value") " " (CODE1 "restart") "の提供に" "要求される関数定義はありません。")))
(setf (gethash '("CONTINUE" . "RESTART") *table*)
  '((CHAPTER NIL 0 "Restart " (CODE1 "CONTINUE")) (CHAPTER ("## 要求される引数のデータ") 2 "なし。")
    (CHAPTER ("## 定義") 2 (CODE1 "continue") " " (CODE1 "restart") "は、" "一般的には"
     (CODE1 "break") "や" (CODE1 "cerror") "のような状況で、" "継続するためのひとつの「明確な」方法が存在するという"
     "プロトコルの一部です。" "ユーザ定義のプロトコルの中にも、" "同様の理由でこれを組み込みたいと思うものがあるかもしれません。"
     "しかし、一般的には特定のアプリケーションに直接適した名前を持つ" "特別な目的の" (CODE1 "restart") "を設計する方がより信頼できます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(let ((x 3))" "  (handler-bind ((error #'(lambda (c)"
      "                            (let ((r (find-restart 'continue c)))"
      "                              (when r (invoke-restart r))))))"
      "    (cond ((not (floatp x))"
      "           (cerror \"Try floating it.\" \"~D is not a float.\" x)"
      "           (float x))" "          (t x)))) =>  3.0"))
    (CHAPTER ("## 参考") 2 "9.1.4.2. " (CODE1 "restart") "," "9.1.4.2.2. "
     (CODE1 "restart") "のインターフェイス," (CODE1 "invoke-restart") "," (CODE1 "continue")
     "（関数）," (CODE1 "assert") "," (CODE1 "cerror") ",")))
(setf (gethash "CONTROL-ERROR" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "CONTROL-ERROR"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "control-error") "," (CODE1 "error") ","
     (CODE1 "serious-condition") "," (CODE1 "condition") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "control-error") "は、" "プログラム内において不正な動的遷移の結果による"
     "エラーの状態で構成されています。" "アクティブではないタグに対する" (CODE1 "throw") "の結果であったり、"
     "もはや動的に利用可能ではないタグに対する" (CODE1 "go") "や" (CODE1 "return-from") "の結果であったりするエラーは、"
     (CODE1 "control-error") "の型になります。")))
(setf (gethash '("CONTROL-ERROR" . "CONDITION-TYPE") *table*) (gethash "CONTROL-ERROR" *table*))
(setf (gethash "COPY-ALIST" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "COPY-ALIST"))
    (CHAPTER ("## 構文") 2 (CODE1 "copy-alist") " " (STRONG "alist") " => "
     (STRONG "new-alist"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "alist") " - 連想リスト" EOL1 (STRONG "new-alist")
     " - 連想リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "copy-alist") "は、" (STRONG "alist") "のコピーを返却します。" EOL2
     (STRONG "alist") "のリスト構造がコピーされ、" (STRONG "alist") "の要素のコンスもまたコピーされます" "（ただしコンスのみ）。"
     (STRONG "alist") "によって直接・間接に関わらず、" "参照されている他のオブジェクトは、" "引き続き共有されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(defparameter *alist* (acons 1 \"one\" (acons 2 \"two\" '())))"
      "*alist* =>  ((1 . \"one\") (2 . \"two\"))"
      "(defparameter *list-copy* (copy-list *alist*))"
      "*list-copy* =>  ((1 . \"one\") (2 . \"two\"))"
      "(defparameter *alist-copy* (copy-alist *alist*))"
      "*alist-copy* =>  ((1 . \"one\") (2 . \"two\"))"
      "(setf (cdr (assoc 2 *alist-copy*)) \"deux\") =>  \"deux\""
      "*alist-copy* =>  ((1 . \"one\") (2 . \"deux\"))"
      "*alist* =>  ((1 . \"one\") (2 . \"two\"))"
      "(setf (cdr (assoc 1 *list-copy*)) \"uno\") =>  \"uno\""
      "*list-copy* =>  ((1 . \"uno\") (2 . \"two\"))"
      "*alist* =>  ((1 . \"uno\") (2 . \"two\"))"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "copy-list")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("COPY-ALIST" . "FUNCTION") *table*) (gethash "COPY-ALIST" *table*))
(setf (gethash "COPY-LIST" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "COPY-LIST"))
    (CHAPTER ("## 構文") 2 (CODE1 "copy-list") " " (STRONG "list") " => " (STRONG "copy"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - 通常のリストかドットリスト" EOL1 (STRONG "copy")
     " - リスト")
    (CHAPTER ("## 定義") 2 (STRONG "list") "のコピーを返却します。" "もし" (STRONG "list") "がドットリストのとき、"
     "結果のリストもまたドットリストです。" EOL2 "ただ" (STRONG "list") "のリスト構造だけをコピーします。" "結果のリストの要素は、引数"
     (STRONG "list") "の対応する要素と同じです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst (list 1 (list 2 3))) =>  (1 (2 3))"
      "(setq slst lst) =>  (1 (2 3))" "(setq clst (copy-list lst)) =>  (1 (2 3))"
      "(eq slst lst) =>  true" "(eq clst lst) =>  false" "(equal clst lst) =>  true"
      "(rplaca lst \"one\") =>  (\"one\" (2 3))" "slst =>  (\"one\" (2 3))"
      "clst =>  (1 (2 3))" "(setf (caadr lst) \"two\") =>  \"two\""
      "lst =>  (\"one\" (\"two\" 3))" "slst =>  (\"one\" (\"two\" 3))"
      "clst =>  (1 (\"two\" 3))"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list") "が循環リストのときの結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "copy-alist") "," (CODE1 "copy-seq") ","
     (CODE1 "copy-tree"))
    (CHAPTER ("## 備考") 2 "作成されたコピーは、" (STRONG "list") "と" (CODE1 "equal") "ですが、"
     (CODE1 "eq") "ではありません。")))
(setf (gethash '("COPY-LIST" . "FUNCTION") *table*) (gethash "COPY-LIST" *table*))
(setf (gethash "COPY-PPRINT-DISPATCH" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "COPY-PPRINT-DISPATCH"))
    (CHAPTER ("## 構文") 2 (CODE1 "copy-pprint-dispatch") " " (CODE1 "&optional") " "
     (STRONG "table") " => " (STRONG "new-table"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "table") " - " (CODE1 "pprint") "ディスパッチテーブルか、"
     (CODE1 "nil") EOL1 (STRONG "new-table") " - 新しい" (CODE1 "pprint") "ディスパッチテーブル")
    (CHAPTER ("## 定義") 2 (STRONG "table") "が指定されたときは、その値のコピーが生成され返却します。" (STRONG "table")
     "が指定されなかったときは、" (CODE1 "*print-pprint-dispatch*") "の値のコピーが返却されます。" (CODE1 "nil")
     "が指定されたときは、" (CODE1 "*print-pprint-dispatch*") "の初期値のコピーが返却されます。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "table") "が" (CODE1 "pprint") "ディスパッチテーブルではないとき、" "型"
     (CODE1 "type-error") "のエラーを通知するべきです。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("COPY-PPRINT-DISPATCH" . "FUNCTION") *table*) (gethash "COPY-PPRINT-DISPATCH" *table*))
(setf (gethash "COPY-SEQ" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "COPY-SEQ"))
    (CHAPTER ("## 構文") 2 (CODE1 "copy-seq") " " (STRONG "sequence") " => "
     (STRONG "copied-sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "sequence") " - 正常なシーケンス" EOL1
     (STRONG "copied-sequence") " - 正常なシーケンス")
    (CHAPTER ("## 定義") 2 "シーケンスのコピーを作成します。" "新しいシーケンスの要素は、対応する引数" (STRONG "sequnece")
     "の要素と同じです。" EOL2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "結果は"
     (STRONG "sequence") "として同じ実際の配列の要素の型を持つ、" "一次元の新しいsimple-arrayです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq str \"a string\") =>  \"a string\""
      "(equalp str (copy-seq str)) =>  true" "(eql str (copy-seq str)) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "copy-list"))
    (CHAPTER ("## 備考") 2 "機能としては、下記と同等です。"
     (CODE3 "```lisp" "```" "(copy-seq x) ==  (subseq x 0)") EOL2 "しかし、プログラマーの意図は、"
     "この二つの場合においては大きく異なるのが一般的です。")))
(setf (gethash '("COPY-SEQ" . "FUNCTION") *table*) (gethash "COPY-SEQ" *table*))
(setf (gethash "COPY-STRUCTURE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "COPY-STRUCTURE"))
    (CHAPTER ("## 構文") 2 (CODE1 "copy-structure") " " (STRONG "structure") " => "
     (STRONG "copy"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "structure") " - 構造体" EOL1 (STRONG "copy")
     " - 構造体のコピー")
    (CHAPTER ("## 定義") 2 "構造体のコピーを返却します。" EOL2 "構造体自身だけをコピーし、スロットの値はコピーしません。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "defstruct") "の" (CODE1 ":copier") "オプション")
    (CHAPTER ("## 備考") 2 (STRONG "copy") "は引数の" (STRONG "structure") "と" (CODE1 "equalp")
     "で同一です。" "しかし" (CODE1 "equal") "はそうではありません。")))
(setf (gethash '("COPY-STRUCTURE" . "FUNCTION") *table*) (gethash "COPY-STRUCTURE" *table*))
(setf (gethash "COPY-SYMBOL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "COPY-SYMBOL"))
    (CHAPTER ("## 構文") 2 (CODE1 "copy-symbol") " " (STRONG "symbol") " &optional "
     (STRONG "copy-properties") " => " (STRONG "new-symbol"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - シンボル" EOL1 (STRONG "copy-properties")
     " - generalized-boolean、デフォルトは" (STRONG "false") EOL1 (STRONG "new-symbol")
     " - 新しい、" (CODE1 "unintern") "なシンボル")
    (CHAPTER ("## 定義") 2 (CODE1 "copy-symbol") "は、新しく、" (CODE1 "unintern") "であり、" "引数"
     (STRONG "symbol") "の名前と" (CODE1 "string=") "で等しい名前を持つシンボルを返却します。"
     "そのシンボル名は、引数のシンボル名と同じである可能性があります。" EOL2 (STRONG "copy-properties") "が"
     (STRONG "false") "のときは、" (STRONG "new-symbol") "は、" (CODE1 "bound") "でも、"
     (CODE1 "fbound") "でもなく、" (CODE1 "null") "のプロパティリストを持ちます。" (STRONG "copy-properties")
     "が" (STRONG "true") "のときは、" (STRONG "new-symbol") "の初期値は" (STRONG "symbol") "の値であり、"
     (STRONG "new-symbol") "の関数定義の初期値は" (STRONG "symbol") "の関数の値であり、"
     (STRONG "new-symbol") "のプロパティリストの初期値は" (STRONG "symbol") "のプロパティリストのコピーされた値です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq fred 'fred-smith) =>  FRED-SMITH"
      "(setf (symbol-value fred) 3) =>  3"
      "(setq fred-clone-1a (copy-symbol fred nil)) =>  #:FRED-SMITH"
      "(setq fred-clone-1b (copy-symbol fred nil)) =>  #:FRED-SMITH"
      "(setq fred-clone-2a (copy-symbol fred t))   =>  #:FRED-SMITH"
      "(setq fred-clone-2b (copy-symbol fred t))   =>  #:FRED-SMITH"
      "(eq fred fred-clone-1a) =>  false" "(eq fred-clone-1a fred-clone-1b) =>  false"
      "(eq fred-clone-2a fred-clone-2b) =>  false"
      "(eq fred-clone-1a fred-clone-2a) =>  false" "(symbol-value fred) =>  3"
      "(boundp fred-clone-1a) =>  false" "(symbol-value fred-clone-2a) =>  3"
      "(setf (symbol-value fred-clone-2a) 4) =>  4" "(symbol-value fred) =>  3"
      "(symbol-value fred-clone-2a) =>  4" "(symbol-value fred-clone-2b) =>  3"
      "(boundp fred-clone-1a) =>  false"
      "(setf (symbol-function fred) #'(lambda (x) x)) =>  #<FUNCTION anonymous>"
      "(fboundp fred) =>  true" "(fboundp fred-clone-1a) =>  false"
      "(fboundp fred-clone-2a) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "symbol") "がシンボルではないとき、" "型" (CODE1 "type-error")
     "のエラーが発せられます。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-symbol"))
    (CHAPTER ("## 備考") 2 "実装者は、むやみにシンボル名の文字をコピーする必要はありません。" "通常の実装においては、"
     (STRONG "new-symbol") "の名前と引数" (STRONG "symbol") "の名前をコピーして同一にするのは、" "良い方法とは言えません。")))
(setf (gethash '("COPY-SYMBOL" . "FUNCTION") *table*) (gethash "COPY-SYMBOL" *table*))
(setf (gethash "COPY-TREE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "COPY-TREE"))
    (CHAPTER ("## 構文") 2 (CODE1 "copy-tree") " " (STRONG "tree") " => "
     (STRONG "new-tree"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "tree") " - ツリー" EOL1 (STRONG "new-tree") " - ツリー")
    (CHAPTER ("## 定義") 2 "コンスのツリーのコピーを作成します。" EOL2 "もし" (STRONG "tree")
     "がコンスではないときは、それが返却されます。" "そうでないときは、" (STRONG "tree") "の" (CODE1 "car") "と"
     (CODE1 "cdr") "で" (CODE1 "copy-tree") "を呼び出し、" "その結果の新しいコンスを作り返却します。" "つまり、"
     (STRONG "tree") "であらわされるツリーの全てのコンスを再帰的にコピーし、" "コンスではないものに遭遇したときだけ停止します。" EOL2
     (CODE1 "copy-tree") "は、循環している構造や、" "部分的に共有している構造を保存できません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq object (list (cons 1 \"one\")"
      "                   (cons 2 (list 'a 'b 'c))))" "=>  ((1 . \"one\") (2 A B C))"
      "(setq object-too object) =>  ((1 . \"one\") (2 A B C))"
      "(setq copy-as-list (copy-list object))" "(setq copy-as-alist (copy-alist object))"
      "(setq copy-as-tree (copy-tree object))" "(eq object object-too) =>  true"
      "(eq copy-as-tree object) =>  false" "(eql copy-as-tree object) =>  false"
      "(equal copy-as-tree object) =>  true" "(setf (first (cdr (second object))) \"a\""
      "      (car (second object)) \"two\""
      "      (car object) '(one . 1)) =>  (ONE . 1)"
      "object =>  ((ONE . 1) (\"two\" \"a\" B C))"
      "object-too =>  ((ONE . 1) (\"two\" \"a\" B C))"
      "copy-as-list =>  ((1 . \"one\") (\"two\" \"a\" B C))"
      "copy-as-alist =>  ((1 . \"one\") (2 \"a\" B C))"
      "copy-as-tree =>  ((1 . \"one\") (2 A B C)) "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "tree-equal")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("COPY-TREE" . "FUNCTION") *table*) (gethash "COPY-TREE" *table*))
(setf (gethash "COUNT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "COUNT") ", " (CODE1 "COUNT-IF") ", "
     (CODE1 "COUNT-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "count") " " (STRONG "item") " " (STRONG "sequence")
     " &key " (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " "
     (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => " (STRONG "n") EOL1
     (CODE1 "count-if") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "key")
     " => " (STRONG "n") EOL1 (CODE1 "count-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "key") " => " (STRONG "n"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "sequence")
     " - 正常なシーケンス" EOL1 (STRONG "predicate") " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子"
     EOL1 (STRONG "from-end") " - generalized-boolean、デフォルトは" (STRONG "false") EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "n") " - " (STRONG "sequence")
     "の長さ以下の非負の整数")
    (CHAPTER ("## 定義") 2 (CODE1 "count") "、" (CODE1 "count-if") "、"
     (CODE1 "count-if-not") "は、" (STRONG "sequence") "の" (STRONG "start") ", "
     (STRONG "end") "の境界内にある要素のうち、" (STRONG "test") "によって満たされるものの数を返却します。" EOL2
     (STRONG "from-end") "は、返却値に直接な効果を持ちません。" "しかし、" (STRONG "from-end") "が"
     (STRONG "true") "のときは、" (STRONG "sequence") "の要素は、" (STRONG "test") "、"
     (STRONG "test-not") "、" (STRONG "key") "の引数が逆順に指定され、" "これらの関数に副作用があるのであれば、"
     "その効果が変更さる可能性があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(count #\\a \"how many A's are there in here?\") =>  2"
      "(count-if-not #'oddp '((1) (2) (3) (4)) :key #'car) =>  2"
      "(count-if #'upper-case-p \"The Crying of Lot 49\" :start 4) =>  2 "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "17.2. テスト関数のルール," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "count-if-not") "は非推奨です。")))
(setf (gethash '("COUNT" . "FUNCTION") *table*) (gethash "COUNT" *table*))
(setf (gethash "COUNT-IF" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "COUNT") ", " (CODE1 "COUNT-IF") ", "
     (CODE1 "COUNT-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "count") " " (STRONG "item") " " (STRONG "sequence")
     " &key " (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " "
     (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => " (STRONG "n") EOL1
     (CODE1 "count-if") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "key")
     " => " (STRONG "n") EOL1 (CODE1 "count-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "key") " => " (STRONG "n"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "sequence")
     " - 正常なシーケンス" EOL1 (STRONG "predicate") " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子"
     EOL1 (STRONG "from-end") " - generalized-boolean、デフォルトは" (STRONG "false") EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "n") " - " (STRONG "sequence")
     "の長さ以下の非負の整数")
    (CHAPTER ("## 定義") 2 (CODE1 "count") "、" (CODE1 "count-if") "、"
     (CODE1 "count-if-not") "は、" (STRONG "sequence") "の" (STRONG "start") ", "
     (STRONG "end") "の境界内にある要素のうち、" (STRONG "test") "によって満たされるものの数を返却します。" EOL2
     (STRONG "from-end") "は、返却値に直接な効果を持ちません。" "しかし、" (STRONG "from-end") "が"
     (STRONG "true") "のときは、" (STRONG "sequence") "の要素は、" (STRONG "test") "、"
     (STRONG "test-not") "、" (STRONG "key") "の引数が逆順に指定され、" "これらの関数に副作用があるのであれば、"
     "その効果が変更さる可能性があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(count #\\a \"how many A's are there in here?\") =>  2"
      "(count-if-not #'oddp '((1) (2) (3) (4)) :key #'car) =>  2"
      "(count-if #'upper-case-p \"The Crying of Lot 49\" :start 4) =>  2 "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "17.2. テスト関数のルール," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "count-if-not") "は非推奨です。")))
(setf (gethash '("COUNT-IF" . "FUNCTION") *table*) (gethash "COUNT-IF" *table*))
(setf (gethash "COUNT-IF-NOT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "COUNT") ", " (CODE1 "COUNT-IF") ", "
     (CODE1 "COUNT-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "count") " " (STRONG "item") " " (STRONG "sequence")
     " &key " (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " "
     (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => " (STRONG "n") EOL1
     (CODE1 "count-if") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "key")
     " => " (STRONG "n") EOL1 (CODE1 "count-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "key") " => " (STRONG "n"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "sequence")
     " - 正常なシーケンス" EOL1 (STRONG "predicate") " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子"
     EOL1 (STRONG "from-end") " - generalized-boolean、デフォルトは" (STRONG "false") EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "n") " - " (STRONG "sequence")
     "の長さ以下の非負の整数")
    (CHAPTER ("## 定義") 2 (CODE1 "count") "、" (CODE1 "count-if") "、"
     (CODE1 "count-if-not") "は、" (STRONG "sequence") "の" (STRONG "start") ", "
     (STRONG "end") "の境界内にある要素のうち、" (STRONG "test") "によって満たされるものの数を返却します。" EOL2
     (STRONG "from-end") "は、返却値に直接な効果を持ちません。" "しかし、" (STRONG "from-end") "が"
     (STRONG "true") "のときは、" (STRONG "sequence") "の要素は、" (STRONG "test") "、"
     (STRONG "test-not") "、" (STRONG "key") "の引数が逆順に指定され、" "これらの関数に副作用があるのであれば、"
     "その効果が変更さる可能性があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(count #\\a \"how many A's are there in here?\") =>  2"
      "(count-if-not #'oddp '((1) (2) (3) (4)) :key #'car) =>  2"
      "(count-if #'upper-case-p \"The Crying of Lot 49\" :start 4) =>  2 "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "17.2. テスト関数のルール," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "count-if-not") "は非推奨です。")))
(setf (gethash '("COUNT-IF-NOT" . "FUNCTION") *table*) (gethash "COUNT-IF-NOT" *table*))
(setf (gethash "CTYPECASE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "TYPECASE") ", " (CODE1 "CTYPECASE") ", "
     (CODE1 "ETYPECASE"))
    (CHAPTER ("## 構文") 2 (CODE1 "typecase") " " (STRONG "keyform") " " (CODE1 "{")
     (STRONG "normal-clause") (CODE1 "}") "\\* [" (STRONG "otherwise-clause") "] => "
     (STRONG "result\\*") EOL1 (CODE1 "ctypecase") " " (STRONG "keyplace") " "
     (CODE1 "{") (STRONG "normal-clause") (CODE1 "}") "\\* => " (STRONG "result\\*") EOL1
     (CODE1 "etypecase") " " (STRONG "keyform") " " (CODE1 "{") (STRONG "normal-clause")
     (CODE1 "}") "\\* => " (STRONG "result\\*")
     (CODE3 "```" "```" "normal-clause ::= (type form*) "
      "otherwise-clause ::= ({otherwise | t} form*) "
      "clause ::= normal-clause | otherwise-clause "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "keyform") " - フォーム。評価され" (STRONG "test-key")
     "を返却します。" EOL1 (STRONG "keyplace") " - フォーム。評価されて最初に" (STRONG "test-key") "を返却します。"
     EOL1 (STRONG "test-key") " - " (STRONG "keyform") "か" (STRONG "keyplace")
     "が評価されることによって返却されるオブジェクト。" EOL1 (STRONG "type") " - 型指定子" EOL1 (STRONG "form")
     " - 暗黙のprogn" EOL1 (STRONG "result") " - マッチした" (STRONG "clause") "の"
     (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 "これらのマクロは、" (STRONG "test-key") "の型のマッチによって選択された"
     (STRONG "clause") "内の" (STRONG "form") "のボディを条件付きで実行します。" EOL2 (STRONG "keyform")
     "と" (STRONG "keyplace") "が評価されて、" (STRONG "test-key") "が生成されます。" EOL2 "そのあと各"
     (STRONG "normal-clause") "が順番に考慮されます。" "もし" (STRONG "test-key") "が"
     (STRONG "clause") "のどれかの型と同じであれば、" "その" (STRONG "clause") "内の" (STRONG "form")
     "が暗黙のprognとして評価され、" (CODE1 "typecase") "、" (CODE1 "ctypecase") "、"
     (CODE1 "etypecase") "フォームの返却値として" "その多値が返却されます。" EOL2 "これらのマクロは、もし"
     (STRONG "normal-clause") "がマッチしなかったときにだけ、" "動作が違っています。" "違いを下記に示します。" EOL2 "- "
     (CODE1 "typecase") "  - もしマッチする" (STRONG "normal-clause") "が存在せず"
     (STRONG "otherwise-clause") "があるときは、" "    自動的に" (STRONG "otherwise-clause")
     "がマッチします。" "    その" (STRONG "clause") "にある" (STRONG "form") "は暗黙のprognとして評価され、"
     "    その" (STRONG "clause") "内の" (STRONG "form") "は暗黙のprognとして評価され、" "    "
     (CODE1 "typecase") "フォームの返却値としてその多値が返却されます。" "    <br><br>" "    もし"
     (STRONG "otherwise-clause") "がないときは、" "    " (CODE1 "typecase") "は" (CODE1 "nil")
     "を返却します。" "    <br><br>" EOL2 "- " (CODE1 "ctypecase") "  - もしマッチする"
     (STRONG "normal-clause") "が存在しないときは、" "    型" (CODE1 "type-error")
     "の修正可能なエラーが発生します。" "    問題の" (CODE1 "datum") "は" (STRONG "test-key") "であり、" "    "
     (CODE1 "expected type") "は" (CODE1 "(member key1 key2 ...)") "と同等の型です。" "    "
     (CODE1 "store-value") " " (CODE1 "restart") "をエラーの修正に使うことができます。" "    <br><br>"
     "    もし" (CODE1 "store-value") " " (CODE1 "restart") "が起動されたら、" "    その引数は新しい"
     (STRONG "test-key") "であり、" "    " (STRONG "keyplace") "への保存は"
     (CODE1 "(setf keyplace test-key)") "のように行われます。" "    それから" (CODE1 "ctypecase")
     "は最初から始められ、" "    各" (STRONG "clause") "が新しく評価されます。" "    <br><br>" "    もし"
     (CODE1 "store-value") " " (CODE1 "restart") "が対話形式で起動されたら、" "    ユーザーは新しい"
     (STRONG "test-key") "を使用できるような" "    プロンプトが表示されます。" "    <br><br>"
     "    いずれのケースも成立しない場合、" "    " (STRONG "keyplace") "のサブフォームは再度評価されるかもしれません。"
     "    <br><br>" EOL2 "- " (CODE1 "etypecase") "  - もしマッチする" (STRONG "normal-clause")
     "が存在しないときは、" "    型" (CODE1 "type-error") "の修正不可能なエラーが発生します。" "    問題の"
     (CODE1 "datum") "は" (STRONG "test-key") "であり、" "    " (CODE1 "expected type") "は"
     (CODE1 "(member key1 key2 ...)") "と同等の型です。" "    <br><br>" "    "
     (CODE1 "ctypecase") "とは対照的に" (CODE1 "etypecase") "の使用者は、" "    もし"
     (STRONG "normal-clause") "がマッチしなかったら" "    " (CODE1 "etypecase")
     "は戻ってこないという事実に頼っています。" "    <br><br>" EOL2 "3つの全ての場合において、" "指定した型にマッチする"
     (STRONG "clause") "が複数あっても許されます。" "特にその型が何かのサブタイプになっているような場合も同様です。"
     "そのような場合は、もっとも早い適切な" (STRONG "clause") "が選ばれます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";;; (この例で使われているTYPE-OFの部分は" ";;;  実装依存であることに注意して下さい)"
      "(defun what-is-it (x)" "  (format t \"~&~S is ~A.~%\"" "          x (typecase x"
      "              (float \"a float\")"
      "              (null \"a symbol, boolean false, or the empty list\")"
      "              (list \"a list\")"
      "              (t (format nil \"a(n) ~(~A~)\" (type-of x))))))" "=>  WHAT-IS-IT"
      "(map 'nil #'what-is-it '(nil (a b) 7.0 7 box))"
      ">>  NIL is a symbol, boolean false, or the empty list." ">>  (A B) is a list."
      ">>  7.0 is a float." ">>  7 is a(n) integer." ">>  BOX is a(n) symbol." "=>  NIL"
      "(setq x 1/3)" "=>  1/3" "(ctypecase x" "    (integer (* x 4))"
      "    (symbol  (symbol-value x)))"
      ">>  Error: The value of X, 1/3, is neither an integer nor a symbol."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Specify a value to use instead." ">>   2: Return to Lisp Toplevel."
      ">>  Debug> :CONTINUE 1" ">>  Use value: 3.7"
      ">>  Error: The value of X, 3.7, is neither an integer nor a symbol."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Specify a value to use instead." ">>   2: Return to Lisp Toplevel."
      ">>  Debug> :CONTINUE 1" ">>  Use value: 12" "=>  48" "x =>  12"))
    (CHAPTER ("## 影響") 2 (CODE1 "ctypecase") "と" (CODE1 "etypecase") "がエラーを通知したときは、"
     "既存の" (CODE1 "handler") "と" (CODE1 "*debug-io*") "に影響を及ぼす可能性があります。")
    (CHAPTER ("## 例外") 2 (STRONG "normal-clause") "にマッチしなかったときは、" (CODE1 "ccase") "と"
     (CODE1 "ecase") "は" "型" (CODE1 "type-error") "のエラーが発生します。" EOL2 "もしある"
     (STRONG "clause") "がそれより早い" (STRONG "clause") "によって完全にシャドウされ、"
     "決して選択されないような状況であったとき、" "コンパイラーは、型" (CODE1 "style-warning") "の警告を出すかどうか"
     "選択することができます。")
    (CHAPTER ("## 参考") 2 (CODE1 "case") "," (CODE1 "cond") "," (CODE1 "setf") ","
     "5.1. 一般化された参照")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(typecase test-key" "  {(type form*)}*)" "== "
      "(let ((#1=#:g0001 test-key))" "  (cond {((typep #1# 'type) form*)}*))")
     EOL2 (CODE1 "etypecase") "と" (CODE1 "ctypecase") "によって使われる特定のエラーメッセージは、"
     "実装によって変わります。" "そんな中で、エラーメッセージの特定の単語の制御が必要なときは、" (CODE1 "typecase") "の"
     (STRONG "otherwise-clause") "で" "明示的に適切なエラーメッセージを発生させるのが良いでしょう。")))
(setf (gethash '("CTYPECASE" . "MACRO") *table*) (gethash "CTYPECASE" *table*))
(setf (gethash "DECLAIM" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DECLAIM"))
    (CHAPTER ("## 構文") 2 (CODE1 "declaim") " " (STRONG "declaration-specifier\\*")
     " => 実装依存")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "declaration-specifier") " - 宣言指定子。評価されません。")
    (CHAPTER ("## 定義") 2 (STRONG "declaration-specifier") "によって指定された宣言を確立します。" EOL2
     "このマクロが" "ファイルコンパイラーによって処理されているファイルの" "トップレベルフォームで現れたとき、 宣言はコンパイル時にも認識されます。"
     "他の定義されているマクロと同様に、ファイルがコンパイルされた後でも" (CODE1 "declaim") "のコンパイル時の副作用が持続されるかどうかは未定です。")
    (CHAPTER ("## 例文") 2) (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "declare") "," (CODE1 "proclaim"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DECLAIM" . "MACRO") *table*) (gethash "DECLAIM" *table*))
(setf (gethash "DECLARATION" *table*)
  '((CHAPTER NIL 0 "Declaration " (CODE1 "DECLARATION"))
    (CHAPTER ("## 構文") 2 "(" (CODE1 "declaration") " " (STRONG "name\\*") ")")
    (CHAPTER ("## 引数") 2 (STRONG "name") " - シンボル") (CHAPTER ("## 影響する束縛の型") 2 "なし")
    (CHAPTER ("## 有効な文脈") 2 (CODE1 "proclaim") "のみ")
    (CHAPTER ("## 定義") 2 "コンパイラーに対して、各" (STRONG "name") "が有効ではあるが"
     "標準ではない可能性がある宣言の名前を知らせます。" EOL2 "この目的は、あるコンパイラーに対して、"
     "この宣言が他のコンパイラーか他のプログラム処理のためのものであるので" "警告を発しないように指示するものです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(declaim (declaration author target-language target-machine))"
      "(declaim (target-language ada))" "(declaim (target-machine IBM-650))"
      "(defun strangep (x)" "  (declare (author \"Harry Tweeker\"))"
      "  (member x '(strange weird odd peculiar)))"))
    (CHAPTER ("## 参考") 2 (CODE1 "declaim") "," (CODE1 "proclaim"))))
(setf (gethash '("DECLARATION" . "DECLARATION") *table*) (gethash "DECLARATION" *table*))
(setf (gethash "DECLARE" *table*)
  '((CHAPTER NIL 0 "Symbol " (CODE1 "DECLARE"))
    (CHAPTER ("## 構文") 2 (CODE1 "declare") " " (STRONG "declaration-specifier\\*"))
    (CHAPTER ("## 引数") 2 (STRONG "declaration-specifier") " - 宣言指定子。評価されません。")
    (CHAPTER ("## 定義") 2 (CODE1 "declare") "の式は、よく宣言と呼ばれ、"
     "特定のフォームのボディ部の開始の部分にのみ記載することができます。" "この文脈が許されるのであれば、フォームの先行した位置にのみ"
     (CODE1 "declare") "かドキュメント文字が許されます。" EOL2 (CODE1 "declare") "式は、ラムダ式か、"
     "下記の表のリストで示すフォームに記載することができます。" EOL2
     "|                           |                      |                                |"
     "|---------------------------|----------------------|--------------------------------|"
     "|" (CODE1 "defgeneric") "          |" (CODE1 "do-external-symbols") " |"
     (CODE1 "prog") "                |" "|" (CODE1 "define-compiler-macro") " |"
     (CODE1 "do-symbols") "   |" (CODE1 "prog*") "                    |" "|"
     (CODE1 "define-method-combination") " |" (CODE1 "dolist") "   |"
     (CODE1 "restart-case") "             |" "|" (CODE1 "define-setf-expander") " |"
     (CODE1 "dotimes") "       |" (CODE1 "symbol-macrolet") "          |" "|"
     (CODE1 "defmacro") "            |" (CODE1 "flet") "           |"
     (CODE1 "with-accessors") "           |" "|" (CODE1 "defmethod") "           |"
     (CODE1 "handler-case") "   |" (CODE1 "with-hash-table-iterator") " |" "|"
     (CODE1 "defsetf") "             |" (CODE1 "labels") "         |"
     (CODE1 "with-input-from-string") "   |" "|" (CODE1 "deftype") "             |"
     (CODE1 "let") "            |" (CODE1 "with-open-file") "           |" "|"
     (CODE1 "defun") "               |" (CODE1 "let*") "           |"
     (CODE1 "with-open-stream") "         |" "|" (CODE1 "destructuring-bind") "  |"
     (CODE1 "locally") "        |" (CODE1 "with-output-to-string") "    |" "|"
     (CODE1 "do") "                  |" (CODE1 "macrolet") "       |"
     (CODE1 "with-package-iterator") "    |" "|" (CODE1 "do*") "                 |"
     (CODE1 "multiple-value-bind") " |" (CODE1 "with-slots") "          |" "|"
     (CODE1 "do-all-symbols") "      |" (CODE1 "pprint-logical-block")
     " |                          |" EOL2 "Figure 3-23. 宣言を配置できる標準フォーム" EOL2
     (CODE1 "declare") "式は、これらのフォームの構文によって" "指定できる場所のみに配置できます。" (CODE1 "declare")
     "式を評価しようとした結果は未定義です。" "そのような式が現れた場合は、それらの出現は暗黙的にチェックされ、" "そして実際には評価されません。" "これが「"
     (CODE1 "declare") "フォーム」ではなく" "「" (CODE1 "declare") "式」と呼んでいる理由です。" EOL2
     "マクロフォームは宣言を展開できません。" (CODE1 "declare") "式は、フォームが参照している" "実際のサブフォームとして現れなければなりません。"
     EOL2 "次の表は、" (CODE1 "declare") "で使用できる宣言識別子です。" EOL2
     "|                      |                 |                |"
     "|----------------------|-----------------|----------------|" "|"
     (CODE1 "dynamic-extent") " |" (CODE1 "ignore") "    |" (CODE1 "optimize") " |" "|"
     (CODE1 "ftype") "          |" (CODE1 "inline") "    |" (CODE1 "special") "  |" "|"
     (CODE1 "ignorable") "      |" (CODE1 "notinline") " |" (CODE1 "type") "     |" EOL2
     "Figure 3-24. ローカル宣言指定子" EOL2 "実装はその他の（実装定義の）宣言識別子を自由にサポートできます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun nonsense (k x z)"
      "  (foo z x)                     ;最初のfooの呼び出し"
      "  (let ((j (foo k x))           ;2回目のfooの呼び出し" "        (x (* k k)))"
      "    (declare (inline foo) (special x z))"
      "    (foo x j z)))               ;3回目のfooの呼び出し")
     EOL2 "この例では、" (CODE1 "inline") "宣言は3回目の" (CODE1 "foo") "の呼び出しのみに適用され、"
     "最初と2番目には適用されません。" (CODE1 "let") "にある" (CODE1 "x") "の" (CODE1 "special") "宣言は"
     (CODE1 "x") "を動的束縛にして、" (CODE1 "let") "のボディ部にある" (CODE1 "x") "の参照を動的参照にします。" "2番目の"
     (CODE1 "foo") "の呼び出しで参照している" (CODE1 "x") "は、" (CODE1 "nonsence")
     "の2番目のパラメーターにあるローカル参照です。" "最初の" (CODE1 "foo") "の呼び出しで参照している" (CODE1 "x") "は、"
     "ローカル参照であり" (CODE1 "special") "ではありません。" (CODE1 "z") "の" (CODE1 "special")
     "宣言は、3番目の" (CODE1 "foo") "の呼び出しの" (CODE1 "z") "を動的参照にします。" "これは" (CODE1 "nonsence")
     "の" (CODE1 "z") "というパラメーターを示していません。" "なぜなら" (CODE1 "special")
     "宣言のパラメーター束縛の中には存在していないからです。" "（" (CODE1 "z") "の" (CODE1 "special") "宣言は"
     (CODE1 "defun") "のボディ部には現れていませんが、" "その内側のフォームには存在してます。"
     "つまりパラメーターの束縛には影響してないと言うことです。）")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (CODE1 "declare") "式をフォームとして評価しようとしたときの結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "proclaim") "," "4.2.3. 型指定子," (CODE1 "declaration") ","
     (CODE1 "dynamic-extent") "," (CODE1 "ftype") "," (CODE1 "ignorable") ","
     (CODE1 "ignore") "," (CODE1 "inline") "," (CODE1 "notinline") "," (CODE1 "optimize")
     "," (CODE1 "type"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DECLARE" . "SYMBOL") *table*) (gethash "DECLARE" *table*))
(setf (gethash "DEFCLASS" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFCLASS"))
    (CHAPTER ("## 構文") 2 (CODE1 "defclass") " " (STRONG "class-name") " ("
     (STRONG "superclass-name\\*") ") (" (STRONG "slot-specifier\\*")
     ") [[class-option]]" " => " (STRONG "new-class")
     (CODE3 "```" "```" "slot-specifier ::= slot-name | (slot-name [[slot-option]])"
      "slot-name ::= symbol" "slot-option ::= {:reader reader-function-name}* |"
      "                {:writer writer-function-name}* |"
      "                {:accessor reader-function-name}* |"
      "                {:initarg initarg-name}* |" "                {:initform form} |"
      "                {:type type-specifier} |"
      "                {:documentation string}"
      "function-name ::= {symbol | (setf symbol)}"
      "class-option ::= (:default-initargs . initarg-list) |"
      "                 (:documentation string) |"
      "                 (:metaclass class-name)"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "class-name") " - " (CODE1 "nil") "ではないシンボル" EOL1
     (STRONG "superclass-name") " - " (CODE1 "nil") "ではないシンボル" EOL1 (STRONG "slot-name")
     " - シンボル。 " "  引数" (STRONG "slot-name") "は、変数名として使用できる構文として有効なシンボルです。" EOL1
     (STRONG "reader-function-name") " - " (CODE1 "nil") "ではないシンボル。" "  "
     (CODE1 ":reader") "はひとつのスロットに複数指定できます。" EOL1 (STRONG "writer-function-name")
     " - ジェネリック関数名。" "  " (CODE1 ":reader") "はひとつのスロットに複数指定できます。" EOL1
     (STRONG "accessor-function-name") " - " (CODE1 "nil") "ではないシンボル。" "  "
     (CODE1 ":accessor") "はひとつのスロットに複数指定できます。" EOL1 (STRONG "allocation-type") " - "
     (CODE1 "(member :instance :class)") "。" "  ひとつのスロットに最大ひとつの指定ができます。" EOL1
     (STRONG "initarg-name") " - シンボル。" "  " (CODE1 ":initarg") "はひとつのスロットに対して複数指定できます。"
     EOL1 (STRONG "form") " - フォーム。" "  " (CODE1 ":initform") "はひとつのスロットに最大ひとつの指定ができます。"
     EOL1 (STRONG "type-specifier") " - 型指定子。" "  " (CODE1 ":type")
     "はひとつのスロットに最大ひとつの指定ができます。" EOL1 (STRONG "class-option")
     " - クラス全体か、全てのクラスのスロットを示します。" EOL1 (STRONG "initarg-list") " - 名前とデフォルトの初期化値のフォームを"
     "  交互に並べた初期化引数のリストです。" "  " (CODE1 ":default-initargs") "は最大ひとつの指定ができます。" EOL1
     (STRONG "class-name") " - " (CODE1 "nil") "ではないシンボル。" (CODE1 ":metaclass")
     "は最大ひとつの指定ができます。" EOL1 (STRONG "new-class") " - 新しいクラスのオブジェクト")
    (CHAPTER ("## 定義") 2 "マクロ" (CODE1 "defclass") "は、新しい名前の付いたクラスを定義します。"
     "その結果として新しいクラスオブジェクトが返却されます。" EOL2 (CODE1 "defclass") "の構文は、"
     "スロットの初期化引数を指定するオプション、" "スロットのデフォルト初期化値を指定するオプション、"
     "そしてスロットの値を読み書きするためのジェネリック関数のメソッドを" "自動的に生成するようなオプションを提供します。"
     "デフォルトではリーダおよびライタ関数は定義されていませんので、" "その生成は明示的に要求する必要があります。" "ただし、スロットは常に"
     (CODE1 "slot-value") "を使用してアクセスすることができます。" EOL2 "新しいクラスを定義すると、同じ名前の型も定義されます。" "式"
     (CODE1 "(typep object class-name)") "は、" "引数" (STRONG "object") "のクラスが"
     (STRONG "class-name") "自身の名前のクラスであるか、" "あるいはクラス" (STRONG "class-name")
     "のサブクラスであるならば、" (STRONG "true") "を返します。" "クラスオブジェクトは型指定子として使われることができます。" "したがって"
     (CODE1 "(typep object class)") "は、" (STRONG "object") "のクラスが、クラス自体か、"
     "クラスのサブクラスである場合に" (STRONG "true") "を返します。" EOL2 "引数の" (STRONG "class-name")
     "は、新しいクラスの適切な名前を指定します。" "もし同名のクラスが存在しており、" "そのクラスが" (CODE1 "standard-class")
     "のインスタンスであり、" "さらに" (CODE1 "defclass") "フォームによる新しいクラスの定義が、" (CODE1 "standard-class")
     "クラスのクラスで指定されていた場合、" "既存のクラスは再定義され、" "そのクラス（サブクラスも含む）のインスタンスは、" "それらが次にアクセスされたときに"
     "新しい定義へと更新されます。" "詳細は4.3.6. クラスの再定義を参照。" EOL2 "引数" (STRONG "superclass-name")
     "は、新しいクラスのダイレクトスーパークラスを指定します。" "もしスーパークラスのリストが空のとき、"
     "スーパークラスはメタクラスによって異なるデフォルト値になりますが、" (CODE1 "standard-class") "のデフォルトは"
     (CODE1 "standard-object") "です。" EOL2 "新しいクラスは、各ダイレクトスーパークラスと、"
     "それら各々のダイレクトスーパークラスの繋がりによって、" "スロットとメソッドが継承されます。" EOL2 "スロットオプションは下記のものが使用可能です。"
     EOL2 "- スロットオプションの" (CODE1 ":reader") "は、" "スロットの値を読み込むための"
     (STRONG "reader-function-name") "という名前のジェネリック関数と、" "修飾子がないメソッドをを定義します。"
     "- スロットオプションの" (CODE1 ":writer") "は、" "スロットの値を書き込むための"
     (STRONG "writer-function-name") "という名前のジェネリック関数と、" "修飾子がないメソッドをを定義します。"
     "- スロットオプションの" (CODE1 ":accessor") "は、" "スロットの値を読み込むための"
     (STRONG "accessor-function-name") "という名前のジェネリック関数と、" "修飾子がないメソッドをを定義します。"
     "さらに、スロットの値を" (CODE1 "setf") "を用いて修正するための" (CODE1 "(setf accessor-function-name)")
     "という名前のジェネリック関数と、" "修飾子がないメソッドをを定義します。" "- スロットオプションの" (CODE1 ":allocation") "は、"
     "割り当てられたスロットが、どこのストレージを使用するかを指定します。" "スロットのストレージは、各インスタンスか、"
     "クラスオブジェクト自身に配置することができます。" "引数" (CODE1 "allocation-type") "の値は、" (CODE1 ":instance")
     "キーワードか、" (CODE1 ":class") "キーワードのどちらかです。" "もし" (CODE1 ":allocation")
     "スロットオプションが指定されなかったときは、" (CODE1 ":allocation :instance") "が指定されたと同じ効果になります。" "  - "
     (STRONG "allocation-type") "が" (CODE1 ":instance") "のとき、" "    名前が"
     (STRONG "slot-name") "の局所スロットは、" "    クラスのそれぞれのインスタンスに配置されます。" "  - "
     (STRONG "allocation-type") "が" (CODE1 ":class") "のとき、指定された名前の共有スロットは、" "    "
     (CODE1 "defclass") "フォームによって生成されたクラスオブジェクトに配置されます。"
     "    このスロットの値は、そのクラスの全てのインスタンスによって共有されます。" "    もしクラス" (CODE1 "C1") "に共有スロットがあるとき、"
     "    " (CODE1 "C1") "のサブクラス" (CODE1 "C2") "はこのひとつのスロットが共有されるでしょう。" "    ただし"
     (CODE1 "C2") "の" (CODE1 "defclass") "フォームで同名のスロットが" "	指定された場合は共有されません。" "    さらに、"
     (CODE1 "C2") "のクラス優先順位リストを見て、" "    " (CODE1 "C2") "のスーパークラスのうちの" (CODE1 "C1")
     "より先行しているものがあり、" "    そのクラスが同名のスロットを定義していた場合でも、" "    スロットの共有は行われません。" "- スロットオプション"
     (CODE1 ":initform") "は、デフォルト初期値のフォームであり、" "  スロットの初期値として使用されます。"
     "  このフォームは、スロットを初期化するときに毎回評価されます。" "  このフォームが評価されるときのレキシカルな環境は、" "  "
     (CODE1 "defclass") "フォームが評価されたときのものになります。" "  レキシカルな環境は、変数と関数両方を参照することに注意してください。"
     "  局所スロットでは、動的な環境は" "  " (CODE1 "make-instance") "が呼ばれた場所であり、" "  共有スロットでは、"
     (CODE1 "defclass") "が評価された場所です。" "  詳細は7.1. オブジェクトの作成と初期化をご確認ください。" "  - どの処理系でも、"
     (CODE1 "defclass") "の構文を" (CODE1 "(slot-name :initform form)") "から" "    省略して"
     (CODE1 "(slot-name form)") "にすることは許されません。" "- スロットオプション" (CODE1 ":initarg") "は、"
     "  初期化引数の名前を" (STRONG "initarg-name") "で宣言し、" "  そのスロットが初期化引数で初期化されるように指定します。"
     "  もし" (CODE1 "initialize-instance") "呼び出し時に" "  初期化引数が値を持っているときは、"
     "  そのスロットに値が格納され、" "  そのスロットに" (CODE1 ":initform") "オプションがある場合は評価されません。"
     "  初期化引数にスロットの値がないときは、" "  そのスロットは、" (CODE1 ":initform") "オプションが指定されてるとき、"
     "  その内容に従って初期化されます。" "- スロットオプション" (CODE1 ":type") "は、"
     "  スロットの内容が常に指定された型であることを指定します。" "  これは、このクラスのオブジェクトが適用できるリーダーのジェネリック関数の"
     "  返却値の型を宣言する効果があります。" "  そのスロットの型に違反した値を保存しようとしたときの結果は未定義です。" "  スロットオプション"
     (CODE1 ":type") "は、7.5.3. スロットの継承とスロットオプションで詳しく説明しています。" "- スロットオプション"
     (CODE1 ":documentation") "は、" "  スロットに、ドキュメント文字を提供します。" "  "
     (CODE1 ":documentation") "はひとつのスロットに、最大ひとつ指定できます。" EOL2 "各クラスオプションは、クラス全体の設定です。"
     EOL1 "クラスオプションは下記のものが使用可能です。" EOL2 "- クラスオプション" (CODE1 ":default-initargs") "は、"
     "  名前とデフォルトの初期化値のフォームを交互に並べた" "  初期化引数のリストによって続けられます。" "  もし、これらの初期化引数のどれかが、" "  "
     (CODE1 "make-instance") "に与えられた初期化引数リストに現れない場合、" "  対応するデフォルト初期値フォームが評価され、"
     "  その初期化引数名とフォームの値が" "  初期化引数リストの最後に追加されてからインスタンスが生成されます。"
     "  詳しくは7.1. オブジェクトの作成と初期化をご確認ください。" "  デフォルト初期値フォームは、使用されるたびに評価されます。"
     "  評価されるときのレキシカルな環境は、" "  " (CODE1 "defclass") "フォームが評価されたときのものです。" "  動的な環境は、"
     (CODE1 "make-instance") "が呼ばれたときのものです。" "  もしクラスオプション" (CODE1 ":default-initargs")
     "に" "  初期化引数名が複数現れたときは、" "  エラーが発生します。" "- クラスオプション" (CODE1 ":documentation") "は、"
     "  クラスオブジェクトにドキュメント文字を、" "  種別" (CODE1 "type") "で、" (STRONG "class-name") "に割り当てます。"
     "  " (CODE1 ":documentation") "は、最大ひとつ指定できます。" "- クラスオプション" (CODE1 ":metaclass")
     "は、" "  定義するクラスのインスタンスが、" "  システムが提供するデフォルトのもの(" (CODE1 "standard-class") "のクラス)とは"
     "  異なるメタクラスを持つことを指定するために使われます。" EOL2 "標準クラスにおいては、" (CODE1 "defclass")
     "は下記のルールに注意してください。" EOL2 "- " (CODE1 "defclass") "フォームによってクラスが評価される前に、"
     "  そのクラスのスーパークラスが定義されている必要はありません。" "- あるクラスの全てのスーパークラスは、"
     "  そのクラスのインスタンスが使用される前には定義されていなければなりません。" "- " (CODE1 "defmethod") "フォームで"
     "  特定パラメーターとして使用される前には、" "  そのクラスは定義されていなければなりません。" EOL2
     "オブジェクトシステムは、これらのルールに従わない場合にも" "対応できるように拡張することが可能です。" EOL2 "いくつかのスロットは、"
     "スーパークラスのクラスによって継承され、いくつかのものは隠蔽され、" "あるいは局所スロットの定義によって変更されます。" "クラスオプションは、"
     (CODE1 ":default-initargs") "以外継承されません。" "スロットとスロットオプションがどのように継承されるかの詳しい説明は、"
     "7.5.3. スロットの継承とスロットオプションをご確認ください。" EOL2 (CODE1 "defclass") "のオプションは拡張できます。"
     "すべての実装は、自身が実装していない" "クラスオプションやスロットオプションを見た場合は、" "エラーを通知することが要求されています。" EOL2
     "複数のreader, writer, accessorを指定したり、" "あるスロットに複数の初期化引数を指定するのは正しいです。" "その他のスロットオプションが"
     "ひとつのスロットの定義に複数指定することはできませんので、" "エラーが発生します。" EOL2
     "もし、あるスロットにreader, writer, accessorが指定されていないとき、" "そのスロットはただ" (CODE1 "slot-value")
     "によってのみアクセスできます。" EOL2 "もし" (CODE1 "defclass") "フォームがトップレベルに現れたとき、"
     "コンパイラーはクラス名を有効な型の名前であると認識し、" "後続の宣言（たとえば" (CODE1 "deftype") "）や、"
     (CODE1 "defmethod") "の特定パラメーター、" "また" (CODE1 "defclass") "の" (CODE1 ":metaclass")
     "オプションでも使用できるようにしなければならない。" "コンパイラーは、" (CODE1 "find-class") "の環境の引数に、"
     "マクロの環境パラメーターで受け取った値を指定したときは、" "クラスの定義を返却できるようにしなければならない。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もしスロットの名前に重複があった場合は、" "型" (CODE1 "program-error") "のエラーが発生します。"
     EOL2 "もし、クラスオプション" (CODE1 ":default-initargs") "に" "初期化引数の名前が複数現れたときは、" "型"
     (CODE1 "program-error") "のエラーが発生します。" EOL2 "もし、スロットオプション" (CODE1 ":allocation") ", "
     (CODE1 ":initform") ", " (CODE1 ":type") ", " (CODE1 ":documentation") "が"
     "ひとつのスロットの定義に複数現れたときは、" "型" (CODE1 "program-error") "のエラーが発生します。" EOL2
     "すべての実装は、自身が実装していない" "クラスオプションやスロットオプションを見た場合は、" "型" (CODE1 "program-error")
     "のエラーが通知することを要求されています。")
    (CHAPTER ("## 参考") 2 (CODE1 "documentation") "," (CODE1 "initialize-instance") ","
     (CODE1 "make-instance") "," (CODE1 "slot-value") "," "4.3. クラス," "4.3.4. 継承,"
     "4.3.6. クラスの再定義," "4.3.5. クラス優先順位リストの決定," "7.1. オブジェクトの作成と初期化")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DEFCLASS" . "MACRO") *table*) (gethash "DEFCLASS" *table*))
(setf (gethash "DEFCONSTANT" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFCONSTANT"))
    (CHAPTER ("## 構文") 2 (CODE1 "defconstant") " " (STRONG "name") " "
     (STRONG "initial-value") " [" (STRONG "documentation") "] => " (STRONG "name"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - シンボル。評価されません。" EOL1
     (STRONG "initial-value") " - フォーム。評価されます。" EOL1 (STRONG "documentation")
     " - 文字列。評価されません。")
    (CHAPTER ("## 定義") 2 (CODE1 "defconstant") "は、" (STRONG "name") "で指定されたグローバル変数に、"
     (STRONG "initial-value") "を評価した結果の値を与えます。" EOL2 (CODE1 "defconstant")
     "によって定義された定数は、" (CODE1 "defconstant") "によって再定義できます。" "しかし、他の操作を使いシンボルに値を割り当てようとしたり、"
     "後続の" (CODE1 "defconstant") "を使い違う値を割り当てようとしたときの" "結果は未定義です。" EOL2
     (STRONG "documentation") "が与えられたとき、" (STRONG "name") "へドキュメント文字を種類"
     (CODE1 "variable") "として割り当てます。" EOL2 (CODE1 "defconstant") "は通常トップレベルフォームに現れますが、"
     "非トップレベルフォームに現れても意味があります。" "しかし、下記で説明するコンパイル時の副作用は、" (CODE1 "defconstant")
     "がトップレベルフォームとして現れた場所でのみ" "効果があります。" EOL2 (CODE1 "defconstant") "実行時に"
     (STRONG "name") "という名前の変数の何らかの束縛がすでに存在するか、" "または" (STRONG "initial-value")
     "とは違った値があるときの結果は未定義です。" EOL2 "レキシカルか動的かどちらかで定数のシンボルを再束縛した時の結果は未定義です。" "言い換えると、"
     (CODE1 "defconstant") "で宣言されたシンボルは、" "常にグローバルな値を参照します。" EOL2 (CODE1 "defconstant")
     "の実行の副作用は、" "少なくとも下記のコードの副作用と同等でなければなりません。"
     (CODE3 "```lisp" "```" "(setf (symbol-value 'name) initial-value)"
      "(setf (documentation 'name 'variable) 'documentation)")
     EOL2 (CODE1 "defconstant") "フォームがトップレベルフォームとして現れたとき、" "コンパイラーは" (STRONG "name")
     "を定数の変数として認識する必要があります。" "実装は値のフォームを、コンパイル時に評価するか、" "ロード時に評価するか、あるいは両方かを選択できます。"
     "したがって、" "ユーザーは" (STRONG "initial-value") "がコンパイル時に評価可能であり、" "（ファイルに"
     (STRONG "name") "が現れるかどうかに関わらず）" "それが常に同じ値で評価されるかを確認する必要があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(defconstant this-is-a-constant 'never-changing \"for a test\") =>  THIS-IS-A-CONSTANT"
      "this-is-a-constant =>  NEVER-CHANGING"
      "(documentation 'this-is-a-constant 'variable) =>  \"for a test\""
      "(constantp 'this-is-a-constant) =>  true"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "declaim") "," (CODE1 "defparameter") ","
     (CODE1 "defvar") "," (CODE1 "documentation") "," (CODE1 "proclaim") ","
     "3.1.2.1.1.3. 定数の変数," "3.2. コンパイル")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DEFCONSTANT" . "MACRO") *table*) (gethash "DEFCONSTANT" *table*))
(setf (gethash "DEFGENERIC" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFGENERIC"))
    (CHAPTER ("## 構文") 2 (CODE1 "defgeneric") " " (STRONG "function-name") " "
     (STRONG "gf-lambda-list") " [[" (STRONG "option") " " (CODE1 "|") " "
     (STRONG "method-description\\*") "]]" EOL1 "=> " (STRONG "new-generic")
     (CODE3 "```" "```" "option ::= (:argument-precedence-order parameter-name+) |"
      "           (declare gf-declaration+) |"
      "           (:documentation gf-documentation) |"
      "           (:method-combination method-combination method-combination-argument*) |"
      "           (:generic-function-class generic-function-class) |"
      "           (:method-class method-class)" NIL "method-description ::="
      "  (:method method-qualifier* specialized-lambda-list"
      "   [[declaration* | documentation]] form*)"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function-name") " - 関数名" EOL1
     (STRONG "generic-function-class") " - " (CODE1 "nil") "ではない、クラス名のシンボル" EOL1
     (STRONG "gf-declaration") " - " (CODE1 "optimize") "の宣言指定子。他の宣言指定子は許されません。" EOL1
     (STRONG "gf-documentation") " - 文字列（評価はされない）" EOL1 (STRONG "gf-lambda-list")
     " - ジェネリック関数のラムダリスト" EOL1 (STRONG "method-class") " - " (CODE1 "nil")
     "ではない、クラス名のシンボル" EOL1 (STRONG "method-combination-argument") " - オブジェクト" EOL1
     (STRONG "method-combination-name") " - " (CODE1 "nil")
     "ではない、method-combinationの型の名前のシンボル" EOL1 (STRONG "method-qualifiers") ", "
     (STRONG "specialized-lambda-list") "," (STRONG "declarations") ", "
     (STRONG "documentation") ", " (STRONG "forms") " - " (CODE1 "defmethod") "に従います。"
     EOL1 (STRONG "new-generic") " - ジェネリック関数オブジェクト" EOL1 (STRONG "parameter-name")
     " - ラムダリスト内にある要求パラメーターの名前のシンボル。" "（もし" (CODE1 ":argument-precedence-order")
     "オプションが定義されているならば、" "  ラムダリスト内のそれぞれの要求パラメーターは、" "  " (STRONG "parameter-name")
     "が正確にひとつ使われなければなりません）")
    (CHAPTER ("## 定義") 2 "マクロ" (CODE1 "defgeneric") "は、ジェネリック関数を定義したり、"
     "ジェネリック関数全体に関わるオプションと宣言を指定するときに使われます。" EOL2 "もし" (STRONG "function-name") "がリストなら、"
     (CODE1 "(setf symbol)") "の形式でなければなりません。" "もし" (CODE1 "(fboundp function-name)") "が"
     (STRONG "false") "のときは、新しいジェネリック関数が作成されます。" "もし"
     (CODE1 "(fdefinition function-name)") "がジェネリック関数のときは、" "そのジェネリック関数は変更されます。" "もし"
     (STRONG "function-name") "が通常の関数か、マクロか、特殊オペレーターの名前のときは、" "エラーが発生します。" EOL2
     (CODE1 "defgeneric") "マクロは、次に示す3つのステップが実行されたかのような効果を示します。" "第一に、以前"
     (CODE1 "defgeneric") "フォームで定義されたメソッドは削除されます。" "第二に、"
     (CODE1 "ensure-generic-function") "が呼び出されます。" "そして最後に、今回の" (CODE1 "defgeneric")
     "フォームによって定義されたメソッドが、" "ジェネリック関数に追加されます。" EOL2 "各" (STRONG "method-description")
     "は、そのジェネリック関数上で、メソッドが宣言されます。" "各メソッドのラムダリストは、" (STRONG "gf-lambda-list")
     "オプションによって指定された" "ラムダリストと合致しなければなりません。" "メソッドの定義が指定されておらず、" "同名のジェネリック関数が存在しない場合は、"
     "メソッドがないジェネリック関数が作成されます。" EOL2 (CODE1 "defgeneric") "の引数" (STRONG "gf-lambda-list")
     "は、" "そのジェネリック関数のメソッドに対して、" "ラムダリストの形を指定します。" "返却されるジェネリック関数上の全てのメソッドは、"
     "この形に合致したラムダリストを持たなければなりません。" "もし、" (CODE1 "defgeneric") "フォームが評価されたとき、"
     "そのジェネリック関数にあるメソッドのラムダリストが" (CODE1 "defgeneric") "フォームに付与されたものと合致しない場合は、"
     "エラーが発生します。" "メソッドの合致に関するさらなる詳細は、7.6.4. ジェネリック関数の全てのメソッドのラムダリストの合意をご確認ください。" EOL2
     "ジェネリック関数は、渡されたすべての引数をメソッドに渡します。" "渡されるのはそれらの値のみであり、デフォルト値は供給されません。"
     "ただし、メソッド定義にはオプション引数とキーワード引数があり、" "デフォルト値と" (CODE1 "supplied-p")
     "パラメーターが使用できることに注意してください。" EOL2 "次に示すオプションが提供されます。" "注意書きがあるもの以外、オプションはただひとつ与えられます。"
     EOL2 "- オプション" (CODE1 ":argument-precedence-order") "は、"
     "  ジェネリック関数が呼び出だされ、特定のメソッドを選択するときに" "  テストを行う要求された引数の順序を指定するために使用されます。"
     "  完全かつ曖昧がないような優先順序が与えられるように、" "  " (STRONG "gf-lambda-list")
     "引数内で指定されたそれぞれのrequired-arguments}は、" "  正確にひとつだけ" (STRONG "parameter-name")
     "として含まれなければなりません。" "  もしこのような条件に合わない場合は、エラーが発生します。" "- " (CODE1 "declare")
     "のオプションは、" "  ジェネリック関数に関する宣言を指定するときに使われます。" "  - " (CODE1 "optimize") "宣言指定子が許されます。"
     "    この宣言は、メソッドの選択の最適化が" (CODE1 "speed") "か" (CODE1 "space") "なのかを指定するものであり、"
     "    メソッドへの効果はありません。" "    メソッドの最適化をどのように制御するかについては、" "    " (CODE1 "optimize")
     "宣言を" (CODE1 "defmethod") "かメソッドの宣言内に" "    直接記載する必要があります。" "    標準で要求される最適化の種類は"
     (CODE1 "speed") "と" (CODE1 "space") "だけですが、" "    実装によっては他の種類も認識するように、"
     "    オブジェクトシステムを拡張することもできます。" "    単純な実装では、メソッドの選出方法をただひとつだけ実装し、" "    "
     (CODE1 "optimize") "宣言指定子を無視するというのが有効です。" "  - " (CODE1 "special") ", "
     (CODE1 "ftype") ", " (CODE1 "function") "," "	" (CODE1 "inline") ", "
     (CODE1 "notinline") ", " (CODE1 "declaration") "の宣言は許されていません。" "	各実装は、"
     (CODE1 "declare") "オプションを拡張して、" "	追加の宣言をサポートすることができます。"
     "	もしある実装が、サポートしていない宣言指定子に遭遇し、" "	その宣言が非標準の宣言の名前で" (CODE1 "proclaim") "されていた場合は、"
     "	警告を発生させるべきです。" "  - " (CODE1 "declare") "オプションは、複数指定されるかもしれません。"
     "    宣言指定子のリストをひとつにまとめて、" "    単体の" (CODE1 "declare") "オプションとして指定したのと同じ効果が得られます。"
     "- 引数" (CODE1 ":documentation") "は、ジェネリック関数のオブジェクトにドキュメント文字を、" "  種類"
     (CODE1 "function") "で、" (STRONG "funciton-name") "に割り当てられます。" "- "
     (CODE1 ":generic-function-class") "オプションは、" "  ジェネリック関数が、システムの提供するデフォルトのもの" "  ("
     (CODE1 "standard-generic-function") "のクラス)とは" "  異なるクラスを持つことを指定するために使われます。" "  引数"
     (STRONG "class-name") "は、ジェネリック関数クラスのクラス名です。" "  もし、" (STRONG "function-name")
     "が既存のジェネリック関数を示しており、" "  新しいジェネリック関数の" (CODE1 ":generic-function-class") "の値が"
     "  古いものと互換性がある場合は、" "  " (CODE1 "change-class") "が呼ばれてジェネリック関数のクラスが変更されます。"
     "  それ以外の場合はエラーが発生します。" "- " (CODE1 ":method-class") "オプションは、"
     "  ジェネリック関数上の全てのメソッドが、" "  システムの提供するデフォルトのもの(" (CODE1 "standard-method") "のクラス)とは"
     "  異なるクラスを持つことを指定するために使われます。" "  引数" (STRONG "class-name") "は、メソッドのクラスとなりえるクラス名です。"
     "- " (CODE1 ":method-combination") "オプションは、"
     "  method-combinationの型の名前であるシンボルが続きます。"
     "  そのシンボルの後に続く引数があるなら、それはmethod-combinationの型に依存します。" "  " (CODE1 "standard")
     "のmethod-combinationは、引数をサポートしません。" "  しかし、" (CODE1 "define-method-combination")
     "の短縮形によって宣言された" "  method-combinationの型は全て、" (STRONG "order") "というオプション引数を受け付けます。"
     "  デフォルトの値は" (CODE1 ":most-specific-first") "であり、" "  もしこの値が"
     (CODE1 ":most-specific-last") "のときは、" "  補助メソッドの順番に影響を与えずに、プライマリメソッドの順番を逆転させます。"
     EOL2 "引数" (STRONG "method-description") "は、ジェネリック関数に関連付けたメソッドを宣言できます。"
     "メソッド宣言にある引数の" (STRONG "method-qualifier") "と" (STRONG "specialized-lambda-list")
     "は、" (CODE1 "defmethod") "と同じです。" EOL2 "引数" (STRONG "form") "は、メソッドのボディ部です。"
     "メソッドのボディ部は、暗黙の" (CODE1 "block") "で囲まれます。" "もし" (STRONG "function-name") "がシンボルのとき、"
     (CODE1 "block") "の名前はジェネリック関数と同じ名前です。" "もし" (STRONG "function-name") "が"
     (CODE1 "(setf symbol)") "のリスト形式の場合は、" (CODE1 "block") "の名前は" (STRONG "symbol") "です。"
     EOL2 "実装は、" (CODE1 "defgeneric") "に別のオプションを含めるよう拡張できます。"
     "もし自身が実装していないオプションが見られた場合は、" "その実装はエラーを発生するよう要求されます。" EOL2 (CODE1 "defgeneric")
     "は、コンパイル時にはどのような副作用も要求されていません。" "特に、コンパイル時に呼び出すためのメソッドは導入されません。"
     "実装者は、コンパイル時のエラーチェック" "（関数呼び出し時の引数の個数チェックであったり、" "あるいは関数名の定義を確認したりすること）のために、"
     "ジェネリック関数についての情報を保存するか選択できます。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "function-name") "が通常の関数か、マクロか、特殊オペレーターの名前のときは、"
     "型" (CODE1 "program-error") "のエラーが発生します。" EOL2 "引数" (STRONG "gf-lambda-list")
     "として指定された各要求された引数は、" (STRONG "parameter-name") "として正確にひとつだけ含まれなければならず、" "そうでないときは、型"
     (CODE1 "program-error") "のエラーが発生します。" EOL2 (STRONG "method-description")
     "によって指定された各メソッドのラムダリストは、" (STRONG "gf-lambda-list")
     "オプションによって指定されたラムダリストと合致していなければならず、" "そうでないときは型" (CODE1 "error") "のエラーが発生します。" EOL2
     "もし、" (CODE1 "defgeneric") "フォームが評価されたとき、" "そのジェネリック関数にあるメソッドのラムダリストが"
     (CODE1 "defgeneric") "フォームに付与されたものと合致しない場合は、" "型" (CODE1 "error") "のエラーが発生します。" EOL2
     "オプションがただひとつではなかった場合は、" "型" (CODE1 "program-error") "のエラーが発生します。" EOL2 "もし、"
     (STRONG "function-name") "が既存のジェネリック関数を示しており、" "新しいジェネリック関数の"
     (CODE1 ":generic-function-class") "の値が" "古いものと互換性がある場合は、" (CODE1 "change-class")
     "が呼ばれてジェネリック関数のクラスが変更されます。" "それ以外の場合は型" (CODE1 "error") "のエラーが発生します。" EOL2 "実装は、"
     (CODE1 "defgeneric") "に別のオプションを含めるよう拡張できます。" "もし自身が実装していないオプションが見られた場合は、" "その実装は型"
     (CODE1 "program-error") "のエラーを発生するよう要求されます。")
    (CHAPTER ("## 参考") 2 (CODE1 "defmethod") "," (CODE1 "documentation") ","
     (CODE1 "ensure-generic-function") "," (CODE1 "generic-function") ","
     "7.6.4. ジェネリック関数の全てのメソッドのラムダリストの合意")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DEFGENERIC" . "MACRO") *table*) (gethash "DEFGENERIC" *table*))
(setf (gethash "DEFINE-COMPILER-MACRO" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFINE-COMPILER-MACRO"))
    (CHAPTER ("## 構文") 2 (CODE1 "define-compiler-macro") " " (STRONG "name") " "
     (STRONG "lambda-list") " [[" (STRONG "declaration\\*") " " (CODE1 "|") " "
     (STRONG "documentation") "]] " (STRONG "form\\*") EOL1 "=> " (STRONG "name"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - 関数名" EOL1 (STRONG "lambda-list")
     " - マクロラムダリスト" EOL1 (STRONG "declaration") " - 宣言式。評価はされません。"
     (STRONG "documentation") " - 文字列。評価はされません。" (STRONG "form") " - フォーム")
    (CHAPTER ("## 定義") 2 "これはコンパイラーマクロ関数の宣言の通常の仕組みです。" "この宣言の方法は" (CODE1 "defmacro")
     "と同じですが、" "ただし下記の違いがあります。" EOL2 "- " (STRONG "name") "は関数名かマクロの関数名です。" EOL2
     "- 展開関数は、マクロ関数としてではなく、" (STRONG "name") "というコンパイラーマクロ関数として導入されます。" EOL2 "- "
     (CODE1 "&whole") "引数は、コンパイラーマクロ関数に渡されたフォームの" "引数に束縛されます。" "残りのラムダリストのパラメーターは、"
     (CODE1 "car") "部がこのフォームに含まれる関数名なので、" "使用される引数は" (CODE1 "cdr") "部になります。" "しかしもしフォームの"
     (CODE1 "car") "部が" (CODE1 "funcall") "というシンボルであったときは、" "引数の分配は" (CODE1 "cddr")
     "部が代わりに使われます。" EOL2 "- " (STRONG "documentation") "は、ドキュメント文字として種別"
     (CODE1 "compiler-macro") "とともに、" "コンパイラーマクロ関数へ割り当てられます。" EOL2
     "- 通常のマクロと異なり、コンパイラマクロは、" "元の形式と同じ形式（" (CODE1 "&whole") "で取得可能）を返すだけで"
     "展開を拒否することができます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun square (x) (expt x 2)) =>  SQUARE"
      "(define-compiler-macro square (&whole form arg)" "  (if (atom arg)"
      "      `(expt ,arg 2)" "      (case (car arg)"
      "        (square (if (= (length arg) 2)"
      "                    `(expt ,(nth 1 arg) 4)" "                    form))"
      "        (expt   (if (= (length arg) 3)"
      "                    (if (numberp (nth 2 arg))"
      "                        `(expt ,(nth 1 arg) ,(* 2 (nth 2 arg)))"
      "                        `(expt ,(nth 1 arg) (* 2 ,(nth 2 arg))))"
      "                    form))" "        (otherwise `(expt ,arg 2))))) =>  SQUARE"
      "(square (square 3)) =>  81" "(macroexpand '(square x)) =>  (SQUARE X), false"
      "(funcall (compiler-macro-function 'square) '(square x) nil)" "=>  (EXPT X 2)"
      "(funcall (compiler-macro-function 'square) '(square (square x)) nil)"
      "=>  (EXPT X 4)"
      "(funcall (compiler-macro-function 'square) '(funcall #'square x) nil)"
      "=>  (EXPT X 2)" NIL "(defun distance-positional (x1 y1 x2 y2)"
      "  (sqrt (+ (expt (- x2 x1) 2) (expt (- y2 y1) 2))))" "=>  DISTANCE-POSITIONAL"
      "(defun distance (&key (x1 0) (y1 0) (x2 x1) (y2 y1))"
      "  (distance-positional x1 y1 x2 y2))" "=>  DISTANCE"
      "(define-compiler-macro distance (&whole form"
      "                                 &rest key-value-pairs"
      "                                 &key (x1 0  x1-p)"
      "                                      (y1 0  y1-p)"
      "                                      (x2 x1 x2-p)"
      "                                      (y2 y1 y2-p)"
      "                                 &allow-other-keys"
      "                                 &environment env)"
      "  (flet ((key (n) (nth (* n 2) key-value-pairs))"
      "         (arg (n) (nth (1+ (* n 2)) key-value-pairs))" "         (simplep (x)"
      "           (let ((expanded-x (macroexpand x env)))"
      "             (or (constantp expanded-x env)"
      "                 (symbolp expanded-x)))))"
      "    (let ((n (/ (length key-value-pairs) 2)))"
      "      (multiple-value-bind (x1s y1s x2s y2s others)"
      "          (loop for (key) on key-value-pairs by #'cddr"
      "                count (eq key ':x1) into x1s"
      "                count (eq key ':y1) into y1s"
      "                count (eq key ':x2) into x2s"
      "                count (eq key ':y1) into y2s"
      "                count (not (member key '(:x1 :x2 :y1 :y2)))"
      "                  into others"
      "                finally (return (values x1s y1s x2s y2s others)))"
      "        (cond ((and (= n 4)" "                    (eq (key 0) :x1)"
      "                    (eq (key 1) :y1)" "                    (eq (key 2) :x2)"
      "                    (eq (key 3) :y2))"
      "               `(distance-positional ,x1 ,y1 ,x2 ,y2))"
      "              ((and (if x1-p (and (= x1s 1) (simplep x1)) t)"
      "                    (if y1-p (and (= y1s 1) (simplep y1)) t)"
      "                    (if x2-p (and (= x2s 1) (simplep x2)) t)"
      "                    (if y2-p (and (= y2s 1) (simplep y2)) t)"
      "                    (zerop others))"
      "               `(distance-positional ,x1 ,y1 ,x2 ,y2))"
      "              ((and (< x1s 2) (< y1s 2) (< x2s 2) (< y2s 2)"
      "                    (zerop others))"
      "               (let ((temps (loop repeat n collect (gensym))))"
      "                 `(let ,(loop for i below n"
      "                              collect (list (nth i temps) (arg i)))"
      "                    (distance" "                      ,@(loop for i below n"
      "                              append (list (key i) (nth i temps)))))))"
      "              (t form))))))" "=>  DISTANCE" "(dolist (form"
      "          '((distance :x1 (setq x 7) :x2 (decf x) :y1 (decf x) :y2 (decf x))"
      "            (distance :x1 (setq x 7) :y1 (decf x) :x2 (decf x) :y2 (decf x))"
      "            (distance :x1 (setq x 7) :y1 (incf x))"
      "            (distance :x1 (setq x 7) :y1 (incf x) :x1 (incf x))"
      "            (distance :x1 a1 :y1 b1 :x2 a2 :y2 b2)"
      "            (distance :x1 a1 :x2 a2 :y1 b1 :y2 b2)"
      "            (distance :x1 a1 :y1 b1 :z1 c1 :x2 a2 :y2 b2 :z2 c2)))"
      "  (print (funcall (compiler-macro-function 'distance) form nil)))"
      ">>  (LET ((#:G6558 (SETQ X 7))" ">>        (#:G6559 (DECF X))"
      ">>        (#:G6560 (DECF X))" ">>        (#:G6561 (DECF X)))"
      ">>    (DISTANCE :X1 #:G6558 :X2 #:G6559 :Y1 #:G6560 :Y2 #:G6561)) "
      ">>  (DISTANCE-POSITIONAL (SETQ X 7) (DECF X) (DECF X) (DECF X)) "
      ">>  (LET ((#:G6567 (SETQ X 7))" ">>        (#:G6568 (INCF X)))"
      ">>    (DISTANCE :X1 #:G6567 :Y1 #:G6568)) "
      ">>  (DISTANCE :X1 (SETQ X 7) :Y1 (INCF X) :X1 (INCF X)) "
      ">>  (DISTANCE-POSITIONAL A1 B1 A2 B2) " ">>  (DISTANCE-POSITIONAL A1 B1 A2 B2) "
      ">>  (DISTANCE :X1 A1 :Y1 B1 :Z1 C1 :X2 A2 :Y2 B2 :Z2 C2) " "=>  NIL"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "compiler-macro-function") "," (CODE1 "defmacro") ","
     (CODE1 "documentation") "," "3.4.11. ドキュメント文字と宣言の文脈的な作用")
    (CHAPTER ("## 備考") 2 (CODE1 "COMMON-LISP") "パッケージにある関数の" "コンパイラーマクロを作成したときの結果は未定義です。"
     "いくつかの処理系では" "このような試行によりそれと同等か同様の重要な定義を" "上書きしてしまう可能性は十分にあります。"
     "一般に、プログラマーは自分自身が保守する関数に対してのみ" "コンパイラマクロ定義を書くことを推奨します。"
     "他の場所で保守されている関数に対してコンパイラマクロ定義を書くことは、" "普通はモジュール性とデータの抽象化に関する"
     "従来のルールに違反するものと見なされます。")))
(setf (gethash '("DEFINE-COMPILER-MACRO" . "MACRO") *table*) (gethash "DEFINE-COMPILER-MACRO" *table*))
(setf (gethash "DEFINE-CONDITION" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFINE-CONDITION"))
    (CHAPTER ("## 構文") 2 (CODE1 "define-condition") " " (STRONG "name") " ("
     (STRONG "parent-type\\*") ") (" (CODE1 "{") (STRONG "slot-spec") (CODE1 "}") "\\*) "
     (STRONG "option\\*") EOL1 "=> " (STRONG "name")
     (CODE3 "```" "```" "slot-spec::= slot-name | (slot-name slot-option) "
      "slot-option::= [[{:reader symbol}* |  "
      "               {:writer function-name}* |  "
      "               {:accessor symbol}* |  "
      "               {:allocation allocation-type} |  "
      "               {:initarg symbol}* |  " "               {:initform form} |  "
      "               {:type type-specifier} ]] "
      "option::= [[(:default-initargs . initarg-list) |  "
      "          (:documentation string) |  " "          (:report report-name) ]] "
      "function-name::= {symbol | (setf symbol)} "
      "allocation-type::= :instance | :class "
      "report-name::= string | symbol | lambda expression "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - シンボル" EOL1 (STRONG "parent-type")
     " - コンディションの型の名前であるシンボル。" "もし" (STRONG "parent-type") "が指定されなかったときは、"
     (STRONG "parent-types") "はデフォルトで" (CODE1 "(condition)") "です。" EOL1
     (STRONG "default-initargs") " - キーワードと値のペアのリスト" EOL1 (STRONG "slot-spec")
     " - スロットの名前か、" (STRONG "slot-name") "に続いてゼロか複数の" (STRONG "slot-option") "を含むリスト。"
     EOL1 (STRONG "slot-name") " - スロットの名前（シンボル）か、" "スロットの名前のリストか、"
     "【翻訳者注釈】名前とスロットのフォームのペアのリスト。" EOL1 (STRONG "option") " - 下記のどれかのもの" EOL2 "- "
     (CODE1 ":reader") "  - " (CODE1 ":reader") "は1つのスロットに対し1つ以上指定できますが、" "    "
     (CODE1 "nil") "は指定できません。" "- " (CODE1 ":writer") "  - " (CODE1 ":writer")
     "は1つのスロットに対し1つ以上指定できますが、" "    ジェネリック関数の名前でなければいけません。" "- " (CODE1 ":accessor")
     "  - " (CODE1 ":accessor") "は1つのスロットに対し1つ以上指定できますが、" "    " (CODE1 "nil")
     "は指定できません。" "- " (CODE1 ":allocation") "  - " (CODE1 ":allocation")
     "は1つのスロットに対し1つ指定できます。" "    " (CODE1 ":allocation") "が指定されなかったときのデフォルト値は"
     (CODE1 ":instance") "です。" "- " (CODE1 ":initarg") "  - " (CODE1 ":initarg")
     "は1つのスロットに対し1つ以上指定できます。" "- " (CODE1 ":initform") "  - " (CODE1 ":initform")
     "は1つのスロットに対し1つ指定できます。" "- " (CODE1 ":type") "  - " (CODE1 ":type")
     "は1つのスロットに対し1つ指定できます。" "- " (CODE1 ":documentation") "  - " (CODE1 ":documentation")
     "は1つのスロットに対し1つ指定できます。" "- " (CODE1 ":report") "  - " (CODE1 ":report") "は1つ指定できます。"
     EOL2 "※翻訳者注釈：名前とスロットフォームは許可されないかもしれません。")
    (CHAPTER ("## 定義") 2 (CODE1 "define-condition") "は新しいコンディションの型を定義します。" "それは"
     (STRONG "name") "という名前であり、" (STRONG "parent-type") "によって名付けられた型か"
     "あるいは型の集合のサブタイプになります。" "各" (STRONG "parent-type") "引数は、新しいコンディションの"
     "直接的なスーパータイプとして指定されます。" "新しいコンディションは各直接的なスーパータイプから" "スロットとメソッドが継承されます。" EOL2
     "もしスロットに名前とスロットのフォームのペアが指定されたとき、" "スロットのフォームは" (CODE1 "make-condition")
     "に明に値が指定されなかったときの" "デフォルト値を提供するためにその" (STRONG "form") "を評価できます。"
     "もしスロットフォームが指定されなかったときは、" "そのスロットの値は実装依存の方法で初期化されます。"
     "（※翻訳者注釈：名前とスロットフォームは許可されないかもしれません）" EOL2 "もし" (STRONG "type") "が定義されるとき、"
     "その型が同じ名前のスロットを持つ他のを継承するとき、" "そのコンディションではただひとつのスロットだけが確保され、" "そのスロットフォームは"
     (STRONG "parent-type") "によって継承された" "他のスロットフォームによって上書きされます。"
     "もしスロットフォームが指定されなかったときは、" "継承されたスロットフォームは（あるならば）まだ見ることができます。" EOL2 "アクセッサは"
     (CODE1 "defclass") "が使われたときと" "同じルールに従って生成されます。" EOL2 (STRONG "slot-option")
     "の定義は下記の通り。" EOL2 "- " (CODE1 ":reader") "  - " (CODE1 ":reader")
     "スロットオプションは、修飾子がないメソッドを" "    " (CODE1 ":reader") "引数で指定した名前のジェネリック関数に定義し、"
     "    その関数はスロットの値を読み込みます。" "    <br><br>" EOL2 "- " (CODE1 ":intiform") "  - "
     (CODE1 ":initform") "スロットオプションは、そのスロットが初期化されるときの" "    デフォルトの初期値フォームを提供するときに使われます。"
     "    このフォームはスロットが初期化するときに毎回評価されて使われます。" "    このフォームが評価されるときのレキシカルな環境は、" "    "
     (CODE1 "define-condition") "フォームが評価されたときの" "    レキシカルな環境です。" "    このレキシカルな環境は、"
     "    変数と関数の両方を参照することに注意してください。" "    ローカルスロットの動的環境は、" "    "
     (CODE1 "make-condition") "が呼び出されたときの動的環境です。" "    共有スロットの動的環境は、" "    "
     (CODE1 "define-condition") "フォームが評価されたときの動的環境です。" "    <br><br>" EOL2 "- "
     (CODE1 ":initarg") "  - " (CODE1 ":initarg") "スロットオプションは、引数のシンボルを"
     "    初期化引数の名前にするように宣言します。" "    この初期化引数によって指定したスロットが初期化されます。" "    もし"
     (CODE1 "initialize-instance") "の呼び出し時に" "    この初期化引数が値を持っているときは、"
     "    指定のスロットに値がか格納され、" "    そのスロットオプションに" (CODE1 ":initform") "があるなら"
     "    それは評価されません。" "    もし指定したスロットで定義された" "    初期化引数が値を持っていないときは、" "    もし指定があるなら"
     (CODE1 ":initform") "スロットオプションに従った値で" "    初期化されます。" "    <br><br>" EOL2 "- "
     (CODE1 ":type") "  - " (CODE1 ":type") "スロットオプションは、スロットの内容が"
     "    常に指定された型であることを指定します。" "    この宣言は、このコンディションの型のオブジェクトに適用される"
     "    ジェネリック関数であるリーダーの返却値の型を" "    効率よく宣言できます。" "    このスロットに安全ではない型の値を格納しようとしたときの"
     "    結果は未定義です。" "    <br><br>" EOL2 "- " (CODE1 ":default-initargs") "  - このオプションは"
     (CODE1 "defclass") "と同じように扱われます。" "    <br><br>" EOL2 "- " (CODE1 ":documentation")
     "  - " (CODE1 ":documentation") "スロットオプションは、" "    そのスロットのドキュメント文字を提供します。"
     "    <br><br>" EOL2 "- " (CODE1 ":report") "  - コンディションの報告は、そのコンディションの型の質問に対して"
     "    " (CODE1 "*print-escape*") "が" (CODE1 "nil") "に指定されているときはいつでも" "    "
     (CODE1 "print-object") "メソッドを仲介します。" "    そのコンディションの型" (CODE1 "C") "の定義に"
     (CODE1 "(:report report-name)") "が指定されたときは、" "    それは下記のものと同等です。"
     (CODE3 "```lisp" "```" "(defmethod print-object ((x c) stream)"
      "  (if *print-escape* (call-next-method) (report-name x stream)))")
     EOL2 "- - もし引数" (CODE1 ":report (report-name)") "で指定された値が" "    シンボルかラムダ式のときは、"
     "    それは" (CODE1 "function") "を受け付けなければなりません。" "    "
     (CODE1 "(function report-name)") "が現在のレキシカルな環境内で評価されます。"
     "    それは2つの引数のコンディションとストリームを受け取り、" "    コンディションの定義をストリームに印刷するような"
     "    関数でなければなりません。" "    この関数は" (CODE1 "*print-escape*") "が" (CODE1 "nil") "のときは"
     "    いつでもコンディションの印刷のときに呼び出されます。" "    <br><br>" "    もし" (STRONG "report-name")
     "が文字列のときは次の省略形になります。"
     (CODE3 "```lisp" "```" "(lambda (condition stream)" "  (declare (ignore condition))"
      "  (write-string report-name stream))")
     EOL2 "- - このオプションは新しいコンディションの型が" "    定義された後で処理されるので、" "    " (CODE1 ":report")
     "関数の内部でスロットのアクセッサを" "    使用することが許されます。" "    もしこのオプションが指定されなかったときは、"
     "    このコンディションの型がどのようにして" "    報告されるのかについての情報は、" "    " (STRONG "parent-type")
     "から継承されます。" "    <br><br>" EOL2 "明に初期化されなかったスロットか、" "あるいはデフォルト値を与えられなかったスロットについて"
     "読み込みをしようとしたときの結果は未定義です。" EOL2 "スロットへの代入を" (CODE1 "setf") "によって"
     "行おうとしようとしたときの結果は未定義です。" EOL2 "もし" (CODE1 "define-condition")
     "フォームがトップレベルフォームに現れたとき、" "コンパイラーはその型の名前を有効なものとして認識しなければならず、" "そのコンパイルされているファイル内の"
     "後続の" (CODE1 "define-condition") "が" "その他のコンディションの" (STRONG "parent-type") "に"
     "そのコンディションの型が参照できるようにしなければなりません。")
    (CHAPTER ("## 例文") 2 "下記の例は" (CODE1 "peg/hole-mismatch") "というコンディションの型の定義であり、" "これは"
     (CODE1 "blocks-world-error") "と呼ばれるコンディションの型を継承しています。"
     (CODE3 "```lisp" "```" "(define-condition peg/hole-mismatch "
      "                  (blocks-world-error)"
      "                  ((peg-shape  :initarg :peg-shape"
      "                               :reader peg/hole-mismatch-peg-shape)"
      "                   (hole-shape :initarg :hole-shape"
      "                               :reader peg/hole-mismatch-hole-shape))"
      "  (:report (lambda (condition stream)"
      "             (format stream \"A ~A peg cannot go in a ~A hole.\""
      "                     (peg/hole-mismatch-peg-shape  condition)"
      "                     (peg/hole-mismatch-hole-shape condition)))))")
     EOL2 "新しい型は" (CODE1 "peg-shape") "と" (CODE1 "hole-shape") "というスロットを持っており、" "よって"
     (CODE1 "make-condition") "は" (CODE1 ":peg-shape") "と" (CODE1 ":hole-shape") "という"
     "キーワードを受け付けます。" "リーダーである" (CODE1 "peg/hole-mismatch-peg-shape") "と"
     (CODE1 "peg/hole-mismatch-hole-shape") "は" "その型のオブジェクトを受付け、" (CODE1 ":report")
     "はその型の情報を出力します。" EOL2 "次のフォームは" (CODE1 "machine-error") "という名前のコンディションの型を定義しており、"
     "これは" (CODE1 "error") "を継承しています。"
     (CODE3 "```lisp" "```" "(define-condition machine-error "
      "                  (error)"
      "                  ((machine-name :initarg :machine-name"
      "                                 :reader machine-error-machine-name))"
      "  (:report (lambda (condition stream)"
      "             (format stream \"There is a problem with ~A.\""
      "                     (machine-error-machine-name condition)))))")
     EOL2 "次の定義の構築は、" (CODE1 "machine-error") "のサブタイプとして"
     "定義された新しいエラーのコンディションとして定義されたものであり、" "機械が利用できないときに使われるものです。"
     (CODE3 "```lisp" "```"
      "(define-condition machine-not-available-error (machine-error) ()"
      "  (:report (lambda (condition stream)"
      "             (format stream \"The machine ~A is not available.\""
      "                     (machine-error-machine-name condition)))))")
     EOL2 "この定義はまだより詳しいコンディションが定義でき、" (CODE1 "machine-not-available-error") "は"
     (CODE1 "machine-name") "の初期化フォームを提供していますが、" "しかし新しいスロットも報告情報も提供していません。" "ただ"
     (CODE1 "machine-name") "のスロットのデフォルト初期化フォームだけ指定しています。"
     (CODE3 "```lisp" "```" "(define-condition my-favorite-machine-not-available-error"
      "                  (machine-not-available-error)"
      "  ((machine-name :initform \"mc.lcs.mit.edu\")))")
     EOL2 "注意してほしいのは、" (CODE1 ":report") "オプションが与えられなくても、" "その型の情報を報告する際には" "継承された"
     (CODE1 "machine-not-available-error") "の情報が使われます。"
     (CODE3 "```lisp" "```" "(define-condition ate-too-much (error) "
      "    ((person :initarg :person :reader ate-too-much-person)"
      "     (weight :initarg :weight :reader ate-too-much-weight)"
      "     (kind-of-food :initarg :kind-of-food"
      "                   :reader :ate-too-much-kind-of-food)))" "=>  ATE-TOO-MUCH"
      "(define-condition ate-too-much-ice-cream (ate-too-much)"
      "  ((kind-of-food :initform 'ice-cream)" "   (flavor       :initarg :flavor"
      "                 :reader ate-too-much-ice-cream-flavor"
      "                 :initform 'vanilla ))" "  (:report (lambda (condition stream)"
      "             (format stream \"~A ate too much ~A ice-cream\""
      "                     (ate-too-much-person condition)"
      "                     (ate-too-much-ice-cream-flavor condition)))))"
      "=>  ATE-TOO-MUCH-ICE-CREAM" "(make-condition 'ate-too-much-ice-cream"
      "                :person 'fred" "                :weight 300"
      "                :flavor 'chocolate)" "=>  #<ATE-TOO-MUCH-ICE-CREAM 32236101>"
      "(format t \"~A\" *)" ">>  FRED ate too much CHOCOLATE ice-cream" "=>  NIL"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-condition") "," (CODE1 "defclass") ","
     "9.1. コンディションシステムの説明")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DEFINE-CONDITION" . "MACRO") *table*) (gethash "DEFINE-CONDITION" *table*))
(setf (gethash "DEFINE-METHOD-COMBINATION" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFINE-METHOD-COMBINATION"))
    (CHAPTER ("## 構文") 2 (CODE1 "define-method-combination") " " (STRONG "name")
     " [[short-form-option]]" EOL1 "=> " (STRONG "name") EOL2
     (CODE1 "define-method-combination") " " (STRONG "name") " " (STRONG "lambda-list")
     " (" (STRONG "method-group-specifier\\*") ")" " [(:arguments . "
     (STRONG "args-lambda-list") ")]" " [(:generic-function "
     (STRONG "generic-function-symbol") ")]" " [[" (STRONG "declaration\\*") " "
     (CODE1 "|") " " (STRONG "documentation") "]]" " " (STRONG "form\\*") EOL1 "=> "
     (STRONG "name")
     (CODE3 "```" "```" "short-form-option::= :documentation documentation |  "
      "                     :identity-with-one-argument identity-with-one-argument |"
      "                     :operator operator"
      "method-group-specifier::= (name {qualifier-pattern+ | predicate} [[long-form-option]])"
      "long-form-option::= :description description |"
      "                    :order order |" "                    :required required-p"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "args-lambda-list")
     " - define-method-combination引数のラムダリスト" EOL1 (STRONG "declaration")
     " - 宣言の式、評価はされません" EOL1 (STRONG "description") " - format-control" EOL1
     (STRONG "documentation") " - 文字列、評価はされません" (STRONG "form") " - 暗黙のprogn。"
     "有効なメソッドをどのようにして結合させるかを計算し、" "フォームとして返却しなければなりません。" EOL1
     (STRONG "generic-function-symbol") " - シンボル" EOL1
     (STRONG "identity-with-one-argument") " - generalized-boolean" EOL1
     (STRONG "lambda-list") " - 通常のラムダリスト" EOL1 (STRONG "name") " - シンボル。"
     "通常、キーワードではなく、" (CODE1 "nil") "でもないシンボルが使われます。" EOL1 (STRONG "operator")
     " - オペレーター。" (STRONG "name") "と" (STRONG "operator") "は、よく同じシンボルが使われます。"
     "これがデフォルトですが、必須ではありません。" EOL1 (STRONG "order") " - " (CODE1 ":most-specific-first")
     "か" (CODE1 ":most-specific-last") "。評価されます。" EOL1 (STRONG "predicate") " - シンボルであり、"
     "それはひとつの引数を取りgeneralized-booleanを返却する関数名。" EOL1 (STRONG "qualifier-pattern")
     " - リストか、シンボル" (CODE1 "*") EOL1 (STRONG "required-p") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "マクロ" (CODE1 "define-method-combination") "は、"
     "新しいmethod-combinationの型を定義するときに使います。" EOL2 (CODE1 "define-method-combination")
     "には2つのフォームがあります。" "短いフォームは単純な機能であり、" "もっとも一般的に必要があると予想されるケースに対応しています。"
     "長いフォームはより強力で、より冗長です。" "これは、" (CODE1 "defmacro") "のように、" "通常はボディ部がバッククォートを使った式であり、"
     "フォームを計算します。" "したがって、任意の制御構造を実装することができます。" "長いフォームは、メソッド修飾子を任意に処理することもできます。" EOL2
     "- 短いフォーム" "  - " (CODE1 "define-method-combination") "の短いフォームの構文は、"
     "    二番目のサブフォームが" (CODE1 "nil") "ではないシンボルか、" "    あるいは現れていないときに認識されます。"
     "    短いフォームを使うと、" "    " (STRONG "name") "が"
     (CODE1 "(operator method-call method-call ...)") "という"
     "    Lispのフォームが生成されるmethod-combinationの型として定義されます。" "    " (STRONG "operator")
     "は関数か、マクロか、" "    特殊オペレーターの名前のシンボルです。" "    " (STRONG "operator")
     "はキーワードオプションによって指定することができ、" "    デフォルト値は" (STRONG "name") "です。" "    <br><br>"
     "    短いフォームのキーワードオプションは下記の通り。" "    - " (CODE1 ":documentation") "オプションは、"
     "      method-combination型のドキュメントに使われます。" "      定義は下記にある長いフォームを参照。" "    - "
     (CODE1 ":identity-with-one-argument") "オプションは、" "      値が" (STRONG "true")
     "のときに最適化を有効にします。" "      （デフォルトは" (STRONG "false") "です。）"
     "      もし適用可能なメソッドが正確にひとつであり、" "      それがプライマリメソッドのとき、"
     "      そのメソッドは有効なメソッドとして機能し、" "      " (STRONG "operator") "を呼び出しません。"
     "      この最適化は、新たに有効なメソッドを作成することがなくなり、" "      また関数呼び出しのオーバーヘッドを抑えます。"
     "      このオプションは" "      " (CODE1 "progn") ", " (CODE1 "and") ", " (CODE1 "+") ", "
     (CODE1 "max") "のようなオペレーターで" "      で使用することを想定しています。" "    - " (CODE1 ":operator")
     "オプションは、オペレーターの名前を指定します。" "      " (STRONG "operator") "引数は、関数か、マクロか、"
     "      特殊オペレーターの名前のシンボルです。" "  - これらのmethod-combinationの型は、"
     "    メソッドに対して正確にひとつの修飾子を要求します。" "    もし適用可能なメソッドに、" "    修飾子がなかったり、"
     "    method-combinationの型がサポートされていない" "    修飾子であったときは、" "    エラーが発生します。"
     "    <br><br>" "    このように定義されたmethod-combinationの機能は、" "    メソッドに2つの役割を与えます。"
     "    このタイプのmethod-combinationによって名前付けられたシンボルが" "    ひとつの修飾子として与えられたメソッドは、"
     "    プライマリメソッドとして定義されます。" "    少なくともひとつのプライマリメソッドが" "    適用可能でないとエラーが発生します。"
     "    ひとつの修飾子として" (CODE1 ":around") "が与えられたメソッドは、" "    " (CODE1 "standard")
     " method-combinationのaroundメソッドと" "    同じふるまいをする補助メソッドです。" "    関数"
     (CODE1 "call-next-method") "は、aroundメソッド内でのみ使用できます。" "    つまり、"
     (CODE1 "define-method-combination") "マクロの" "    短いフォームによって定義された"
     "    プライマリメソッド内では使用することができません。" "    <br><br>"
     "    この方法で定義されたmethod-combinationの機能は、" "    オプション引数" (STRONG "order") "を受け取ります。"
     "    デフォルト値は" (CODE1 ":most-specific-first") "です。" "    値"
     (CODE1 ":most-specific-last") "は、" "    補助メソッドの順番に影響することなく、"
     "    プライマリメソッドの順番を逆順にさせます。" "    <br><br>" "    短いフォームは、自動的にエラーチェックを含み、"
     "    またaroundメソッドもサポートします。" "    <br><br>"
     "    組み込みのmethod-combination型の説明は、7.6.6.4. 組み込みのMethod-Combinationを参照してください。"
     "    <br><br>" EOL2 "- 長いフォーム" "  - " (CODE1 "define-method-combination")
     "の長いフォームの構文は、" "    二番目のサブフォームがリストのときに認識されます。" "    <br><br>" "    "
     (STRONG "lambda-list") "は、" (CODE1 "defgeneric") "の" (CODE1 ":method-combination")
     "オプションの" "    型method-combinationの名前の後に提供されている" "    どのような引数も受け取ります。" "    <br><br>"
     "    メソッドグループのリストについては次の通り。" "    各指定子は、パターンとマッチする修飾子か、" "    " (STRONG "predicate")
     "でテストされた修飾子か、どちらかの判定によって、" "    適用可能なメソッド特定の役割を果たすためのサブセットを選択します。"
     "    これらのメソッドグループ指定子は、" "    このmethod-combination型で使用できる" "    全てのメソッド修飾子を定義します。"
     "    <br><br>" "    各" (STRONG "method-group-specifier") "の" (CODE1 "car")
     "部は、変数名のシンボルです。" "    " (CODE1 "define-method-combination") "のボディ部のフォームを実行しているとき、"
     "    この変数はメソッドグループ内のメソッドのリストに束縛されます。" "    このリスト中のメソッドは、" (CODE1 ":order")
     "オプションによって順序付けられます。" "    <br><br>" "    もし" (STRONG "qualifier-pattern")
     "がシンボルなら、それは" (CODE1 "*") "でなければなりません。" "    もしメソッドの修飾子のリストと" "    "
     (STRONG "qualifier-pattern") "が" (CODE1 "equal") "で一致する場合" "    （ただしシンボル"
     (CODE1 "*") "はどんな" (STRONG "qualifier-pattern") "にもマッチします）、" "    メソッドは"
     (STRONG "qualifier-pattern") "にマッチすると言えます。" "    したがって、"
     (STRONG "qualifier-pattern") "は、次に示すうちのひとつに当てはまります。"
     "    空のリストの場合は、修飾子がないメソッドにマッチします。" "    シンボル" (CODE1 "*") "は、すべてのメソッドにマッチします。"
     "    通常のリストのときは、" "    メソッドにはリストの長さと同じ数の修飾子があり、" "    各修飾子が対応するリストの要素にマッチします。"
     "    もしドットリストのときは、シンボル" (CODE1 "*") "で終端します" "    （" (CODE1 "*")
     "は、続くどんな数の修飾子にもマッチします）。" "    <br><br>" "    適用可能な各メソッドは、左から右の順番で、" "    "
     (STRONG "qualifier-patterns") "と" (STRONG "predicate") "のテストが行われます。" "    "
     (STRONG "qualifier-patterns") "か" (STRONG "predicate") "が" (STRONG "true") "のときは、"
     "    そのメソッドはすぐに対応するメソッドグループのメンバーとなり、" "    それ以上のテストは行われません。"
     "    したがって、メソッドグループが複数の" (STRONG "qualifier-pattern") "を持つ場合、" "    メソッドはそのうちの1つの"
     (STRONG "qualifier-pattern") "を満たすだけで" "    グループのメンバーとなることができます。" "    <br><br>"
     "    もしどのメソッドグループにも属さない適用可能なメソッドがある場合は、" "    関数" (CODE1 "invalid-method-error")
     "が呼び出されます。" "    <br><br>" "    メソッドグループは、" (STRONG "qualifier-patter") "と"
     (STRONG "predicate") "に続いて" "    キーワードオプションを指定することができます。" "    キーワードオプションはリストでもシンボル"
     (CODE1 "*") "でもないので、" "    追加の" (STRONG "qualifier-pattern") "と区別することができます。"
     "    キーワードオプションは次の通りです。" "    - " (CODE1 ":description") "オプションは、"
     "      メソッドグループ内のメソッドの役割の説明を指定するときに使われます。" "      プログラミング環境のツールは、"
     "      簡潔な説明を出力するときは、" "      "
     (CODE1 "(apply #'format stream format-control (method-qualifiers method))") "を"
     "      実行することを期待しています。" "      ほとんどの場合、" (STRONG "format-control") "は"
     (CODE1 "format") "指示子を含みませんが、" "      一般性のために利用できます。" "    - " (CODE1 ":order")
     "オプションは、メソッドの順序を指定します。" "      " (STRONG "order") "引数は、"
     (CODE1 ":most-specific-first") "か" (CODE1 ":most-specific-last") "に"
     "      評価されるフォームです。" "      もしそのほかの値に評価された場合はエラーが発生します。" "      " (CODE1 ":order")
     "が指定されなかったときは、デフォルトは" (CODE1 ":most-specific-first") "です。" "    - "
     (CODE1 ":require") "オプションは、" "      メソッドグループに少なくともひとつのメソッドが必要かどうかを指定します。"
     "      もし値が" (STRONG "true") "であり、かつメソッドグループが空のとき" "      （これは、適用可能なメソッドが、"
     (STRONG "qualifier-pattern") "にマッチしないか" "      あるいは" (STRONG "predicate")
     "を満たさなかったとき）" "      エラーが発生します。" "      " (CODE1 ":require") "が指定されないときは、デフォルトは"
     (CODE1 "nil") "です。" "  - メソッドグループ指定子を使用することで、"
     "    メソッドを選択し、可能な役割にあうように分け、必要なエラーチェックを行うのに、" "    便利な構文が提供されます。"
     "    ボディ部のフォームにて、通常のリスト処理を行い、" "    " (CODE1 "method-qualifiers") "と"
     (CODE1 "invalid-method-error") "の関数を使用することで、" "    さらなるメソッドのフィルタリングを行うことができます。"
     "    メソッドグループ指定子内で名前付けられた変数に" "    " (CODE1 "setq") "を使うこともできますし、"
     "    追加の変数に束縛することもできます。" "    また、メソッドグループ指定子の仕組みをバイパスして、"
     "    ボディ部のフォーム内ですべてを行うこともできます。" "    これは、" (STRONG "qualifier-patter") "が"
     (CODE1 "*") "のみである" "    単体のメソッドグループを記述することで実現できます。" "    変数にはすべての適用可能なメソッドのリストが"
     "    " (CODE1 "most-specific-first") "順に束縛されます。" "    <br><br>" "    ボディ部"
     (STRONG "form") "では、有効なメソッドをどのようにして結合させるかを計算し、" "    フォームとして返却します。" "    有効なメソッドは"
     (CODE1 "null") "のレキシカルな環境から" "    加えてローカルマクロ" (CODE1 "call-method") "の定義と、" "    "
     (CODE1 "COMMON-LISP-USER") "パッケージからアクセスできないシンボル名の束縛で" "    拡張された環境下で評価されます。"
     "    メソッドグループ指定子によって生成されたリストのうちの" "    ひとつのメソッドオブジェクトと、次のメソッドのリストが与えられると、" "    "
     (CODE1 "call-method") "は、" (CODE1 "call-next-method") "が次のメソッドとして利用可能な"
     "    メソッドを呼び出します。" "    <br><br>" "    ある有効なメソッドが、" "    単体のメソッドを呼び出す他に効果を持たないとき、"
     "    単体のメソッドをそのまま有効なメソッドとして呼び出し、" "    新たに有効なメソッドの生成をする必要がないように" "    最適化する実装もあります。"
     "    この最適化は、有効なメソッドのフォームが、" "    最初のフォームはメソッドオブジェクトで、" "    二番目のフォームは" (CODE1 "nil")
     "か" "    あるいは指定されていないような" (CODE1 "call-method") "マクロの呼び出しで"
     "    全体が構成されているような場合において有効です。" "    各" (CODE1 "define-method-combination") "のボディ部は"
     "    この最適が必要な場合は、" "    " (CODE1 "progn") ", " (CODE1 "and") ", "
     (CODE1 "multiple-value-prog1") "などの" "    冗長な呼び出しを削除する責任を負います。" "    <br><br>"
     "    リスト" (CODE1 "(:arguments . lambda-list)") "は、" "    宣言かドキュメント文字の前に記述することができます。"
     "    このフォームは、method-combinationが" "    メソッドを結合するための一部としてある特定の動作を行い、"
     "    続けてジェネリック関数の引数にアクセスする" "    必要が生じた場合において有効です。" "    " (STRONG "lambda-list")
     "によって定義された各パラメーターの変数は、" "    有効なメソッドの中に挿入されたフォーム内で束縛されます。" "    この" (STRONG "form")
     "が有効なメソッドの実行中に評価されるとき、" "    それらの値はジェネリック関数に対応する引数になります。" "    そのようなフォームを"
     (CODE1 "setf") "の" (CODE1 "place") "として使用した時の結果は未定です。" "    引数の対応は、"
     (CODE1 ":arguments") "の" (STRONG "lambda-list") "と、" "    ジェネリック関数の"
     (STRONG "lambda-list") "を、" "    それぞれ次の三つのセクションに分けて計算します。"
     "    その三つは、要求パラメーター、オプションパラメーター、" "    そして、キーワードと" (CODE1 "rest") "パラメーターです。"
     "    ある特定の呼び出し時にジェネリック関数に指定された引数もまた、" "    三つのセクションに分割されます。" "    要求された引数のセクションは、"
     "    ジェネリック関数が保有する要求された引数と同じ数の引数を含み、" "    オプション引数のセクションは"
     "    ジェネリック関数が保有するオプション引数と同じ数の引数を含み、" "    そしてキーワードと" (CODE1 "rest")
     "引数のセクションは残りの引数を含みます。" "    " (CODE1 ":arguments") "の" (STRONG "lambda-list") "にある"
     "    要求された引数とオプション引数の" "    セクション内にある各パラメーターは、" "    対応する引数のセクションと"
     "    同じ位置にある引数にアクセスします。" "    もし" (CODE1 "arguments") "の" (STRONG "lambda-list")
     "のセクションの方が短いときは、" "    余分な引数は無視されます。" "    もし" (CODE1 "arguments") "の"
     (STRONG "lambda-list") "のセクションの方が長いときは、" "    超過した要求パラメーターは" (CODE1 "nil") "が束縛され、"
     "    超過したオプションパラメーターはそれぞれの" (CODE1 "initform") "に束縛されます。" "    "
     (CODE1 ":arguments") "の" (STRONG "lambda-list") "のキーワードと" (CODE1 "rest") "パラメーターは、"
     "    引数のキーワードと" (CODE1 "rest") "のセクションにアクセスされます。" "    もし" (CODE1 ":arguments") "の"
     (STRONG "lambda-list") "に" (CODE1 "&key") "が含まれているときは、" "    "
     (CODE1 "&allow-other-keys") "が含まれているかのようにふるまいます。" "    <br><br>" "    さらに、"
     (CODE1 ":arguments") "の" (STRONG "lambda-list") "の最初に" "    " (CODE1 "&whole var")
     "配置することができます。" "    これは、ジェネリック関数に指定されたすべての引数のリストを、" "    評価される" (STRONG "form")
     "に対して" (STRONG "var") "に束縛します。" "    これはキーワードや" (CODE1 "rest") "引数だけでなく、"
     "    すべての引数にアクセスするので、" (CODE1 "&rest") "とは異なります。" "    <br><br>"
     "    ボディ部で検出されたエラーコンディションは、" "    " (CODE1 "method-combination-error") "か"
     (CODE1 "invalid-method-error") "で" "    報告するべきです。"
     "    これらの関数は、エラーメッセージに必要な文脈的情報を追加し、" "    そして適切なエラーを通知します。" "    <br><br>"
     "    ボディ部" (STRONG "form") "は、メソッドグループ指定子と" "    ラムダリストによって作成された束縛の内側で評価されます。"
     "    ボディ部の先頭にある宣言は、" "    ラムダリストにの束縛の内側に直接配置され、" "    そしてメソッドグループの変数の束縛の外側に配置されます。"
     "    したがって、この方法では、メソッドグループの変数は宣言できません。" "    ただし、ボディ部の周囲に局所的に使用することはできます。"
     "    <br><br>" "    ボディ部" (STRONG "form") "の中では、" (STRONG "generic-function-symbol")
     "は" "    ジェネリック関数オブジェクトが束縛されます。" "    <br><br>" "    " (STRONG "documentation")
     "は、ドキュメント文字が" (STRONG "name") "として、" "    （種類は" (CODE1 "method-combination") "で）"
     "    method-combinationオブジェクトに割り当てられます。" "    <br><br>"
     "    同じ特定子の二つのメソッドが、それぞれ違う修飾子を持つとき、" "    メソッド選択と結合の過程を定義した7.6.6. メソッドの選択とコンビネーションの"
     "    ステップ2で定義されているアルゴリズムでは、" "    順序付けされないことに注意してください。" "    通常、2つのメソッドは修飾子が異なるので、"
     "    有効なメソッド内では違う役割をします。" "    しかしステップ2でどのように並び変えても、" "    有効なメソッドは同じです。"
     "    もし二つのメソッドが同じ役割であり" "    それらの順序が重要な時はエラーが発生します。" "    これは"
     (CODE1 "define-method-combination") "の修飾子の" "    パターンマッチの部分で発生します。" EOL2 "もし"
     (CODE1 "define-method-combination") "フォームがトップレベルフォームに現れたとき、"
     "コンパイラーはmethod-combinationの名前が、" "続く" (CODE1 "defgeneric")
     "フォームのmethod-combination名で" "有効であると認識させなければなりません。" "しかし、method-combinationが実行されるのは、"
     (CODE1 "define-method-combination") "フォームの実行時より早くはないので、"
     "ジェネリック関数がmethod-combinationを使うときまで" "可能な限り遅らせて実行されます。")
    (CHAPTER ("## 例文") 2 (CODE1 "define-method-combination") "の長いフォームの例のほとんどは、"
     "メソッド結合の機能の宣言の一部として、" "提供されている関係関数の使用も説明をしています。"
     (CODE3 "```lisp" "```" ";;; define-method-combinationの短いフォームの例" " "
      "(define-method-combination and :identity-with-one-argument t)" " "
      "(defmethod func and ((x class1) y) ...)" " " ";;; このサンプルと同等の長いフォームの例:" " "
      "(define-method-combination and" "        (&optional (order :most-specific-first))"
      "        ((around (:around))" "         (primary (and) :order order :required t))"
      "  (let ((form (if (rest primary)"
      "                  `(and ,@(mapcar #'(lambda (method)"
      "                                      `(call-method ,method))"
      "                                  primary))"
      "                  `(call-method ,(first primary)))))" "    (if around"
      "        `(call-method ,(first around)" "                      (,@(rest around)"
      "                       (make-method ,form)))" "        form)))" " "
      ";;; define-method-combinationの長いフォームの例" " "
      ";The default method-combination technique"
      "(define-method-combination standard ()" "        ((around (:around))"
      "         (before (:before))" "         (primary () :required t)"
      "         (after (:after)))" "  (flet ((call-methods (methods)"
      "           (mapcar #'(lambda (method)"
      "                       `(call-method ,method))" "                   methods)))"
      "    (let ((form (if (or before after (rest primary))"
      "                    `(multiple-value-prog1"
      "                       (progn ,@(call-methods before)"
      "                              (call-method ,(first primary)"
      "                                           ,(rest primary)))"
      "                       ,@(call-methods (reverse after)))"
      "                    `(call-method ,(first primary)))))" "      (if around"
      "          `(call-method ,(first around)"
      "                        (,@(rest around)"
      "                         (make-method ,form)))" "          form))))" "  "
      ";どれかがnon-nilを返却するまでメソッドを実行する単純な例" "(define-method-combination or ()"
      "        ((methods (or)))" "  `(or ,@(mapcar #'(lambda (method)"
      "                     `(call-method ,method))" "                 methods)))" "  "
      ";先行のより完成されたバージョン" "(define-method-combination or"
      "        (&optional (order ':most-specific-first))" "        ((around (:around))"
      "         (primary (or)))" "  ;; order引数の処理" "  (case order"
      "    (:most-specific-first)"
      "    (:most-specific-last (setq primary (reverse primary)))"
      "    (otherwise (method-combination-error \"~S is an invalid order.~@"
      "    :most-specific-first and :most-specific-last are the possible values.\""
      "                                         order)))" "  ;; プライマリメソッドは必要"
      "  (unless primary"
      "    (method-combination-error \"A primary method is required.\"))"
      "  ;; プライマリメソッドを呼び出すフォームの構築" "  (let ((form (if (rest primary)"
      "                  `(or ,@(mapcar #'(lambda (method)"
      "                                     `(call-method ,method))"
      "                                 primary))"
      "                  `(call-method ,(first primary)))))" "    ;; aroundメソッドを囲むフォーム"
      "    (if around" "        `(call-method ,(first around)"
      "                      (,@(rest around)"
      "                       (make-method ,form)))" "        form)))" "  "
      ";オプション:orderと:requireを使った同じ例" "(define-method-combination or"
      "        (&optional (order ':most-specific-first))" "        ((around (:around))"
      "         (primary (or) :order order :required t))"
      "  (let ((form (if (rest primary)"
      "                  `(or ,@(mapcar #'(lambda (method)"
      "                                     `(call-method ,method))"
      "                                 primary))"
      "                  `(call-method ,(first primary)))))" "    (if around"
      "        `(call-method ,(first around)" "                      (,@(rest around)"
      "                       (make-method ,form)))" "        form)))" "  "
      ";この短いフォームの呼出しは先行と同一のふるまいをする"
      "(define-method-combination or :identity-with-one-argument t)" " "
      ";qualifiersの正の整数によるメソッドの順序付け" ";この小さな例では:aroundメソッドは許されない"
      "(define-method-combination example-method-combination ()"
      "        ((methods positive-integer-qualifier-p))"
      "  `(progn ,@(mapcar #'(lambda (method)"
      "                        `(call-method ,method))"
      "                    (stable-sort methods #'<"
      "                      :key #'(lambda (method)"
      "                               (first (method-qualifiers method)))))))" NIL
      "(defun positive-integer-qualifier-p (method-qualifiers)"
      "  (and (= (length method-qualifiers) 1)"
      "       (typep (first method-qualifiers) '(integer 0 *))))" "  "
      ";;; 引数:argumentsの使用例" "(define-method-combination progn-with-lock ()"
      "        ((methods ()))" "  (:arguments object)" "  `(unwind-protect"
      "       (progn (lock (object-lock ,object))"
      "              ,@(mapcar #'(lambda (method)"
      "                            `(call-method ,method))"
      "                        methods))" "     (unlock (object-lock ,object))))"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 副作用") 2 "コンパイラーはコンパイル時の副次的な処理を行う必要はありません。")
    (CHAPTER ("## 例外") 2 "短いフォームで定義されたmethod-combinationの型は、" "メソッドに対して正確にひとつの修飾子を要求します。"
     "もし適用可能なメソッドに、修飾子がなかったり、" "method-combinationの型がサポートされていない" "修飾子であったときは、" "型"
     (CODE1 "error") "のエラーが発生します。" "少なくともひとつのプライマリメソッドが適用可能でないと" "型" (CODE1 "error")
     "のエラーが発生します。" EOL2 "もしどのメソッドグループにも属さない適用可能なメソッドがある場合は、" "システムは、型" (CODE1 "error")
     "のエラーを通知し、" "そのメソッドが使用中のmethod-combinationの種類に対して無効であることを示します。" EOL2 "もし"
     (CODE1 ":require") "オプションの値が" (STRONG "true") "であり、かつメソッドグループが空のとき"
     "（これは、適用可能なメソッドが、" (STRONG "qualifier-pattern") "にマッチしないか" "あるいは"
     (STRONG "predicate") "を満たさなかったとき）" "型" (CODE1 "error") "のエラーが発生します。" EOL2 "もし"
     (STRONG "order") "引数が評価された値が、" (CODE1 ":most-specific-first") "か"
     (CODE1 ":most-specific-last") "の" "どちらでもなかった場合は型" (CODE1 "error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "call-method") "," (CODE1 "call-next-method") ","
     (CODE1 "documentation") "," (CODE1 "method-qualifiers") ","
     (CODE1 "method-combination-error") "," (CODE1 "invalid-method-error") ","
     (CODE1 "defgeneric") "," "7.6.6. メソッドの選択とコンビネーション,"
     "7.6.6.4. 組み込みのMethod-Combination," "3.4.11. ドキュメント文字と宣言の文脈的な作用")
    (CHAPTER ("## 備考") 2 (CODE1 "defgeneric") "の" (CODE1 ":method-combination") "オプションは、"
     "ジェネリック関数が特定のmethod-combination型を使用するように" "指定するときに使われます。"
     (CODE1 ":method-combination") "オプションの最初の引数はmethod-combination型の名前であり、"
     "残りの引数はその型へのオプションです。")))
(setf (gethash '("DEFINE-METHOD-COMBINATION" . "MACRO") *table*) (gethash "DEFINE-METHOD-COMBINATION" *table*))
(setf (gethash "DEFINE-MODIFY-MACRO" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFINE-MODIFY-MACRO"))
    (CHAPTER ("## 構文") 2 (CODE1 "define-modify-macro") " " (STRONG "name") " "
     (STRONG "lambda-list") " " (STRONG "function") " [" (STRONG "documentation") "] => "
     (STRONG "name"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - シンボル" EOL1 (STRONG "lambda-list") " - "
     (CODE1 "define-modify-macro") "ラムダリスト" EOL1 (STRONG "function") " - シンボル" EOL1
     (STRONG "documentation") " - 文字列。評価されません。")
    (CHAPTER ("## 定義") 2 (CODE1 "define-modify-macro") "は、" (STRONG "name") "という名前で"
     (CODE1 "place") "に読み書きを行うマクロを定義します。" EOL2 "新しいマクロの引数は、最初は" (CODE1 "place") "であり、"
     "続く引数は指定された" (STRONG "lambda-list") "です。" (CODE1 "define-modify-macro")
     "によって定義されたマクロは、" (CODE1 "get-setf-expansion") "へ正しく環境パラメーターが渡されます。" EOL2
     "マクロが起動されると、" (STRONG "function") "が古い内容の" (CODE1 "place") "と"
     (STRONG "lambda-list") "を引数に適用され、" "そして" (CODE1 "place") "は結果の値で更新されます。" EOL2
     "多重評価（下記を参照）を回避する問題を除けば、" (CODE1 "define-modify-macro") "の展開は下記と同等になります。"
     (CODE3 "```lisp" "```" "(defmacro name (reference . lambda-list)" "  documentation"
      "  `(setf ,reference" "         (function ,reference ,arg1 ,arg2 ...)))")
     EOL2 "ここで、" (CODE1 "arg1, arg2, ...") "は" (STRONG "lambda-list") "に現れるパラメーターであり、"
     (CODE1 "rest") "パラメーターが適切に規定されているものとしています。" EOL2 (CODE1 "define-modify-macro")
     "によって定義された" "マクロ呼び出しのサブフォームは、" "5.1.1.1. " (CODE1 "place")
     "のサブフォームの評価によって記載されている通りに評価されます。" EOL2 (STRONG "documentation") "はドキュメント文字の種別"
     (CODE1 "function") "として、" "そのマクロ関数へ割り当てられます。" EOL2 "もし"
     (CODE1 "define-modify-macro") "フォームがトップレベルフォームに現れたとき、"
     "コンパイラーはコンパイル時にマクロ定義を保存しなければならないので、" "ファイル内でその後に現れたマクロを正しく展開できます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(define-modify-macro appendf (&rest args) "
      "   append \"Append onto list\") =>  APPENDF" "(setq x '(a b c) y x) =>  (A B C)"
      "(appendf x '(d e f) '(1 2 3)) =>  (A B C D E F 1 2 3)" "x =>  (A B C D E F 1 2 3)"
      "y =>  (A B C)" "(define-modify-macro new-incf (&optional (delta 1)) +)"
      "(define-modify-macro unionf (other-set &rest keywords) union)"))
    (CHAPTER ("## 副作用") 2 "マクロ定義が" (STRONG "name") "にアサインされます。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "defsetf") "," (CODE1 "define-setf-expander") ","
     (CODE1 "documentation") "," "3.4.11. ドキュメント文字と宣言の文脈的な作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DEFINE-MODIFY-MACRO" . "MACRO") *table*) (gethash "DEFINE-MODIFY-MACRO" *table*))
(setf (gethash "DEFINE-SETF-EXPANDER" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFINE-SETF-EXPANDER"))
    (CHAPTER ("## 構文") 2 (CODE1 "define-setf-expander") " " (STRONG "access-fn") " "
     (STRONG "lambda-list") " [[" (STRONG "declaration\\*") " " (CODE1 "|") " "
     (STRONG "documentation") "]] " (STRONG "form\\*") EOL1 "=> " (STRONG "access-fn"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "access-fn") " - 関数かマクロの名前のシンボル" EOL1
     (STRONG "lambda-list") " - マクロラムダリスト" EOL1 (STRONG "declaration") " - 宣言式。評価されません。"
     EOL1 (STRONG "documentation") " - 文字列。評価されません。" EOL1 (STRONG "form") " - 暗黙のprogn")
    (CHAPTER ("## 定義") 2 (CODE1 "define-setf-expander") "は、" (CODE1 "setf") "が"
     (STRONG "access-fn") "により参照された" (CODE1 "place") "を更新する手段を指定します。" EOL2 (CODE1 "setf")
     "は、" (CODE1 "place") "に" (STRONG "access-fn") "という語と" (CODE1 "place")
     "への新しい値が指定されたとき、" "適切に更新を行うためのフォームを展開します。" EOL2 (STRONG "lambda-list")
     "は、分割のラムダリストをサポートします。" "3.4.4. マクロのラムダリストをご確認ください。" EOL2 (STRONG "documentation")
     "は、ドキュメント文字として種類" (CODE1 "setf") "で" (STRONG "access-fn") "に割り当てられます。" EOL2
     (STRONG "form") "はsetf-expanderの定義を構成し、" (CODE1 "setf") "が呼び出され" (CODE1 "place") "に"
     (STRONG "access-fn") "が与えられたときは" "そのsetf-expanderを計算しなければなりません。" "setf-expander関数は、"
     (CODE1 "define-setf-expander") "フォームが現れる" "同じレキシカルな環境によって定義されます。" (STRONG "form")
     "が実行されている間、" (STRONG "lambda-list") "内の変数は、" (CODE1 "place") "フォームの部分に束縛されます。"
     (CODE1 "define-setf-expander") "フォームの" (STRONG "lambda-list") "以外の" (STRONG "form")
     "であるボディ部は、" "暗黙的に" (STRONG "access-fn") "という名前の" (CODE1 "block") "で囲まれます。" EOL2
     (STRONG "form") "の評価は、5.1.1.2. Setfの展開で定義されたような" "5つの値を返却しなければなりません。" EOL2 "もし"
     (CODE1 "define-setf-expander") "フォームがトップレベルフォームとして現れたときは、" "コンパイラは、そのファイルの後で"
     (CODE1 "setf") "が呼ばれたときに展開が行われるよう、" "setf-expanderを有効にしなければなりません。" "もし同じファイルの後で"
     (CODE1 "place") "が" (STRONG "access-fn") "を使用するときは、" "プログラマーは、" (STRONG "form")
     "をコンパイル時に" "評価できることを保証しなければなりません。" "コンパイラーは、" (CODE1 "get-setf-expansion") "の環境引数が"
     "マクロの環境パラメータの値を受け取った場合、" "コンパイル時にこれらのsetf-expanderを" "利用できるようにしなければなりません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun lastguy (x) (car (last x))) =>  LASTGUY"
      "(define-setf-expander lastguy (x &environment env)"
      "  \"Set the last element in a list to the given value.\""
      "  (multiple-value-bind (dummies vals newval setter getter)"
      "      (get-setf-expansion x env)" "    (let ((store (gensym)))"
      "      (values dummies" "              vals" "              `(,store)"
      "              `(progn (rplaca (last ,getter) ,store) ,store)"
      "              `(lastguy ,getter))))) =>  LASTGUY" "(setq a (list 'a 'b 'c 'd)"
      "      b (list 'x)" "      c (list 1 2 3 (list 4 5 6))) =>  (1 2 3 (4 5 6))"
      "(setf (lastguy a) 3) =>  3" "(setf (lastguy b) 7) =>  7"
      "(setf (lastguy (lastguy c)) 'lastguy-symbol) =>  LASTGUY-SYMBOL" "a =>  (A B C 3)"
      "b =>  (7)" "c =>  (1 2 3 (4 5 LASTGUY-SYMBOL))"
      ";;; (LDB bytespec int)フォームののset-expander。" ";;; intフォームは自身をSETFで適切に扱います。"
      "(define-setf-expander ldb (bytespec int &environment env)"
      "  (multiple-value-bind (temps vals stores"
      "                         store-form access-form)"
      "      (get-setf-expansion int env) ; intのsetf-expander取得"
      "    (let ((btemp (gensym))     ;byte指定子の一時変数"
      "          (store (gensym))     ;byteを保存する一時変数"
      "          (stemp (first stores))) ;byteを保存する一時変数"
      "      (if (cdr stores) (error \"Can't expand this.\"))" ";;; LDBのsetf展開の5つの返却値"
      "      (values (cons btemp temps)       ;一時変数"
      "              (cons bytespec vals)     ;フォームの値"
      "              (list store)             ;保存の変数"
      "              `(let ((,stemp (dpb ,store ,btemp ,access-form)))"
      "                 ,store-form" "                 ,store)               ;保存するフォーム"
      "              `(ldb ,btemp ,access-form) ;アクセスするフォーム" "             ))))"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "setf") "," (CODE1 "defsetf") "," (CODE1 "documentation")
     "," (CODE1 "get-setf-expansion") "," "3.4.11. ドキュメント文字と宣言の文脈的な作用")
    (CHAPTER ("## 備考") 2 (CODE1 "define-setf-expander") "の" (CODE1 "defsetf")
     "の長いフォームとの違いは、" "本体を実行しているときの" (CODE1 "place") "フォームの部分で" (STRONG "lambda-list")
     "の変数の束縛が、" "そのような部分の値を一時変数に束縛してないところです。" "さらに" (CODE1 "define-setf-expander") "は、"
     (CODE1 "defsetf") "の制限である" (STRONG "access-fn") "が関数か関数のようなマクロである必要はなく、"
     (STRONG "lambda-list") "に" (CODE1 "defmacro") "のような" "任意の分配のパターンが許されます。")))
(setf (gethash '("DEFINE-SETF-EXPANDER" . "MACRO") *table*) (gethash "DEFINE-SETF-EXPANDER" *table*))
(setf (gethash "DEFINE-SYMBOL-MACRO" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFINE-SYMBOL-MACRO"))
    (CHAPTER ("## 構文") 2 (CODE1 "define-symbol-macro") " " (STRONG "symbol") " "
     (STRONG "expansion") EOL1 "=> " (STRONG "symbol"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - シンボル" EOL1 (STRONG "expansion")
     " - フォーム")
    (CHAPTER ("## 定義") 2 "シンボル" (STRONG "symbol") "について、" "グローバルに影響するマクロ展開の仕組みを提供します。"
     EOL2 (STRONG "symbol") "という名前のシンボルマクロの" "展開関数をグローバルに確立します。" EOL2 "シンボルマクロの展開関数は、"
     "ただフォームと環境が適用されたときに" "正しい展開を返すことが保証されています。" "（特に展開が概念的に、展開関数か環境かその両方かの、"
     "どこに保存されるのかは実装依存です）" EOL2 "各グローバル下で参照される" (STRONG "symbol") "は" "（ただし、同じ名前"
     (STRONG "symbol") "の変数かシンボルマクロの" "束縛によってシャドウされていないとき）、" "通常のマクロ展開処理が行われます。"
     "3.1.2.1.1. フォームとしてのシンボルをご確認ください。" "シンボルマクロの展開は、通常のマクロと同様に、"
     "シンボルマクロの参照先と同じレキシカル環境において、" "さらにマクロ展開が行われます。" EOL2 "もしこの" (STRONG "symbol") "の定義"
     "（ただし、同じ名前" (STRONG "symbol") "の変数かシンボルマクロの" "束縛によってシャドウされていないとき）のスコープ内で"
     (CODE1 "special") "宣言が行われたときの結果は未定義です。" EOL2 "この定義のスコープ内で" (CODE1 "setq") "を使って"
     (STRONG "symbol") "に値をセットしたときは、" "それは" (CODE1 "setf") "を使ったかのように扱われます。"
     (CODE1 "psetq") "での" (STRONG "symbol") "は、" (CODE1 "psetf") "のように扱われ、"
     (CODE1 "multiple-value-setq") "は" (CODE1 "setf") "の" (CODE1 "values") "のように扱われます。"
     EOL2 "シンボルマクロの束縛は、" (CODE1 "let") "と" (CODE1 "symbol-macrolet") "によってシャドウされます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defvar *things* (list 'alpha 'beta 'gamma)) =>  *THINGS*"
      NIL "(define-symbol-macro thing1 (first *things*)) =>  THING1"
      "(define-symbol-macro thing2 (second *things*)) =>  THING2"
      "(define-symbol-macro thing3 (third *things*)) =>  THING3" NIL "thing1 =>  ALPHA"
      "(setq thing1 'ONE) =>  ONE" "*things* =>  (ONE BETA GAMMA)"
      "(multiple-value-setq (thing2 thing3) (values 'two 'three)) =>  TWO"
      "thing3 =>  THREE" "*things* =>  (ONE TWO THREE)" NIL
      "(list thing2 (let ((thing2 2)) thing2)) =>  (TWO 2)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "symbol") "がすでにグローバル変数として定義されていたときは、" "型"
     (CODE1 "program-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "symbol-macrolet") "," (CODE1 "macroexpand"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DEFINE-SYMBOL-MACRO" . "MACRO") *table*) (gethash "DEFINE-SYMBOL-MACRO" *table*))
(setf (gethash "DEFMACRO" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFMACRO"))
    (CHAPTER ("## 構文") 2 (CODE1 "defmacro") " " (STRONG "name") " "
     (STRONG "lambda-list") " [[" (STRONG "declaration\\*") " " (CODE1 "|") " "
     (STRONG "documentation") "]] " (STRONG "form\\*") EOL1 "=> " (STRONG "name"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - シンボル" EOL1 (STRONG "lambda-list")
     " - マクロラムダリスト" EOL1 (STRONG "declaration") " - 宣言式。評価されません。" EOL1
     (STRONG "documentation") " - 文字列。評価されません。" EOL1 (STRONG "form") " - フォーム")
    (CHAPTER ("## 定義") 2 "グローバル環境下において、" (STRONG "name") "という名前のマクロ関数を、" (STRONG "name")
     "というマクロとして定義します。" "そのマクロ関数は、" (CODE1 "defmacro") "が現れたところと同じ" "レキシカルな環境で定義されます。"
     EOL2 (STRONG "lambda-list") "のパラーメーターの変数は、" "マクロが呼ばれた部分を分配して束縛します。" EOL2
     "展開関数はフォームと環境の2つの引数を受け付けます。" "展開関数はフォームを返却します。" "展開関数のボディ部は、" (STRONG "form")
     "によって指定されます。" (STRONG "form") "は順に実行されます。" "最後の" (STRONG "form")
     "が実行された値が、マクロ展開としての返却値になります。" "展開関数のボディ部である" (STRONG "form") "は（ただし"
     (STRONG "lambda-list") "は除く）、" "暗黙的に" (STRONG "name") "という" (CODE1 "block")
     "に囲まれます。" EOL2 (STRONG "lambda-list") "は3.4.4. マクロのラムダリストに記載されている要求に準拠します。" EOL2
     (STRONG "documentation") "は、ドキュメント文字として種別" (CODE1 "function") "を" "そのマクロ関数に割り当てます。"
     EOL2 (CODE1 "defmacro") "はマクロの再定義に使われますし、" "関数定義をマクロ定義に置き換えることにも使われます。" EOL2
     (STRONG "form") "の展開は再帰的に行われ、" "返却されたフォームのサブフォームにある" "他のマクロの展開も含めてから終了させなければなりません。"
     EOL2 "マクロを完全に展開した結果に" "リテラルオブジェクト以外の循環リスト構造が含まれていた時の" "結果は未定義です。" EOL2 "もし"
     (CODE1 "defmacro") "フォームがトップレベルフォームとして現れたときは、"
     "コンパイラは、そのファイルの後でマクロが呼ばれたときに展開が行われるよう、" "マクロ定義を保存しなければなりません。" EOL2
     "もしコンパイルされたファイル内でそのマクロが参照されたときは、" "ユーザーは、コンパイル時にマクロ本体を評価できるよう" "保証しなければなりません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defmacro mac1 (a b) \"Mac1 multiplies and adds\" "
      "           `(+ ,a (* ,b 3))) =>  MAC1 " "(mac1 4 5) =>  19 "
      "(documentation 'mac1 'function) =>  \"Mac1 multiplies and adds\" "
      "(defmacro mac2 (&optional (a 2 b) (c 3 d) &rest x) `'(,a ,b ,c ,d ,x)) =>  MAC2 "
      "(mac2 6) =>  (6 T 3 NIL NIL) " "(mac2 6 3 8) =>  (6 T 3 T (8)) "
      "(defmacro mac3 (&whole r a &optional (b 3) &rest x &key c (d a))"
      "   `'(,r ,a ,b ,c ,d ,x)) =>  MAC3 "
      "(mac3 1 6 :d 8 :c 9 :d 10) =>  ((MAC3 1 6 :D 8 :C 9 :D 10) 1 6 9 8 (:D 8 :C 9 :D 10)) ")
     EOL2 "通常のラムダリスト構文の" "リストではなくパラメーター名が現れる場所に" "分割のラムダリストを埋め込むことができます。"
     "この規則は曖昧性を防ぐために存在します。" "例えば、次の例文は正しくありません。"
     (CODE3 "```lisp" "```" "(defmacro loser (x &optional (a b &rest c) &rest z)"
      "   ...)")
     EOL2 "なぜなら通常のラムダリストの構文は、" (CODE1 "&optional") "の後にリストを許容するからです。" "リストである"
     (CODE1 "(a b &rest c)") "は、" "オプション引数の名前" (CODE1 "a") "と、デフォルト値が" (CODE1 "b") "、"
     (CODE1 "supplied-p") "パラメーターが" (CODE1 "&rest") "（正しくありません）、" "そして余分なシンボル"
     (CODE1 "c") "（これも正しくありません）として解釈されます。" "下記の例もまた正しくありません。"
     (CODE3 "```lisp" "```" "(defmacro loser (x &optional ((a b &rest c)) &rest z)"
      "   ...)")
     EOL2 "余分なカッコをセットしたことにより、曖昧性はなくなりました。" "しかし、この定義は今でも正しくはなく、" "なぜなら"
     (CODE1 "(loser (car pool))") "のようなマクロ呼び出しのときに、" "ラムダリストの" (CODE1 "(a b &rest c)")
     "フォームの各引数に何も与えるものはなく、" "明にデフォルト引数が与えられていないため、" "そのデフォルトに" (CODE1 "nil") "をラムダリストに"
     "マッチさせようとするからです。" "フォームを持っていない空リスト" (CODE1 "nil") "を" "パラメーター" (CODE1 "a") "と"
     (CODE1 "b") "に対して満たそうとしたときの結果は指定されていません。" "完全に正しい定義は次のどちらかになります。"
     (CODE3 "```lisp" "```"
      "(defmacro loser (x &optional ((a b &rest c) '(nil nil)) &rest z)" "  ...)")
     EOL2 "あるいは、"
     (CODE3 "```lisp" "```"
      "(defmacro loser (x &optional ((&optional a b &rest c)) &rest z)" "  ...)")
     EOL2 "これらは微妙に違っています。" "最初の定義は、もしマクロ呼び出しで" (CODE1 "a") "が明に指定されたら、" (CODE1 "b")
     "もまた明に指定しなければならないと要求しています。" "それに対して二番目の定義は、そのような共有はありません。" "例えば、"
     (CODE3 "```lisp" "```" "(loser (car pool) ((+ x 1)))") EOL2
     "この式は二番目の定義では正しい呼び出しですが、" "最初の方はそうではありません。"
     (CODE3 "```lisp" "```" "(defmacro dm1a (&whole x) `',x)"
      "(macroexpand '(dm1a))  =>  (QUOTE (DM1A))" "(macroexpand '(dm1a a)) is an error."
      NIL "(defmacro dm1b (&whole x a &optional b) `'(,x ,a ,b))"
      "(macroexpand '(dm1b))  is an error."
      "(macroexpand '(dm1b q))  =>  (QUOTE ((DM1B Q) Q NIL))"
      "(macroexpand '(dm1b q r)) =>  (QUOTE ((DM1B Q R) Q R))"
      "(macroexpand '(dm1b q r s)) is an error."
      "(defmacro dm2a (&whole form a b) `'(form ,form a ,a b ,b))"
      "(macroexpand '(dm2a x y)) =>  (QUOTE (FORM (DM2A X Y) A X B Y))"
      "(dm2a x y) =>  (FORM (DM2A X Y) A X B Y)" NIL
      "(defmacro dm2b (&whole form a (&whole b (c . d) &optional (e 5)) "
      "                &body f &environment env)"
      "  ``(,',form ,,a ,',b ,',(macroexpand c env) ,',d ,',e ,',f))"
      ";バッククォートが実行されるので、実装はわずかに本質的に違う式" ";（しかし機能的にはそうではない）を展開することに注意してくださ。"
      "(macroexpand '(dm2b x1 (((incf x2) x3 x4)) x5 x6))"
      "=>  (LIST* '(DM2B X1 (((INCF X2) X3 X4))" "                  X5 X6)"
      "           X1"
      "           '((((INCF X2) X3 X4)) (SETQ X2 (+ X2 1)) (X3 X4) 5 (X5 X6)))," "    T"
      "(let ((x1 5))" "  (macrolet ((segundo (x) `(cadr ,x)))"
      "    (dm2b x1 (((segundo x2) x3 x4)) x5 x6)))"
      "=>  ((DM2B X1 (((SEGUNDO X2) X3 X4)) X5 X6)"
      "     5 (((SEGUNDO X2) X3 X4)) (CADR X2) (X3 X4) 5 (X5 X6))"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "define-compiler-macro") "," (CODE1 "destructuring-bind")
     "," (CODE1 "documentation") "," (CODE1 "macroexpand") ","
     (CODE1 "*macroexpand-hook*") "," (CODE1 "macrolet") "," (CODE1 "macro-function") ","
     "3.1. 評価," "3.2. コンパイル," "3.4.11. ドキュメント文字と宣言の文脈的な作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DEFMACRO" . "MACRO") *table*) (gethash "DEFMACRO" *table*))
(setf (gethash "DEFMETHOD" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFMETHOD"))
    (CHAPTER ("## 構文") 2 (CODE1 "defmethod") " " (STRONG "function-name") " "
     (STRONG "method-qualifier\\*") " " (STRONG "specialized-lambda-list") " [["
     (STRONG "declaration\\*") " " (CODE1 "|") " " (STRONG "documentation") "]] "
     (STRONG "form\\*") EOL1 "=> " (STRONG "new-method")
     (CODE3 "```" "```" "function-name ::= {symbol | (setf symbol)}" NIL
      "method-qualifier ::= non-list" NIL "specialized-lambda-list ::="
      "  ({var | (var parameter-specializer-name)}*"
      "   [&optional {var | (var [initform [supplied-p-parameter] ])}*]" "   [&rest var]"
      "   [&key {var | ({var | (keywordvar)} [initform [supplied-p-parameter]])}*"
      "         [&allow-other-keys] ]" "   [&aux {var | (var [initform] )}*])" NIL
      "parameter-specializer-name ::= symbol | (eql eql-specializer-form)"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "declaration") " - 宣言の式。評価はされません。" EOL1
     (STRONG "documentation") " - 文字列。評価はされません。" EOL1 (STRONG "var") " - 変数名" EOL1
     (STRONG "eql-specializer-form") " - フォーム" EOL1 (STRONG "form") " - フォーム" EOL1
     (STRONG "initform") " - フォーム" EOL1 (STRONG "supplied-p-parameter") " - 変数名" EOL1
     (STRONG "new-method") " - 新しいメソッドオブジェクト")
    (CHAPTER ("## 定義") 2 "マクロ" (CODE1 "defmethod") "は、ジェネリック関数にメソッドを定義します。" EOL2 "もし"
     (CODE1 "(fboundp function-name)") "が" (CODE1 "nil") "のときは、"
     "ジェリック関数は次のような設定で作成されます。" "デフォルトの引数の優先順位オーダー（各引数は左が右より特定的）、" "ジェネリック関数クラスは"
     (CODE1 "standard-generic-function") "、" "メソッドグラスは" (CODE1 "standard-method") "、"
     "そしてmethod-combinationは" (CODE1 "standard") "です。"
     "ジェネリック関数のラムダリストは、定義されるメソッド関数のラムダリストと合致します。" "もし" (CODE1 "defmethod")
     "フォームのキーワード引数があるときは、" "ジェネリック関数のラムダリストに" (CODE1 "&key") "があります"
     "（ただしキーワード引数自体はありません）。" "もし" (STRONG "function-name") "が通常の関数か、マクロか、"
     "特殊オペレーターの名前の場合はエラーが発生します。" EOL2 "もしジェネリック関数が現に" (STRONG "function-name")
     "という名前であるとき、" "メソッドのラムダリストがそのジェネリック関数のラムダリストと合致します。" "もしこの状態が保持できないときは、エラーが発せられます。"
     "この文脈の合致についての定義は、7.6.4. ジェネリック関数の全てのメソッドのラムダリストの合意をご確認ください。" EOL2 "各"
     (STRONG "method-qualifier") "の引数は、" "メソッドを識別するためにmethod-combinationで使用されるオブジェクトです。"
     "method-combinationタイプは、メソッドの修飾子でできることを" "さらに制限するかもしれません。" (CODE1 "standard")
     " method-combinationタイプは、" "修飾子のないメソッドと、" (CODE1 ":before") ", " (CODE1 ":after")
     ", " (CODE1 ":around") "いずれかのキーワードの" "単体の修飾子を使用することができます。" EOL2 "引数"
     (STRONG "specialized-lambda-list") "は、通常のラムダリストと似ていますが、"
     "要求パラメーターを特化したパラメーターに置き換えることができます。" "特化したパラメーターは"
     (CODE1 "(var parameter-specializer-name)") "形式のリストです。" "ただ要求パラメーターだけが特定化できます。" "もし、"
     (STRONG "parameter-specializer-name") "がシンボルのときは、クラスの名前です。" "もしリストの場合は、"
     (CODE1 "(eql eql-specializer-form)") "の形式になります。"
     (STRONG "parameter-specializer-name") "が" (CODE1 "(eql eql-specializer-form)")
     "形式のときは、" "対応する引数が" (STRONG "eql-specializer-form") "の値のオブジェクトと、" (CODE1 "eql")
     "で一致しなければメソッドが適用できないことを意味します。" "要求パラメーターに" (STRONG "parameter-specializer-name")
     "がない場合は、" "標準の値としてクラス" (CODE1 "t") "が与えられます。" "さらなる詳細については、7.6.2. メソッドの紹介をご確認ください。"
     EOL2 "引数" (STRONG "form") "は、メソッドのボディ部です。" "メソッドのボディ部は、暗黙の" (CODE1 "block")
     "で囲まれます。" "もし" (STRONG "function-name") "がシンボルのとき、" (CODE1 "block")
     "の名前はジェネリック関数と同じ名前です。" "もし" (STRONG "function-name") "が" (CODE1 "(setf symbol)")
     "のリスト形式の場合は、" (CODE1 "block") "の名前は" (STRONG "symbol") "です。" EOL2
     "作成されるメソッドオブジェクトのクラスは、" "メソッドを定義するジェネリック関数の" "メソッドクラスオプションで指定されたものです。" EOL2
     "もしジェネリック関数が、特定化されたパラメーターと修飾子が" "合致しているメソッドをすでに持っている場合は、" (CODE1 "defmethod")
     "は既存のメソッドを定義された現在のものに置き換えます。" EOL2 "特定化されたパラメーターについては、"
     "7.6.2. メソッドの紹介で説明したように特定パラメーター名から派生します。" EOL2 "マクロ" (CODE1 "defmethod")
     "の展開は、各特化したパラメーターを" (STRONG "") "参照" (STRONG "") "します" "（" (CODE1 "declare") "の定義の"
     (CODE1 "ignore") "の定義を参照してください）。" "これは、特定化するパラメーター名を" "明に" (CODE1 "t")
     "とした場合も含まれます。" "つまり、メソッド本体で特化したパラメーターが参照されない場合でも" "コンパイラーは警告を出力しませんが、"
     "メソッド本体で特化したパラメーターではない" "パラメーターが参照されない場合は警告を発します。" "このため、" (CODE1 "t")
     "を特定化したパラメーターは、" "特化したパラメーターではないパラメーターと" "文脈的に同一ではありません。" EOL2 "メソッド本体の先頭にある宣言で、"
     "メソッドのラムダリストの変数に適用されるものは、" "束縛に対応するものと同じスコープを持つ宣言として扱われます。" EOL2 "メソッド本体の先頭にある宣言で、"
     (CODE1 "call-next-method") "と" (CODE1 "next-method-p") "に束縛されてる関数への適用は、"
     "メソッドのボディ部内でのそれらの関数の参照に適用されます。" "外側で行われる" (CODE1 "call-next-method") "と"
     (CODE1 "next-method-p") "の" "どのような束縛についても、" "またそれらの束縛に関連付けられる宣言に対しても、"
     "メソッドのボディ部内では隠蔽されます。" EOL2 "メソッド本体の先頭にある自由形式の宣言の範囲は" "メソッドのボディ部全体であり、"
     "それは暗黙のローカル関数の定義も含まれます。" "しかしラムダリストの変数の初期化フォームは除外されます。" EOL2 (CODE1 "defmethod")
     "は、コンパイル時にはどのような副作用も要求されていません。" "特に、コンパイル時に呼び出すためのメソッドは導入されません。"
     "実装者は、コンパイル時のエラーチェック" "（関数呼び出し時の引数の個数チェックであったり、" "あるいは関数名の定義を確認したりすること）のために、"
     "ジェネリック関数についての情報を保存するか選択できます。" EOL2 (STRONG "documentation")
     "は、メソッドオブジェクトにドキュメント文字を割り当てます。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "参照されるジェネリック関数の定義")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "function-name") "が通常の関数か、マクロか、" "特殊オペレーターの名前の場合は、"
     "型" (CODE1 "error") "のエラーが発生します。" EOL2 "もしジェネリック関数が現に" (STRONG "function-name")
     "という名前であるとき、" "メソッドのラムダリストがそのジェネリック関数のラムダリストと合致します。" "もしこの状態が保持できないときは、" "型"
     (CODE1 "error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "defgeneric") "," (CODE1 "documentation") ","
     "7.6.2. メソッドの紹介," "7.6.4. ジェネリック関数の全てのメソッドのラムダリストの合意," "7.6.3. 特定パラメーターと修飾子の合致,"
     "3.4.11. ドキュメント文字と宣言の文脈的な作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DEFMETHOD" . "MACRO") *table*) (gethash "DEFMETHOD" *table*))
(setf (gethash "DEFPACKAGE" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFPACKAGE"))
    (CHAPTER ("## 構文") 2 (CODE1 "defpackage") " " (STRONG "defined-package-name") " [["
     (STRONG "option") "]] => " (STRONG "package")
     (CODE3 "```" "```" "option::= (:nicknames nickname*)* |  "
      "          (:documentation string) |  " "          (:use package-name*)* |  "
      "          (:shadow {symbol-name}*)* |  "
      "          (:shadowing-import-from package-name {symbol-name}*)* |  "
      "          (:import-from package-name {symbol-name}*)* |  "
      "          (:export {symbol-name}*)* |  " "          (:intern {symbol-name}*)* |  "
      "          (:size integer) "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "defined-package-name") " - 文字列指定子" EOL1
     (STRONG "package-name") " - パッケージ指定子" EOL1 (STRONG "nickname") " - 文字列指定子" EOL1
     (STRONG "symbol-name") " - 文字列指定子" EOL1 (STRONG "package") " - "
     (STRONG "package-name") "という名前のパッケージ")
    (CHAPTER ("## 定義") 2 (CODE1 "defpackage") "は指定されたパッケージを作成し、" "そのパッケージを返却します。" EOL2
     "もし" (STRONG "defined-package-name") "がすでに存在しているパッケージを示していたら、"
     "その名前とパッケージのマッピングの対応は変更されません。" "もし新しい定義がパッケージの現在の状況と変わっていたときは、" "その結果は定義されていません。"
     "実装によっては、新しい定義を反映するよう、" "既存のパッケージを修正するか選択するかもしれません。" "もし"
     (STRONG "defined-package-name") "がシンボルのときは、その名前が使われます。" EOL2 "標準のオプションを下記に示します。"
     EOL2 "- " (CODE1 ":nicknames") "  - " (CODE1 ":nicknames")
     "の引数はパッケージのニックネームに指定した名前をセットします。" "    <br><br>" EOL2 "- " (CODE1 ":documentation")
     "  - " (CODE1 ":documentation") "の引数は、ドキュメント文字を指定します。"
     "    それはパッケージのドキュメント文字に割り当てます。" "    ひとつの" (CODE1 "defpackage") "フォームに" "    最大ひとつの"
     (CODE1 ":documentation") "オプションを記載することができます。" "    <br><br>" EOL2 "- "
     (CODE1 ":use") "  - " (CODE1 ":use") "引数は、" (STRONG "package-name")
     "という名前のパッケージが継承するように、" "    パッケージに対して設定を行います。" "    <br><br>" EOL2 "- "
     (CODE1 ":shadow") "  - " (CODE1 ":shadow") "引数は、" (STRONG "symbol-names")
     "という名前のシンボルを" "    パッケージ内に作成するように定義します。" "    それらのシンボルは、" (CODE1 "shadow")
     "によるもののように" "    効果的に" (CODE1 "shadowing") "シンボルのリストに追加されます。" "    <br><br>" EOL2
     "- " (CODE1 ":shadowing-import-from") "  - 引数の" (STRONG "symbol-names")
     "によって名前が付いたシンボルを" "    指定した" (STRONG "package-name") "内に探します" "    （"
     (CODE1 "find-symbol") "によるもののように検索が実行されます）。" "    その結果のシンボルがそのパッケージ内に"
     (CODE1 "import") "されるように定義し、" "    " (CODE1 "shadowing-import") "によるもののように" "    "
     (CODE1 "shadowing") "シンボルのリストに配置されます。" "    <br><br>" EOL2 "- "
     (CODE1 ":import-from") "  - 引数の" (STRONG "symbol-names") "によって名前が付いたシンボルを" "    "
     (STRONG "package-name") "という名前のパッケージ内から探し、" "    それらが定義しているパッケージに" (CODE1 "import")
     "されます。" "    どのような場合でも、定義されているパッケージ以外の" "    パッケージでシンボルを作成してはいけません。" "    <br><br>"
     EOL2 "- " (CODE1 ":export") "  - 引数の" (STRONG "symbol-names") "によって名前が付いたシンボルを"
     "    " (STRONG "package-name") "という名前のパッケージ内から探すか、" "    あるいは定義しているパッケージに作成し、それを"
     (CODE1 "export") "します。" "    継承されるシンボルが作成されるのではなく使用されるとき、" "    " (CODE1 ":export")
     "オプションは" (CODE1 ":use") "オプションと互いに作用します。" "    " (CODE1 "import")
     "されるシンボルが作成されるのではなく使用されるとき、" "    " (CODE1 ":export") "オプションは"
     (CODE1 ":import-from") "および" "    " (CODE1 "shadowing-import-from")
     "オプションと互いに作用します。" "    もし" (CODE1 ":export") "オプションの引数が" "    "
     (CODE1 "use-package") "によって（継承された）内部シンボルとして" "    アクセス可能であるとき、" "    "
     (STRONG "symbol-name") "という名前のシンボルは、" "    最初に定義されているパッケージに" (CODE1 "import") "され、"
     "    そのあとそのパッケージから" (CODE1 "export") "されます。" "    <br><br>" EOL2 "- "
     (CODE1 ":intern") "  - 引数の" (STRONG "symbol-names") "によって名前が付いたシンボルを" "    "
     (STRONG "package-name") "という名前のパッケージ内から探すか、" "    あるいは定義しているパッケージに作成します。"
     "    継承されるシンボルが作成されるのではなく使用されるとき、" "    " (CODE1 ":intern") "オプションは" (CODE1 ":use")
     "オプションと互いに作用します。" "    <br><br>" EOL2 "- " (CODE1 ":size") "  - " (CODE1 ":size")
     "オプションの引数は、予想されるパッケージ内の" "    シンボルの数の近似値を宣言します。"
     "    これはただの効率化のヒントであり、実装によっては無視されるかもしれません。" "    <br><br>" EOL2 (CODE1 "defpackage")
     "フォームに現れるオプションの順番は無関係です。" "それらが実行される順番は下記のようになります。" EOL2 "1. " (CODE1 ":shadow") "と"
     (CODE1 ":shadowing-import-from") "2. " (CODE1 ":use") "3. " (CODE1 ":import-from")
     "と" (CODE1 ":intern") "4. " (CODE1 ":export") EOL2 (CODE1 ":use") "オプションが処理されるときに"
     "衝突による偽りの名前をブロックする必要があるため、" "最初に" (CODE1 "shadow") "を確立させます。" (CODE1 ":use")
     "オプションが次に実行されるので、" (CODE1 ":intern") "と" (CODE1 ":export")
     "オプションが継承されたシンボルを普通に参照できます。" (CODE1 ":export") "オプションが最後に実行されるとき、"
     "それは他のオプションの何かによって作成された" "シンボルを参照することができます。" "とくに" (CODE1 "shadowing") "シンボルと"
     (CODE1 "import") "シンボルを" "外部シンボルにすることができます。" EOL2 "もし" (CODE1 "defpackage")
     "フォームがトップレベルフォームとして現れたとき、" "ロード時にこのマクロによって実行される全ての通常のアクションは、"
     "コンパイル時にもまた実行されなければいけません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defpackage \"MY-PACKAGE\""
      "  (:nicknames \"MYPKG\" \"MY-PKG\")" "  (:use \"COMMON-LISP\")"
      "  (:shadow \"CAR\" \"CDR\")"
      "  (:shadowing-import-from \"VENDOR-COMMON-LISP\"  \"CONS\")"
      "  (:import-from \"VENDOR-COMMON-LISP\"  \"GC\")"
      "  (:export \"EQ\" \"CONS\" \"FROBOLA\")" "  )" " " " " "(defpackage my-package"
      "  (:nicknames mypkg :MY-PKG)  ; Common Lispの大文字小文字の慣習を思い出そう"
      "  (:use common-lisp)          ; シンボルの慣習"
      "  (:shadow CAR :cdr #:cons)                              "
      "  (:export \"CONS\")            ; これはshadowされる" "  )"))
    (CHAPTER ("## 影響") 2 "存在するパッケージ")
    (CHAPTER ("## 例外") 2 (CODE1 ":nicknames") "で指定したひとつが" "すでに既存のパッケージで参照されていたときは、" "型"
     (CODE1 "package-error") "のエラーが発生します。" EOL2 "もし" (CODE1 ":size") "か"
     (CODE1 ":documentation") "が複数現れていたときは" "型" (CODE1 "program-error") "のエラーが発生します。"
     EOL2 "実装が拡張のオプションを許すとき、" "あるオプションが実際にはその実装でサポートされていないものとして現れたとき、" "型"
     (CODE1 "program-error") "のエラーが発生します。" EOL2 "オプションの" (CODE1 ":shadow") ", "
     (CODE1 ":intern") ", " (CODE1 ":import-from") ", " (CODE1 ":shadowing-import-from")
     "に" "指定された" (STRONG "symbol-name") "引数の集まりは、" "全てが互いに素でなければいけません。" "加えて、"
     (CODE1 ":export") "と" (CODE1 ":intern") "のに指定された" (STRONG "symbol-name") "引数は"
     "互いに素でなければいけません。" EOL2 "この文脈での互いに素というのは、" "2つの" (STRONG "symbol-names") "が互いに"
     (CODE1 "string=") "で" "等しくないものとして定義されます。" "このどちらかの条件に違反していたときは、" "型"
     (CODE1 "program-error") "のエラーが発生します。" EOL2 (CODE1 ":shadowing-import-from") "と"
     (CODE1 ":import-from") "オプションについて、" (STRONG "package-name") "という名前のパッケージに" "引数"
     (STRONG "symbol-names") "のうちのひとつが" "アクセス可能なシンボルではないとき、" "修正可能な型"
     (CODE1 "package-error") "のエラーが発生します。" EOL2 "名前の衝突エラーは、" (CODE1 "make-package") ", "
     (CODE1 "use-package") ", " (CODE1 "import") ", " (CODE1 "export") "の"
     "基本的な呼び出しによって捕捉されます。" "11.1. パッケージの説明をご確認ください。")
    (CHAPTER ("## 参考") 2 (CODE1 "documentation") "," "11.1. パッケージの説明," "3.2. コンパイル")
    (CHAPTER ("## 備考") 2 "いくつかの他のパッケージの作成に続く" (CODE1 "defpackage") "の呼び出しで、"
     (CODE1 ":import-from") "か" (CODE1 ":shadowing-import-from") "オプションを用いて"
     "それらのシンボルをアクセス可能な状態にしたいものの" "外部シンボルにする必要はないときは、" (CODE1 ":intern") "オプションが便利です。"
     EOL2 "パッケージの全体の定義を一か所に配置し、" "全てのパッケージの定義のプログラムを" "ひとつのファイルにしたいとき"
     (CODE1 "defpackage") "の使用をお勧めします。" "このファイルは、" "これらのパッケージに依存する他の何かを"
     "ロードしたりコンパイルしたりする前に" "ロードすることができます。" "このようなファイルは" " 初期状態の異常を回避するために、"
     (CODE1 "COMMON-LISP-USER") "パッケージで読み込むことができます。" EOL2 (CODE1 "defpackage")
     "は、2つの「互いに再帰的」なパッケージを" "作成するときには使えません。" "例えば次の通り。"
     (CODE3 "```lisp" "```" "(defpackage my-package"
      "  (:use common-lisp your-package)    ;最初にyour-packageの存在が必要"
      "  (:export \"MY-FUN\"))                " "(defpackage your-package"
      "  (:use common-lisp)"
      "  (:import-from my-package \"MY-FUN\") ;最初にmy-packageの存在が必要"
      "  (:export \"MY-FUN\"))")
     EOL2 "しかし、" (CODE1 "defpackage") "をより標準的に使ったあとで、" (CODE1 "use-package") "、"
     (CODE1 "import") "、" (CODE1 "export") "などの" "パッケージに影響を与える関数を使って、"
     "そのようなリンクを確立することを妨げるものは何もありません。" EOL2 (CODE1 "defpackage") "のマクロ展開は、"
     "通常は名前を文字列に正規化するので、" "ソースファイルにランダムなシンボルが含まれる" (CODE1 "defpackage") "フォームが"
     "配置されているようなときでさえ、" "コンパイルファイルにはただ文字列だけが配置されます。" EOL2 "よく追加で実装依存のオプションに、"
     "キーワードそれ自身のフォームで" (CODE1 "(keyword T)") "という" "リストの省略形を表すことがあります。"
     "この構文は、これをサポートしていない実装では、" "認識できないオプションとして適切に報告されるべきです。")))
(setf (gethash '("DEFPACKAGE" . "MACRO") *table*) (gethash "DEFPACKAGE" *table*))
(setf (gethash "DEFPARAMETER" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFPARAMETER"))
    (CHAPTER ("## 構文") 2 (CODE1 "defparameter") " " (STRONG "name") " "
     (STRONG "initial-value") " [" (STRONG "documentation") "] => " (STRONG "name") EOL1
     (CODE1 "defvar") " " (STRONG "name") " [" (STRONG "initial-value") " ["
     (STRONG "documentation") "]] => " (STRONG "name"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - シンボル、評価されません。" EOL1
     (STRONG "initial-value") " - フォーム。" (CODE1 "defparameter") "は常に評価されます。" "しかし"
     (CODE1 "defvar") "は" (STRONG "name") "が" (CODE1 "bound") "ではないときのみ評価されます。" EOL1
     (STRONG "documentation") " - 文字列、評価されません。")
    (CHAPTER ("## 定義") 2 (CODE1 "defparameter") "と" (CODE1 "defvar") "は、" (STRONG "name")
     "を動的変数として確立します。" EOL2 (CODE1 "defparameter") "は、" (STRONG "name") "という動的変数に"
     (STRONG "initial-value") "を" "無条件に割り当てます。" "対称的に" (CODE1 "defvar") "は"
     (STRONG "name") "という変数が" (CODE1 "bound") "ではない場合において、" "与えられた"
     (STRONG "initial-value") "の値を割り当てます。" EOL2 (STRONG "initial-value") "が与えられなかったときは、"
     (CODE1 "defvar") "は" (STRONG "name") "の動的変数に手を加えず" "値のセルをそのままにします。" "もし"
     (STRONG "name") "が前に" (CODE1 "bound") "のときは古い値のままにしますし、" "以前の値が" (CODE1 "unbound")
     "であったときは" (CODE1 "unbound") "のままにします。" EOL2 (STRONG "documentation") "が与えられたときは、"
     (STRONG "name") "に対してドキュメント文字を種別" (CODE1 "variable") "として割り当てます。" EOL2
     (CODE1 "defparameter") "と" (CODE1 "defvar") "は通常トップレベルフォームに現れますが、"
     "非トップレベルフォームに現れても意味があります。" "しかし、下記で説明するコンパイル時の副作用は、" (CODE1 "defconstant")
     "がトップレベルフォームとして現れた場所でのみ" "効果があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defparameter *p* 1) =>  *P*" "*p* =>  1"
      "(constantp '*p*) =>  false" "(setq *p* 2) =>  2" "(defparameter *p* 3) =>  *P*"
      "*p* =>  3" NIL "(defvar *v* 1) =>  *V*" "*v* =>  1" "(constantp '*v*) =>  false"
      "(setq *v* 2) =>  2" "(defvar *v* 3) =>  *V*" "*v* =>  2" NIL "(defun foo ()"
      "  (let ((*p* 'p) (*v* 'v))" "    (bar))) =>  FOO"
      "(defun bar () (list *p* *v*)) =>  BAR" "(foo) =>  (P V)")
     EOL2 (CODE1 "defparameter") "と" (CODE1 "defvar") "の主な操作上の違いは、"
     (CODE1 "defparameter") "は" (STRONG "name") "に無条件にアサインするのに対して、" (CODE1 "defvar")
     "は条件付きでそれを行うことにあります。" "実際にこれらは" (CODE1 "defparameter") "はロードやリロード時に"
     "定義で新しい値を変数に設定するときに便利ですし、" (CODE1 "defvar") "の場合はファイルのロードやリロード時に"
     "古い値をそのままにしておきたいときに便利です。" "例として、次のような内容のファイルを示します。"
     (CODE3 "```lisp" "```" "(defvar *the-interesting-numbers* '())"
      "(defmacro define-interesting-number (name n)" "  `(progn (defvar ,name ,n)"
      "          (pushnew ,name *the-interesting-numbers*)" "          ',name))"
      "(define-interesting-number *my-height* 168) ;cm"
      "(define-interesting-number *my-weight* 13)  ;stones")
     EOL2 "この" (CODE1 "*the-interesting-numbers*") "の初期値" (CODE1 "()") "はただの種であり、"
     "一度そこから何かを育てたあとは" "他の何かリセットすることはないでしょう。" "そのため、" (CODE1 "defvar") "を使うことで、"
     "ファイルを二回読み込んだときに" (CODE1 "*interesting-numbers*") "の情報が" "リセットされないようにしています。" "確かに"
     (CODE1 "define-interesting-number") "の" "二回の呼び出しは処理されますが、"
     "しかし他のファイルで追加の呼び出しがあったときは" "その情報が損失することはありません。" "一方、次のコードを見てみます。"
     (CODE3 "```lisp" "```" "(defparameter *default-beep-count* 3)"
      "(defun beep (&optional (n *default-beep-count*))"
      "  (dotimes (i n) (si:%beep 1000. 100000.) (sleep 0.1)))")
     EOL2 "ここでは、コードを編集して" (CODE1 "*default-beep-count*") "の初期値を変更し、"
     "ファイルをリロードして新しい値を取得する" "ということを簡単に想像できます。" "値の更新を簡単にするために" (CODE1 "defparameter")
     "を使用しました。" EOL2 "一方で、このような状況で" (CODE1 "defvar") "を使うことは潜在的な価値があります。" "例えば、誰かが事前に"
     (CODE1 "*default-beep-count*") "の違う値を定義していたとします。"
     "あるいは、ファイルを読み込んでからその値を手動で変更したとします。" "どちらの場合でも、" (CODE1 "defparameter") "のかわりに"
     (CODE1 "defvar") "を使用していれば、" "ファイルのロード・リロードを行っても" "それらのユーザーの好みは上書きされることはありません。" EOL2
     (CODE1 "defvar") "と" (CODE1 "defparameter") "のどちらを選んでも、" "プログラムには目に見える結果をもたらしますが、"
     "それにもかかわらず主観的な理由で選択されることがあります。")
    (CHAPTER ("## 副作用") 2 "もし" (CODE1 "defvar") "か" (CODE1 "defparameter") "が"
     "トップレベルフォームとして現れたときは、" "コンパイラーは" (STRONG "name") "を" (CODE1 "special") "として"
     (CODE1 "proclaim") "されるよう" "認識しなければなりません。" "しかし、コンパイル時に" (STRONG "initial-value")
     "フォームが評価されたり、" (STRONG "name") "という動的変数に代入してはいけません。" EOL2 "適合するプログラムの正しい動作を妨げない限り、"
     "コンパイル時または実行時に、" "追加の（実装で定義された）副作用があってもかまいません。")
    (CHAPTER ("## 影響") 2 (CODE1 "defvar") "は、" (STRONG "name") "が" (CODE1 "bound")
     "であるかどうかに影響されます。")
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "declaim") "," (CODE1 "defconstant") ","
     (CODE1 "documentation") "," "3.2. コンパイル")
    (CHAPTER ("## 備考") 2 "慣習として動的変数の名前には" "始まりと終わりにアスタリスクを付けたものが使われます。" "例えば"
     (CODE1 "*foo*") "は良い動的変数の名前ですが、" "レキシカル変数には使われません。" (CODE1 "foo")
     "であれば良いレキシカル変数の名前になりますが、" "動的変数には使われません。" "この命名規則は、Common Lisp内に定義されたすべての名前で見られますが、"
     "適合するプログラムも適合する実装もこの規則を遵守する義務はありません。" EOL2 "追加で副作用が許可される理由は、"
     "実装がその定義に付随する通常の「帳簿管理」を行えるようにすることです。" "例えば、" (CODE1 "defvar") "と"
     (CODE1 "defparameter") "フォームのマクロ展開には、" "定義が記載されているソースファイルの名前を記録するためにアレンジした"
     "コードが含まれるかもしれません。" EOL2 (CODE1 "defparameter") "と" (CODE1 "defvar") "は下記のように定義されます。"
     (CODE3 "```lisp" "```" "(defmacro defparameter (name initial-value "
      "                        &optional (documentation nil documentation-p))"
      "  `(progn (declaim (special ,name))"
      "          (setf (symbol-value ',name) ,initial-value)"
      "          ,(when documentation-p"
      "             `(setf (documentation ',name 'variable) ',documentation))"
      "          ',name))" "(defmacro defvar (name &optional"
      "                       (initial-value nil initial-value-p)"
      "                       (documentation nil documentation-p))"
      "  `(progn (declaim (special ,name))" "          ,(when initial-value-p"
      "             `(unless (boundp ',name)"
      "                (setf (symbol-value ',name) ,initial-value)))"
      "          ,(when documentation-p"
      "             `(setf (documentation ',name 'variable) ',documentation))"
      "          ',name))"))))
(setf (gethash '("DEFPARAMETER" . "MACRO") *table*) (gethash "DEFPARAMETER" *table*))
(setf (gethash "DEFSETF" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFSETF"))
    (CHAPTER ("## 構文") 2 "短いフォーム:" EOL1 (CODE1 "defsetf") " " (STRONG "access-fn") " "
     (STRONG "update-fn") " [" (STRONG "documentation") "]" EOL1 "=> "
     (STRONG "access-fn") EOL2 "長いフォーム:" EOL1 (CODE1 "defsetf") " " (STRONG "access-fn")
     " " (STRONG "lambda-list") " (" (STRONG "store-variable\\*") ")" " [["
     (STRONG "declaration\\*") " " (CODE1 "|") " " (STRONG "documentation") "]] "
     (STRONG "form\\*") EOL1 "=> " (STRONG "access-fn"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "access-fn") " - 関数かマクロの名前のシンボル" EOL1
     (STRONG "update-fn") " - 関数かマクロの名前のシンボル" EOL1 (STRONG "lambda-list") " - "
     (CODE1 "defsetf") "ラムダリスト" EOL1 (STRONG "store-variable") " - シンボル（変数名）" EOL1
     (STRONG "declaration") " - 宣言式。評価されません。" EOL1 (STRONG "documentation")
     " - 文字列。評価されません。" EOL1 (STRONG "form") " - フォーム")
    (CHAPTER ("## 定義") 2 (CODE1 "defsetf") "は、比較的簡単な場合の" (CODE1 "place") "のフォーム"
     (CODE1 "(access-fn ...)") "を" "どのようにして" (CODE1 "setf") "で適用するか定義します"
     "（より一般的なアクセスの機能については、" (CODE1 "define-setf-expander") "をご確認下さい）。"
     (STRONG "access-fn") "という関数かマクロは、" "それらの引数の全てを評価しなければなりません。" EOL2 (CODE1 "defsetf")
     "は、「短いフォーム」、「長いフォーム」と呼ばれる" "2つのフォームのひとつを取ることができます。" "それらは2番目の引数の型によって区別されます。" EOL2
     "短いフォームを使うとき、" (STRONG "update-fn") "は関数かマクロの名前でなければならず、" "それは" (STRONG "access-fn")
     "よりひとつ多い引数を取ります。" "もし" (CODE1 "setf") "に与えられた" (CODE1 "place") "で"
     (STRONG "access-fn") "が呼ばれたとき、" (STRONG "access-fn") "へ与えられたすべての引数と"
     "最後の引数として新しい値を追加したものを" (STRONG "update-fn") "に指定して呼びし展開します" "（最後の新しい値は"
     (STRONG "update-fn") "によって返却する必要があります）。" EOL2 (CODE1 "defsetf") "の長いフォームは、"
     (CODE1 "defmacro") "に似ています。" (STRONG "lambda-list") "は" (STRONG "access-fn")
     "の引数を定義します。" (STRONG "store-variable") "は" (CODE1 "place") "へ格納する値か多値を定義します。"
     (STRONG "body") "は" (STRONG "access-fn") "の呼び出しの" (CODE1 "setf") "への展開を計算する必要があります。"
     "展開関数は" (CODE1 "defsetf") "フォームが現れたところと" "同じレキシカルな環境上で定義されます。" EOL2 (STRONG "form")
     "を評価している間、" (STRONG "lambda-list") "と" (STRONG "store-variable") "の変数は、"
     (CODE1 "gensym") "や" (CODE1 "gentemp") "によって生成された一時変数に束縛され、" (CODE1 "setf")
     "の展開によってこれらのサブフォームの値に束縛されます。" "この束縛によって、評価順の問題を考慮することなく" (STRONG "form")
     "を書くことができるようになります。" (CODE1 "defsetf") "は、このような場合において可能であれば、"
     "一時変数が最終的な値を最適化するように調整します。" EOL2 (CODE1 "defsetf") "のコード本体は、" "暗黙的に"
     (STRONG "access-fn") "という名前の" (CODE1 "block") "で囲まれます。" EOL2 (CODE1 "defsetf") "は"
     (CODE1 "place") "のサブフォームが" "正確に一度だけ評価されることを保証します。" EOL2 (STRONG "documentation")
     "は、ドキュメント文字の種別" (CODE1 "setf") "として" (STRONG "access-fn") "に割り当てをします。" EOL2 "もし"
     (CODE1 "defsetf") "フォームがトップレベルフォームとして現れたときは、" "コンパイラは、そのファイルの後で" (CODE1 "setf")
     "が呼ばれたときに展開が行われるよう、" "setf-expanderを有効にしなければなりません。" "もし同じファイルの後で" (CODE1 "place")
     "が" (STRONG "access-fn") "を使用するときは、" "ユーザーは、もしあるなら" (STRONG "form") "をコンパイル時に"
     "評価できることを保証しなければなりません。" "コンパイラーは、" (CODE1 "get-setf-expansion") "の環境引数が"
     "マクロの環境パラメータの値を受け取った場合、" "コンパイル時にこれらのsetf-expanderを" "利用できるようにしなければなりません。")
    (CHAPTER ("## 例文") 2 "次の式の効果は、Common Lispシステム内に構築されています。"
     (CODE3 "```lisp" "```" "(defsetf symbol-value set)") EOL2 "これは"
     (CODE1 "(setf (symbol-value foo) fu)") "というフォームが" (CODE1 "(set foo fu)") "に展開されます。"
     EOL2 "次の文に注意してください。" (CODE3 "```lisp" "```" "(defsetf car rplaca)") EOL2
     "この文は正しくはなく、" "なぜなら" (CODE1 "rplaca") "は最後の引数を返却しないからです。"
     (CODE3 "```lisp" "```"
      "(defun middleguy (x) (nth (truncate (1- (list-length x)) 2) x)) =>  MIDDLEGUY"
      "(defun set-middleguy (x v)" "   (unless (null x)"
      "     (rplaca (nthcdr (truncate (1- (list-length x)) 2) x) v))"
      "   v) =>  SET-MIDDLEGUY" "(defsetf middleguy set-middleguy) =>  MIDDLEGUY"
      "(setq a (list 'a 'b 'c 'd)" "      b (list 'x)"
      "      c (list 1 2 3 (list 4 5 6) 7 8 9)) =>  (1 2 3 (4 5 6) 7 8 9)"
      "(setf (middleguy a) 3) =>  3" "(setf (middleguy b) 7) =>  7"
      "(setf (middleguy (middleguy c)) 'middleguy-symbol) =>  MIDDLEGUY-SYMBOL"
      "a =>  (A 3 C D)" "b =>  (7)" "c =>  (1 2 3 (4 MIDDLEGUY-SYMBOL 6) 7 8 9)")
     EOL2 (CODE1 "defsetf") "の長いフォームの使用例。"
     (CODE3 "```lisp" "```"
      "(defsetf subseq (sequence start &optional end) (new-sequence)"
      "  `(progn (replace ,sequence ,new-sequence"
      "                   :start1 ,start :end1 ,end)"
      "          ,new-sequence)) =>  SUBSEQ" "(defvar *xy* (make-array '(10 10)))"
      "(defun xy (&key ((x x) 0) ((y y) 0)) (aref *xy* x y)) =>  XY"
      "(defun set-xy (new-value &key ((x x) 0) ((y y) 0))"
      "  (setf (aref *xy* x y) new-value)) =>  SET-XY"
      "(defsetf xy (&key ((x x) 0) ((y y) 0)) (store)"
      "  `(set-xy ,store 'x ,x 'y ,y)) =>  XY" "(get-setf-expansion '(xy a b))"
      "=>  (#:t0 #:t1)," "  (a b)," "  (#:store),"
      "  ((lambda (&key ((x #:x)) ((y #:y))) " "     (set-xy #:store 'x #:x 'y #:y))"
      "   #:t0 #:t1)," "  (xy #:t0 #:t1)" "(xy 'x 1) =>  NIL" "(setf (xy 'x 1) 1) =>  1"
      "(xy 'x 1) =>  1" "(let ((a 'x) (b 'y))" "  (setf (xy a 1 b 2) 3)"
      "  (setf (xy b 5 a 9) 14))" "=>  14" "(xy 'y 0 'x 1) =>  1"
      "(xy 'x 1 'y 2) =>  3"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "documentation") "," (CODE1 "setf") ","
     (CODE1 "define-setf-expander") "," (CODE1 "get-setf-expansion") "," "5.1. 一般化された参照,"
     "3.4.11. ドキュメント文字と宣言の文脈的な作用")
    (CHAPTER ("## 備考") 2 (STRONG "form") "には正しい値（" (STRONG "store-variable") "の値か多値）の"
     "返却のための規定を含めなければなりません。" "これは" (CODE1 "defsetf") "によってではなく" (STRONG "form")
     "によって処理します。" "なぜなら、多くの場合この値は、その場所に保存して正しい値を返す関数を"
     "同時に呼び出すことによって、余分なコストをかけずに返却できるからです。" EOL2 (CODE1 "setf") "の" (STRONG "access-fn")
     "の呼び出しは、" (STRONG "access-fn") "の全ての引数もまた評価されます。" "それはどの引数も特別に扱うことができません。" "つまり"
     (CODE1 "defsetf") "は、" (CODE1 "(ldb field reference)") "のような"
     "バイトの一般参照への格納方法を記述することができません。" (CODE1 "define-setf-expander") "は、" (CODE1 "defsetf")
     "によって課されている制限に" "ふさわしくないような状況を処理するために使われ、" "ユーザーに対して追加の制御を与えます。")))
(setf (gethash '("DEFSETF" . "MACRO") *table*) (gethash "DEFSETF" *table*))
(setf (gethash "DEFSTRUCT" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFSTRUCT"))
    (CHAPTER ("## 構文") 2 (CODE1 "defstruct") " " (STRONG "name-and-options") " ["
     (STRONG "documentation") "] " (CODE1 "{") (STRONG "slot-description") (CODE1 "}")
     "\\*" EOL1 "=> " (STRONG "structure-name")
     (CODE3 "```" "```"
      "name-and-options::= structure-name | (structure-name [[options]]) "
      "options::= conc-name-option | " "           {constructor-option}* | "
      "           copier-option | " "           include-option | "
      "           initial-offset-option | " "           named-option | "
      "           predicate-option | " "           printer-option | "
      "           type-option "
      "conc-name-option::= :conc-name | (:conc-name) | (:conc-name conc-name) "
      "constructor-option::= :constructor | " "                      (:constructor) | "
      "                      (:constructor constructor-name) | "
      "                      (:constructor constructor-name constructor-arglist) "
      "copier-option::= :copier | (:copier) | (:copier copier-name) "
      "predicate-option::= :predicate | (:predicate) | (:predicate predicate-name) "
      "include-option::= (:include included-structure-name {slot-description}*) "
      "printer-option::= print-object-option | print-function-option "
      "print-object-option::= (:print-object printer-name) | (:print-object) "
      "print-function-option::= (:print-function printer-name) | (:print-function) "
      "type-option::= (:type type) " "named-option::= :named "
      "initial-offset-option::= (:initial-offset initial-offset) "
      "slot-description::= slot-name |  "
      "                    (slot-name [slot-initform [[slot-option]]]) "
      "slot-option::= :type slot-type |  "
      "               :read-only slot-read-only-p "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "conc-name") " - 文字列指定子" EOL1
     (STRONG "constructor-arglist") " - " (CODE1 "boa") "ラムダリスト" EOL1
     (STRONG "constructor-name") " - シンボル" EOL1 (STRONG "copier-name") " - シンボル" EOL1
     (STRONG "included-structure-name") " - すでに定義されている構造体の名前。" "派生された型は許されず、"
     "構造体名に展開されるものも禁止されることに注意して下さい。" EOL1 (STRONG "initial-offset") " - 非負の整数" EOL1
     (STRONG "predicate-name") " - シンボル" EOL1 (STRONG "printer-name") " - 関数名かラムダ式" EOL1
     (STRONG "slot-name") " - シンボル" EOL1 (STRONG "slot-initform") " - フォーム" EOL1
     (STRONG "slot-read-only-p") " - generalized-boolean" EOL1 (STRONG "structure-name")
     " - シンボル" EOL1 (STRONG "type") " - 次の型指定子のどれかであり、" (CODE1 "list") ", "
     (CODE1 "vector") "," (CODE1 "(vector size)") ", あるいはその他の実装で適用可能な定義された型指定子。" EOL1
     (STRONG "documentation") " - 文字列。評価されません。")
    (CHAPTER ("## 定義") 2 (CODE1 "defstruct") "は構造体の型を定義し、" "その名前は"
     (STRONG "structure-type") "であり、" (STRONG "slot-option") "によって指定された名前付きのスロットが付きます。"
     EOL2 (CODE1 "defstruct") "は、" "スロットを読み込むリーダーと、" "そのようなリーダーを" (CODE1 "setf")
     "上で正しく動作する" "修正する機能を定義します。" "無効にしない限り、" (STRONG "name") (CODE1 "-p") "という名前の述部と、"
     (CODE1 "make-") (STRONG "constructor-name") "という名前の生成関数、" (CODE1 "copy-")
     (STRONG "constructor-name") "というコピーの関数が定義されます。" "これらの全ての名前の関数は自動的に生成され、" "自動的に"
     (CODE1 "inline") "として宣言されます" "（実装が区別できる場合）。" EOL2 (STRONG "documentation")
     "が与えられると、" (STRONG "structure-name") "がドキュメント文字に与えられ、" "種別" (CODE1 "structure")
     "と共に割り当てられます。" "また" (CODE1 ":type") "が指定されていないときは、" (STRONG "structure-name")
     "がドキュメント文字、" "種別が" (CODE1 "type") "という、" "クラス名が" (STRONG "structure-name") "の"
     "クラスオブジェクトのための割り当てが行われます。" EOL2 (CODE1 "defstruct") "は、"
     "本機能によって作成された構造体のインスタンスを生成するために使われる" "構築関数を定義します。" "標準の名前は" (CODE1 "make-")
     (STRONG "structure-name") "です。" "引数の" (STRONG "constructor") "オプションによって与えられた名前によって、"
     "違う名前を付けることができます。" (CODE1 "nil") "が指定されたときは、" "構築関数は作成されません。" EOL2
     "新しい構造体の型が定義された後は、" "その型のインスタンスは通常はその型の構築関数を使うことで作成できます。"
     "構築関数の呼び出しは、次のようなフォームになります。"
     (CODE3 "```lisp" "```" "(constructor-function-name" " slot-keyword-1 form-1"
      " slot-keyword-2 form-2" " ...)")
     EOL2 "構築関数の引数は、全てキーワード引数です。" "各キーワード引数のスロットは、" "構造体のスロットの名前に対応したキーワードの"
     "名前でなければいけません。" "全ての" (STRONG "keyword") "と" (STRONG "form") "は評価されます。"
     "もしスロットがこの方法で初期化されないときは、" "それは構築関数呼び出し時にスロットの定義内の" (STRONG "slot-initform")
     "を評価することによって初期化されます。" "もし" (STRONG "slot-initform") "が与えられなかったとき、" "何かの値が明に代入される前に"
     "そのスロットを読み込もうとしたときの結果は未定義です。" EOL2 (CODE1 "defstruct") "で指定された各"
     (STRONG "slot-initform") "の要素は、" "構築関数が指定されてない要素以外にに対して使われたとき、"
     (STRONG "slot-initform") "は構築関数を呼び出すたびに再評価されます。" (STRONG "slot-initform") "は、"
     "特定の構造体インスタンスの生成に必要になるまで" "評価されません。" "もし決して必要としないのであれば、" "スロット定義の型を指定したとしても、"
     "決して型の不適合によるエラーは発生しません。" "この場合、警告は発生されません。" "例えば、下記の一連のフォームは、最後の呼び出しでのみエラーが生じます。"
     (CODE3 "```lisp" "```" "(defstruct person (name 007 :type string)) "
      "(make-person :name \"James\")" "(make-person)")
     EOL2 "これは構築関数のキーワードパラメーターが" (STRONG "slot-initform") "の初期化フォームとして使用されたかのように動作します。"
     EOL2 "スロットの名前のシンボルは、実装において" "構築巻子のラムダ式の変数にその名前を使用してはいけません。" "なぜならそれらのシンボルは、"
     (CODE1 "special") "に宣言されたり、" "その名前で定数変数が定義されるかもしれないからです。" "スロットのデフォルトの初期化フォームは、"
     (CODE1 "defstruct") "フォーム自身が現れた" "レキシカルな環境内で評価されます。" "あるいは構築関数の呼び出しが現れた"
     "動的な環境で評価されます。" EOL2 "例えば、もし" (CODE1 "(gensym)") "フォームが初期化フォームとして" "構築関数の呼び出し内か、"
     "あるいは" (CODE1 "defstruct") "によるデフォルト初期化フォーム内かの" "どちらかで使われたとき、" "全ての構築関数の呼び出しにおいて、"
     (CODE1 "gensym") "が一度だけ呼ばれて" "新しいシンボルを生成します。" EOL2 (CODE1 "defstruct") "の各"
     (STRONG "slot-description") "は、" "ゼロかあるいは複数の" (STRONG "slot-option") "を指定できます。"
     (STRONG "slot-option") "はキーワードと値" "（評価されるフォームではなく値はそれ自身）" "のペアを含みます。" "例えば、"
     (CODE3 "```lisp" "```" "(defstruct ship" "  (x-position 0.0 :type short-float)"
      "  (y-position 0.0 :type short-float)" "  (x-velocity 0.0 :type short-float)"
      "  (y-velocity 0.0 :type short-float)"
      "  (mass *default-ship-mass* :type short-float :read-only t))")
     EOL2 "これは、各スロットが常に" (CODE1 "short-float") "を含み、" "最後のスロットは一度" (CODE1 "ship")
     "を構築したら" "変更不可能なスロットとして定義されています。" EOL2 "利用可能な" (STRONG "slot-option") "は下記の通り。" EOL2
     "- " (CODE1 ":type") " " (STRONG "type") "  - これはスロットが常に" (STRONG "type")
     "型の内容であることを指定します。" "    これは変数と関数に全体的に似ており、" "    効率よくリーダー関数の返却値の型を宣言できます。"
     "    スロットの初期化時と代入時に型チェックを行った際の" "    結果は実装依存です。" "    " (STRONG "type") "は評価されません。"
     "    この値は有効な型指定子でなければなりません。" "    <br><br>" EOL2 "- " (CODE1 ":read-only") " "
     (STRONG "x") "  - " (STRONG "x") "が" (STRONG "true") "のとき、"
     "    これはスロットが変更不可能であることを指定します。" "    それは構築時に指定された値を脛に含むことを意味します。"
     "    そのスロットのリーダー関数を指定した" (CODE1 "setf") "は受け付けません。" "    もし" (STRONG "x") "が"
     (STRONG "false") "なら、その" (STRONG "slot-option") "は効果を持ちません。" "    " (STRONG "x")
     "は評価されません。" "    <br><br>" EOL2 "下記のキーワードオプションは、" (CODE1 "defstruct") "で使うことができます。"
     (CODE1 "defstruct") "オプションは、" "キーワードか、キーワードとそのキーワードの引数のリストの" "どちらかを指定できます。"
     "キーワード自身が指定されたときは、" "そのキーワードと引数なしのリストを指定したことと同じです。" (CODE1 "defstruct") "オプションの構文は、"
     (STRONG "slot-option") "が使われたペアの構文と違っています。" "これらのオプションどのどの部分も評価されません。" EOL2 "- "
     (CODE1 ":conc-name") "  - これはリーダー（そしてアクセッサ）関数の"
     "    名前に自動的にプレフィックスとして付与されるものを指定します。" "    標準の動作は、構造体の全てのリーダー関数の名前の最初を"
     "    その構造体の名前とそれに続くハイフンで始まるようにするものです。" "    <br><br>" "    " (CODE1 ":conc-name")
     "は別のプレフィックスを使用するときに指定します。" "    もしセパレーターとしてハイフンを使用したいのであれば、"
     "    プレフィックスの部分としてそれを指定しなければなりません。" "    もし" (CODE1 ":conc-name") "が" (CODE1 "nil")
     "のときか引数を指定しなかった場合は、" "    プレフィックスは使用されません。" "    したがって、リーダー関数の名前はスロットの名前と同じになります。"
     "    もしプレフィックスに" (CODE1 "nil") "以外が指定されたとき、" "    各スロットのリーダー関数の名前は、"
     "    プレフィックスとスロットの名前を結合したもので構築され、" "    その結果のシンボルを" (CODE1 "defstruct")
     "フォームが展開された時点での" "    現在のパッケージに" (CODE1 "intern") "したもにになります。" "    <br><br>" "    "
     (CODE1 ":conc-name") "に何を与えても、" "    プレフィックスの付いていないスロット名とのキーワードが"
     "    コンストラクタ関数で使用されることに注意してください。" "    リーダー関数の名前は、" (CODE1 "setf") "の引数にも使用されます。"
     "    下記に例を示します。"
     (CODE3 "```lisp" "```"
      " (defstruct (door (:conc-name dr-)) knob-color width material) =>  DOOR"
      " (setq my-door (make-door :knob-color 'red :width 5.0)) "
      "=>  #S(DOOR :KNOB-COLOR RED :WIDTH 5.0 :MATERIAL NIL)"
      " (dr-width my-door) =>  5.0" " (setf (dr-width my-door) 43.7) =>  43.7"
      " (dr-width my-door) =>  43.7")
     EOL2 "- - " (CODE1 ":conc-name") "オプションが明に指定されたかどうかに関わらず、"
     "    次の規則が生成されるリーダー（あるいはアクセッサ）の名前の" "    衝突を管理します。" "    ある構造体の型を" (CODE1 "S1") "、"
     "    スロットの名前が" (CODE1 "X1") "であり、" "    そのリーダー関数の名前が" (CODE1 "R") "とします。"
     "    これは他の構造体の" (CODE1 "S2") "によって継承されています。" "    " (CODE1 "S2") "はスロット"
     (CODE1 "X2") "があり、" "    同じ名前のリーダー関数" (CODE1 "R") "を指定しています。" "    " (CODE1 "S2")
     "はまだ" (CODE1 "R") "の定義を生成しておらず、" "    かわりに" (CODE1 "S1") "の定義から定義" (CODE1 "R")
     "が継承されています。" "    （このような場合、もし" (CODE1 "X1") "と" (CODE1 "X2") "が違うスロットのときは、"
     "    実装は" (CODE1 "style-warning") "を通知するかもしれません）" "    <br><br>" EOL2 "- "
     (CODE1 ":constructor") "  - このオプションは、ゼロか、ひとつか、2つの引数を取ります。"
     "    もし少なくともひとつの引数が指定されれており、" "    最初の引数が" (CODE1 "nil") "ではないとき、"
     "    その引数は構築関数の名前を指定したシンボルです。" "    もし引数が指定されなかったとき"
     "    （あるいはもし自身のオプションが指定されなかったとき）" "    構築の名前は、文字列" (CODE1 "\"MAKE-\"")
     "と構造体の名前を結合したものを生成し、" "    その名前を" (CODE1 "defstruct") "フォームが展開された時点の"
     "    現在のパッケージに" (CODE1 "intern") "したもにになります。" "    もし引数が" (CODE1 "nil") "で与えられたときは、"
     "    構築関数は定義されません。" "    <br><br>" "    もし" (CODE1 ":constructor") "が"
     (CODE1 "(constructor name arglist)") "として与えられたとき、" "    キーワード駆動の構築関数の作成のかわりに、"
     "    " (CODE1 "defstruct") "は「位置的な」構築関数を定義します。" "    それは引数の位置かあるいは場合によってはキーワードによって"
     "    決定される意味を持つ引数を取ります。" "    " (STRONG "arglist") "はどの引数を構築するかを定義したものとして使われます。"
     "    単純な場合として、" "    例えば" (CODE1 "(:constructor make-foo (a b c))") "のようなものは、"
     "    " (CODE1 "make-foo") "を3つの引数の構築関数として定義し、" "    それらの引数はスロットの名前" (CODE1 "a") ", "
     (CODE1 "b") ", " (CODE1 "c") "の初期化に使用されます。" "    <br><br>"
     "    このタイプの構築は、「By Order of Arguments（引数の順による）」" "    の操作と言われ、それはよく" (CODE1 "boa")
     "構築として知られています。" "    <br><br>" "    " (STRONG "arglist") "である" (CODE1 "boa")
     "構築がどのように処理されるかの情報は、" "    3.4.6. " (CODE1 "boa") "ラムダリストをご確認ください。" "    <br><br>"
     "    " (CODE1 ":constructor") "オプションは複数許容され、" "    それぞれ違ったパラメーターを取る"
     "    いくつかの構築関数を定義することができます。" "    <br><br>" "    " (CODE1 "defstruct") "は" "    "
     (CODE1 ":constructor") "オプションが明に指定されていないときか、" "    " (CODE1 ":constructor")
     "オプションが名前の引数なしに指定されていたときのみ" "    デフォルトの名前をキーワードの構築関数を作成します。" "    <br><br>" "    "
     (CODE1 "(:constructor nil)") "は、" "    他の構築関数のオプションが指定されていないときにのみ意味します。" "    それは"
     (CODE1 "defstruct") "による他の全ての構築関数の生成を禁止します。" "    <br><br>" "    それ以外では、"
     (CODE1 "defstruct") "は、" "    指定された各" (CODE1 ":constructor") "オプションにしたがって"
     "    構築関数を生成します。" "    これは複数のキーワードによる構築関数を指定するのと同様に、" "    複数の" (CODE1 "boa")
     "構築を指定することも許されます。" "    <br><br>" EOL2 "- " (CODE1 ":copier")
     "  - このオプションはひとつの引数にシンボルを受け取り、" "    これはコピー関数の名前を指定します。" "    もし引数が指定されなかったか、"
     "    あるいはオプション自体指定されなかったときは、" "    名前は文字列" (CODE1 "\"COPY-\"") "と構造体の名前を結合したものを生成し、"
     "    その名前を" (CODE1 "defstruct") "フォームが展開された時点の" "    現在のパッケージに" (CODE1 "intern")
     "したもにになります。" "    もし引数が" (CODE1 "nil") "で与えられたときは、" "    コピー関数は定義されません。"
     "    <br><br>" "    自動的に定義されたコピー関数は、" "    引数に定義しているその構造体の型を受け取る"
     "    ひとつの引数の関数になります。" "    コピー関数は、その引数と同じ型を持つ" "    新しい構造体を生成し、"
     "    それは元の構造体と同じ要素の値を持ちます。" "    つまりその要素の値は再帰的にはコピーされません。" "    もし"
     (CODE1 "defstruct") "の" (CODE1 ":type") "オプションが使われなかったときは、" "    下記のものと同等になります。"
     "    <br>" "    "
     (CODE1 "(copier-name x) = (copy-structure (the structure-name x))") "    <br><br>"
     EOL2 "- " (CODE1 ":include") "  - このオプションは、新しい構造体の定義を他の構造体の定義の拡張として"
     "    構築したいときに使用します。" "    例えば次の式があるとします。"
     (CODE3 "```lisp" "```" "(defstruct person name age sex)") EOL2 "- - 新しい構造体の表現である"
     (CODE1 "astronaut") "は、" "    " (CODE1 "name") ", " (CODE1 "age") ", " (CODE1 "sex")
     "という属性と、" "    " (CODE1 "person") "構造体の操作関数、" "    " (CODE1 "astronaut") "が定義した"
     (CODE1 ":include") "を" "    次のようにして作成します。"
     (CODE3 "```lisp" "```" "(defstruct (astronaut (:include person)"
      "                      (:conc-name astro-))" "   helmet-size"
      "   (favorite-beverage 'tang))")
     EOL2 "- - " (CODE1 ":include") "は、その構造体がincludeされた構造体と" "    同じスロットを持つように定義するものです。"
     "    このような方法で作成されたものは、" "    includeされた構造体のリーダー関数もまた、" "    今回定義した構造体で使用できます。"
     "    この例では、したがって" (CODE1 "astronaut") "では5つのスロットを持ちます。" "    その内訳は、3つが"
     (CODE1 "person") "の定義であり、" "    2つが" (CODE1 "astronaut") "自身のものです。" "    "
     (CODE1 "person") "構造体によって定義されたリーダー関数は、" "    " (CODE1 "astronaut")
     "構造体のインスタンスでも適用でき、" "    そしてそれは正しく動作します。" "    さらに" (CODE1 "astronaut")
     "はそれらの要素に対する" "    自分自身のリーダー関数も定義されます。" "    下記の例は、" (CODE1 "astronaut")
     "構造体を使用したものです。"
     (CODE3 "```lisp" "```" "(setq x (make-astronaut :name 'buzz"
      "                        :age 45." "                        :sex t"
      "                        :helmet-size 17.5))" "(person-name x) =>  BUZZ"
      "(astro-name x) =>  BUZZ" "(astro-favorite-beverage x) =>  TANG"
      "(reduce #'+ astros :key #'person-age) ; 空かもしれないastrosシーケンスの"
      "                                      ; 年齢の合計を得ます")
     EOL2 "- - リーダー関数の" (CODE1 "person-name") "と" (CODE1 "astro-name") "の違いは、" "    "
     (CODE1 "person-name") "は" (CODE1 "astronaut") "を含むどの" (CODE1 "person")
     "にも正しく適用できますが、" "    " (CODE1 "astro-name") "はただ" (CODE1 "astronaut") "のみ正しく適用できます。"
     "    実装はリーダー関数を使用するときに正しく確認しないかもしれません。" "    <br><br>" "    ひとつの"
     (CODE1 "defstruct") "に" "    多くてもひとつの" (CODE1 ":include") "を指定できます。" "    "
     (CODE1 ":include") "の引数は要求され、" "    以前に定義された何かの構造体の名前でなければなりません。" "    もし構造体の定義に"
     (CODE1 ":type") "オプションがないときは、" "    includeされる構造体もまた" (CODE1 ":type") "オプションを"
     "    指定されていてはいけません。" "    もし構造体の定義に" (CODE1 ":type") "オプションがあるときは、"
     "    includeされる構造体は" "    同じ表現の型を指定した" (CODE1 ":type") "オプションで"
     "    定義されていなければなりません。" "    <br><br>" "    もし" (CODE1 ":type") "オプションがないとき、"
     "    includeされた構造体の名前はデータ型の名前であり" "    " (CODE1 "typep") "によって認識できる正当な型指定子なので、"
     "    これはinclude構造体のサブタイプになります。" "    上記の例の場合、" (CODE1 "astronaut") "は"
     (CODE1 "person") "のサブタイプです。" "    したがって、"
     (CODE3 "```lisp" "```" " (typep (make-astronaut) 'person) =>  true") EOL2 "- - これは"
     (CODE1 "person") "の全ての操作が" (CODE1 "astronaut") "でも動作することを示しています。" "    <br><br>"
     "    " (CODE1 ":include") "を使用した構造体は、" "    その" (CODE1 ":include") "オプションを使用することで、"
     "    include構造体が指定したものとは違ったスロットの" "    デフォルト値か" (STRONG "slot-option")
     "をしていることができます。" "    例えば下記の通り。"
     (CODE3 "```lisp" "```" "(:include included-structure-name slot-description*)") EOL2
     "- - 各" (STRONG "slot-description") "は、include構造体のスロットと" "    同じ"
     (STRONG "slot-name") "を持ったものでなければなりません。" "    もし" (STRONG "slot-description") "が"
     (STRONG "slot-initform") "を持たないとき、" "    新しい構造体のそのスロットは初期値を持ちません。"
     "    それ以外のときは、その初期値フォームは" "    " (STRONG "slot-description") "の"
     (STRONG "slot-initform") "に置き換わります。" "    通常は書き込み可能なスロットは読み込み専用にできます。"
     "    もしinclude構造体のあるスロットが読み込み専用のとき、" "    新しいものもまた読み込み専用でなければなりません。"
     "    もしあるスロットに型が指定されていたときは、" "    新しいものはinclude構造体で指定された型の" "    サブタイプでなければなりません。"
     "    <br><br>" "    例えば、" (CODE1 "astronaut") "の" (CODE1 "age") "をデフォルトを"
     (CODE1 "45") "にしたものは下記の通り。"
     (CODE3 "```lisp" "```" " (defstruct (astronaut (:include person (age 45)))"
      "    helmet-size" "    (favorite-beverage 'tang))")
     EOL2 "- - もし" (CODE1 ":include") "を" (CODE1 ":type") "オプションと一緒に使用したとき、"
     "    その効果は、まず最初にinclude構造体の表現で必要な" "    要素の数だけスキップします。" "    さらに"
     (CODE1 ":initial-offset") "オプションの指定による" "    追加の要素をスキップします。"
     "    そのあとで、この点から要素の確保が始まります。" "    例えば下記の通り。"
     (CODE3 "```lisp" "```" "(defstruct (binop (:type list) :named (:initial-offset 2))"
      "  (operator '? :type symbol)   " "  operand-1" "  operand-2) =>  BINOP"
      "(defstruct (annotated-binop (:type list)"
      "                            (:initial-offset 3)"
      "                            (:include binop))"
      " commutative associative identity) =>  ANNOTATED-BINOP"
      "(make-annotated-binop :operator '*" "                      :operand-1 'x"
      "                      :operand-2 5" "                      :commutative t"
      "                      :associative t" "                      :identity 1)"
      "  =>  (NIL NIL BINOP * X 5 NIL NIL NIL T T 1)")
     EOL2 "- - 最初の2つの" (CODE1 "nil") "の要素は、" "    " (CODE1 "binop") "の定義にある"
     (CODE1 ":initial-offset") "の" (CODE1 "2") "のものです。" "    次の4つの要素は構造体の名前と、" "    "
     (CODE1 "binop") "の3つのスロットが含まれています。" "    その次の3つの" (CODE1 "nil") "の要素は" "    "
     (CODE1 "annotated-binop") "の定義にある" (CODE1 ":initial-offset") "の" (CODE1 "3")
     "のものです。" "    最後の3つの要素は" (CODE1 "annotated-binop") "の追加のスロットが含まれています。"
     "    <br><br>" EOL2 "- " (CODE1 ":initial-offset") "  - " (CODE1 ":initial-offset")
     "は" (CODE1 "defstruct") "に対して、" "    ボディ部で記述されてるスロットを確保し始める前に、"
     "    指定した数のスロットをスキップするように指示します。" "    このオプションの引数はスロットの数であり、" "    "
     (CODE1 "defstruct") "はスキップしなければなりません。" "    " (CODE1 ":initial-offset") "は"
     (CODE1 ":type") "が指定されたときのみ使用できます。" "    <br><br>" "    " (CODE1 ":initial-offset")
     "は、スロットを最初からではなく" "    指定した要素から確保し始めることができます。" "    例えば、下記のフォーム"
     (CODE3 "```lisp" "```" "(defstruct (binop (:type list) (:initial-offset 2))"
      "  (operator '? :type symbol)" "  operand-1" "  operand-2) =>  BINOP")
     EOL2 "- - こちらの" (CODE1 "make-binop") "の動作と返却値を下記に示します。"
     (CODE3 "```lisp" "```" "(make-binop :operator '+ :operand-1 'x :operand-2 5)"
      "=>  (NIL NIL + X 5)" "(make-binop :operand-2 4 :operator '*)"
      "=>  (NIL NIL * NIL 4)")
     EOL2 "- - 選択関数である、" (CODE1 "binop-operator") ", " (CODE1 "binop-operand-1") ", "
     (CODE1 "binop-operand-2") "は、" "    それぞれ" (CODE1 "third") ", " (CODE1 "fourth") ", "
     (CODE1 "fifth") "と本質的に同等です。" "    似たようなフォームとして"
     (CODE3 "```lisp" "```" "(defstruct (binop (:type list) :named (:initial-offset 2))"
      "  (operator '? :type symbol)" "  operand-1" "  operand-2) =>  BINOP")
     EOL2 "- - こちらの" (CODE1 "make-binop") "の動作と返却値を下記に示します。"
     (CODE3 "```lisp" "```"
      "(make-binop :operator '+ :operand-1 'x :operand-2 5) =>  (NIL NIL BINOP + X 5)"
      "(make-binop :operand-2 4 :operator '*) =>  (NIL NIL BINOP * NIL 4)")
     EOL2 "- - 最初の2つの" (CODE1 "nil") "の要素は、" "    " (CODE1 "binop") "の定義にある"
     (CODE1 ":initial-offset") "の" (CODE1 "2") "のものです。" "    次の4つの要素は構造体の名前と、" "    "
     (CODE1 "binop") "の3つのスロットが含まれています。" "    <br><br>" EOL2 "- " (CODE1 ":named") "  - "
     (CODE1 ":name") "は、構造体に名前を付けるよう指定します。" "    もし" (CODE1 ":type") "が指定されていないときは、"
     "    構造体は常に名前付けられます。" "    <br><br>" "    例えば、下記のフォームを考えます。"
     (CODE3 "```lisp" "```" "(defstruct (binop (:type list))"
      "  (operator '? :type symbol)" "  operand-1" "  operand-2) =>  BINOP")
     EOL2 "- - この定義は、" (CODE1 "make-binop") "という構築関数と3つの選択関数である" "    "
     (CODE1 "binop-operator") ", " (CODE1 "binop-operand-1") ", "
     (CODE1 "binop-operand-2") "を定義します。" "    （しかし下記に説明する理由にて" (CODE1 "binop-p")
     "は定義されません）" "    <br><br>" "    " (CODE1 "make-binop") "の効果は単純に3つの長さのリストを構築します。"
     (CODE3 "```lisp" "```"
      "(make-binop :operator '+ :operand-1 'x :operand-2 5) =>  (+ X 5)  "
      "(make-binop :operand-2 4 :operator '*) =>  (* NIL 4)")
     EOL2 "- - これはちょうど" (CODE1 "list") "関数のようですが、" "    キーワード引数を受け取ることと、" "    "
     (CODE1 "binop") "というデータ型という概念に適用した" "    スロットの標準値を用意する点が違っています。"
     "    同じように、3つの選択関数である" "    " (CODE1 "binop-operator") ", "
     (CODE1 "binop-operand-1") ", " (CODE1 "binop-operand-2") "は、" "    それぞれ"
     (CODE1 "car") ", " (CODE1 "cadr") ", " (CODE1 "caddr") "と本質的に同等です。"
     "    これらは完全には同等ではないでしょう。" "    なぜなら、例えばある実装では" "    各選択関数の引数が長さ" (CODE1 "3")
     "のリストであるかどうかを" "    保証するためのエラーチェックを追加するような" "    正当化を行うかもしれません。" "    <br><br>"
     "    " (CODE1 "binop") "はデータ型という概念であって、" "    Common Lispの型システムの一部ではありません。" "    "
     (CODE1 "typep") "は" (CODE1 "binop") "を型指定子として認識しませんし、" "    " (CODE1 "type-of") "は"
     (CODE1 "binop") "構造体を与えても" "    " (CODE1 "list") "と返却します。" "    "
     (CODE1 "make-binop") "で構築されたデータ構造と、" "    正しい構造を持つその他のリストを" "    区別する方法はありません。"
     "    <br><br>" "    この" (CODE1 "make-binop") "によって作成された構造体から" "    構造体名"
     (CODE1 "binop") "を知る方法はありません。" "    これは構造体に名前がついているときのみ行うことができます。"
     "    名前付き構造体は、その構造体のインスタンスが与えられたときに、" "    構造体名（型の名前）を確実に復元できるという性質を持っています。" "    "
     (CODE1 ":type") "オプションなしで定義された構造体では、" "    構造体名は実際にCommon Lispのデータ型システムの一部になります。"
     "    このような構造体を" (CODE1 "type-of") "に適用したとき、" "    そのオブジェクトの型の構造体名が返却されます。" "    "
     (CODE1 "typep") "は正当な型指定子として構造体名を認識します。" "    <br><br>" "    " (CODE1 ":type")
     "オプションと一緒に定義された構造体について、" "    " (CODE1 "type-of") "は、" (CODE1 "list") "か"
     (CODE1 "(vector t)") "のように" "    指定した" (CODE1 ":type") "オプションに依存したものが返却されます。"
     "    構造体名は有効な型指定子にはなりません。" "    しかし、もし" (CODE1 ":named") "オプションが指定されていたときは、"
     "    構造体（" (CODE1 "defstruct") "の構築関数によって作成されたもの）は、" "    常に構造体名を含みます。"
     "    これは構造体のインスタンスから構造体名を知ることができるということと、" "    概念的な型に対しての適切な" (CODE1 "predicate")
     "を" "    定義することができるということです。" "    自動的に定義される" (CODE1 "name-p") "という構造体の"
     (CODE1 "predicate") "は、" "    最初にその引数が正当な型（" (CODE1 "list") ", "
     (CODE1 "(vector t)") ", その他）で" "    あるかどうかを確認し、 そのあと最初の要素が"
     "    適切な型の名前を含んでいるかどうかを確認します。" "    <br><br>" "    次に示す例の" (CODE1 "binop") "を考えます。"
     "    これは" (CODE1 ":named") "オプションを追加しただけのものです。"
     (CODE3 "```lisp" "```" "(defstruct (binop (:type list) :named)"
      "  (operator '? :type symbol)" "  operand-1" "  operand-2) =>  BINOP")
     EOL2 "- - これにより、構築関数" (CODE1 "make-binop") "と3つの選択関数" "    "
     (CODE1 "binop-operator") ", " (CODE1 "binop-operand-1") ", "
     (CODE1 "binop-operand-2") "が定義されます。" "    " (CODE1 "make-binop")
     "の効果は、今回のものは4つの長さのリストを構築します"
     (CODE3 "```lisp" "```"
      "(make-binop :operator '+ :operand-1 'x :operand-2 5) =>  (BINOP + X 5)"
      "(make-binop :operand-2 4 :operator '*) =>  (BINOP * NIL 4)")
     EOL2 "- - この構造体は以前のものと同じレイアウトを持っていますが、" "    構造体名" (CODE1 "binop")
     "がリストの最初の要素に含まれています。" "    選択関数" (CODE1 "binop-operator") ", "
     (CODE1 "binop-operand-1") ", " (CODE1 "binop-operand-2") "は" "    それぞれ"
     (CODE1 "cadr") ", " (CODE1 "caddr") ", " (CODE1 "cadddr") "と本質的に同等です。" "    "
     (CODE1 "predicate") "である" (CODE1 "binop-p") "は、下記の定義と多かれ少なかれ同等です。"
     (CODE3 "```lisp" "```" "(defun binop-p (x)"
      "  (and (consp x) (eq (car x) 'binop))) =>  BINOP-P")
     EOL2 "- - " (CODE1 "binop") "という名前はまだ" (CODE1 "typep") "で識別できるような"
     "    有効な型指定子ではありませんが、" "    しかし少なくとも" (CODE1 "binop") "構造体と他の似たような定義の構造体と"
     "    区別をつける方法はあります。" "    <br><br>" EOL2 "- " (CODE1 ":predicate")
     "  - このオプションはひとつの引数を取り、" "    それは" (CODE1 "predicate") "の名前を指定したものです。"
     "    もし引数が指定されないか、オプション自身が指定されなかったときは、" "    " (CODE1 "predicate") "の名前は、構造体の名前と文字列"
     (CODE1 "\"-P-\"") "を結合したものを生成し、" "    その名前を" (CODE1 "defstruct") "フォームが展開された時点の"
     "    現在のパッケージに" (CODE1 "intern") "したもにになります。" "    もし引数が" (CODE1 "nil") "で与えられたときは、"
     "    " (CODE1 "predicate") "関数は定義されません。" "    " (CODE1 "predicate")
     "を定義できるのは構造体に名前がついているときであり、" "    もし" (CODE1 ":type") "が指定されて、かつ" (CODE1 ":named")
     "が指定されなかったときは、" "    " (CODE1 ":predicate") "は指定しないかあるいは:" (CODE1 "nil") "の値を"
     "    指定するかのどちらかでなければなりません。" "    <br><br>" EOL2 "- " (CODE1 ":print-function") ", "
     (CODE1 ":print-object") "  - " (CODE1 ":print-function") "と" (CODE1 ":print-object")
     "のオプションは、" "    型" (STRONG "structure-name") "の構造体のための" "    "
     (CODE1 "print-object") "メソッドを生成します。" "    これらのオプションは同義語ではありませんが、"
     "    似たような機能を提供します。" "    これらのオプションの選択（" (CODE1 ":print-function") "か"
     (CODE1 ":print-object") "）は、" "    どのようにして" (STRONG "printer-name")
     "という関数を呼び出すのかに影響します。" "    これらのオプションはただひとつだけ使うことができます。" "    そしてこれらのオプションは"
     (CODE1 ":type") "が指定されなかったときのみ使用できます。" "    <br><br>" "    もし"
     (CODE1 ":print-function") "オプションが使われたとき、" "    構造体の名前" (STRONG "structure-name")
     "が印字されるときに" "    指定された" (CODE1 "printer") "関数が次の3つの引数と共に呼び出されます。" "  " EOL1
     "    - 印字したい構造体（" (STRONG "structure-name") "の一般的なインスタンス）" "    - 印字先のストリーム"
     "    - 現在の深さを示す整数値。この整数の値は実装によって" "      異なるかもしれませんが、それは"
     "      不確実な深さが適切かどうかを判断するために" "      " (CODE1 "*print-level*") "と比較することで"
     "      信頼性を高めることができます。" EOL2 "    " (CODE1 "(:print-function printer-name)") "の指定は、"
     "    おおよそ次のものと同一です。"
     (CODE3 "```lisp" "```" "(defmethod print-object ((object structure-name) stream)"
      "  (funcall (function printer-name) object stream <<current-print-depth>>))")
     EOL2 "- - " (CODE1 "<<current-print-depth>>") "は、現在の印字がどれくらい深いのかという"
     "    プリンターの値を表現したものです。" "    " (CODE1 "<<current-print-depth>>") "が常に0であり、" "    "
     (CODE1 "*print-level*") "が" (CODE1 "nil") "でない場合、"
     "    印刷が再帰的に下降するにつれて順次小さな値に再束縛されるか、" "    あるいは、同じ走査中に印刷が再帰的に下降するにつれて" "    "
     (CODE1 "current-print-depth") "の値が変化し、" "    " (CODE1 "*print-level*") "が一定のままであるかは"
     "    実装依存です。" "    <br><br>" EOL2 "    もし" (CODE1 ":print-object") "オプションが使われたとき、"
     "    構造体の名前" (STRONG "structure-name") "が印字されるときに" "    指定された" (CODE1 "printer")
     "関数が次の2つの引数と共に呼び出されます。" "  " EOL1 "    - 印字したい構造体（" (STRONG "structure-name")
     "の一般的なインスタンス）" "    - 印字先のストリーム" EOL2 "    " (CODE1 "(:print-object printer-name)")
     "の指定は、" "    おおよそ次のものと同一です。"
     (CODE3 "```lisp" "```" "(defmethod print-object ((object structure-name) stream)"
      "  (funcall (function printer-name) object stream))")
     EOL2 "- - もし" (CODE1 ":type") "オプションが指定されなかったとき、" "    さらに"
     (CODE1 ":print-function") "か" (CODE1 ":print-object") "オプションが指定され、" "    その"
     (STRONG "printer-name") "が指定されなかったときは、" "    " (CODE1 "print-object") "メソッドは" "    "
     (STRONG "structure-name") "で" (CODE1 "specialized") "されたメソッドを生成し、" "    実装の関数である"
     (CODE1 "#S") "表記を用いた構造体の" "    標準的な印刷を呼び出します。" "    22.1.3.12. 構造体の印字をご確認ください。"
     "    <br><br>" "    もし" (CODE1 ":print-function") "と" (CODE1 ":print-object") "の"
     "    どちらのオプションも指定されなかったときは、" "    " (CODE1 "defstruct") "は"
     (STRONG "structure-name") "に特化した" "    " (CODE1 "print-object") "メソッドは生成せず、" "    "
     (CODE1 ":include") "オプションによって指定された構造体のものか、" "    あるいは構造体の印刷のデフォルトの動作のものかが"
     "    標準的なふるまいとして継承されます。" "    " (CODE1 "print-object")
     "関数と、22.1.3.12. 構造体の印字をご確認ください。" "    <br><br>" "    " (CODE1 "*print-circle*") "が"
     (STRONG "true") "のとき、" "    ユーザーが定義した印刷関数は" "    オブジェクトを印刷するときに"
     "    指定されたストリームを用いて" (CODE1 "write") ", " (CODE1 "prin1") "," "    " (CODE1 "princ")
     ", " (CODE1 "format") "を使用できますが、" "    循環構造を検出したときは" (CODE1 "#n#") "構文を用いた印刷がされます。"
     "    これは、" (CODE1 "print-object") "に" "    " (CODE1 ":print-function")
     "オプションで追加されたメソッドを適用できます。" "    もしユーザーが定義した印刷関数が" "    指定されたもの以外のストリームに対して行われたとき、"
     "    循環構造の検出はそのストリームでやり直しされます。" "    " (CODE1 "*print-circle*") "変数をご確認ください。"
     "    <br><br>" EOL2 "- " (CODE1 ":type") "  - " (CODE1 ":type")
     "は構造体が使用する表現を明確に指定します。" "    この引数は、下記のどれかでなければなりません。" EOL2 "    - " (CODE1 "vector")
     "      - これは" (CODE1 "(vector t)") "として指定された結果と同じものが生成されます。" "        この構造体は一般的な"
     (CODE1 "vector") "として表現され、" "        " (CODE1 "vector") "の要素に値が保存されます。"
     "        もし構造体に" (CODE1 ":name") "が指定されていたときは、" "        最初の要素は" (CODE1 "vector")
     "の1番目の要素であり、" "        指定されていないときは0番目の要素です。" "        <br><br>" EOL2 "    - "
     (CODE1 "(vector element-type)") "      - この構造体は（可能であれば特定化された）" (CODE1 "vector")
     "として表現され、" "        " (CODE1 "vector") "の要素に値が保存されます。" "        全ての要素は指定された型の"
     (CODE1 "vector") "に" "        格納できるような型でなければなりません。" "        もし構造体に" (CODE1 ":name")
     "が指定されていたときは、" "        最初の要素は" (CODE1 "vector") "の1番目の要素であり、"
     "        指定されていないときは0番目の要素です。" "        <br><br>" EOL2 "    - " (CODE1 "list")
     "      - この構造体はリストとして表現されます。" "        もし構造体に" (CODE1 ":name") "が指定されていたときは、"
     "        最初の要素は" (CODE1 "cadr") "であり、" "        指定されていないときは" (CODE1 "car") "の要素です。"
     "        <br><br>" EOL2 "    このオプションの指定は、" "    特定の表現へ強制する効果があり、"
     "    defstructで指定された順序で" "    対応する連続した要素を指定した表現で" "    格納する効果があります。" "    これは構造体名が"
     (CODE1 "typep") "によって識別できる" "    有効な型指定子になることも禁止します。" "    <br><br>" EOL2
     "    例えば下記の例を考えます。"
     (CODE3 "```lisp" "```" "(defstruct (quux (:type list) :named) x y)") EOL2 "- - これは、"
     (CODE1 "list") "関数を使用したかのように、" "    " (CODE1 "car") "が" (CODE1 "quux")
     "であるようなリストを生成する" "    構築関数を作らなければいけません。" "    <br><br>" "    もし次のような型が定義されたとき"
     (CODE3 "```lisp" "```" "(deftype quux () '(satisfies quux-p))") EOL2 "- - 次のフォーム"
     (CODE3 "```lisp" "```" "(typep (make-quux) 'quux)") EOL2 "- - これは正確に次のようなものの実行を"
     "    返却しなければなりません。" (CODE3 "```lisp" "```" "(typep (list 'quux nil nil) 'quux)")
     EOL2 "- - もし" (CODE1 ":type") "が指定されなかったときは、" "    構造体は型" (CODE1 "structure-object")
     "の" "    オブジェクトとして表現されます。" "    <br><br>" "    " (CODE1 ":type") "オプションがない"
     (CODE1 "defstruct") "は、" "    構造体名のクラスを定義します。" "    構造体のインスタンスのメタクラスは"
     (CODE1 "structure-class") "です。" "    <br><br>" EOL2 (CODE1 "defstruct")
     "の構造体を再定義したときの結果は未定義です。" EOL2 (CODE1 "defstruct") "に何もオプションを指定しなかった場合は、"
     "新しい構造体のインスタンスでは" "次のような操作を行う関数が自動的に定義されます。" EOL2 "- 述部" (CODE1 "predicate") "  - "
     (STRONG "structure-name") (CODE1 "-p") "という名前の" (CODE1 "predicate") "が定義され、"
     "    構造体の型のメンバーかどうかをテストします。" "    " (CODE1 "predicate") "の呼び出し"
     (CODE1 "(structure-name-p object)") "は、" "    " (STRONG "object") "がその型であれば"
     (STRONG "true") "を、" "    そうでなければ" (STRONG "false") "を返却します。" "    " (CODE1 "typep")
     "もまた新しい型の名前を" "    " (STRONG "object") "がその型に属したものかどう" "    かテストする際に使用できます。"
     "    このような関数の呼び出しは" "    " (CODE1 "(typep object 'structure-name)") "というフォームを持ちます。"
     "    <br><br>" EOL2 "- 要素のリーダー関数(reader function)" "  - リーダー関数は、構造体の要素を読むために定義されます。"
     "    各スロットの名前について、対応するリーダー関数が" "    " (CODE1 "structure-name-slot-name")
     "という名前で生成されます。" "    この関数は指定されたスロットの内容を読み込みます。"
     "    各リーダー関数は引数に構造体型のインスタンスをひとつ取ります。" "    " (CODE1 "setf") "は、変更可能なスロットに対して"
     "    リーダー関数を指定することで使用できます。" "    <br><br>" EOL2 "- 構築関数" "  - 構築関数は"
     (CODE1 "make-structure-name") "という名前で定義されます。" "    この関数は構造体型の新しいインスタンスを生成した返却します。"
     "    <br><br>" EOL2 "- コピー関数" "  - コピー関数は" (CODE1 "copy-structure-name")
     "という名前で定義されます。" "    コピー関数は構造体型のオブジェクトを引数に取り、" "    同じ型の新しいオブジェクトを作成してそのコピーを行います。"
     "    コピー関数は元のものと全体の構成が同じである新しい構造体を作ります。" "    2つの構造体インスタンスの各要素は" (CODE1 "eql")
     "で等しくなります。" "    <br><br>" EOL2 "もし" (CODE1 "defstruct") "フォームがトップレベルフォームとして現れたとき、"
     "コンパイラーは構造体の型を後続の宣言（例えば" (CODE1 "deftype") "）で" "有効な型として認識できるようにし、構造体のスロットのリーダーを"
     (CODE1 "setf") "で使用可能にしなければなりません。" "さらにコンパイラーは同じファイルで構造体名を参照する" "別の"
     (CODE1 "defstruct") "定義で" (CODE1 ":include") "を使用できるように"
     "構造体の型についての十分な情報を保存しなければなりません。" (CODE1 "defstruct") "が生成する関数はコンパイル時の環境で"
     "定義する必要はありませんが、 コンパイラーは後続の" (CODE1 "inline") "呼び出しのために、"
     "関数のコードに関する十分な情報を保存する必要があるかもしれません。" (CODE1 "#S") "リーダーマクロは、コンパイル時に新しく定義された構造体型については"
     "認識するかもしれませんししないかもしれません。")
    (CHAPTER ("## 例文") 2 "構造体の定義の例を下記に示します。"
     (CODE3 "```lisp" "```" "(defstruct ship" "  x-position" "  y-position"
      "  x-velocity" "  y-velocity" "  mass)")
     EOL2 "これは全ての" (CODE1 "ship") "が5つの名前を持った要素持つ" "オブジェクトであると宣言しています。"
     "このフォームの評価は、次のことを行います。" EOL2 "1. " (CODE1 "ship-x-position") "というひとつの引数"
     (CODE1 "ship") "を受け取る関数を定義し、" "   それは" (CODE1 "ship") "の" (CODE1 "x-position")
     "を返却します。" "   " (CODE1 "ship-y-position") "とその他の要素も似たような関数の定義が与えられます。"
     "   これらの関数はアクセス関数と呼ばれ、" "   構造体の要素にアクセスするときに使用されます。" EOL2 "2. " (CODE1 "ship") "は、"
     (CODE1 "ship") "のインスタンスの型の名前になります。" "   " (CODE1 "ship") "は" (CODE1 "typep")
     "で使用可能であり、" "   例えば" (CODE1 "(typep x 'ship)") "は" (CODE1 "x") "が" (CODE1 "ship")
     "のときは" (STRONG "true") "に、" "   " (CODE1 "x") "が" (CODE1 "ship") "以外のオブジェクトのときは"
     (STRONG "false") "になります。" EOL2 "3. " (CODE1 "ship-p") "という名前のひとつの引数を取る関数が定義されます。"
     "   これは" (CODE1 "predicate") "であり、引数が" (CODE1 "ship") "のときは" (STRONG "true") "を、"
     "   それ以外のときは" (STRONG "false") "を返却します。" EOL2 "4. " (CODE1 "make-ship")
     "と呼ばれる関数が定義され、" "   起動されると5つの要素を持つ構造体のデータが作成されます。" "   各要素にはアクセス関数を使うのが適切です。"
     "   下記の実行がなされたとき、" (CODE3 "```lisp" "```" "(setq ship2 (make-ship))") EOL2 "- "
     (CODE1 "ship2") "には新しい" (CODE1 "ship") "オブジェクトがセットされます。" "  初期値を希望する要素に供給したい場合は、"
     "  " (CODE1 "make-ship") "の呼び出しにキーワード引数を使います。" "  例えば下記の通り。"
     (CODE3 "```lisp" "```" "(setq ship2 (make-ship :mass *default-ship-mass*"
      "                       :x-position 0" "                       :y-position 0))")
     EOL2 "- これは新しい" (CODE1 "ship") "が構築され、3つの要素に初期化されます。"
     "  この関数は新しい構造体を作成するので「構築関数」と呼ばれます。" EOL2 "5. " (CODE1 "copy-ship")
     "と呼ばれる引数をひとつ受け取る関数が定義されます。" "   引数が" (CODE1 "ship") "オブジェクトのとき、新しい" (CODE1 "ship")
     "オブジェクトが生成され" "   引数のものをコピーします。この関数は「コピー関数」と呼ばれます。" EOL2 (CODE1 "setf") "は"
     (CODE1 "ship") "の変更可能な要素に使うことができます。"
     (CODE3 "```lisp" "```" "(setf (ship-x-position ship2) 100)") EOL2 "これは"
     (CODE1 "ship2") "の" (CODE1 "x-position") "を" (CODE1 "100") "に変更しています。" "これは"
     (CODE1 "defstruct") "の動作として、" "各アクセス関数に対して" (CODE1 "defsetf") "を適用するように"
     "生成しているので動作します。"
     (CODE3 "```lisp" "```" ";;;" ";;; 例1" ";;; 構造体型townの定義"
      ";;; area, watertowers, firetrucks, population, elevation が要素" ";;;"
      "(defstruct town" "            area" "            watertowers"
      "            (firetrucks 1 :type fixnum)    ;初期化スロット" "            population "
      "            (elevation 5128 :read-only t)) ;スロットは変更不可" "=>  TOWN" ";townインスタンスの作成"
      "(setq town1 (make-town :area 0 :watertowers 0)) =>  #S(TOWN...)"
      ";townのpredicateは新しいインスタンスを認識できる" "(town-p town1) =>  true"
      ";新しいtownのareaはmake-townによって設定" "(town-area town1) =>  0" ";新しいtownのelevationは初期値"
      "(town-elevation town1) =>  5128" ";setfはリーダー関数を認識できる"
      "(setf (town-population town1) 99) =>  99" "(town-population town1) =>  99"
      ";コピー関数はtown1のコピーを作る" "(setq town2 (copy-town town1)) =>  #S(TOWN...)"
      "(= (town-population town1) (town-population town2))  =>  true"
      ";elevationは読み込み専用スロットなのでこの値は" ";構造体が作成されたときのみ設定できる"
      "(setq town3 (make-town :area 0 :watertowers 3 :elevation 1200))" "=>  #S(TOWN...)"
      ";;;" ";;; 例2" ";;; 構造体型clownの定義" ";;; この構造体は非標準のprefixを使う" ";;;"
      "(defstruct (clown (:conc-name bozo-))" "            (nose-color 'red)         "
      "            frizzy-hair-p polkadots) =>  CLOWN"
      "(setq funny-clown (make-clown)) =>  #S(CLOWN)" ";非標準のリーダーの名前を使う"
      "(bozo-nose-color funny-clown) =>  RED        "
      "(defstruct (klown (:constructor make-up-klown) ;キーワードの変更以外は"
      "            (:copier clone-klown)              ;似たような定義"
      "            (:predicate is-a-bozo-p))"
      "            nose-color frizzy-hair-p polkadots) =>  klown" ";変更した構築関数が今存在する"
      "(fboundp 'make-up-klown) =>  true" ";;;" ";;; 例3" ";;; 構造体型vehicleの定義"
      ";;; その後vehicle構造体をincludeした" ";;; truck構造体を定義する" ";;;"
      "(defstruct vehicle name year (diesel t :read-only t)) =>  VEHICLE"
      "(defstruct (truck (:include vehicle (year 79)))"
      "            load-limit                          "
      "            (axles 6)) =>  TRUCK"
      "(setq x (make-truck :name 'mac :diesel t :load-limit 17))" "=>  #S(TRUCK...)"
      ";vehicleリーダーがtruckで動作する" "(vehicle-name x)" "=>  MAC" ";デフォルト値は:include項指定のもの"
      "(vehicle-year x)" "=>  79 "
      "(defstruct (pickup (:include truck))     ;pickup型はtruckをinclude"
      "            camper long-bed four-wheel-drive) =>  PICKUP"
      "(setq x (make-pickup :name 'king :long-bed t)) =>  #S(PICKUP...)"
      ";:includeのデフォルト値は継承されたもの" "(pickup-year x) =>  79" ";;;" ";;; 例4" ";;; BOA構築の使用"
      ";;;" "(defstruct (dfs-boa                      ;BOA構築"
      "              (:constructor make-dfs-boa (a b c)) "
      "              (:constructor create-dfs-boa"
      "                (a &optional b (c 'cc) &rest d &aux e (f 'ff))))"
      "            a b c d e f) =>  DFS-BOA" ";a, b, cは位置によって設定し、&restは初期化しない"
      "(setq x (make-dfs-boa 1 2 3)) =>  #(DFS-BOA...)" "(dfs-boa-a x) =>  1"
      ";aとbはセット、cとfはデフォルト" ";a and b set, c and f defaulted"
      "(setq x (create-dfs-boa 1 2)) =>  #(DFS-BOA...)" "(dfs-boa-b x) =>  2"
      "(eq (dfs-boa-c x) 'cc) =>  true" ";a, b, cはセット、&restはdに集められている"
      "(setq x (create-dfs-boa 1 2 3 4 5 6)) =>  #(DFS-BOA...)"
      "(dfs-boa-d x) =>  (4 5 6)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし2つのスロットの名前が" "（直接現れたか、" (CODE1 ":include")
     "オプションによって継承されたかに関わらず）" (CODE1 "string=") "で等しいときは、" (CODE1 "defstruct") "は型"
     (CODE1 "program-error") "のエラーが発生します。" EOL2 (STRONG "included-structure-name")
     "が構造体型の名前ではないときの結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "documentation") "," (CODE1 "print-object") ","
     (CODE1 "setf") "," (CODE1 "subtypep") "," (CODE1 "type-of") "," (CODE1 "typep") ","
     "3.2. コンパイル")
    (CHAPTER ("## 備考") 2 (STRONG "printer-name") "はプリンターを制御する" (CODE1 "*print-escape*")
     "のような変数を見なければなりません。" EOL2 (STRONG "slot-initform") "と対応するスロットの" (CODE1 ":type")
     "オプション間では、" "型の不一致による警告を禁止する必要があります。" "なぜなら、スロットオプションを指定するために"
     (STRONG "slot-initform") "を指定する必要があり、" "場合よっては適切なデフォルト値が存在しないかもしれません。" EOL2
     (CODE1 "defstruct") "が" (CODE1 "setf") "の使用による" "スロットのアクセッサを変更する仕組みは" "実装依存です。"
     "例えば、これは" (CODE1 "setf") "関数か、" (CODE1 "setf") "展開か、" "あるいはその他の" (CODE1 "setf")
     "への実装コードとして知られている" "実装依存の仕組みなどが使われます。")))
(setf (gethash '("DEFSTRUCT" . "MACRO") *table*) (gethash "DEFSTRUCT" *table*))
(setf (gethash "DEFTYPE" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFTYPE"))
    (CHAPTER ("## 構文") 2 (CODE1 "deftype") " " (STRONG "name") " " (STRONG "lambda-list")
     " [[" (STRONG "declaration\\*") " " (CODE1 "|") " " (STRONG "documentation") "]] "
     (STRONG "form\\*") " => " (STRONG "name"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - シンボル" EOL1 (STRONG "lambda-list") " - "
     (CODE1 "deftype") "ラムダリスト" EOL1 (STRONG "declaration") " - 宣言式。評価されません。" EOL1
     (STRONG "documentation") " - 文字列。評価されません。" EOL1 (STRONG "form") " - フォーム")
    (CHAPTER ("## 定義") 2 (CODE1 "deftype") "は" (STRONG "name") "という名前の派生した型指定子を定義します。"
     "新しい型指定子の意味は、" "その型指定子を別の型指定子に展開する関数で与えられ、" "展開されたもの自身が別の派生された型指定子の参照を"
     "含んでいればさらに展開されます。" EOL2 "新しく定義された型指定子は、" (CODE1 "(name arg1 arg2 ...)") "というフォームを"
     "リストとして受け取り参照します。" "引数の数は" (STRONG "lambda-list") "に適合しなければなりません。"
     "もし新しい型指定子が引数を取らないか、" "全ての引数がオプションのときは、" "その型指定子は原始的な型指定子として使われます" "（つまり"
     (CODE1 "(name)") "のかわりに" (CODE1 "name") "が使用できます）。" EOL2 "引数の式である、型指定子, "
     (CODE1 "arg1") ", ..., " (CODE1 "argn") "は評価されません。" "かわりにこれらのリテラルオブジェクトは"
     "対応するパラメーターに束縛されたオブジェクトになります。" EOL2 (CODE1 "deftype") "フォームのボディ部（ただし"
     (STRONG "lambda-list") "は除く）は、" "暗黙的に" (STRONG "name") "という名前の" (CODE1 "block")
     "に囲まれ、" "暗黙のprognとして評価され、" "新しい型指定子を返却します。" EOL2 "ボディ部のレキシカルな環境は、" (CODE1 "deftype")
     "フォームが評価された時点のものであり、" (STRONG "lambda-list") "の変数によって拡張されます。" EOL2 "型指定子の再帰展開は、"
     "その型指定子についてネストされた展開も含めて、" "展開結果を返却して終了しなければなりません。" EOL2
     "型指定子を全展開した結果に循環構造が含まれているときは、" "それが" (CODE1 "member") "か" (CODE1 "eql")
     "型指定子で参照されている" "オブジェクト内に含まれているのではない場合、結果は未定義です。" EOL2 (STRONG "documentation")
     "はドキュメント文字の種類" (CODE1 "type") "として" (STRONG "name") "に割り当てられます。" EOL2 "もし"
     (CODE1 "deftype") "フォームがトップレベルフォームとして現れたとき、" "コンパイラーは後に続く型宣言で" (STRONG "name")
     "という名前が" "認識されることを保証しなければなりません。" "プログラマーは後に続く型宣言で" (STRONG "name") "という名前が参照されるとき、"
     (CODE1 "deftype") "フォームのボディ部がコンパイル時に" "評価されることを保証しなければなりません。"
     "型指定子の展開がコンパイル時に完全に定義できないとき" "（おそらく知らない型指定子の展開か、" "コンパイル時の環境で定義されていない関数を指定した"
     (CODE1 "satisfies") "のため）、" "実装は宣言内のその型の参照を無視するか、" "警告を発するか、あるいはその両方かを行うでしょう。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun equidimensional (a)" "  (or (< (array-rank a) 2)"
      "      (apply #'= (array-dimensions a)))) =>  EQUIDIMENSIONAL"
      "(deftype square-matrix (&optional type size)"
      "  `(and (array ,type (,size ,size))"
      "        (satisfies equidimensional))) =>  SQUARE-MATRIX"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "declare") "," (CODE1 "defmacro") ","
     (CODE1 "documentation") "," "4.2.3. 型指定子," "3.4.11. ドキュメント文字と宣言の文脈的な作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DEFTYPE" . "MACRO") *table*) (gethash "DEFTYPE" *table*))
(setf (gethash "DEFUN" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFUN"))
    (CHAPTER ("## 構文") 2 (CODE1 "defun") " " (STRONG "function-name") " "
     (STRONG "lambda-list") " [[" (STRONG "declaration\\*") " " (CODE1 "|") " "
     (STRONG "documentation") "]] " (STRONG "form\\*") EOL1 "=> "
     (STRONG "function-name"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function-name") " - 関数名" EOL1
     (STRONG "lambda-list") " - 通常のラムダリスト" EOL1 (STRONG "declaration") " - 宣言式、評価されません"
     EOL1 (STRONG "documentation") " - 文字列、評価されません" EOL1 (STRONG "form") " - 暗黙のprogn"
     EOL1 (STRONG "block-name") " - " (STRONG "function-name") "の、関数のblock名")
    (CHAPTER ("## 定義") 2 "グローバル環境下で" (STRONG "function-name") "という名前の新しい関数を定義します。"
     "関数のボディ部は、" (CODE1 "defun") "に含まれるフォームによって定義されます。"
     "それは関数が呼ばれたときに、暗黙のprognとして実行されます。" (CODE1 "defun") "は、" "新しい関数を定義するときに使われたり、"
     "正しくない定義の修正したバージョンを導入したり、" "すでに定義されている関数を再定義したり、" "関数としてマクロを再定義するときにも使用できます。" EOL2
     (CODE1 "defun") "は、暗黙的に関数定義のボディ部" (STRONG "form") "を、" (STRONG "block-name")
     "という名前の" (CODE1 "block") "で囲みます" "（しかし" (STRONG "lambda-list") "のフォームは囲みません）。" EOL2
     (STRONG "documentation") "は、ドキュメント文字を名前に対して" (CODE1 "function") "という種類で設定し、"
     "関数オブジェクトにも設定します。" EOL2 (CODE1 "defun") "を評価すると、" "下記のラムダ式を" (CODE1 "defun")
     "が実行された" "レキシカルな環境な環境下で処理し、" "その関数を" (STRONG "function-name") "というグローバルな名前に設定します。"
     (CODE3 "```lisp" "```" " (lambda lambda-list" "   [[declaration* | documentation]]"
      "   (block block-name form*))")
     EOL2 "（引数はマクロ展開時に評価されます）" EOL2 (CODE1 "defun") "は、コンパイル時にはどのような副作用も要求されていません。" "特に"
     (CODE1 "defun") "は、コンパイル時には関数定義を利用可能にしません。" "実装者は、コンパイル時のエラーチェック"
     "（関数呼び出し時の引数の個数チェックなど）のために" "関数についての情報を保存したり、" "関数をインライン展開できるようにすることを選択できます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun recur (x)" " (when (> x 0)"
      "   (recur (1- x)))) =>  RECUR "
      "(defun ex (a b &optional c (d 66) &rest keys &key test (start 0))"
      "   (list a b c d keys test start)) =>  EX " "(ex 1 2) =>  (1 2 NIL 66 NIL NIL 0)"
      "(ex 1 2 3 4 :test 'equal :start 50) "
      "=>  (1 2 3 4 (:TEST EQUAL :START 50) EQUAL 50)"
      "(ex :test 1 :start 2) =>  (:TEST 1 :START 2 NIL NIL 0)" NIL
      ";; この関数は呼び出し側で引数の型チェックを行うことを想定しており" ";; コンパイラーもその仮定を認めています"
      "(defun discriminant (a b c)" "  (declare (number a b c))"
      "  \"Compute the discriminant for a quadratic equation.\""
      "  (- (* b b) (* 4 a c))) =>  DISCRIMINANT" "(discriminant 1 2/3 -2) =>  76/9" NIL
      ";; この関数は呼び出し側で引数の型チェックを行わないと仮定しており" ";; どんな仮定より先に明に型チェックを実行します"
      "(defun careful-discriminant (a b c)"
      "  \"Compute the discriminant for a quadratic equation.\""
      "  (check-type a number)" "  (check-type b number)" "  (check-type c number)"
      "  (locally (declare (number a b c))"
      "    (- (* b b) (* 4 a c)))) =>  CAREFUL-DISCRIMINANT"
      "(careful-discriminant 1 2/3 -2) =>  76/9"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "flet") "," (CODE1 "labels") "," (CODE1 "block") ","
     (CODE1 "return-from") "," (CODE1 "declare") "," (CODE1 "documentation") ","
     "3.1. 評価," "3.4.1. 通常のラムダリスト," "3.4.11. ドキュメント文字と宣言の文脈的な作用")
    (CHAPTER ("## 備考") 2 (CODE1 "return-from") "は、" (CODE1 "defun") "定義の関数を"
     "普通より早く返却したいときに使用することができます。" EOL2 "関数定義に関する追加情報（通常はデバッグ情報）が記録されると、"
     "さらなる副作用が発生する可能性があります。")))
(setf (gethash '("DEFUN" . "MACRO") *table*) (gethash "DEFUN" *table*))
(setf (gethash "DEFVAR" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DEFPARAMETER"))
    (CHAPTER ("## 構文") 2 (CODE1 "defparameter") " " (STRONG "name") " "
     (STRONG "initial-value") " [" (STRONG "documentation") "] => " (STRONG "name") EOL1
     (CODE1 "defvar") " " (STRONG "name") " [" (STRONG "initial-value") " ["
     (STRONG "documentation") "]] => " (STRONG "name"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - シンボル、評価されません。" EOL1
     (STRONG "initial-value") " - フォーム。" (CODE1 "defparameter") "は常に評価されます。" "しかし"
     (CODE1 "defvar") "は" (STRONG "name") "が" (CODE1 "bound") "ではないときのみ評価されます。" EOL1
     (STRONG "documentation") " - 文字列、評価されません。")
    (CHAPTER ("## 定義") 2 (CODE1 "defparameter") "と" (CODE1 "defvar") "は、" (STRONG "name")
     "を動的変数として確立します。" EOL2 (CODE1 "defparameter") "は、" (STRONG "name") "という動的変数に"
     (STRONG "initial-value") "を" "無条件に割り当てます。" "対称的に" (CODE1 "defvar") "は"
     (STRONG "name") "という変数が" (CODE1 "bound") "ではない場合において、" "与えられた"
     (STRONG "initial-value") "の値を割り当てます。" EOL2 (STRONG "initial-value") "が与えられなかったときは、"
     (CODE1 "defvar") "は" (STRONG "name") "の動的変数に手を加えず" "値のセルをそのままにします。" "もし"
     (STRONG "name") "が前に" (CODE1 "bound") "のときは古い値のままにしますし、" "以前の値が" (CODE1 "unbound")
     "であったときは" (CODE1 "unbound") "のままにします。" EOL2 (STRONG "documentation") "が与えられたときは、"
     (STRONG "name") "に対してドキュメント文字を種別" (CODE1 "variable") "として割り当てます。" EOL2
     (CODE1 "defparameter") "と" (CODE1 "defvar") "は通常トップレベルフォームに現れますが、"
     "非トップレベルフォームに現れても意味があります。" "しかし、下記で説明するコンパイル時の副作用は、" (CODE1 "defconstant")
     "がトップレベルフォームとして現れた場所でのみ" "効果があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defparameter *p* 1) =>  *P*" "*p* =>  1"
      "(constantp '*p*) =>  false" "(setq *p* 2) =>  2" "(defparameter *p* 3) =>  *P*"
      "*p* =>  3" NIL "(defvar *v* 1) =>  *V*" "*v* =>  1" "(constantp '*v*) =>  false"
      "(setq *v* 2) =>  2" "(defvar *v* 3) =>  *V*" "*v* =>  2" NIL "(defun foo ()"
      "  (let ((*p* 'p) (*v* 'v))" "    (bar))) =>  FOO"
      "(defun bar () (list *p* *v*)) =>  BAR" "(foo) =>  (P V)")
     EOL2 (CODE1 "defparameter") "と" (CODE1 "defvar") "の主な操作上の違いは、"
     (CODE1 "defparameter") "は" (STRONG "name") "に無条件にアサインするのに対して、" (CODE1 "defvar")
     "は条件付きでそれを行うことにあります。" "実際にこれらは" (CODE1 "defparameter") "はロードやリロード時に"
     "定義で新しい値を変数に設定するときに便利ですし、" (CODE1 "defvar") "の場合はファイルのロードやリロード時に"
     "古い値をそのままにしておきたいときに便利です。" "例として、次のような内容のファイルを示します。"
     (CODE3 "```lisp" "```" "(defvar *the-interesting-numbers* '())"
      "(defmacro define-interesting-number (name n)" "  `(progn (defvar ,name ,n)"
      "          (pushnew ,name *the-interesting-numbers*)" "          ',name))"
      "(define-interesting-number *my-height* 168) ;cm"
      "(define-interesting-number *my-weight* 13)  ;stones")
     EOL2 "この" (CODE1 "*the-interesting-numbers*") "の初期値" (CODE1 "()") "はただの種であり、"
     "一度そこから何かを育てたあとは" "他の何かリセットすることはないでしょう。" "そのため、" (CODE1 "defvar") "を使うことで、"
     "ファイルを二回読み込んだときに" (CODE1 "*interesting-numbers*") "の情報が" "リセットされないようにしています。" "確かに"
     (CODE1 "define-interesting-number") "の" "二回の呼び出しは処理されますが、"
     "しかし他のファイルで追加の呼び出しがあったときは" "その情報が損失することはありません。" "一方、次のコードを見てみます。"
     (CODE3 "```lisp" "```" "(defparameter *default-beep-count* 3)"
      "(defun beep (&optional (n *default-beep-count*))"
      "  (dotimes (i n) (si:%beep 1000. 100000.) (sleep 0.1)))")
     EOL2 "ここでは、コードを編集して" (CODE1 "*default-beep-count*") "の初期値を変更し、"
     "ファイルをリロードして新しい値を取得する" "ということを簡単に想像できます。" "値の更新を簡単にするために" (CODE1 "defparameter")
     "を使用しました。" EOL2 "一方で、このような状況で" (CODE1 "defvar") "を使うことは潜在的な価値があります。" "例えば、誰かが事前に"
     (CODE1 "*default-beep-count*") "の違う値を定義していたとします。"
     "あるいは、ファイルを読み込んでからその値を手動で変更したとします。" "どちらの場合でも、" (CODE1 "defparameter") "のかわりに"
     (CODE1 "defvar") "を使用していれば、" "ファイルのロード・リロードを行っても" "それらのユーザーの好みは上書きされることはありません。" EOL2
     (CODE1 "defvar") "と" (CODE1 "defparameter") "のどちらを選んでも、" "プログラムには目に見える結果をもたらしますが、"
     "それにもかかわらず主観的な理由で選択されることがあります。")
    (CHAPTER ("## 副作用") 2 "もし" (CODE1 "defvar") "か" (CODE1 "defparameter") "が"
     "トップレベルフォームとして現れたときは、" "コンパイラーは" (STRONG "name") "を" (CODE1 "special") "として"
     (CODE1 "proclaim") "されるよう" "認識しなければなりません。" "しかし、コンパイル時に" (STRONG "initial-value")
     "フォームが評価されたり、" (STRONG "name") "という動的変数に代入してはいけません。" EOL2 "適合するプログラムの正しい動作を妨げない限り、"
     "コンパイル時または実行時に、" "追加の（実装で定義された）副作用があってもかまいません。")
    (CHAPTER ("## 影響") 2 (CODE1 "defvar") "は、" (STRONG "name") "が" (CODE1 "bound")
     "であるかどうかに影響されます。")
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "declaim") "," (CODE1 "defconstant") ","
     (CODE1 "documentation") "," "3.2. コンパイル")
    (CHAPTER ("## 備考") 2 "慣習として動的変数の名前には" "始まりと終わりにアスタリスクを付けたものが使われます。" "例えば"
     (CODE1 "*foo*") "は良い動的変数の名前ですが、" "レキシカル変数には使われません。" (CODE1 "foo")
     "であれば良いレキシカル変数の名前になりますが、" "動的変数には使われません。" "この命名規則は、Common Lisp内に定義されたすべての名前で見られますが、"
     "適合するプログラムも適合する実装もこの規則を遵守する義務はありません。" EOL2 "追加で副作用が許可される理由は、"
     "実装がその定義に付随する通常の「帳簿管理」を行えるようにすることです。" "例えば、" (CODE1 "defvar") "と"
     (CODE1 "defparameter") "フォームのマクロ展開には、" "定義が記載されているソースファイルの名前を記録するためにアレンジした"
     "コードが含まれるかもしれません。" EOL2 (CODE1 "defparameter") "と" (CODE1 "defvar") "は下記のように定義されます。"
     (CODE3 "```lisp" "```" "(defmacro defparameter (name initial-value "
      "                        &optional (documentation nil documentation-p))"
      "  `(progn (declaim (special ,name))"
      "          (setf (symbol-value ',name) ,initial-value)"
      "          ,(when documentation-p"
      "             `(setf (documentation ',name 'variable) ',documentation))"
      "          ',name))" "(defmacro defvar (name &optional"
      "                       (initial-value nil initial-value-p)"
      "                       (documentation nil documentation-p))"
      "  `(progn (declaim (special ,name))" "          ,(when initial-value-p"
      "             `(unless (boundp ',name)"
      "                (setf (symbol-value ',name) ,initial-value)))"
      "          ,(when documentation-p"
      "             `(setf (documentation ',name 'variable) ',documentation))"
      "          ',name))"))))
(setf (gethash '("DEFVAR" . "MACRO") *table*) (gethash "DEFVAR" *table*))
(setf (gethash "DELETE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "REMOVE"))
    (CHAPTER ("## 構文") 2 (CODE1 "remove") " " (STRONG "item") " " (STRONG "sequence")
     " &key " (STRONG "from-end") " " (STRONG "test") " " (STRONG "test-not") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "remove-if") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "remove-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "delete") " " (STRONG "item") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "test") " "
     (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") " => " (STRONG "result-sequence") EOL1 (CODE1 "delete-if") " "
     (STRONG "predicate") " " (STRONG "sequence") " &key " (STRONG "from-end") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "delete-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL2 (STRONG "sequence")
     " - 正常なシーケンス" EOL1 (STRONG "predicate") " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子"
     EOL1 (STRONG "from-end") " - generalized-boolean、デフォルトは" (STRONG "false") EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "count")
     " - 整数か" (CODE1 "nil") "。デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "result-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "remove") "、" (CODE1 "remove-if") "、"
     (CODE1 "remove-if-not") "は、" (STRONG "sequence") "からテストを満たした要素を削除したものを返却します。" EOL2
     (CODE1 "delete") "、" (CODE1 "delete-if") "、" (CODE1 "delete-if-not") "は、" "それぞれ"
     (CODE1 "remove") "、" (CODE1 "remove-if") "、" (CODE1 "remove-if-not") "に"
     "似ていますが、これらは" (STRONG "sequence") "を修正します。" EOL2 "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のとき、返却値は" (CODE1 "vector") "であり、" (STRONG "sequence")
     "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence") "がリストなら、返却値はリストです。" EOL2
     (STRONG "from-end") "が" (STRONG "true") "のときは、" "ただ" (STRONG "count")
     "が指定されたときが重要になります。" "このような場合、右端から（左端ではなく）テストを満たす" (STRONG "count") "の要素だけが削除されます。"
     EOL2 (STRONG "count") "が与えられたとき、削除する要素数を制限できます。" "もしテストを満たす要素が" (STRONG "count")
     "を越えていたときは、" "それらの要素は左端か右端（" (STRONG "from-end") "の値による）から、" "ただ" (STRONG "count")
     "で指定された数だけ削除されます。" "もし" (STRONG "count") "負の値が指定されたときは、" (CODE1 "0")
     "が指定されたかのようにふるまいます。" "もし" (STRONG "count") "が" (CODE1 "nil") "のときは、" (STRONG "item")
     "にマッチした全てに影響します。" EOL2 "これらの全ての関数は、削除されなかった要素は、" "結果内に" (STRONG "sequence")
     "と同じ順序で現れます。" EOL2 (CODE1 "remove") "、" (CODE1 "remove-if") "、"
     (CODE1 "remove-if-not") "は、" (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start")
     ", " (STRONG "end") "に囲まれたサブシーケンスのテストを満たし" "削除されたもの以外は同じ要素を返却します。" "これは非破壊的な操作です。"
     "もし要素の削除が必要になった時は、コピーが返却されます。" (CODE1 "remove") "の返却値は、" (STRONG "sequence")
     "を共有するかもしれません。" "もし要素に削除が生じなかったときは、" "入力の" (STRONG "sequence")
     "と同一のものが返却される可能性があります。" EOL2 (CODE1 "delete") "、" (CODE1 "delete-if") "、"
     (CODE1 "delete-if-not") "は、" (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start")
     ", " (STRONG "end") "に囲まれたサブシーケンスのテストを満たし" "削除されたもの以外は同じ要素を返却します。"
     (STRONG "sequence") "は返却値の構築のために破壊されるかもしれません。" "しかし、返却値は" (STRONG "sequence")
     "と同一の場合もあれば、" "そうではない場合もあります。" EOL2 (CODE1 "delete") "は、" (STRONG "sequence")
     "がリストのときは、" (STRONG "sequence") "のトップレベルのリスト構造の" "どの" (CODE1 "car") ", "
     (CODE1 "cdr") "でも" (CODE1 "setf") "することが許されています。" "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のときは、" (CODE1 "delete") "は" (CODE1 "vector") "の次元を変更し、"
     "その要素を並べ替えをせず、新しい位置にスライドして" "返却値の" (CODE1 "vector") "を構築することが許されています。" EOL2
     "delete-ifは以下のように正確に動作するように制約されています。"
     (CODE3 "```lisp" "```" " (delete nil sequence"
      "             :test #'(lambda (ignore item) (funcall test item))"
      "             ...)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(remove 4 '(1 3 4 5 9)) =>  (1 3 5 9)"
      "(remove 4 '(1 2 4 1 3 4 5)) =>  (1 2 1 3 5)"
      "(remove 4 '(1 2 4 1 3 4 5) :count 1) =>  (1 2 1 3 4 5)"
      "(remove 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) =>  (1 2 4 1 3 5)"
      "(remove 3 '(1 2 4 1 3 4 5) :test #'>) =>  (4 3 4 5)"
      "(setq lst '(list of four elements)) =>  (LIST OF FOUR ELEMENTS)"
      "(setq lst2 (copy-seq lst)) =>  (LIST OF FOUR ELEMENTS)"
      "(setq lst3 (delete 'four lst)) =>  (LIST OF ELEMENTS)"
      "(equal lst lst2) =>  false" "(remove-if #'oddp '(1 2 4 1 3 4 5)) =>  (2 4 4)"
      "(remove-if #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t) " "=>  (1 2 4 1 3 5)"
      "(remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9) :count 2 :from-end t)"
      "=>  (1 2 3 4 5 6 8)" "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester) =>  (1 2 1 3 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester :count 1) =>  (1 2 1 3 4 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester :count 1 :from-end t) =>  (1 2 4 1 3 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 3 tester :test #'>) =>  (4 3 4 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete-if #'oddp tester) =>  (2 4 4)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete-if #'evenp tester :count 1 :from-end t) =>  (1 2 4 1 3 5)    "
      "(setq tester (list 1 2 3 4 5 6)) =>  (1 2 3 4 5 6) "
      "(delete-if #'evenp tester) =>  (1 3 5) " "tester =>  implementation-dependent"
      "(setq foo (list 'a 'b 'c)) =>  (A B C)" "(setq bar (cdr foo)) =>  (B C)"
      "(setq foo (delete 'b foo)) =>  (A C)" "bar =>  ((C)) or ..."
      "(eq (cdr foo) (car bar)) =>  T or ..."))
    (CHAPTER ("## 副作用") 2 (CODE1 "delete") "、" (CODE1 "delete-if") "、"
     (CODE1 "delete-if-not") "の場合、" (STRONG "sequence") "は返却値の構築のために破壊されるかもしれません。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "返却値は"
     (CODE1 "simple") "かもしれませんし、そうでないかもしれません。" "また、返却値は" (STRONG "sequence")
     "と同一かもしれませんし、" "そうでないかもしれません。" EOL2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "delete-if-not") "と" (CODE1 "remove-if-not") "は非推奨です。")))
(setf (gethash '("DELETE" . "FUNCTION") *table*) (gethash "DELETE" *table*))
(setf (gethash "DELETE-DUPLICATES" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "REMOVE-DUPLICATES") ", "
     (CODE1 "DELETE-DUPLICATES"))
    (CHAPTER ("## 構文") 2 (CODE1 "remove-duplicates") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "test") " " (STRONG "test-not") " " (STRONG "start")
     " " (STRONG "end") " " (STRONG "key") EOL1 "=> " (STRONG "result-sequence") EOL2
     (CODE1 "delete-duplicates") " " (STRONG "sequence") " &key " (STRONG "from-end") " "
     (STRONG "test") " " (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " "
     (STRONG "key") EOL1 "=> " (STRONG "result-sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "sequence") " - 正常なシーケンス" EOL1 (STRONG "from-end")
     " - generalized-boolean、デフォルトは" (STRONG "false") EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "result-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "remove-duplicates") "は、" "他の要素とマッチするような要素を削除した"
     (STRONG "sequence") "のコピーを返却します。" EOL2 "もし" (STRONG "sequence") "が" (CODE1 "vector")
     "のとき、返却値は" (CODE1 "vector") "であり、" (STRONG "sequence") "と同じ実際の配列の要素の型を持ちます。" "もし"
     (STRONG "sequence") "がリストなら、返却値はリストです。" EOL2 (STRONG "sequence") "の要素は対で比較され、"
     "どれか2つが一致すれば、先に発生したものが捨てられます。" "ただし，" (STRONG "from-end") "が" (STRONG "true")
     "の場合は、" "後に発生したものが捨てられます。" EOL2 (CODE1 "remove-duplicates") "と"
     (CODE1 "delete-duplicates") "は、" (STRONG "sequence") "と同じ型のシーケンスに、"
     "残りのどの2つの要素にもマッチしないように、" "十分に要素取り除いた内容のものを返却します。" "返却値に残った要素の順序は、"
     (STRONG "sequence") "に現れるものと同じです。" EOL2 (CODE1 "remove-duplicates") "の返却値は、"
     (STRONG "sequence") "を共有するかもしれません。" "もし要素に削除が生じなかったときは、" "入力の" (STRONG "sequence")
     "と同一のものが返却される可能性があります。" EOL2 (CODE1 "delete-duplicates") "は、" (STRONG "sequence")
     "がリストのときは、" (STRONG "sequence") "のトップレベルのリスト構造の" "どの" (CODE1 "car") ", "
     (CODE1 "cdr") "でも" (CODE1 "setf") "することが許されています。" "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のときは、" (CODE1 "delete-duplicates") "は" (CODE1 "vector") "の次元を変更し、"
     "その要素を並べ替えをせず、新しい位置にスライドして" "返却値の" (CODE1 "vector") "を構築することが許されています。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(remove-duplicates \"aBcDAbCd\" :test #'char-equal :from-end t) =>  \"aBcD\""
      "(remove-duplicates '(a b c b d d e)) =>  (A C B D E)"
      "(remove-duplicates '(a b c b d d e) :from-end t) =>  (A B C D E)"
      "(remove-duplicates '((foo #\\a) (bar #\\%) (baz #\\A))"
      "    :test #'char-equal :key #'cadr) =>  ((BAR #\\%) (BAZ #\\A))"
      "(remove-duplicates '((foo #\\a) (bar #\\%) (baz #\\A)) "
      "    :test #'char-equal :key #'cadr :from-end t) =>  ((FOO #\\a) (BAR #\\%))"
      "(setq tester (list 0 1 2 3 4 5 6))"
      "(delete-duplicates tester :key #'oddp :start 1 :end 6) =>  (0 4 5 6)"))
    (CHAPTER ("## 副作用") 2 (CODE1 "delete-duplicates") "は、" (STRONG "sequence")
     "を破壊的に修正するかもしれません。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "返却値は"
     (CODE1 "simple") "かもしれませんし、そうでないかもしれません。" "また、返却値は" (STRONG "sequence")
     "と同一かもしれませんし、" "そうでないかもしれません。" EOL2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2
     "これらの関数は、" (STRONG "sequence") "を集合で表現される" "標準形に変換するのに便利です。")))
(setf (gethash '("DELETE-DUPLICATES" . "FUNCTION") *table*) (gethash "DELETE-DUPLICATES" *table*))
(setf (gethash "DELETE-FILE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "DELETE-FILE"))
    (CHAPTER ("## 構文") 2 (CODE1 "delete-file") " " (STRONG "filespec") " => "
     (CODE1 "t"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "filespec") " - パス名指定子")
    (CHAPTER ("## 定義") 2 (STRONG "filespec") "で指定されたファイルを削除します。" EOL2 "もし"
     (STRONG "filespec") "の指定子が開いたストリームのとき、" (STRONG "filespec") "と関連付けられたファイルに影響を及ぼします"
     "（もしファイルシステムが許容するなら）。" "このような場合、" (STRONG "filespec") "は即座に閉じられ、" "削除がすぐに発生するか、"
     "あるいは" (STRONG "filespec") "が暗に閉じられるまで削除を遅らせるかは、" "ファイルシステムの要求に依存します。" EOL2
     "存在しないファイルの削除を実行したときに、" "成功するかどうかは実装依存です。" EOL2 (CODE1 "delete-file") "は継続可能なら"
     (STRONG "true") "を返却し、" "そうではないときは型" (CODE1 "file-error") "のエラーが発生します。" EOL2
     (STRONG "filespec") "にワイルドカードの要素が含まれるとき、" "または" (STRONG "filespec") "が"
     (CODE1 "nil") "の要素を持っており、" "ファイルシステムが" (CODE1 "nil") "の要素を" "許容していないときの結果は未定義です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(with-open-file (s \"delete-me.text\" :direction :output :if-exists :error))"
      "=>  NIL"
      "(setq p (probe-file \"delete-me.text\")) =>  #P\"R:>fred>delete-me.text.1\""
      "(delete-file p) =>  T" "(probe-file \"delete-me.text\") =>  false"
      "(with-open-file (s \"delete-me.text\" :direction :output :if-exists :error)"
      "  (delete-file s))" "=>  T" "(probe-file \"delete-me.text\") =>  false"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし削除処理が成功しなかったときは、" "型" (CODE1 "file-error") "のエラーが発生します。" EOL2
     "もし" (STRONG "filespec") "がワイルドカードを含んでいたときは、" "型" (CODE1 "file-error")
     "のエラーが発生するかもしれません。")
    (CHAPTER ("## 参考") 2 (CODE1 "pathname") "," (CODE1 "logical-pathname") ","
     "20.1. ファイルシステムの説明," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DELETE-FILE" . "FUNCTION") *table*) (gethash "DELETE-FILE" *table*))
(setf (gethash "DELETE-IF" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "REMOVE"))
    (CHAPTER ("## 構文") 2 (CODE1 "remove") " " (STRONG "item") " " (STRONG "sequence")
     " &key " (STRONG "from-end") " " (STRONG "test") " " (STRONG "test-not") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "remove-if") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "remove-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "delete") " " (STRONG "item") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "test") " "
     (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") " => " (STRONG "result-sequence") EOL1 (CODE1 "delete-if") " "
     (STRONG "predicate") " " (STRONG "sequence") " &key " (STRONG "from-end") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "delete-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL2 (STRONG "sequence")
     " - 正常なシーケンス" EOL1 (STRONG "predicate") " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子"
     EOL1 (STRONG "from-end") " - generalized-boolean、デフォルトは" (STRONG "false") EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "count")
     " - 整数か" (CODE1 "nil") "。デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "result-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "remove") "、" (CODE1 "remove-if") "、"
     (CODE1 "remove-if-not") "は、" (STRONG "sequence") "からテストを満たした要素を削除したものを返却します。" EOL2
     (CODE1 "delete") "、" (CODE1 "delete-if") "、" (CODE1 "delete-if-not") "は、" "それぞれ"
     (CODE1 "remove") "、" (CODE1 "remove-if") "、" (CODE1 "remove-if-not") "に"
     "似ていますが、これらは" (STRONG "sequence") "を修正します。" EOL2 "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のとき、返却値は" (CODE1 "vector") "であり、" (STRONG "sequence")
     "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence") "がリストなら、返却値はリストです。" EOL2
     (STRONG "from-end") "が" (STRONG "true") "のときは、" "ただ" (STRONG "count")
     "が指定されたときが重要になります。" "このような場合、右端から（左端ではなく）テストを満たす" (STRONG "count") "の要素だけが削除されます。"
     EOL2 (STRONG "count") "が与えられたとき、削除する要素数を制限できます。" "もしテストを満たす要素が" (STRONG "count")
     "を越えていたときは、" "それらの要素は左端か右端（" (STRONG "from-end") "の値による）から、" "ただ" (STRONG "count")
     "で指定された数だけ削除されます。" "もし" (STRONG "count") "負の値が指定されたときは、" (CODE1 "0")
     "が指定されたかのようにふるまいます。" "もし" (STRONG "count") "が" (CODE1 "nil") "のときは、" (STRONG "item")
     "にマッチした全てに影響します。" EOL2 "これらの全ての関数は、削除されなかった要素は、" "結果内に" (STRONG "sequence")
     "と同じ順序で現れます。" EOL2 (CODE1 "remove") "、" (CODE1 "remove-if") "、"
     (CODE1 "remove-if-not") "は、" (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start")
     ", " (STRONG "end") "に囲まれたサブシーケンスのテストを満たし" "削除されたもの以外は同じ要素を返却します。" "これは非破壊的な操作です。"
     "もし要素の削除が必要になった時は、コピーが返却されます。" (CODE1 "remove") "の返却値は、" (STRONG "sequence")
     "を共有するかもしれません。" "もし要素に削除が生じなかったときは、" "入力の" (STRONG "sequence")
     "と同一のものが返却される可能性があります。" EOL2 (CODE1 "delete") "、" (CODE1 "delete-if") "、"
     (CODE1 "delete-if-not") "は、" (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start")
     ", " (STRONG "end") "に囲まれたサブシーケンスのテストを満たし" "削除されたもの以外は同じ要素を返却します。"
     (STRONG "sequence") "は返却値の構築のために破壊されるかもしれません。" "しかし、返却値は" (STRONG "sequence")
     "と同一の場合もあれば、" "そうではない場合もあります。" EOL2 (CODE1 "delete") "は、" (STRONG "sequence")
     "がリストのときは、" (STRONG "sequence") "のトップレベルのリスト構造の" "どの" (CODE1 "car") ", "
     (CODE1 "cdr") "でも" (CODE1 "setf") "することが許されています。" "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のときは、" (CODE1 "delete") "は" (CODE1 "vector") "の次元を変更し、"
     "その要素を並べ替えをせず、新しい位置にスライドして" "返却値の" (CODE1 "vector") "を構築することが許されています。" EOL2
     "delete-ifは以下のように正確に動作するように制約されています。"
     (CODE3 "```lisp" "```" " (delete nil sequence"
      "             :test #'(lambda (ignore item) (funcall test item))"
      "             ...)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(remove 4 '(1 3 4 5 9)) =>  (1 3 5 9)"
      "(remove 4 '(1 2 4 1 3 4 5)) =>  (1 2 1 3 5)"
      "(remove 4 '(1 2 4 1 3 4 5) :count 1) =>  (1 2 1 3 4 5)"
      "(remove 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) =>  (1 2 4 1 3 5)"
      "(remove 3 '(1 2 4 1 3 4 5) :test #'>) =>  (4 3 4 5)"
      "(setq lst '(list of four elements)) =>  (LIST OF FOUR ELEMENTS)"
      "(setq lst2 (copy-seq lst)) =>  (LIST OF FOUR ELEMENTS)"
      "(setq lst3 (delete 'four lst)) =>  (LIST OF ELEMENTS)"
      "(equal lst lst2) =>  false" "(remove-if #'oddp '(1 2 4 1 3 4 5)) =>  (2 4 4)"
      "(remove-if #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t) " "=>  (1 2 4 1 3 5)"
      "(remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9) :count 2 :from-end t)"
      "=>  (1 2 3 4 5 6 8)" "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester) =>  (1 2 1 3 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester :count 1) =>  (1 2 1 3 4 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester :count 1 :from-end t) =>  (1 2 4 1 3 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 3 tester :test #'>) =>  (4 3 4 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete-if #'oddp tester) =>  (2 4 4)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete-if #'evenp tester :count 1 :from-end t) =>  (1 2 4 1 3 5)    "
      "(setq tester (list 1 2 3 4 5 6)) =>  (1 2 3 4 5 6) "
      "(delete-if #'evenp tester) =>  (1 3 5) " "tester =>  implementation-dependent"
      "(setq foo (list 'a 'b 'c)) =>  (A B C)" "(setq bar (cdr foo)) =>  (B C)"
      "(setq foo (delete 'b foo)) =>  (A C)" "bar =>  ((C)) or ..."
      "(eq (cdr foo) (car bar)) =>  T or ..."))
    (CHAPTER ("## 副作用") 2 (CODE1 "delete") "、" (CODE1 "delete-if") "、"
     (CODE1 "delete-if-not") "の場合、" (STRONG "sequence") "は返却値の構築のために破壊されるかもしれません。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "返却値は"
     (CODE1 "simple") "かもしれませんし、そうでないかもしれません。" "また、返却値は" (STRONG "sequence")
     "と同一かもしれませんし、" "そうでないかもしれません。" EOL2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "delete-if-not") "と" (CODE1 "remove-if-not") "は非推奨です。")))
(setf (gethash '("DELETE-IF" . "FUNCTION") *table*) (gethash "DELETE-IF" *table*))
(setf (gethash "DELETE-IF-NOT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "REMOVE"))
    (CHAPTER ("## 構文") 2 (CODE1 "remove") " " (STRONG "item") " " (STRONG "sequence")
     " &key " (STRONG "from-end") " " (STRONG "test") " " (STRONG "test-not") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "remove-if") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "remove-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "delete") " " (STRONG "item") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "test") " "
     (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") " => " (STRONG "result-sequence") EOL1 (CODE1 "delete-if") " "
     (STRONG "predicate") " " (STRONG "sequence") " &key " (STRONG "from-end") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "delete-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL2 (STRONG "sequence")
     " - 正常なシーケンス" EOL1 (STRONG "predicate") " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子"
     EOL1 (STRONG "from-end") " - generalized-boolean、デフォルトは" (STRONG "false") EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "count")
     " - 整数か" (CODE1 "nil") "。デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "result-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "remove") "、" (CODE1 "remove-if") "、"
     (CODE1 "remove-if-not") "は、" (STRONG "sequence") "からテストを満たした要素を削除したものを返却します。" EOL2
     (CODE1 "delete") "、" (CODE1 "delete-if") "、" (CODE1 "delete-if-not") "は、" "それぞれ"
     (CODE1 "remove") "、" (CODE1 "remove-if") "、" (CODE1 "remove-if-not") "に"
     "似ていますが、これらは" (STRONG "sequence") "を修正します。" EOL2 "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のとき、返却値は" (CODE1 "vector") "であり、" (STRONG "sequence")
     "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence") "がリストなら、返却値はリストです。" EOL2
     (STRONG "from-end") "が" (STRONG "true") "のときは、" "ただ" (STRONG "count")
     "が指定されたときが重要になります。" "このような場合、右端から（左端ではなく）テストを満たす" (STRONG "count") "の要素だけが削除されます。"
     EOL2 (STRONG "count") "が与えられたとき、削除する要素数を制限できます。" "もしテストを満たす要素が" (STRONG "count")
     "を越えていたときは、" "それらの要素は左端か右端（" (STRONG "from-end") "の値による）から、" "ただ" (STRONG "count")
     "で指定された数だけ削除されます。" "もし" (STRONG "count") "負の値が指定されたときは、" (CODE1 "0")
     "が指定されたかのようにふるまいます。" "もし" (STRONG "count") "が" (CODE1 "nil") "のときは、" (STRONG "item")
     "にマッチした全てに影響します。" EOL2 "これらの全ての関数は、削除されなかった要素は、" "結果内に" (STRONG "sequence")
     "と同じ順序で現れます。" EOL2 (CODE1 "remove") "、" (CODE1 "remove-if") "、"
     (CODE1 "remove-if-not") "は、" (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start")
     ", " (STRONG "end") "に囲まれたサブシーケンスのテストを満たし" "削除されたもの以外は同じ要素を返却します。" "これは非破壊的な操作です。"
     "もし要素の削除が必要になった時は、コピーが返却されます。" (CODE1 "remove") "の返却値は、" (STRONG "sequence")
     "を共有するかもしれません。" "もし要素に削除が生じなかったときは、" "入力の" (STRONG "sequence")
     "と同一のものが返却される可能性があります。" EOL2 (CODE1 "delete") "、" (CODE1 "delete-if") "、"
     (CODE1 "delete-if-not") "は、" (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start")
     ", " (STRONG "end") "に囲まれたサブシーケンスのテストを満たし" "削除されたもの以外は同じ要素を返却します。"
     (STRONG "sequence") "は返却値の構築のために破壊されるかもしれません。" "しかし、返却値は" (STRONG "sequence")
     "と同一の場合もあれば、" "そうではない場合もあります。" EOL2 (CODE1 "delete") "は、" (STRONG "sequence")
     "がリストのときは、" (STRONG "sequence") "のトップレベルのリスト構造の" "どの" (CODE1 "car") ", "
     (CODE1 "cdr") "でも" (CODE1 "setf") "することが許されています。" "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のときは、" (CODE1 "delete") "は" (CODE1 "vector") "の次元を変更し、"
     "その要素を並べ替えをせず、新しい位置にスライドして" "返却値の" (CODE1 "vector") "を構築することが許されています。" EOL2
     "delete-ifは以下のように正確に動作するように制約されています。"
     (CODE3 "```lisp" "```" " (delete nil sequence"
      "             :test #'(lambda (ignore item) (funcall test item))"
      "             ...)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(remove 4 '(1 3 4 5 9)) =>  (1 3 5 9)"
      "(remove 4 '(1 2 4 1 3 4 5)) =>  (1 2 1 3 5)"
      "(remove 4 '(1 2 4 1 3 4 5) :count 1) =>  (1 2 1 3 4 5)"
      "(remove 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) =>  (1 2 4 1 3 5)"
      "(remove 3 '(1 2 4 1 3 4 5) :test #'>) =>  (4 3 4 5)"
      "(setq lst '(list of four elements)) =>  (LIST OF FOUR ELEMENTS)"
      "(setq lst2 (copy-seq lst)) =>  (LIST OF FOUR ELEMENTS)"
      "(setq lst3 (delete 'four lst)) =>  (LIST OF ELEMENTS)"
      "(equal lst lst2) =>  false" "(remove-if #'oddp '(1 2 4 1 3 4 5)) =>  (2 4 4)"
      "(remove-if #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t) " "=>  (1 2 4 1 3 5)"
      "(remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9) :count 2 :from-end t)"
      "=>  (1 2 3 4 5 6 8)" "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester) =>  (1 2 1 3 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester :count 1) =>  (1 2 1 3 4 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester :count 1 :from-end t) =>  (1 2 4 1 3 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 3 tester :test #'>) =>  (4 3 4 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete-if #'oddp tester) =>  (2 4 4)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete-if #'evenp tester :count 1 :from-end t) =>  (1 2 4 1 3 5)    "
      "(setq tester (list 1 2 3 4 5 6)) =>  (1 2 3 4 5 6) "
      "(delete-if #'evenp tester) =>  (1 3 5) " "tester =>  implementation-dependent"
      "(setq foo (list 'a 'b 'c)) =>  (A B C)" "(setq bar (cdr foo)) =>  (B C)"
      "(setq foo (delete 'b foo)) =>  (A C)" "bar =>  ((C)) or ..."
      "(eq (cdr foo) (car bar)) =>  T or ..."))
    (CHAPTER ("## 副作用") 2 (CODE1 "delete") "、" (CODE1 "delete-if") "、"
     (CODE1 "delete-if-not") "の場合、" (STRONG "sequence") "は返却値の構築のために破壊されるかもしれません。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "返却値は"
     (CODE1 "simple") "かもしれませんし、そうでないかもしれません。" "また、返却値は" (STRONG "sequence")
     "と同一かもしれませんし、" "そうでないかもしれません。" EOL2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "delete-if-not") "と" (CODE1 "remove-if-not") "は非推奨です。")))
(setf (gethash '("DELETE-IF-NOT" . "FUNCTION") *table*) (gethash "DELETE-IF-NOT" *table*))
(setf (gethash "DELETE-PACKAGE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "DELETE-PACKAGE"))
    (CHAPTER ("## 構文") 2 (CODE1 "delete-package") " " (STRONG "package") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "package") " - パッケージ指定子" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "delete-package") "は" (STRONG "package") "を"
     "全てのパッケージシステムのデータ構造から削除します。" "もし操作が成功したとき、" (CODE1 "delete-package") "は"
     (STRONG "true") "を、" "それ以外は" (CODE1 "nil") "を返却します。" (CODE1 "delete-package")
     "の効果は、" (STRONG "package") "の名前とニックネームが" "認識されたパッケージの名前ではなくなるというものです。"
     "そのパッケージオブジェクトは、まだパッケージです" "（例えば" (CODE1 "packagep") "は" (STRONG "true") "になります）が、"
     (CODE1 "package-name") "は" (CODE1 "nil") "を返却します。" (CODE1 "COMMON-LISP") "パッケージか"
     (CODE1 "KEYWORD") "パッケージを削除した結果は未定義です。" "いったん削除された" (STRONG "package") "に対して"
     "他のパッケージの操作を行った結果は未定義です。" "とくに削除された" (STRONG "package") "を" (CODE1 "*package*")
     "に束縛したときか、" "あるいは削除された" (STRONG "package") "を引数に指定したときに、" (CODE1 "find-symbol") "や"
     (CODE1 "intern") "や、" "パッケージからシンボル名を探すような他の関数によって" "実行されたときの結果は未定義です。" EOL2 "もし"
     (STRONG "package") "がすでに削除されたパッケージオブジェクトであったときは、" (CODE1 "delete-package") "は即座に"
     (CODE1 "nil") "を返却します。" EOL2 "この操作が完了したあと、" "前のホームパッケージが" (STRONG "package")
     "であったシンボルの" "ホームパッケージは実装依存です。" "例外として、" (STRONG "package") "内のアクセス可能なシンボルは、"
     "ホームパッケージが" (STRONG "package") "ではないシンボルは変更されません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq *foo-package* (make-package \"FOO\" :use nil))"
      "(setq *foo-symbol*  (intern \"FOO\" *foo-package*))"
      "(export *foo-symbol* *foo-package*)" NIL
      "(setq *bar-package* (make-package \"BAR\" :use '(\"FOO\")))"
      "(setq *bar-symbol*  (intern \"BAR\" *bar-package*))"
      "(export *foo-symbol* *bar-package*)" "(export *bar-symbol* *bar-package*)" NIL
      "(setq *baz-package* (make-package \"BAZ\" :use '(\"BAR\")))" NIL
      "(symbol-package *foo-symbol*) =>  #<PACKAGE \"FOO\">"
      "(symbol-package *bar-symbol*) =>  #<PACKAGE \"BAR\">" NIL
      "(prin1-to-string *foo-symbol*) =>  \"FOO:FOO\""
      "(prin1-to-string *bar-symbol*) =>  \"BAR:BAR\"" NIL
      "(find-symbol \"FOO\" *bar-package*) =>  FOO:FOO, :EXTERNAL" NIL
      "(find-symbol \"FOO\" *baz-package*) =>  FOO:FOO, :INHERITED"
      "(find-symbol \"BAR\" *baz-package*) =>  BAR:BAR, :INHERITED" NIL
      "(packagep *foo-package*) =>  true" "(packagep *bar-package*) =>  true"
      "(packagep *baz-package*) =>  true" NIL "(package-name *foo-package*) =>  \"FOO\""
      "(package-name *bar-package*) =>  \"BAR\""
      "(package-name *baz-package*) =>  \"BAZ\"" NIL
      "(package-use-list *foo-package*) =>  ()"
      "(package-use-list *bar-package*) =>  (#<PACKAGE \"FOO\">)"
      "(package-use-list *baz-package*) =>  (#<PACKAGE \"BAR\">)" NIL
      "(package-used-by-list *foo-package*) =>  (#<PACKAGE \"BAR\">)"
      "(package-used-by-list *bar-package*) =>  (#<PACKAGE \"BAZ\">)"
      "(package-used-by-list *baz-package*) =>  ()" NIL "(delete-package *bar-package*)"
      ">>  Error: Package BAZ uses package BAR."
      ">>  If continued, BAZ will be made to unuse-package BAR,"
      ">>  and then BAR will be deleted." ">>  Type :CONTINUE to continue."
      ">>  Debug> :CONTINUE" "=>  T" NIL
      "(symbol-package *foo-symbol*) =>  #<PACKAGE \"FOO\">"
      "(symbol-package *bar-symbol*) is unspecified" NIL
      "(prin1-to-string *foo-symbol*) =>  \"FOO:FOO\""
      "(prin1-to-string *bar-symbol*) is unspecified" NIL
      "(find-symbol \"FOO\" *bar-package*) is unspecified" NIL
      "(find-symbol \"FOO\" *baz-package*) =>  NIL, NIL"
      "(find-symbol \"BAR\" *baz-package*) =>  NIL, NIL" NIL
      "(packagep *foo-package*) =>  T" "(packagep *bar-package*) =>  T"
      "(packagep *baz-package*) =>  T" NIL "(package-name *foo-package*) =>  \"FOO\""
      "(package-name *bar-package*) =>  NIL" "(package-name *baz-package*) =>  \"BAZ\""
      NIL "(package-use-list *foo-package*) =>  ()"
      "(package-use-list *bar-package*) is unspecified"
      "(package-use-list *baz-package*) =>  ()" NIL
      "(package-used-by-list *foo-package*) =>  ()"
      "(package-used-by-list *bar-package*) is unspecified"
      "(package-used-by-list *baz-package*) =>  ()"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "package") "指定子が現在有効な名前ではなかったとき、" "修正可能な型"
     (CODE1 "program-error") "のエラーが通知されます。" "もし修正がされたとき、削除の処理は実施されず、" "かわりに"
     (CODE1 "delete-package") "は即座に" (CODE1 "nil") "を返却します。" EOL2 "もし" (STRONG "package")
     "が他のパッケージに使われていたときは、" "修正可能な型" (CODE1 "program-error") "のエラーが通知されます。" "もし修正がされたとき、"
     (CODE1 "unuse-package") "は効果的に呼ばれて" "依存しているものを取り除き、" (STRONG "package") "の外部シンボルは"
     (STRONG "package") "を使っているそれらのパッケージで" "アクセスできなくなります。" "したがって"
     (CODE1 "delete-package") "は" "ちょうどそれを使うパッケージが存在しなくなるかのように" (STRONG "package")
     "を削除します。")
    (CHAPTER ("## 参考") 2 (CODE1 "unuse-package")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DELETE-PACKAGE" . "FUNCTION") *table*) (gethash "DELETE-PACKAGE" *table*))
(setf (gethash "DESTRUCTURING-BIND" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DESTRUCTURING-BIND"))
    (CHAPTER ("## 構文") 2 (CODE1 "destructuring-bind") " " (STRONG "lambda-list") " "
     (STRONG "expression") " " (STRONG "declaration\\*") " " (STRONG "form\\*") EOL1
     "=> " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "lambda-list") " - 分割のラムダリスト" EOL1
     (STRONG "expression") " - フォーム" EOL1 (STRONG "declaration") " - 宣言式、評価されません。" EOL1
     (STRONG "form") " - 暗黙のprogn" EOL1 (STRONG "result") " - " (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "destructuring-bind") "は、" (STRONG "lambda-list")
     "で指定された各変数を、" (STRONG "expression") "の評価の返却値で得られた木構造に対応する値で束縛し、" "それから"
     (CODE1 "destructuring-bind") "は" (STRONG "form") "を評価します。" EOL2
     (STRONG "lambda-list") "でサポートされる分割の定義は3.4.5. 分割のラムダリストをご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(defun iota (n) (loop for i from 1 to n collect i))       ;helper"
      "(destructuring-bind ((a &optional (b 'bee)) one two three)"
      "    `((alpha) ,@(iota 3))" "  (list a b three two one)) =>  (ALPHA BEE 3 2 1)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "expression") "の評価した返却値が" "分割のパターンにマッチしなかったときは、"
     "型" (CODE1 "error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "macrolet") "," (CODE1 "defmacro"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DESTRUCTURING-BIND" . "MACRO") *table*) (gethash "DESTRUCTURING-BIND" *table*))
(setf (gethash "DIGIT-CHAR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "DIGIT-CHAR"))
    (CHAPTER ("## 構文") 2 (CODE1 "digit-char") " " (STRONG "weight") " &optional "
     (STRONG "radix") " => " (STRONG "char"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "weight") " - 非負の整数" EOL1 (STRONG "radix")
     " - 基数。デフォルトは10。" EOL1 (STRONG "char") " - 文字か" (STRONG "false"))
    (CHAPTER ("## 定義") 2 "もし" (STRONG "weight") "が" (STRONG "radix") "より小さいとき、"
     (CODE1 "digit-char") "は" "基数の設定値を考慮して" (STRONG "weight") "の文字を返却します。"
     "結果がアルファベット文字の場合は、大文字が返却されます。" EOL2 "もし" (STRONG "weight") "が" (STRONG "radix")
     "以上の場合は、" (CODE1 "digit-char") "は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(digit-char 0) =>  #\\0" "(digit-char 10 11) =>  #\\A"
      "(digit-char 10 10) =>  false" "(digit-char 7) =>  #\\7"
      "(digit-char 12) =>  false" "(digit-char 12 16) =>  #\\C  ;not #\\c"
      "(digit-char 6 2) =>  false" "(digit-char 1 2) =>  #\\1"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "digit-char-p") ", " (CODE1 "graphic-char-p")
     ", 2.1. 文字の構文")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DIGIT-CHAR" . "FUNCTION") *table*) (gethash "DIGIT-CHAR" *table*))
(setf (gethash "DIGIT-CHAR-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "DIGIT-CHAR-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "digit-char-p") " " (STRONG "char") " &optional "
     (STRONG "radix") " => " (STRONG "weight"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "char") " - 文字" EOL1 (STRONG "radix")
     " - 基数。デフォルトは10。" EOL1 (STRONG "weight") " - " (STRONG "radix") "未満の非負の整数か、"
     (STRONG "false"))
    (CHAPTER ("## 定義") 2 (STRONG "char") "が、" (STRONG "radix") "値の数字かどうかを調べます" "（例えば"
     (STRONG "weight") "が" (STRONG "radix") "より小さいかどうか）。" "もし" (STRONG "radix")
     "内の数字であった場合、" (STRONG "weight") "は整数が返却されます。" "それ以外は" (CODE1 "nil") "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(digit-char-p #\\5)    =>  5"
      "(digit-char-p #\\5 2)  =>  false" "(digit-char-p #\\A)    =>  false"
      "(digit-char-p #\\a)    =>  false" "(digit-char-p #\\A 11) =>  10"
      "(digit-char-p #\\a 11) =>  10" "(mapcar #'(lambda (radix)"
      "            (map 'list #'(lambda (x) (digit-char-p x radix))"
      "                 \"059AaFGZ\"))" "        '(2 8 10 16 36))"
      "=>  ((0 NIL NIL NIL NIL NIL NIL NIL)" "     (0 5 NIL NIL NIL NIL NIL NIL)"
      "     (0 5 9 NIL NIL NIL NIL NIL)" "     (0 5 9 10 10 15 NIL NIL)"
      "     (0 5 9 10 10 15 16 35))"))
    (CHAPTER ("## 影響") 2 "なし。" "（この関数の結果は、現在のreadtableで有効になっているかもしれない" "特別な構文に依存しません。）")
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "alphanumericp"))
    (CHAPTER ("## 備考") 2 "数値は図形文字です。")))
(setf (gethash '("DIGIT-CHAR-P" . "FUNCTION") *table*) (gethash "DIGIT-CHAR-P" *table*))
(setf (gethash "DIRECTORY" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "DIRECTORY"))
    (CHAPTER ("## 構文") 2 (CODE1 "directory") " " (STRONG "pathspec") " " (CODE1 "&key")
     " => " (STRONG "pathnames"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathspec") " = パス名指定子。ワイルドカードが含まれるかもしれません。" EOL1
     (STRONG "pathnames") " - 物理パス名のリスト")
    (CHAPTER ("## 定義") 2 "ファイルシステム内において、" (STRONG "pathspec")
     "にマッチする名前を持つファイルがもしあるなら決定し、" "それらのファイルの実際の名前に対応するパス名の新しいリストを返却します。" EOL2 "実装は"
     (CODE1 "directory") "のキーワード引数に" "実装定義のものを受け付けるように拡張するかもしれません。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "ホストコンピューターのファイルシステム")
    (CHAPTER ("## 例外") 2 "もしディレクトリのリストを取得しようとしたときに失敗したときは、" "型" (CODE1 "file-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "pathname") "," (CODE1 "logical-pathname") ","
     (CODE1 "ensure-directories-exist") "," "20.1. ファイルシステムの説明,"
     "20.1.2. 開かれた・閉じたストリームのファイル操作," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "pathspec") "にワイルドカードが含まれていないとき、"
     "結果のリストはゼロかひとつの要素が含まれているものになります。" EOL2 (CODE1 "directory") "の引数リストには、"
     "標準のキーワード引数が定義されてはいませんが、" (CODE1 "&key") "が定義されています。" (CODE1 ":allow-other-keys t")
     "は、" "仕様に適合したプログラムにおいては、" "プログラムに通された実装でサポートされていない" "どのような追加のキーワード引数も"
     "静かに無視するときに使われます。")))
(setf (gethash '("DIRECTORY" . "FUNCTION") *table*) (gethash "DIRECTORY" *table*))
(setf (gethash "DIRECTORY-NAMESTRING" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "NAMESTRING") ", " (CODE1 "FILE-NAMESTRING") ", "
     (CODE1 "DIRECTORY-NAMESTRING") "," (CODE1 "HOST-NAMESTRING") ", "
     (CODE1 "ENOUGH-NAMESTRING"))
    (CHAPTER ("## 構文") 2 (CODE1 "namestring") " " (STRONG "pathname") " => "
     (STRONG "namestring") EOL1 (CODE1 "file-namestring") " " (STRONG "pathname") " => "
     (STRONG "namestring") EOL1 (CODE1 "directory-namestring") " " (STRONG "pathname")
     " => " (STRONG "namestring") EOL1 (CODE1 "host-namestring") " " (STRONG "pathname")
     " => " (STRONG "namestring") EOL1 (CODE1 "enough-namestring") " "
     (STRONG "pathname") " " (CODE1 "&optional") " " (STRONG "defaults") " => "
     (STRONG "namestring"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathname") " - パス名指定子" EOL1 (STRONG "defaults")
     " - パス名指定子。" "デフォルトは" (CODE1 "*default-pathname-defaults*") "の値です。" EOL1
     (STRONG "namestring") " - 文字列か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "pathname") "を名前文字列に変換します。"
     (STRONG "pathname") "によって表現される名前は、" "実装依存の基準のフォームに従った" "名前文字列として返却されます。" EOL2
     (CODE1 "namestring") "は、" (STRONG "pathname") "の完全なフォームを返却します。" EOL2
     (CODE1 "file-namestring") "は、" (STRONG "pathname") "の名前とタイプとバージョンの要素だけを返却します。" EOL2
     (CODE1 "directory-namestring") "は、" (STRONG "pathname") "のディレクトリの名前の部分を返却します。" EOL2
     (CODE1 "host-namestring") "は、ホスト名を返却します。" EOL2 (CODE1 "enough-namestring") "は、"
     (STRONG "pathname") "が" (STRONG "defaults") "から相対的に考慮されたものによって、"
     "同一と見なせるのに十分なファイル名である" "省略された名前文字列を返却します。" "これは、全ての場合において次のような関係を要求します。"
     (CODE3 "```lisp" "```"
      "(merge-pathnames (enough-namestring pathname defaults) defaults)"
      "==  (merge-pathnames (parse-namestring pathname nil defaults) defaults)")
     EOL2 (CODE1 "enough-namestring") "の結果は、" "このような基準を満たした最も短い適切な文字列です。" EOL2
     "この3つの短い名前文字列をある順にて結合することによって" "有効な名前文字列を生成することは必ずしも可能ではありません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(namestring \"getty\")            " "=>  \"getty\""
      "(setq q (make-pathname :host \"kathy\" " "                        :directory "
      "                          (pathname-directory *default-pathname-defaults*)"
      "                        :name \"getty\")) "
      "=>  #S(PATHNAME :HOST \"kathy\" :DEVICE NIL :DIRECTORY directory-name "
      "      :NAME \"getty\" :TYPE NIL :VERSION NIL)" "(file-namestring q) =>  \"getty\""
      "(directory-namestring q) =>  directory-name" "(host-namestring q) =>  \"kathy\" "
      ";;; Unix構文の使用とこの例での特定のUnixバージョンによる" ";;; ワイルドカード表記の使用によって作成されたもの" "(namestring"
      "  (translate-pathname \"/usr/dmr/hacks/frob.l\""
      "                      \"/usr/d*/hacks/*.l\""
      "                      \"/usr/d*/backup/hacks/backup-*.*\"))"
      ">  \"/usr/dmr/backup/hacks/backup-frob.l\"" "(namestring"
      "  (translate-pathname \"/usr/dmr/hacks/frob.l\""
      "                      \"/usr/d*/hacks/fr*.l\""
      "                      \"/usr/d*/backup/hacks/backup-*.*\"))"
      "=>  \"/usr/dmr/backup/hacks/backup-ob.l\"" NIL
      ";;; これは上記の例に似ていますが2つの違ったホストを使用しています。" ";;; UがUnixであり、VがVMSです。ファイルタイプの変換と"
      ";;; アルファベットの大文字小文字の表記に注意してください。" "(namestring"
      "  (translate-pathname \"U:/usr/dmr/hacks/frob.l\""
      "                      \"U:/usr/d*/hacks/*.l\""
      "                      \"V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*\"))"
      "=>  \"V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-FROB.LSP\"" "(namestring"
      "  (translate-pathname \"U:/usr/dmr/hacks/frob.l\""
      "                      \"U:/usr/d*/hacks/fr*.l\""
      "                      \"V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*\"))"
      "=>  \"V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-OB.LSP\""))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "truename") "," (CODE1 "merge-pathnames") ","
     (CODE1 "pathname") "," (CODE1 "logical-pathname") "," "20.1. ファイルシステムの説明,"
     "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DIRECTORY-NAMESTRING" . "FUNCTION") *table*) (gethash "DIRECTORY-NAMESTRING" *table*))
(setf (gethash "DO" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DO") ", " (CODE1 "DO*"))
    (CHAPTER ("## 構文") 2 (CODE1 "do") " (" (CODE1 "{") (STRONG "var") " " (CODE1 "|")
     " (" (STRONG "var") " [" (STRONG "init-form") " [" (STRONG "step-form") "]])"
     (CODE1 "}") "\\*)" " (" (STRONG "end-test-form") " " (STRONG "result-form\\*") ") "
     (STRONG "declaration\\*") " " (CODE1 "{") (STRONG "tag") " | " (STRONG "statement")
     (CODE1 "}") "\\*" EOL1 "=> " (STRONG "result\\*") EOL2 (CODE1 "do*") " ("
     (CODE1 "{") (STRONG "var") " " (CODE1 "|") " (" (STRONG "var") " ["
     (STRONG "init-form") " [" (STRONG "step-form") "]])" (CODE1 "}") "\\*)" " ("
     (STRONG "end-test-form") " " (STRONG "result-form\\*") ") "
     (STRONG "declaration\\*") " " (CODE1 "{") (STRONG "tag") " | " (STRONG "statement")
     (CODE1 "}") "\\*" EOL1 "=> " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - シンボル" EOL1 (STRONG "init-form") " - フォーム"
     EOL1 (STRONG "step-form") " - フォーム" EOL1 (STRONG "end-test-form") " - フォーム" EOL1
     (STRONG "result-form") " - 暗黙のprogn" EOL1 (STRONG "declaration") " - 宣言式。評価されません。"
     EOL1 (STRONG "tag") " - " (CODE1 "go") "のタグ。評価されません。" EOL1 (STRONG "statement")
     " - compound-form。下記の説明に従って評価されます。" EOL1 (STRONG "result") " - もし" (CODE1 "return")
     "か" (CODE1 "return-from") "が実行されたときは、" "そのフォームから渡された返却値であり、" "それ以外の場合は"
     (STRONG "result-form") "による返却値です。")
    (CHAPTER ("## 定義") 2 (CODE1 "do") "は、テスト条件に入っている状態のときに" (STRONG "statememt")
     "のグループを繰り返します。" (CODE1 "do") "は任意の数の繰り返し変数" (STRONG "var") "を束縛し、"
     "それは繰り返し中に並列に実行されます。" "初期値は、繰り返し変数に" (STRONG "init-form") "を使うことによって" "与えることができます。"
     (STRONG "step-form") "は、繰り返し中に" (STRONG "var") "を" "どのように更新して進めるべきかを指定します。" "もし"
     (STRONG "end-test-form") "条件が、ボディ部の実行前に合致したとき、" "その繰り返しは終了します。" (STRONG "tag") "は"
     (STRONG "statement") "にラベル付けされます。" EOL2 (CODE1 "do*") "は正確に" (CODE1 "do") "と似ていますが、"
     "ただ" (STRONG "var") "の束縛の進め方が" "並列ではなく順番に行われることが違っています。" EOL2 "最初の繰り返し前に、全ての"
     (STRONG "init-form") "が評価され、" "各" (STRONG "var") "に" (STRONG "init-form")
     "の指定があったものに" "それぞれの値を束縛します。" "これは束縛であり代入ではありませんので、"
     "もしループが終了したらそれらの変数は古い値に復旧されるでしょう。" (CODE1 "do") "は、全ての" (STRONG "init-form") "は"
     "どんな" (STRONG "var") "についても束縛される前に実行されます。" (STRONG "init-form") "は、" (CODE1 "do")
     "の実行が始まる前の" (STRONG "var") "として見えている束縛を参照することができます。" (CODE1 "do*") "は、最初の"
     (STRONG "init-form") "が評価されたら、" "最初の" (STRONG "var") "にその値の束縛が行われ、" "2番目の"
     (STRONG "init-form") "が評価されたら、" "2番目の" (STRONG "var") "にその値が束縛され、" "それを繰り返します。"
     "つまり一般的に、" (CODE1 "k") "番目の" (STRONG "init-form") "は、" (CODE1 "j") "番目（" (CODE1 "j")
     " < " (CODE1 "k") "）の" "新しい束縛を参照することができ、" "それ以外のとき、" (CODE1 "j") "番目の"
     (STRONG "var") "は古い値が参照されます。" EOL2 "各繰り返しが始まり、各変数の処理が終わったあと、"
     (STRONG "end-test-form") "が評価されます。" "もし結果が" (STRONG "false") "のときは、" (CODE1 "do")
     "の（あるいは" (CODE1 "do*") "の）フォームのボディ部が" "続けて実行されます。" "もし結果が" (STRONG "true") "のときは、"
     (STRONG "result-form") "が暗黙のprognとして順に評価されれ、" "それから" (CODE1 "do") "か" (CODE1 "do*")
     "が返却されます。" EOL2 "各繰り返しが始まり、最初以外の実行のとき、" (STRONG "var") "は次のように更新されます。" "全ての"
     (STRONG "step-form") "は、もし指定されていたときは評価され、" "それは左から右に行われ、" "返却値は対応する" (STRONG "var")
     "に代入されます。" (STRONG "step-form") "を持たない" (STRONG "var") "は、代入されません。" (CODE1 "do")
     "は、全ての" (STRONG "step-form") "が" (STRONG "var") "の更新前に評価されます。" (STRONG "var")
     "への値の代入は、" (CODE1 "psetq") "が使用されたかのように並列で行われます。" "全ての" (STRONG "step-form") "は"
     (STRONG "var") "が変更される前に評価されるため、" (STRONG "step-form") "は、他の" (STRONG "step-form")
     "の前にあっても" "全ての" (STRONG "var") "は常に古い値を参照するような状況で評価されます。" (CODE1 "do*") "は、最初の"
     (STRONG "step-form") "が評価され、" "それから最初の" (STRONG "var") "にその値が代入され、" "そのあと2番目の"
     (STRONG "step-form") "が評価され、" "そして2番目の" (STRONG "var") "にその値が代入され、" "繰り返します。"
     "変数への代入は" (CODE1 "setq") "を使用したかのように順番に行われます。" (CODE1 "do") "と" (CODE1 "do*")
     "のどちらも、" "全ての" (STRONG "var") "を更新したあとで" "すでに説明した通り" (STRONG "end-test-form")
     "が評価されて、" "そして繰り返しが継続します。" EOL2 (CODE1 "do") "の（そして" (CODE1 "do*") "も同様）残りの部分は、"
     "暗黙の" (CODE1 "tagbody") "で構成されます。" EOL2 (STRONG "tag") "は" (CODE1 "do")
     "の繰り返し内のボディ部内に出現し、" "それはボディ部に" (CODE1 "go") "文の出現によって使用されます" "（しかしそのような"
     (CODE1 "go") "文は、変数定義や" (STRONG "end-test-form") "、" (STRONG "result-form")
     "には現れないでしょう）。" (CODE1 "do") "のボディ部が終わりに到達したとき、" "次の繰り返しのサイクル（各" (STRONG "step-form")
     "の評価の最初）が始まります。" EOL2 (CODE1 "nil") "という名前の暗黙の" (CODE1 "block") "が、" (CODE1 "do")
     "と" (CODE1 "do*") "のフォーム全体を囲みます。" (CODE1 "return") "文は、ループを即座に終了させるために、"
     "どこの地点でも使用することができます。" EOL2 (STRONG "init-form") "は" (STRONG "var") "に関連付けられる初期値です。"
     "もし" (STRONG "init-form") "が省略されていたときの" (STRONG "var") "の初期値は" (CODE1 "nil") "です。"
     "もし" (STRONG "declaration") "が" (STRONG "var") "に指定されていたときは、" (STRONG "init-form")
     "は" (STRONG "declaration") "に一致しなければなりません。" EOL2 (STRONG "declaration") "は、"
     (CODE1 "do") "と" (CODE1 "do*") "のボディ部の最初に" "配置することができます。" "それらは" (CODE1 "do") "と"
     (CODE1 "do*") "のボディ部のコードと、" (CODE1 "do") "と" (CODE1 "do*") "の" (STRONG "var")
     "の束縛と、" (STRONG "step-form") "と、" (STRONG "end-test-form") "と、"
     (STRONG "result-form") "に適用します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(do ((temp-one 1 (1+ temp-one))"
      "      (temp-two 0 (1- temp-two)))"
      "     ((> (- temp-one temp-two) 5) temp-one)) =>  4" NIL
      "(do ((temp-one 1 (1+ temp-one))" "      (temp-two 0 (1+ temp-one)))     "
      "     ((= 3 temp-two) temp-one)) =>  3" NIL "(do* ((temp-one 1 (1+ temp-one))"
      "       (temp-two 0 (1+ temp-one)))"
      "      ((= 3 temp-two) temp-one)) =>  2                     " NIL
      "(do ((j 0 (+ j 1)))" "    (nil)                       ;永久に実行"
      "  (format t \"~%Input ~D:\" j)" "  (let ((item (read)))"
      "    (if (null item) (return)   ;*itemがNILになるまで処理"
      "        (format t \"~&Output ~D: ~S\" j item))))" ">>  Input 0: banana"
      ">>  Output 0: BANANA" ">>  Input 1: (57 boxes)" ">>  Output 1: (57 BOXES)"
      ">>  Input 2: NIL" "=>  NIL" NIL "(setq a-vector (vector 1 nil 3 nil))"
      "(do ((i 0 (+ i 1))     ;a-vectorのnullの要素を全部0に設定"
      "     (n (array-dimension a-vector 0)))" "    ((= i n))"
      "  (when (null (aref a-vector i))" "    (setf (aref a-vector i) 0))) =>  NIL"
      "a-vector =>  #(1 0 3 0)")
     (CODE3 "```" "```" "(do ((x e (cdr x))" "     (oldx x x))" "    ((null x))"
      "  body)")
     EOL2 "上記は、インデックスの変数を並列に代入する例です。" "最初の繰り返しでは、" (CODE1 "oldx") "の値は、" (CODE1 "x")
     "の値が何であれ、" (CODE1 "do") "に入る前の" (CODE1 "x") "に設定されます。" "続く繰り返しでは、" (CODE1 "oldx")
     "には" (CODE1 "x") "が持つ以前の繰り返しの値が含まれます。"
     (CODE3 "```lisp" "```" "(do ((x foo (cdr x))" "     (y bar (cdr y))"
      "     (z '() (cons (f (car x) (car y)) z)))" "    ((or (null x) (null y))"
      "     (nreverse z)))")
     EOL2 "上記の例は" (CODE1 "(mapcar #'f foo bar)") "と同じことを実行します。" (CODE1 "x")
     "の次のステップの計算は、" "変数が並列で次のステップに計算されるという事実の例になります。" "また、繰り返しのボディ部は空です。"
     (CODE3 "```lisp" "```" "(defun list-reverse (list)" "       (do ((x list (cdr x))"
      "            (y '() (cons (car x) y)))" "           ((endp x) y)))")
     EOL2 "次にネストされた繰り返しの例として、" "コンスのリストというデータ構造を考えるものを示します。" "各コンスの" (CODE1 "car")
     "はシンボルのリストであり、" "各コンスの" (CODE1 "cdr") "は対応する値を含む長さが等しいリストです。"
     "そのようなデータ構造は連想リストに似ていますが、" "しかし「フレーム」によって分割されるので、" "全体の構造はrib-case（胸郭）に似ています"
     "そのようなデータ構造を見る関数を下記に示します。"
     (CODE3 "```lisp" "```" "(defun ribcage-lookup (sym ribcage)           "
      "       (do ((r ribcage (cdr r)))" "           ((null r) nil)"
      "         (do ((s (caar r) (cdr s))" "              (v (cdar r) (cdr v))) "
      "             ((null s))" "           (when (eq (car s) sym)"
      "             (return-from ribcage-lookup (car v)))))) =>  RIBCAGE-LOOKUP"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "他の繰り返し関数（" (CODE1 "dolist") ", " (CODE1 "dotimes") ", "
     (CODE1 "loop") "）と、" "より原始的な機能（" (CODE1 "tagbody") ", " (CODE1 "go") ", "
     (CODE1 "block") "," " " (CODE1 "return") ", " (CODE1 "let") ", " (CODE1 "setq")
     "）。")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "end-test-form") "が" (CODE1 "nil") "のとき、"
     "テストは決して成功しないでしょう。" "これは「永久に実行」という語を提供し、" (CODE1 "do") "と" (CODE1 "do*")
     "のボディ部は繰り返し実行されます。" "このような無限ループは、" (CODE1 "return") "," (CODE1 "return-from") ","
     (CODE1 "go") "の外側の脱出," (CODE1 "throw") "によって終了させることができます。" EOL2 (CODE1 "do")
     "フォームはより原始的なフォームである、" (CODE1 "block") ", " (CODE1 "return") ", " (CODE1 "let") ","
     (CODE1 "loop") ", " (CODE1 "tagbody") ", " (CODE1 "psetq") "の語句によって次のように説明できます。"
     (CODE3 "```lisp" "```" "(block nil        " "  (let ((var1 init1)"
      "        (var2 init2)" "        ..." "        (varn initn))" "    declarations"
      "    (loop (when end-test (return (progn . result)))"
      "          (tagbody . tagbody)" "          (psetq var1 step1"
      "                 var2 step2" "                 ..."
      "                 varn stepn))))")
     EOL2 (CODE1 "do*") "も似ていますが、" (CODE1 "let*") "と" (CODE1 "setq") "を、" "それぞれ"
     (CODE1 "let") "と" (CODE1 "psetq") "に置き換えたものになります。")))
(setf (gethash '("DO" . "MACRO") *table*) (gethash "DO" *table*))
(setf (gethash "DO*" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DO") ", " (CODE1 "DO*"))
    (CHAPTER ("## 構文") 2 (CODE1 "do") " (" (CODE1 "{") (STRONG "var") " " (CODE1 "|")
     " (" (STRONG "var") " [" (STRONG "init-form") " [" (STRONG "step-form") "]])"
     (CODE1 "}") "\\*)" " (" (STRONG "end-test-form") " " (STRONG "result-form\\*") ") "
     (STRONG "declaration\\*") " " (CODE1 "{") (STRONG "tag") " | " (STRONG "statement")
     (CODE1 "}") "\\*" EOL1 "=> " (STRONG "result\\*") EOL2 (CODE1 "do*") " ("
     (CODE1 "{") (STRONG "var") " " (CODE1 "|") " (" (STRONG "var") " ["
     (STRONG "init-form") " [" (STRONG "step-form") "]])" (CODE1 "}") "\\*)" " ("
     (STRONG "end-test-form") " " (STRONG "result-form\\*") ") "
     (STRONG "declaration\\*") " " (CODE1 "{") (STRONG "tag") " | " (STRONG "statement")
     (CODE1 "}") "\\*" EOL1 "=> " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - シンボル" EOL1 (STRONG "init-form") " - フォーム"
     EOL1 (STRONG "step-form") " - フォーム" EOL1 (STRONG "end-test-form") " - フォーム" EOL1
     (STRONG "result-form") " - 暗黙のprogn" EOL1 (STRONG "declaration") " - 宣言式。評価されません。"
     EOL1 (STRONG "tag") " - " (CODE1 "go") "のタグ。評価されません。" EOL1 (STRONG "statement")
     " - compound-form。下記の説明に従って評価されます。" EOL1 (STRONG "result") " - もし" (CODE1 "return")
     "か" (CODE1 "return-from") "が実行されたときは、" "そのフォームから渡された返却値であり、" "それ以外の場合は"
     (STRONG "result-form") "による返却値です。")
    (CHAPTER ("## 定義") 2 (CODE1 "do") "は、テスト条件に入っている状態のときに" (STRONG "statememt")
     "のグループを繰り返します。" (CODE1 "do") "は任意の数の繰り返し変数" (STRONG "var") "を束縛し、"
     "それは繰り返し中に並列に実行されます。" "初期値は、繰り返し変数に" (STRONG "init-form") "を使うことによって" "与えることができます。"
     (STRONG "step-form") "は、繰り返し中に" (STRONG "var") "を" "どのように更新して進めるべきかを指定します。" "もし"
     (STRONG "end-test-form") "条件が、ボディ部の実行前に合致したとき、" "その繰り返しは終了します。" (STRONG "tag") "は"
     (STRONG "statement") "にラベル付けされます。" EOL2 (CODE1 "do*") "は正確に" (CODE1 "do") "と似ていますが、"
     "ただ" (STRONG "var") "の束縛の進め方が" "並列ではなく順番に行われることが違っています。" EOL2 "最初の繰り返し前に、全ての"
     (STRONG "init-form") "が評価され、" "各" (STRONG "var") "に" (STRONG "init-form")
     "の指定があったものに" "それぞれの値を束縛します。" "これは束縛であり代入ではありませんので、"
     "もしループが終了したらそれらの変数は古い値に復旧されるでしょう。" (CODE1 "do") "は、全ての" (STRONG "init-form") "は"
     "どんな" (STRONG "var") "についても束縛される前に実行されます。" (STRONG "init-form") "は、" (CODE1 "do")
     "の実行が始まる前の" (STRONG "var") "として見えている束縛を参照することができます。" (CODE1 "do*") "は、最初の"
     (STRONG "init-form") "が評価されたら、" "最初の" (STRONG "var") "にその値の束縛が行われ、" "2番目の"
     (STRONG "init-form") "が評価されたら、" "2番目の" (STRONG "var") "にその値が束縛され、" "それを繰り返します。"
     "つまり一般的に、" (CODE1 "k") "番目の" (STRONG "init-form") "は、" (CODE1 "j") "番目（" (CODE1 "j")
     " < " (CODE1 "k") "）の" "新しい束縛を参照することができ、" "それ以外のとき、" (CODE1 "j") "番目の"
     (STRONG "var") "は古い値が参照されます。" EOL2 "各繰り返しが始まり、各変数の処理が終わったあと、"
     (STRONG "end-test-form") "が評価されます。" "もし結果が" (STRONG "false") "のときは、" (CODE1 "do")
     "の（あるいは" (CODE1 "do*") "の）フォームのボディ部が" "続けて実行されます。" "もし結果が" (STRONG "true") "のときは、"
     (STRONG "result-form") "が暗黙のprognとして順に評価されれ、" "それから" (CODE1 "do") "か" (CODE1 "do*")
     "が返却されます。" EOL2 "各繰り返しが始まり、最初以外の実行のとき、" (STRONG "var") "は次のように更新されます。" "全ての"
     (STRONG "step-form") "は、もし指定されていたときは評価され、" "それは左から右に行われ、" "返却値は対応する" (STRONG "var")
     "に代入されます。" (STRONG "step-form") "を持たない" (STRONG "var") "は、代入されません。" (CODE1 "do")
     "は、全ての" (STRONG "step-form") "が" (STRONG "var") "の更新前に評価されます。" (STRONG "var")
     "への値の代入は、" (CODE1 "psetq") "が使用されたかのように並列で行われます。" "全ての" (STRONG "step-form") "は"
     (STRONG "var") "が変更される前に評価されるため、" (STRONG "step-form") "は、他の" (STRONG "step-form")
     "の前にあっても" "全ての" (STRONG "var") "は常に古い値を参照するような状況で評価されます。" (CODE1 "do*") "は、最初の"
     (STRONG "step-form") "が評価され、" "それから最初の" (STRONG "var") "にその値が代入され、" "そのあと2番目の"
     (STRONG "step-form") "が評価され、" "そして2番目の" (STRONG "var") "にその値が代入され、" "繰り返します。"
     "変数への代入は" (CODE1 "setq") "を使用したかのように順番に行われます。" (CODE1 "do") "と" (CODE1 "do*")
     "のどちらも、" "全ての" (STRONG "var") "を更新したあとで" "すでに説明した通り" (STRONG "end-test-form")
     "が評価されて、" "そして繰り返しが継続します。" EOL2 (CODE1 "do") "の（そして" (CODE1 "do*") "も同様）残りの部分は、"
     "暗黙の" (CODE1 "tagbody") "で構成されます。" EOL2 (STRONG "tag") "は" (CODE1 "do")
     "の繰り返し内のボディ部内に出現し、" "それはボディ部に" (CODE1 "go") "文の出現によって使用されます" "（しかしそのような"
     (CODE1 "go") "文は、変数定義や" (STRONG "end-test-form") "、" (STRONG "result-form")
     "には現れないでしょう）。" (CODE1 "do") "のボディ部が終わりに到達したとき、" "次の繰り返しのサイクル（各" (STRONG "step-form")
     "の評価の最初）が始まります。" EOL2 (CODE1 "nil") "という名前の暗黙の" (CODE1 "block") "が、" (CODE1 "do")
     "と" (CODE1 "do*") "のフォーム全体を囲みます。" (CODE1 "return") "文は、ループを即座に終了させるために、"
     "どこの地点でも使用することができます。" EOL2 (STRONG "init-form") "は" (STRONG "var") "に関連付けられる初期値です。"
     "もし" (STRONG "init-form") "が省略されていたときの" (STRONG "var") "の初期値は" (CODE1 "nil") "です。"
     "もし" (STRONG "declaration") "が" (STRONG "var") "に指定されていたときは、" (STRONG "init-form")
     "は" (STRONG "declaration") "に一致しなければなりません。" EOL2 (STRONG "declaration") "は、"
     (CODE1 "do") "と" (CODE1 "do*") "のボディ部の最初に" "配置することができます。" "それらは" (CODE1 "do") "と"
     (CODE1 "do*") "のボディ部のコードと、" (CODE1 "do") "と" (CODE1 "do*") "の" (STRONG "var")
     "の束縛と、" (STRONG "step-form") "と、" (STRONG "end-test-form") "と、"
     (STRONG "result-form") "に適用します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(do ((temp-one 1 (1+ temp-one))"
      "      (temp-two 0 (1- temp-two)))"
      "     ((> (- temp-one temp-two) 5) temp-one)) =>  4" NIL
      "(do ((temp-one 1 (1+ temp-one))" "      (temp-two 0 (1+ temp-one)))     "
      "     ((= 3 temp-two) temp-one)) =>  3" NIL "(do* ((temp-one 1 (1+ temp-one))"
      "       (temp-two 0 (1+ temp-one)))"
      "      ((= 3 temp-two) temp-one)) =>  2                     " NIL
      "(do ((j 0 (+ j 1)))" "    (nil)                       ;永久に実行"
      "  (format t \"~%Input ~D:\" j)" "  (let ((item (read)))"
      "    (if (null item) (return)   ;*itemがNILになるまで処理"
      "        (format t \"~&Output ~D: ~S\" j item))))" ">>  Input 0: banana"
      ">>  Output 0: BANANA" ">>  Input 1: (57 boxes)" ">>  Output 1: (57 BOXES)"
      ">>  Input 2: NIL" "=>  NIL" NIL "(setq a-vector (vector 1 nil 3 nil))"
      "(do ((i 0 (+ i 1))     ;a-vectorのnullの要素を全部0に設定"
      "     (n (array-dimension a-vector 0)))" "    ((= i n))"
      "  (when (null (aref a-vector i))" "    (setf (aref a-vector i) 0))) =>  NIL"
      "a-vector =>  #(1 0 3 0)")
     (CODE3 "```" "```" "(do ((x e (cdr x))" "     (oldx x x))" "    ((null x))"
      "  body)")
     EOL2 "上記は、インデックスの変数を並列に代入する例です。" "最初の繰り返しでは、" (CODE1 "oldx") "の値は、" (CODE1 "x")
     "の値が何であれ、" (CODE1 "do") "に入る前の" (CODE1 "x") "に設定されます。" "続く繰り返しでは、" (CODE1 "oldx")
     "には" (CODE1 "x") "が持つ以前の繰り返しの値が含まれます。"
     (CODE3 "```lisp" "```" "(do ((x foo (cdr x))" "     (y bar (cdr y))"
      "     (z '() (cons (f (car x) (car y)) z)))" "    ((or (null x) (null y))"
      "     (nreverse z)))")
     EOL2 "上記の例は" (CODE1 "(mapcar #'f foo bar)") "と同じことを実行します。" (CODE1 "x")
     "の次のステップの計算は、" "変数が並列で次のステップに計算されるという事実の例になります。" "また、繰り返しのボディ部は空です。"
     (CODE3 "```lisp" "```" "(defun list-reverse (list)" "       (do ((x list (cdr x))"
      "            (y '() (cons (car x) y)))" "           ((endp x) y)))")
     EOL2 "次にネストされた繰り返しの例として、" "コンスのリストというデータ構造を考えるものを示します。" "各コンスの" (CODE1 "car")
     "はシンボルのリストであり、" "各コンスの" (CODE1 "cdr") "は対応する値を含む長さが等しいリストです。"
     "そのようなデータ構造は連想リストに似ていますが、" "しかし「フレーム」によって分割されるので、" "全体の構造はrib-case（胸郭）に似ています"
     "そのようなデータ構造を見る関数を下記に示します。"
     (CODE3 "```lisp" "```" "(defun ribcage-lookup (sym ribcage)           "
      "       (do ((r ribcage (cdr r)))" "           ((null r) nil)"
      "         (do ((s (caar r) (cdr s))" "              (v (cdar r) (cdr v))) "
      "             ((null s))" "           (when (eq (car s) sym)"
      "             (return-from ribcage-lookup (car v)))))) =>  RIBCAGE-LOOKUP"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "他の繰り返し関数（" (CODE1 "dolist") ", " (CODE1 "dotimes") ", "
     (CODE1 "loop") "）と、" "より原始的な機能（" (CODE1 "tagbody") ", " (CODE1 "go") ", "
     (CODE1 "block") "," " " (CODE1 "return") ", " (CODE1 "let") ", " (CODE1 "setq")
     "）。")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "end-test-form") "が" (CODE1 "nil") "のとき、"
     "テストは決して成功しないでしょう。" "これは「永久に実行」という語を提供し、" (CODE1 "do") "と" (CODE1 "do*")
     "のボディ部は繰り返し実行されます。" "このような無限ループは、" (CODE1 "return") "," (CODE1 "return-from") ","
     (CODE1 "go") "の外側の脱出," (CODE1 "throw") "によって終了させることができます。" EOL2 (CODE1 "do")
     "フォームはより原始的なフォームである、" (CODE1 "block") ", " (CODE1 "return") ", " (CODE1 "let") ","
     (CODE1 "loop") ", " (CODE1 "tagbody") ", " (CODE1 "psetq") "の語句によって次のように説明できます。"
     (CODE3 "```lisp" "```" "(block nil        " "  (let ((var1 init1)"
      "        (var2 init2)" "        ..." "        (varn initn))" "    declarations"
      "    (loop (when end-test (return (progn . result)))"
      "          (tagbody . tagbody)" "          (psetq var1 step1"
      "                 var2 step2" "                 ..."
      "                 varn stepn))))")
     EOL2 (CODE1 "do*") "も似ていますが、" (CODE1 "let*") "と" (CODE1 "setq") "を、" "それぞれ"
     (CODE1 "let") "と" (CODE1 "psetq") "に置き換えたものになります。")))
(setf (gethash '("DO*" . "MACRO") *table*) (gethash "DO*" *table*))
(setf (gethash "DO-ALL-SYMBOLS" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DO-SYMBOLS") ", " (CODE1 "DO-EXTERNAL-SYMBOLS") ", "
     (CODE1 "DO-ALL-SYMBOLS"))
    (CHAPTER ("## 構文") 2 (CODE1 "do-symbols") " (" (STRONG "var") " [" (STRONG "package")
     " [" (STRONG "result-form") "]]) " (STRONG "declaration\\*") " " (CODE1 "{")
     (STRONG "tag") " " (CODE1 "|") " " (STRONG "statement") (CODE1 "}") "\\*" " => "
     (STRONG "result\\*") EOL2 (CODE1 "do-external-symbols") " (" (STRONG "var") " ["
     (STRONG "package") " [" (STRONG "result-form") "]]) " (STRONG "declaration\\*") " "
     (CODE1 "{") (STRONG "tag") " " (CODE1 "|") " " (STRONG "statement") (CODE1 "}")
     "\\*" " => " (STRONG "result\\*") EOL2 (CODE1 "do-all-symbols") " (" (STRONG "var")
     " [" (STRONG "result-form") "]) " (STRONG "declaration\\*") " " (CODE1 "{")
     (STRONG "tag") " " (CODE1 "|") " " (STRONG "statement") (CODE1 "}") "\\*" " => "
     (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - 変数名。評価されません。" EOL1 (STRONG "package")
     " - パッケージ指定子。評価されます。" (CODE1 "do-symbols") "と" (CODE1 "do-external-symbols") "の"
     "デフォルトは現在のパッケージ。" EOL1 (STRONG "result-form") " - フォーム。下記の説明に従って評価されます。" "デフォルトは"
     (CODE1 "nil") "。" EOL1 (STRONG "declaration") " - 宣言式。評価されません。" EOL1 (STRONG "tag")
     " - " (CODE1 "go") "タグ。評価されません。" EOL1 (STRONG "statement")
     " - compound-form。下記の説明に従って評価されます。" EOL1 (STRONG "result") " - 通常の返却が生じたときは"
     (STRONG "return-from") "の返却値であり、" "例外的な返却が生じたときは遷移が生じた値が返却されます。")
    (CHAPTER ("## 定義") 2 (CODE1 "do-symbols") ", " (CODE1 "do-external-symbols") ", "
     (CODE1 "do-all-symbols") "は、" "パッケージのシンボルに対して繰り返しを行います。" "選択されたパッケージの集合内の各シンボルについて、"
     (STRONG "var") "にシンボルが束縛されて、" "ボディ部の" (STRONG "statement") "が実行されます。"
     "全てのシンボルが処理されたとき、" (STRONG "result-form") "が評価されてマクロの値として返却されます。" EOL2
     (CODE1 "do-symbols") "は、" (STRONG "package") "でアクセス可能な" "シンボルに対して繰り返しを行います。"
     "複数のパッケージから継承されているシンボルは、" (STRONG "statement") "が一回以上実行されるでしょう。" EOL2
     (CODE1 "do-all-symbols") "は、" "全ての登録されているパッケージで繰り返しを行います。" (CODE1 "do-all-symbols")
     "は、どの登録されたパッケージに対しても" "アクセス可能ではないシンボルは処理されないので、" "全てのシンボルが何であれ実行するわけではありません。"
     (CODE1 "do-all-symbols") "は、" "いくつかのパッケージに現れるシンボルは" "複数回処理されるかもしれません。" EOL2
     (CODE1 "do-external-symbols") "は、" (STRONG "package") "の外部シンボルに対して繰り返しを行います。" EOL2
     (STRONG "result-form") "が評価されるとき、" (STRONG "var") "は束縛されており" (CODE1 "nil")
     "の値を持っています。" EOL2 (CODE1 "nil") "という名前の暗黙の" (CODE1 "block") "が" (CODE1 "do-symbols")
     ", " (CODE1 "do-external-symbols") "," (CODE1 "do-all-symbols") "フォーム全体を囲みます。"
     (CODE1 "return") "か" (CODE1 "return-from") "は" "繰り返しを早期に終わらせるときに使用されます。" EOL2
     "もしボディ部の実行が、" (CODE1 "unintern") "の使用によって" (STRONG "var") "の現在の値からシンボルを取り除く以外に、"
     "繰り返しが行われているパッケージの" "集合に含まれるシンボルに影響を与えるのであれば、" "その結果は未定義です。" EOL2 "それぞれのマクロについて、"
     "名前が束縛されているスコープは、" "初期値フォームは含まれませんが、" "しかしオプションの結果のフォームは含まれます。" EOL2 "ボディ部のどんな"
     (STRONG "tag") "も、" (CODE1 "tagbody") "とものとして扱われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(make-package 'temp :use nil) =>  #<PACKAGE \"TEMP\">"
      "(intern \"SHY\" 'temp) =>  TEMP::SHY, NIL ;SHY will be an internal symbol"
      "                                        ;in the package TEMP"
      "(export (intern \"BOLD\" 'temp) 'temp)  =>  T  ;BOLD will be external  "
      "(let ((lst ()))" "  (do-symbols (s (find-package 'temp)) (push s lst))" "  lst)"
      "=>  (TEMP::SHY TEMP:BOLD)" "OR=>  (TEMP:BOLD TEMP::SHY)" "(let ((lst ()))"
      "  (do-external-symbols (s (find-package 'temp) lst) (push s lst))" "  lst) "
      "=>  (TEMP:BOLD)"
      "(let ((lst ()))                                                     "
      "  (do-all-symbols (s lst)"
      "    (when (eq (find-package 'temp) (symbol-package s)) (push s lst)))" "  lst)"
      "=>  (TEMP::SHY TEMP:BOLD)" "OR=>  (TEMP:BOLD TEMP::SHY)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "intern") "," (CODE1 "export") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DO-ALL-SYMBOLS" . "MACRO") *table*) (gethash "DO-ALL-SYMBOLS" *table*))
(setf (gethash "DO-EXTERNAL-SYMBOLS" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DO-SYMBOLS") ", " (CODE1 "DO-EXTERNAL-SYMBOLS") ", "
     (CODE1 "DO-ALL-SYMBOLS"))
    (CHAPTER ("## 構文") 2 (CODE1 "do-symbols") " (" (STRONG "var") " [" (STRONG "package")
     " [" (STRONG "result-form") "]]) " (STRONG "declaration\\*") " " (CODE1 "{")
     (STRONG "tag") " " (CODE1 "|") " " (STRONG "statement") (CODE1 "}") "\\*" " => "
     (STRONG "result\\*") EOL2 (CODE1 "do-external-symbols") " (" (STRONG "var") " ["
     (STRONG "package") " [" (STRONG "result-form") "]]) " (STRONG "declaration\\*") " "
     (CODE1 "{") (STRONG "tag") " " (CODE1 "|") " " (STRONG "statement") (CODE1 "}")
     "\\*" " => " (STRONG "result\\*") EOL2 (CODE1 "do-all-symbols") " (" (STRONG "var")
     " [" (STRONG "result-form") "]) " (STRONG "declaration\\*") " " (CODE1 "{")
     (STRONG "tag") " " (CODE1 "|") " " (STRONG "statement") (CODE1 "}") "\\*" " => "
     (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - 変数名。評価されません。" EOL1 (STRONG "package")
     " - パッケージ指定子。評価されます。" (CODE1 "do-symbols") "と" (CODE1 "do-external-symbols") "の"
     "デフォルトは現在のパッケージ。" EOL1 (STRONG "result-form") " - フォーム。下記の説明に従って評価されます。" "デフォルトは"
     (CODE1 "nil") "。" EOL1 (STRONG "declaration") " - 宣言式。評価されません。" EOL1 (STRONG "tag")
     " - " (CODE1 "go") "タグ。評価されません。" EOL1 (STRONG "statement")
     " - compound-form。下記の説明に従って評価されます。" EOL1 (STRONG "result") " - 通常の返却が生じたときは"
     (STRONG "return-from") "の返却値であり、" "例外的な返却が生じたときは遷移が生じた値が返却されます。")
    (CHAPTER ("## 定義") 2 (CODE1 "do-symbols") ", " (CODE1 "do-external-symbols") ", "
     (CODE1 "do-all-symbols") "は、" "パッケージのシンボルに対して繰り返しを行います。" "選択されたパッケージの集合内の各シンボルについて、"
     (STRONG "var") "にシンボルが束縛されて、" "ボディ部の" (STRONG "statement") "が実行されます。"
     "全てのシンボルが処理されたとき、" (STRONG "result-form") "が評価されてマクロの値として返却されます。" EOL2
     (CODE1 "do-symbols") "は、" (STRONG "package") "でアクセス可能な" "シンボルに対して繰り返しを行います。"
     "複数のパッケージから継承されているシンボルは、" (STRONG "statement") "が一回以上実行されるでしょう。" EOL2
     (CODE1 "do-all-symbols") "は、" "全ての登録されているパッケージで繰り返しを行います。" (CODE1 "do-all-symbols")
     "は、どの登録されたパッケージに対しても" "アクセス可能ではないシンボルは処理されないので、" "全てのシンボルが何であれ実行するわけではありません。"
     (CODE1 "do-all-symbols") "は、" "いくつかのパッケージに現れるシンボルは" "複数回処理されるかもしれません。" EOL2
     (CODE1 "do-external-symbols") "は、" (STRONG "package") "の外部シンボルに対して繰り返しを行います。" EOL2
     (STRONG "result-form") "が評価されるとき、" (STRONG "var") "は束縛されており" (CODE1 "nil")
     "の値を持っています。" EOL2 (CODE1 "nil") "という名前の暗黙の" (CODE1 "block") "が" (CODE1 "do-symbols")
     ", " (CODE1 "do-external-symbols") "," (CODE1 "do-all-symbols") "フォーム全体を囲みます。"
     (CODE1 "return") "か" (CODE1 "return-from") "は" "繰り返しを早期に終わらせるときに使用されます。" EOL2
     "もしボディ部の実行が、" (CODE1 "unintern") "の使用によって" (STRONG "var") "の現在の値からシンボルを取り除く以外に、"
     "繰り返しが行われているパッケージの" "集合に含まれるシンボルに影響を与えるのであれば、" "その結果は未定義です。" EOL2 "それぞれのマクロについて、"
     "名前が束縛されているスコープは、" "初期値フォームは含まれませんが、" "しかしオプションの結果のフォームは含まれます。" EOL2 "ボディ部のどんな"
     (STRONG "tag") "も、" (CODE1 "tagbody") "とものとして扱われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(make-package 'temp :use nil) =>  #<PACKAGE \"TEMP\">"
      "(intern \"SHY\" 'temp) =>  TEMP::SHY, NIL ;SHY will be an internal symbol"
      "                                        ;in the package TEMP"
      "(export (intern \"BOLD\" 'temp) 'temp)  =>  T  ;BOLD will be external  "
      "(let ((lst ()))" "  (do-symbols (s (find-package 'temp)) (push s lst))" "  lst)"
      "=>  (TEMP::SHY TEMP:BOLD)" "OR=>  (TEMP:BOLD TEMP::SHY)" "(let ((lst ()))"
      "  (do-external-symbols (s (find-package 'temp) lst) (push s lst))" "  lst) "
      "=>  (TEMP:BOLD)"
      "(let ((lst ()))                                                     "
      "  (do-all-symbols (s lst)"
      "    (when (eq (find-package 'temp) (symbol-package s)) (push s lst)))" "  lst)"
      "=>  (TEMP::SHY TEMP:BOLD)" "OR=>  (TEMP:BOLD TEMP::SHY)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "intern") "," (CODE1 "export") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DO-EXTERNAL-SYMBOLS" . "MACRO") *table*) (gethash "DO-EXTERNAL-SYMBOLS" *table*))
(setf (gethash "DO-SYMBOLS" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DO-SYMBOLS") ", " (CODE1 "DO-EXTERNAL-SYMBOLS") ", "
     (CODE1 "DO-ALL-SYMBOLS"))
    (CHAPTER ("## 構文") 2 (CODE1 "do-symbols") " (" (STRONG "var") " [" (STRONG "package")
     " [" (STRONG "result-form") "]]) " (STRONG "declaration\\*") " " (CODE1 "{")
     (STRONG "tag") " " (CODE1 "|") " " (STRONG "statement") (CODE1 "}") "\\*" " => "
     (STRONG "result\\*") EOL2 (CODE1 "do-external-symbols") " (" (STRONG "var") " ["
     (STRONG "package") " [" (STRONG "result-form") "]]) " (STRONG "declaration\\*") " "
     (CODE1 "{") (STRONG "tag") " " (CODE1 "|") " " (STRONG "statement") (CODE1 "}")
     "\\*" " => " (STRONG "result\\*") EOL2 (CODE1 "do-all-symbols") " (" (STRONG "var")
     " [" (STRONG "result-form") "]) " (STRONG "declaration\\*") " " (CODE1 "{")
     (STRONG "tag") " " (CODE1 "|") " " (STRONG "statement") (CODE1 "}") "\\*" " => "
     (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - 変数名。評価されません。" EOL1 (STRONG "package")
     " - パッケージ指定子。評価されます。" (CODE1 "do-symbols") "と" (CODE1 "do-external-symbols") "の"
     "デフォルトは現在のパッケージ。" EOL1 (STRONG "result-form") " - フォーム。下記の説明に従って評価されます。" "デフォルトは"
     (CODE1 "nil") "。" EOL1 (STRONG "declaration") " - 宣言式。評価されません。" EOL1 (STRONG "tag")
     " - " (CODE1 "go") "タグ。評価されません。" EOL1 (STRONG "statement")
     " - compound-form。下記の説明に従って評価されます。" EOL1 (STRONG "result") " - 通常の返却が生じたときは"
     (STRONG "return-from") "の返却値であり、" "例外的な返却が生じたときは遷移が生じた値が返却されます。")
    (CHAPTER ("## 定義") 2 (CODE1 "do-symbols") ", " (CODE1 "do-external-symbols") ", "
     (CODE1 "do-all-symbols") "は、" "パッケージのシンボルに対して繰り返しを行います。" "選択されたパッケージの集合内の各シンボルについて、"
     (STRONG "var") "にシンボルが束縛されて、" "ボディ部の" (STRONG "statement") "が実行されます。"
     "全てのシンボルが処理されたとき、" (STRONG "result-form") "が評価されてマクロの値として返却されます。" EOL2
     (CODE1 "do-symbols") "は、" (STRONG "package") "でアクセス可能な" "シンボルに対して繰り返しを行います。"
     "複数のパッケージから継承されているシンボルは、" (STRONG "statement") "が一回以上実行されるでしょう。" EOL2
     (CODE1 "do-all-symbols") "は、" "全ての登録されているパッケージで繰り返しを行います。" (CODE1 "do-all-symbols")
     "は、どの登録されたパッケージに対しても" "アクセス可能ではないシンボルは処理されないので、" "全てのシンボルが何であれ実行するわけではありません。"
     (CODE1 "do-all-symbols") "は、" "いくつかのパッケージに現れるシンボルは" "複数回処理されるかもしれません。" EOL2
     (CODE1 "do-external-symbols") "は、" (STRONG "package") "の外部シンボルに対して繰り返しを行います。" EOL2
     (STRONG "result-form") "が評価されるとき、" (STRONG "var") "は束縛されており" (CODE1 "nil")
     "の値を持っています。" EOL2 (CODE1 "nil") "という名前の暗黙の" (CODE1 "block") "が" (CODE1 "do-symbols")
     ", " (CODE1 "do-external-symbols") "," (CODE1 "do-all-symbols") "フォーム全体を囲みます。"
     (CODE1 "return") "か" (CODE1 "return-from") "は" "繰り返しを早期に終わらせるときに使用されます。" EOL2
     "もしボディ部の実行が、" (CODE1 "unintern") "の使用によって" (STRONG "var") "の現在の値からシンボルを取り除く以外に、"
     "繰り返しが行われているパッケージの" "集合に含まれるシンボルに影響を与えるのであれば、" "その結果は未定義です。" EOL2 "それぞれのマクロについて、"
     "名前が束縛されているスコープは、" "初期値フォームは含まれませんが、" "しかしオプションの結果のフォームは含まれます。" EOL2 "ボディ部のどんな"
     (STRONG "tag") "も、" (CODE1 "tagbody") "とものとして扱われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(make-package 'temp :use nil) =>  #<PACKAGE \"TEMP\">"
      "(intern \"SHY\" 'temp) =>  TEMP::SHY, NIL ;SHY will be an internal symbol"
      "                                        ;in the package TEMP"
      "(export (intern \"BOLD\" 'temp) 'temp)  =>  T  ;BOLD will be external  "
      "(let ((lst ()))" "  (do-symbols (s (find-package 'temp)) (push s lst))" "  lst)"
      "=>  (TEMP::SHY TEMP:BOLD)" "OR=>  (TEMP:BOLD TEMP::SHY)" "(let ((lst ()))"
      "  (do-external-symbols (s (find-package 'temp) lst) (push s lst))" "  lst) "
      "=>  (TEMP:BOLD)"
      "(let ((lst ()))                                                     "
      "  (do-all-symbols (s lst)"
      "    (when (eq (find-package 'temp) (symbol-package s)) (push s lst)))" "  lst)"
      "=>  (TEMP::SHY TEMP:BOLD)" "OR=>  (TEMP:BOLD TEMP::SHY)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "intern") "," (CODE1 "export") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("DO-SYMBOLS" . "MACRO") *table*) (gethash "DO-SYMBOLS" *table*))
(setf (gethash "DOCUMENTATION" *table*)
  '((CHAPTER NIL 0)))
(setf (gethash '("DOCUMENTATION" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "DOCUMENTATION" *table*))
(setf (gethash "DOLIST" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DOLIST"))
    (CHAPTER ("## 構文") 2 (CODE1 "dolist") " (" (STRONG "var") " " (STRONG "list-form")
     " [" (STRONG "result-form") "]) " (STRONG "declaration\\*") " " (CODE1 "{")
     (STRONG "tag") " " (CODE1 "|") " " (STRONG "statement") (CODE1 "}") "\\*" EOL1 "=> "
     (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - シンボル" EOL1 (STRONG "list-form") " - フォーム"
     EOL1 (STRONG "result-form") " - フォーム" EOL1 (STRONG "declaration") " - 宣言式。評価されません。"
     EOL1 (STRONG "tag") " - " (CODE1 "go") "のタグ。評価されません。" EOL1 (STRONG "statement")
     " - compound-form。下記の説明に従って評価されます。" EOL1 (STRONG "result") " - もし" (CODE1 "return")
     "か" (CODE1 "return-from") "が実行されたときは、" "そのフォームから渡された返却値であり、" "それ以外の場合は"
     (STRONG "result-form") "による返却値です。")
    (CHAPTER ("## 定義") 2 (CODE1 "dolist") "は、リストの要素に対して繰り返しを行います。" (CODE1 "dolist")
     "のボディ部は" (CODE1 "tagbody") "Ni似ています。" "それは" (STRONG "tag") "と" (STRONG "statement")
     "が続くものが含まれます。" EOL2 (CODE1 "dolist") "は" (STRONG "list-form") "を評価し、"
     "それはリストでなければいけません。" "そのあとボディ部がリストの各要素ごとに一度だけ実行され、" "実行は" (STRONG "tag") "と"
     (STRONG "statement") "を順番に行われ、" "その際に" (STRONG "var") "を各要素に束縛します。" "そして"
     (STRONG "result-form") "を評価します。" (STRONG "tag") "は" (STRONG "statement")
     "にラベル付けされます。" EOL2 (STRONG "result-form") "が実行された時点で、" (STRONG "var") "には"
     (CODE1 "nil") "が束縛されています。" EOL2 (CODE1 "nil") "という名前の暗黙の" (CODE1 "block") "が、"
     (CODE1 "dolist") "のフォーム全体を囲みます。" (CODE1 "return") "文は、それ以上の繰り返しを行うことなく"
     "ループを即座に終了させるときに使われ、" "そのときの返却値は0や複数の値を指定できます。" EOL2 (STRONG "var") "の束縛のスコープは、"
     (STRONG "list-form") "を含みませんが" (STRONG "result-form") "は含まれます。" EOL2
     (CODE1 "dolist") "が各繰り返しごとに" (STRONG "var") "の" "新しい束縛を確立するかどうか、" "あるいは"
     (STRONG "var") "が一度束縛されてからその後の繰り返しで" "代入されるのかどうかは" "実装依存です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq temp-two '()) =>  NIL"
      "(dolist (temp-one '(1 2 3 4) temp-two) (push temp-one temp-two)) =>  (4 3 2 1)"
      NIL "(setq temp-two 0) =>  0"
      "(dolist (temp-one '(1 2 3 4)) (incf temp-two)) =>  NIL" "temp-two =>  4" NIL
      "(dolist (x '(a b c d)) (prin1 x) (princ \" \")) " ">>  A B C D " "=>  NIL"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "do") "," (CODE1 "dotimes") "," (CODE1 "tagbody") ","
     "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 "go") "は、" (CODE1 "dotimes") "のボディ部で" (STRONG "tag")
     "によってラベル付けされた文へ" "遷移を制御するために使用されます。")))
(setf (gethash '("DOLIST" . "MACRO") *table*) (gethash "DOLIST" *table*))
(setf (gethash "DOTIMES" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "DOTIMES"))
    (CHAPTER ("## 構文") 2 (CODE1 "dotimes") " (" (STRONG "var") " " (STRONG "count-form")
     " [" (STRONG "result-form") "]) " (STRONG "declaration\\*") " " (CODE1 "{")
     (STRONG "tag") " " (CODE1 "|") " " (STRONG "statement") (CODE1 "}") "\\*" EOL1 "=> "
     (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - シンボル" EOL1 (STRONG "count-form")
     " - フォーム" EOL1 (STRONG "result-form") " - フォーム" EOL1 (STRONG "declaration")
     " - 宣言式。評価されません。" EOL1 (STRONG "tag") " - " (CODE1 "go") "のタグ。評価されません。" EOL1
     (STRONG "statement") " - compound-form。下記の説明に従って評価されます。" EOL1 (STRONG "result")
     " - もし" (CODE1 "return") "か" (CODE1 "return-from") "が実行されたときは、"
     "そのフォームから渡された返却値であり、" "それ以外の場合は" (STRONG "result-form") "による返却値です。")
    (CHAPTER ("## 定義") 2 (CODE1 "dotimes") "は、一連の整数による繰り返しを行います。" EOL2 (CODE1 "dotimes")
     "は" (STRONG "count-form") "を評価し" "その返却値は整数でなければなりません。" "もし" (STRONG "count-form")
     "がゼロか負の場合は、ボディ部は実行されません。" "それから" (CODE1 "dotimes") "はボディ部をいちど実行するごとに、" "各整数値を0から"
     (STRONG "count-form") "を含まない値まで上げて行き、" (STRONG "tag") "と" (STRONG "statement")
     "を順番に実行し、" "その際に" (STRONG "var") "を各整数に束縛します。" "そして" (STRONG "result-form")
     "を評価します。" (STRONG "result-form") "が処理された時点で、" (STRONG "var")
     "にはボディ部が実行された回数が束縛されています。" (STRONG "tag") "は" (STRONG "statement") "にラベル付けされます。"
     EOL2 (CODE1 "nil") "という名前の暗黙の" (CODE1 "block") "が、" (CODE1 "dotimes")
     "のフォーム全体を囲みます。" (CODE1 "return") "文は、それ以上の繰り返しを行うことなく" "ループを即座に終了させるときに使われ、"
     "そのときの返却値は0や複数の値を指定できます。" EOL2 "繰り返しのボディ部は暗黙の" (CODE1 "tagbody") "であり、" "これは"
     (CODE1 "go") "文の遷移先としてのタグを含みます。" "宣言は繰り返しのボディ部の前に配置できます。" EOL2 (STRONG "var")
     "の束縛のスコープは、" (STRONG "count-form") "を含みませんが" (STRONG "result-form") "は含まれます。" EOL2
     (CODE1 "dotimes") "が各繰り返しごとに" (STRONG "var") "の" "新しい束縛を確立するかどうか、" "あるいは"
     (STRONG "var") "が一度束縛されてからその後の繰り返しで" "代入されるのかどうかは" "実装依存です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(dotimes (temp-one 10 temp-one)) =>  10"
      "(setq temp-two 0) =>  0" "(dotimes (temp-one 10 t) (incf temp-two)) =>  T"
      "temp-two =>  10")
     EOL2 "次に文字列を処理する" (CODE1 "dotimes") "の使用例を示します"
     (CODE3 "```lisp" "```" ";;; もし指定された文字列のサブシーケンスが回文ならTrue。"
      ";;; （つまり前から読んでも後ろから読んでも同じとき）" "(defun palindromep (string &optional"
      "                          (start 0)"
      "                          (end (length string)))"
      "  (dotimes (k (floor (- end start) 2) t)"
      "   (unless (char-equal (char string (+ start k))"
      "                       (char string (- end k 1)))" "     (return nil))))"
      "(palindromep \"Able was I ere I saw Elba\") =>  T"
      "(palindromep \"A man, a plan, a canal--Panama!\") =>  NIL"
      "(remove-if-not #'alpha-char-p          ;Remove punctuation."
      "              \"A man, a plan, a canal--Panama!\")"
      "=>  \"AmanaplanacanalPanama\"" "(palindromep" " (remove-if-not #'alpha-char-p"
      "               \"A man, a plan, a canal--Panama!\")) =>  T" "(palindromep"
      " (remove-if-not" "  #'alpha-char-p"
      "  \"Unremarkable was I ere I saw Elba Kramer, nu?\")) =>  T" "(palindromep"
      " (remove-if-not" "  #'alpha-char-p" "  \"A man, a plan, a cat, a ham, a yak,"
      "                 a yam, a hat, a canal--Panama!\")) =>  T"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "do") "," (CODE1 "dolist") "," (CODE1 "tagbody"))
    (CHAPTER ("## 備考") 2 (CODE1 "go") "は、" (CODE1 "dotimes") "のボディ部で" (STRONG "tag")
     "によってラベル付けされた文へ" "遷移を制御するために使用されます。")))
(setf (gethash '("DOTIMES" . "MACRO") *table*) (gethash "DOTIMES" *table*))
(setf (gethash "DYNAMIC-EXTENT" *table*)
  '((CHAPTER NIL 0 "Declaration " (CODE1 "DYNAMIC-EXTENT"))
    (CHAPTER ("## 構文") 2 "(" (CODE1 "dynamic-extent") " [[" (STRONG "var\\*") " "
     (CODE1 "|") " (" (CODE1 "function") " " (STRONG "fn") ")\\*]])")
    (CHAPTER ("## 引数") 2 (STRONG "var") " - 変数名" EOL1 (STRONG "fn") " - 関数名")
    (CHAPTER ("## 有効な文脈") 2 (CODE1 "declare")) (CHAPTER ("## 影響する束縛の型") 2 "変数、関数")
    (CHAPTER ("## 定義") 2 "この宣言で指定された各変数" (CODE1 "vari") "が" "どのような扱いになるのかを説明します。"
     "あるフォームに含まれる部分を" (CODE1 "F") "とします。" (CODE1 "F") "によって対象の変数が束縛されている必要はありませんが、"
     "あとでそれぞれの場合を考えます。" "変数" (CODE1 "vari") "が取る値を" (CODE1 "vij") "とします。" (CODE1 "vij")
     "がある時点で" (CODE1 "vari") "の値になるときに、" (CODE1 "xijk") "を" (CODE1 "vij")
     "の「他からアクセス不可の部分」であるとします。" "ちょうど" (CODE1 "F") "の実行が終了した直後に、" "もし" (CODE1 "F") "が"
     (CODE1 "vari") "を束縛していた場合は、" (CODE1 "xijk") "はアクセス不可能です。" "もし" (CODE1 "F") "が"
     (CODE1 "vari") "を束縛していない場合は、" (CODE1 "xijk") "は" (CODE1 "vari")
     "の現在の値の「他からアクセス不可の部分」です。" "同じ関係が関数の名前空間の束縛について各" (CODE1 "fni") "にも生じます。" EOL2
     "コンパイラーはこの情報を処理系に適切な方法で、" "かつCommon Lispの意味に衝突しないような方法で" "使うことが許されます。" EOL2
     (CODE1 "dynamic-extent") "宣言は、自由宣言と境界宣言のどちらでも利用できます。" EOL2 (CODE1 "dynamic-extent")
     "宣言にある" (STRONG "var") "と" (STRONG "fn") "の名前は、" "シンボルマクロとマクロの束縛を参照してはいけません。")
    (CHAPTER ("## 例文") 2 "初期値をスタック領域で確保するには、" "そのオブジェクトの作成時にスタック領域の確保が可能かどうかを"
     "知る必要があるため、" "レキシカルに初期値が現れてない変数に対して" (CODE1 "dynamic-extent")
     "宣言をするのは一般的に有効ではありません。" "例えば、次のように記載します。"
     (CODE3 "```lisp" "```" "(defun f ()" "  (let ((x (list 1 2 3)))"
      "    (declare (dynamic-extent x))" "        ...))")
     EOL2 "これはコンパイラーに対して、" "ローカル変数" (CODE1 "x") "によって保持されるリストを"
     "スタック領域から確保して欲しいと許可を出しています。" "これは許可されますが、実際にはおそらく使いやすくありません。" "次の例を見てみます。"
     (CODE3 "```lisp" "```" "(defun g (x) (declare (dynamic-extent x)) ...)"
      "(defun f () (g (list 1 2 3)))")
     EOL2 "多くのコンパイラーはおそらく" (CODE1 "f") "の中では、" (CODE1 "g") "の引数をスタック領域に確保しません。"
     "なぜならコンパイラーが" (CODE1 "f") "内部から" (CODE1 "g") "の状況を推定する際に" "モジュール性の違反であるとみなすからです。"
     (CODE1 "g") "の定義が互換性のないものに変更されたときに、" (CODE1 "f") "の再コンパイルに責任を持てる実装のみが、" (CODE1 "f")
     "内の" (CODE1 "g") "へのリスト引数を" "正当な方法としてスタック確保できます。" EOL2 "別の例を示します。"
     (CODE3 "```lisp" "```" "(declaim (inline g))"
      "(defun g (x) (declare (dynamic-extent x)) ...)" "(defun f () (g (list 1 2 3)))"
      NIL "(defun f ()" "  (flet ((g (x) (declare (dynamic-extent x)) ...))"
      "    (g (list 1 2 3))))")
     EOL2 "この例では、いくつかのコンパイラーは最適化を可能にしますし、" "そうでないものもあります。" EOL2 "別の最適化で「スタックに確保された"
     (CODE1 "rest") "リスト」と呼ばれるものは" "（実装がこの最適化をサポートしているならば）、" "次のように行います。"
     (CODE3 "```lisp" "```" "(defun f (&rest x)" "  (declare (dynamic-extent x))"
      "  ...)")
     EOL2 "この例では" (CODE1 "x") "の初期値は明になっていないことに注意してください。" "このような場合でも関数" (CODE1 "f")
     "は引数として渡されるリスト" (CODE1 "x") "の編成に責任を持ちます。" "もし実装が最適化をサポートしているのであれば、" "コンパイラーは関数"
     (CODE1 "f") "に対して、リストの生成をヒープ領域ではなく" "スタック領域に構築するような最適化を行います。" EOL2 "下記の例を見てみます。"
     (CODE3 "```lisp" "```" "(let ((x (list 'a1 'b1 'c1))"
      "      (y (cons 'a2 (cons 'b2 (cons 'c2 nil)))))"
      "  (declare (dynamic-extent x y))" "  ...)")
     EOL2 (CODE1 "x") "の他からアクセス不可の部分は3つのコンスであり、" (CODE1 "y") "の他からアクセス不可の部分は他の3つのコンスです。"
     "シンボル" (CODE1 "a1") ", " (CODE1 "b1") ", " (CODE1 "c1") ", " (CODE1 "a2") ", "
     (CODE1 "b2") ", " (CODE1 "c2") "と" (CODE1 "nil") "は、" (CODE1 "x") "か" (CODE1 "y")
     "の他からアクセス不可の部分であることに注意してください。" "なぜなら、それらは" (CODE1 "intern") "されており、"
     (CODE1 "intern") "されているものはパッケージからアクセスできるからです。" "しかし、もし" (CODE1 "intern")
     "されていない新しいシンボルが使われている場合、" "それは、そのシンボルが含まれるリストの" "他からアクセス不可の部分になります。"
     (CODE3 "```lisp" "```" ";; この例では、Xに束縛されているリストをスタック領域に" ";; 確保することを実装に許可しています。"
      "(let ((x (list 1 2 3)))" "  (declare (dynamic-extent x))" "  (print x)" "  :done)"
      ">>  (1 2 3)" "=>  :DONE" " " ";; この例では、Lに束縛されるリストがスタック確保可能です。"
      "(defun zap (x y z)" "  (do ((l (list x y z) (cdr l)))" "      ((null l))"
      "    (declare (dynamic-extent l))" "    (prin1 (car l)))) =>  ZAP" "(zap 1 2 3)"
      ">>  123" "=>  NIL" NIL ";; いくつかの実装は、Lに束縛されるリストをスタックに確保できるよう"
      ";; LIST-ALL-PACKAGESのコードを開放しているかもしれません。" "(do ((l (list-all-packages) (cdr l)))"
      "    ((null l))" "  (declare (dynamic-extent l))"
      "  (let ((name (package-name (car l))))"
      "    (when (string-search \"COMMON-LISP\" name) (print name))))"
      ">>  \"COMMON-LISP\"" ">>  \"COMMON-LISP-USER\"" "=>  NIL" NIL
      ";; いくつかの実装では、restのリストをスタックに確保できます。" ";; 下記のような宣言は、そのような実装に対してrestリストを"
      ";; スタック確保したいという合図になるはずです。" "(defun add (&rest x)" "  (declare (dynamic-extent x))"
      "  (apply #'+ x)) =>  ADD" "(add 1 2 3) =>  6" NIL "(defun zap (n m)"
      "  ;; (RANDOM (+ M 1))を計算するには、だいたいO(N)の速度になります。" "  ;; これはとても遅いですが良いコンパイラーなら少なくとも"
      "  ;; 大量のヒープ領域を消費することはないでしょう。 :-}" "  (let ((a (make-array n)))"
      "    (declare (dynamic-extent a))" "    (dotimes (i n) "
      "      (declare (dynamic-extent i))" "      (setf (aref a i) (random (+ i 1))))"
      "    (aref a m))) =>  ZAP" "(< (zap 5 3) 3) =>  true")
     EOL2 "下記の例は値" (CODE1 "x") "がその範囲から外で使用されているためエラーです。"
     (CODE3 "```lisp" "```" "(length (list (let ((x (list 1 2 3)))  ; Invalid"
      "               (declare (dynamic-extent x))" "               x)))" NIL
      "(progn (let ((x (list 1 2 3)))  ; Invalid" "         (declare (dynamic-extent x))"
      "         x)" "       nil)"))
    (CHAPTER ("## 参考") 2 (CODE1 "declare"))
    (CHAPTER ("## 備考") 2 "この最も一般的な最適化は、" (STRONG "var") "変数の初期値のオブジェクトを" "スタック領域に確保します。"
     EOL2 "実装は単純にこの宣言を無視することも許されます。")))
(setf (gethash '("DYNAMIC-EXTENT" . "DECLARATION") *table*) (gethash "DYNAMIC-EXTENT" *table*))
(setf (gethash "ECASE" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "CASE") ", " (CODE1 "CCASE") ", " (CODE1 "ECASE"))
    (CHAPTER ("## 構文") 2 (CODE1 "case") " " (STRONG "keyform") " " (CODE1 "{")
     (STRONG "normal-clause") (CODE1 "}") "\\* [" (STRONG "otherwise-clause") "] => "
     (STRONG "result\\*") EOL1 (CODE1 "ccase") " " (STRONG "keyplace") " " (CODE1 "{")
     (STRONG "normal-clause") (CODE1 "}") "\\* => " (STRONG "result\\*") EOL1
     (CODE1 "ecase") " " (STRONG "keyform") " " (CODE1 "{") (STRONG "normal-clause")
     (CODE1 "}") "\\* => " (STRONG "result\\*")
     (CODE3 "```" "```" "normal-clause ::= (keys form*) "
      "otherwise-clause ::= ({otherwise | t} form*) "
      "clause ::= normal-clause | otherwise-clause "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "keyform") " - フォーム。評価され" (STRONG "test-key")
     "を返却します。" EOL1 (STRONG "keyplace") " - フォーム。評価されて最初に" (STRONG "test-key") "を返却します。"
     EOL1 "もしキーにマッチしなかったときは、可能であれば後で" (CODE1 "place") "としても使われます。" EOL1
     (STRONG "test-key") " - " (STRONG "keyform") "か" (STRONG "keyplace")
     "が評価されることによって返却されるオブジェクト。" EOL1 (STRONG "keys") " - オブジェクトのリストの指定子。" (CODE1 "case")
     "の場合、シンボル" (CODE1 "t") "と" (CODE1 "otherwise") "は" "キー指定子として使用することができません。"
     "キーとしてそれらのシンボルを使用したいときは、" "それぞれ" (CODE1 "(t)") "、" (CODE1 "(otherwise)")
     "をかわりに使わなければいけません。" EOL1 (STRONG "form") " - 暗黙のprogn" EOL1 (STRONG "result")
     " - マッチした" (STRONG "clause") "の" (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 "これらのマクロは、" (STRONG "test-key") "とのマッチによって選択された"
     (STRONG "clause") "内の" (STRONG "form") "のボディを条件付きで実行します。" EOL2 (STRONG "keyform")
     "と" (STRONG "keyplace") "が評価されて、" (STRONG "test-key") "が生成されます。" EOL2 "そのあと各"
     (STRONG "normal-clause") "が順番に考慮されます。" "もし" (STRONG "test-key") "が"
     (STRONG "clause") "のどれかのキーと同じであれば、" "その" (STRONG "clause") "内の" (STRONG "form")
     "が暗黙のprognとして評価され、" (CODE1 "case") "、" (CODE1 "ccase") "、" (CODE1 "ecase")
     "フォームの返却値として" "その多値が返却されます。" EOL2 "これらのマクロは、もし" (STRONG "normal-clause")
     "がマッチしなかったときにだけ、" "動作が違っています。" "違いを下記に示します。" EOL2 "- " (CODE1 "case") "  - もしマッチする"
     (STRONG "normal-clause") "が存在せず" (STRONG "otherwise-clause") "があるときは、" "    自動的に"
     (STRONG "otherwise-clause") "がマッチします。" "    その" (STRONG "clause") "にある"
     (STRONG "form") "は暗黙のprognとして評価され、" "    その" (STRONG "clause") "内の" (STRONG "form")
     "は暗黙のprognとして評価され、" "    " (CODE1 "case") "フォームの返却値としてその多値が返却されます。" "    <br><br>"
     "    もし" (STRONG "otherwise-clause") "がないときは、" "    " (CODE1 "case") "は"
     (CODE1 "nil") "を返却します。" "    <br><br>" EOL2 "- " (CODE1 "ccase") "  - もしマッチする"
     (STRONG "normal-clause") "が存在しないときは、" "    型" (CODE1 "type-error")
     "の修正可能なエラーが発生します。" "    問題の" (CODE1 "datum") "は" (STRONG "test-key") "であり、" "    "
     (CODE1 "expected type") "は" (CODE1 "(member key1 key2 ...)") "と同等の型です。" "    "
     (CODE1 "store-value") " " (CODE1 "restart") "をエラーの修正に使うことができます。" "    <br><br>"
     "    もし" (CODE1 "store-value") " " (CODE1 "restart") "が起動されたら、" "    その引数は新しい"
     (STRONG "test-key") "であり、" "    " (STRONG "keyplace") "への保存は"
     (CODE1 "(setf keyplace test-key)") "のように行われます。" "    それから" (CODE1 "ccase")
     "は最初から始められ、" "    各" (STRONG "clause") "が新しく評価されます。" "    <br><br>"
     "    いずれのケースも成立しない場合、" "    " (STRONG "keyplace") "のサブフォームは再度評価されるかもしれません。"
     "    <br><br>" EOL2 "- " (CODE1 "ecase") "  - もしマッチする" (STRONG "normal-clause")
     "が存在しないときは、" "    型" (CODE1 "type-error") "の修正不可能なエラーが発生します。" "    問題の"
     (CODE1 "datum") "は" (STRONG "test-key") "であり、" "    " (CODE1 "expected type") "は"
     (CODE1 "(member key1 key2 ...)") "と同等の型です。" "    <br><br>" "    " (CODE1 "ccase")
     "とは対照的に" (CODE1 "ecase") "の使用者は、" "    もし" (STRONG "normal-clause") "がマッチしなかったら"
     "    " (CODE1 "ecase") "は戻ってこないという事実に頼っています。" "    <br><br>")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(dolist (k '(1 2 3 :four #\\v () t 'other))"
      "   (format t \"~S \"" "      (case k ((1 2) 'clause1)"
      "              (3 'clause2)" "              (nil 'no-keys-so-never-seen)"
      "              ((nil) 'nilslot)" "              ((:four #\\v) 'clause4)"
      "              ((t) 'tslot)" "              (otherwise 'others)))) "
      ">>  CLAUSE1 CLAUSE1 CLAUSE2 CLAUSE4 CLAUSE4 NILSLOT TSLOT OTHERS " "=>  NIL"
      "(defun add-em (x) (apply #'+ (mapcar #'decode x)))" "=>  ADD-EM"
      "(defun decode (x)" "  (ccase x" "    ((i uno) 1)" "    ((ii dos) 2)"
      "    ((iii tres) 3)" "    ((iv cuatro) 4)))" "=>  DECODE"
      "(add-em '(uno iii)) =>  4" "(add-em '(uno iiii))"
      ">>  Error: The value of X, IIII, is not I, UNO, II, DOS, III,"
      ">>         TRES, IV, or CUATRO." ">>   1: Supply a value to use instead."
      ">>   2: Return to Lisp Toplevel." ">>  Debug> :CONTINUE 1"
      ">>  Value to evaluate and use for X: 'IV" "=>  5"))
    (CHAPTER ("## 副作用") 2 "デバッガーに入るかもしれません。" "もし" (CODE1 "store-value") " "
     (CODE1 "restart") "が実行されたとき、" (STRONG "keyplace") "の値は変更されるかもしれません。")
    (CHAPTER ("## 影響") 2 (CODE1 "ccase") "と" (CODE1 "ecase") "がエラーを通知したときは、" "既存の"
     (CODE1 "handler") "と" (CODE1 "*debug-io*") "に影響を及ぼす可能性があります。")
    (CHAPTER ("## 例外") 2 (STRONG "normal-clause") "にマッチしなかったときは、" (CODE1 "ccase") "と"
     (CODE1 "ecase") "は" "型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "cond") "," (CODE1 "typecase") "," (CODE1 "setf") ","
     "5.1. 一般化された参照")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(case test-key" "  {((key*) form*)}*)" "== "
      "(let ((#1=#:g0001 test-key))" "  (cond {((member #1# '(key*)) form*)}*))")
     EOL2 (CODE1 "ecase") "と" (CODE1 "ccase") "によって使われる特定のエラーメッセージは、" "実装によって変わります。"
     "そんな中で、エラーメッセージの特定の単語の制御が必要なときは、" (CODE1 "case") "の" (STRONG "otherwise-clause") "で"
     "明示的に適切なエラーメッセージを発生させるのが良いでしょう。")))
(setf (gethash '("ECASE" . "MACRO") *table*) (gethash "ECASE" *table*))
(setf (gethash "ECHO-STREAM" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "ECHO-STREAM"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "echo-stream") "," (CODE1 "stream") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 (CODE1 "echo") "ストリームは双方向ストリームであり、" "関連付けられた入力ストリームから取得を行い、"
     "関連付けられた出力ストリームに送信を行います。" EOL2 "入力ストリームからの全ての入力は、" "出力ストリームに送信（エコー）されます。"
     "入力はデータを受け付けて即座にエコーされるか、" "あるいは入力ストリームから読み込み処理を行ったあとにエコーされるかは、" "実装依存です。")
    (CHAPTER ("## 参考") 2 (CODE1 "echo-stream-input-stream") ","
     (CODE1 "echo-stream-output-stream") "," (CODE1 "make-echo-stream"))))
(setf (gethash '("ECHO-STREAM" . "SYSTEM-CLASS") *table*) (gethash "ECHO-STREAM" *table*))
(setf (gethash "ECHO-STREAM-INPUT-STREAM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ECHO-STREAM-INPUT-STREAM") ", "
     (CODE1 "ECHO-STREAM-OUTPUT-STREAM"))
    (CHAPTER ("## 構文") 2 (CODE1 "echo-stream-input-stream") " " (STRONG "echo-stream")
     " => " (STRONG "input-stream") EOL1 (CODE1 "echo-stream-output-stream") " "
     (STRONG "echo-stream") " => " (STRONG "output-stream"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "echo-stream") " - " (CODE1 "echo") "ストリーム" EOL1
     (STRONG "input-stream") " - 入力ストリーム" EOL1 (STRONG "output-stream") " - 出力ストリーム")
    (CHAPTER ("## 定義") 2 (CODE1 "echo-stream-input-stream") "は、" (STRONG "echo-stream")
     "が入力を受け取るストリームを返却します。" EOL2 (CODE1 "echo-stream-output-stream") "は、"
     (STRONG "echo-stream") "が出力を送信するストリームを返却します。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("ECHO-STREAM-INPUT-STREAM" . "FUNCTION") *table*) (gethash "ECHO-STREAM-INPUT-STREAM" *table*))
(setf (gethash "ECHO-STREAM-OUTPUT-STREAM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ECHO-STREAM-INPUT-STREAM") ", "
     (CODE1 "ECHO-STREAM-OUTPUT-STREAM"))
    (CHAPTER ("## 構文") 2 (CODE1 "echo-stream-input-stream") " " (STRONG "echo-stream")
     " => " (STRONG "input-stream") EOL1 (CODE1 "echo-stream-output-stream") " "
     (STRONG "echo-stream") " => " (STRONG "output-stream"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "echo-stream") " - " (CODE1 "echo") "ストリーム" EOL1
     (STRONG "input-stream") " - 入力ストリーム" EOL1 (STRONG "output-stream") " - 出力ストリーム")
    (CHAPTER ("## 定義") 2 (CODE1 "echo-stream-input-stream") "は、" (STRONG "echo-stream")
     "が入力を受け取るストリームを返却します。" EOL2 (CODE1 "echo-stream-output-stream") "は、"
     (STRONG "echo-stream") "が出力を送信するストリームを返却します。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("ECHO-STREAM-OUTPUT-STREAM" . "FUNCTION") *table*) (gethash "ECHO-STREAM-OUTPUT-STREAM" *table*))
(setf (gethash "EIGHTH" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "FIRST") ", " (CODE1 "SECOND") ", " (CODE1 "THIRD")
     ", " (CODE1 "FOURTH") ", " (CODE1 "FIFTH") "," (CODE1 "SIXTH") ", "
     (CODE1 "SEVENTH") ", " (CODE1 "EIGHTH") ", " (CODE1 "NINTH") ", " (CODE1 "TENTH"))
    (CHAPTER ("## 構文") 2 (CODE1 "first") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "second") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "third") " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fourth")
     " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fifth") " "
     (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "sixth") " " (STRONG "list")
     " => " (STRONG "object") EOL1 (CODE1 "seventh") " " (STRONG "list") " => "
     (STRONG "object") EOL1 (CODE1 "eighth") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "ninth") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "tenth") " " (STRONG "list") " => " (STRONG "object") EOL1 "(" (CODE1 "setf")
     " (" (CODE1 "first") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "second") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "third") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "fourth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "fifth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "sixth") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "seventh") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "eighth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "ninth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "tenth") " " (STRONG "list") ") " (STRONG "new-object")
     ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト、ドットリストと循環リストも受け付けます。" EOL1
     (STRONG "object") ", " (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "関数" (CODE1 "first") ", " (CODE1 "second") ", " (CODE1 "third")
     ", " (CODE1 "fourth") ", " (CODE1 "fifth") "," (CODE1 "sixth") ", "
     (CODE1 "seventh") ", " (CODE1 "eighth") ", " (CODE1 "ninth") ", " (CODE1 "tenth")
     "は、" "それぞれリストの1番目、2番目、3番目、4番目、5番目、" "6番目、7番目、8番目、9番目、10番目の要素にアクセスします。"
     "具体的には次のようになります。"
     (CODE3 "```lisp" "```" "(first list)    ==   (car list)"
      "(second list)   ==   (car (cdr list))" "(third list)    ==   (car (cddr list))"
      "(fourth list)   ==   (car (cdddr list))"
      "(fifth list)    ==   (car (cddddr list))"
      "(sixth list)    ==   (car (cdr (cddddr list)))"
      "(seventh list)  ==   (car (cddr (cddddr list)))"
      "(eighth list)   ==   (car (cdddr (cddddr list)))"
      "(ninth list)    ==   (car (cddddr (cddddr list)))"
      "(tenth list)    ==   (car (cdr (cddddr (cddddr list))))")
     EOL2 (CODE1 "setf") "は、これらの関数を使うことによって" "既存の構成要素を変更することもできます。"
     "上記の等価な関係を用いて同じように適用できます。" "例えば次のようになります。"
     (CODE3 "```lisp" "```"
      "(setf (fifth list) new-object) == (setf (car (cddddr list)) new-object)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst '(1 2 3 (4 5 6) ((V)) vi 7 8 9 10)) "
      "=>  (1 2 3 (4 5 6) ((V)) VI 7 8 9 10)" "(first lst) =>  1" "(tenth lst) =>  10"
      "(fifth lst) =>  ((V))" "(second (fourth lst)) =>  5" "(sixth '(1 2 3)) =>  NIL"
      "(setf (fourth lst) \"four\") =>  \"four\""
      "lst =>  (1 2 3 \"four\" ((V)) VI 7 8 9 10)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "car") "," (CODE1 "nth"))
    (CHAPTER ("## 備考") 2 (CODE1 "first") "は機能的には" (CODE1 "car") "と同じです。" (CODE1 "second")
     "は機能的には" (CODE1 "cadr") "と同じです。" (CODE1 "third") "は機能的には" (CODE1 "caddr") "と同じです。"
     (CODE1 "fourth") "は機能的には" (CODE1 "cadddr") "と同じです。" EOL2 "通常の番号付けは1から開始しますが、"
     (CODE1 "nth") "によって使われる採番は0開始であり、" "次の関係が成り立ちます。"
     (CODE3 "```lisp" "```" "(fifth x) == (nth 4 x)"))))
(setf (gethash '("EIGHTH" . "ACCESSOR") *table*) (gethash "EIGHTH" *table*))
(setf (gethash "ELT" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "ELT"))
    (CHAPTER ("## 構文") 2 (CODE1 "elt") " " (STRONG "sequence") " " (STRONG "index")
     " => " (STRONG "object") EOL1 "(" (CODE1 "setf") " (" (CODE1 "elt") " "
     (STRONG "sequence") " " (STRONG "index") ") " (STRONG "new-object") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "sequence") " - 正常なシーケンス" EOL1 (STRONG "index")
     " - " (STRONG "sequence") "の有効なシーケンスのインデックス" EOL1 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "sequence") "の" (STRONG "index") "指定の要素にアクセスします。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq str (copy-seq \"0123456789\")) =>  \"0123456789\""
      "(elt str 6) =>  #\\6" "(setf (elt str 0) #\\#) =>  #\\#"
      "str =>  \"#123456789\""))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。" EOL2 (STRONG "index") "が、" (STRONG "sequence")
     "の有効なシーケンスのインデックスではないとき、" "型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "aref") "," (CODE1 "nth") "," "3.2.1. コンパイラーの用語")
    (CHAPTER ("## 備考") 2 (CODE1 "aref") "は、" (CODE1 "vector") "のfill-pointerを越えた、"
     (CODE1 "vector") "の要素に" "アクセスするときに使用します。")))
(setf (gethash '("ELT" . "ACCESSOR") *table*) (gethash "ELT" *table*))
(setf (gethash "END-OF-FILE" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "END-OF-FILE"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "end-of-file") "," (CODE1 "stream-error") ","
     (CODE1 "error") "," (CODE1 "serious-condition") "," (CODE1 "condition") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "end-of-file") "は、" "もうデータがないストリームに対して"
     "読み込み処理を行ったことに関係する" "エラーのコンディションを含みます。")
    (CHAPTER ("## 参考") 2 (CODE1 "stream-error-stream"))))
(setf (gethash '("END-OF-FILE" . "CONDITION-TYPE") *table*) (gethash "END-OF-FILE" *table*))
(setf (gethash "ENDP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ENDP"))
    (CHAPTER ("## 構文") 2 (CODE1 "endp") " " (STRONG "list") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト、ドットリストと循環リストも受け付けます。" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "list") "が空のリストなら" (STRONG "true") "を返却します。"
     (STRONG "list") "がコンスなら" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(endp nil) =>  true" "(endp '(1 2)) =>  false"
      "(endp (cddr '(1 2))) =>  true"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list") "がリストでなかったときは、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 (CODE1 "endp") "の目的は、" "通常のリストの終わりを確認することです。" (CODE1 "endp")
     "はコンス内に降りて行かないので、" "ドットリストを与えてもうまく動作します。" "しかしもし短いリストに対して反復的に" (CODE1 "cdr")
     "を呼び続けられ、" "それらのリストが" (CODE1 "endp") "によってテストされ続けたとき、" "このような状況において、" "最終的に"
     (CODE1 "nil") "ではないアトム（実際にリストではない）が" (CODE1 "endp") "の引数になったときの結果は未定義です。" "これは"
     (CODE1 "endp") "が使われる普通の方法であり、" (CODE1 "endp") "を使用する際に引数の型が通常のリストであるか、"
     "あるいはアトムであるかを強制せず、" "単純な関数として" (CODE1 "endp") "を扱うということは、" "保守的なプログラミングスタイルであり"
     (CODE1 "endp") "の目的とも一致しています。")))
(setf (gethash '("ENDP" . "FUNCTION") *table*) (gethash "ENDP" *table*))
(setf (gethash "ENOUGH-NAMESTRING" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "NAMESTRING") ", " (CODE1 "FILE-NAMESTRING") ", "
     (CODE1 "DIRECTORY-NAMESTRING") "," (CODE1 "HOST-NAMESTRING") ", "
     (CODE1 "ENOUGH-NAMESTRING"))
    (CHAPTER ("## 構文") 2 (CODE1 "namestring") " " (STRONG "pathname") " => "
     (STRONG "namestring") EOL1 (CODE1 "file-namestring") " " (STRONG "pathname") " => "
     (STRONG "namestring") EOL1 (CODE1 "directory-namestring") " " (STRONG "pathname")
     " => " (STRONG "namestring") EOL1 (CODE1 "host-namestring") " " (STRONG "pathname")
     " => " (STRONG "namestring") EOL1 (CODE1 "enough-namestring") " "
     (STRONG "pathname") " " (CODE1 "&optional") " " (STRONG "defaults") " => "
     (STRONG "namestring"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathname") " - パス名指定子" EOL1 (STRONG "defaults")
     " - パス名指定子。" "デフォルトは" (CODE1 "*default-pathname-defaults*") "の値です。" EOL1
     (STRONG "namestring") " - 文字列か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "pathname") "を名前文字列に変換します。"
     (STRONG "pathname") "によって表現される名前は、" "実装依存の基準のフォームに従った" "名前文字列として返却されます。" EOL2
     (CODE1 "namestring") "は、" (STRONG "pathname") "の完全なフォームを返却します。" EOL2
     (CODE1 "file-namestring") "は、" (STRONG "pathname") "の名前とタイプとバージョンの要素だけを返却します。" EOL2
     (CODE1 "directory-namestring") "は、" (STRONG "pathname") "のディレクトリの名前の部分を返却します。" EOL2
     (CODE1 "host-namestring") "は、ホスト名を返却します。" EOL2 (CODE1 "enough-namestring") "は、"
     (STRONG "pathname") "が" (STRONG "defaults") "から相対的に考慮されたものによって、"
     "同一と見なせるのに十分なファイル名である" "省略された名前文字列を返却します。" "これは、全ての場合において次のような関係を要求します。"
     (CODE3 "```lisp" "```"
      "(merge-pathnames (enough-namestring pathname defaults) defaults)"
      "==  (merge-pathnames (parse-namestring pathname nil defaults) defaults)")
     EOL2 (CODE1 "enough-namestring") "の結果は、" "このような基準を満たした最も短い適切な文字列です。" EOL2
     "この3つの短い名前文字列をある順にて結合することによって" "有効な名前文字列を生成することは必ずしも可能ではありません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(namestring \"getty\")            " "=>  \"getty\""
      "(setq q (make-pathname :host \"kathy\" " "                        :directory "
      "                          (pathname-directory *default-pathname-defaults*)"
      "                        :name \"getty\")) "
      "=>  #S(PATHNAME :HOST \"kathy\" :DEVICE NIL :DIRECTORY directory-name "
      "      :NAME \"getty\" :TYPE NIL :VERSION NIL)" "(file-namestring q) =>  \"getty\""
      "(directory-namestring q) =>  directory-name" "(host-namestring q) =>  \"kathy\" "
      ";;; Unix構文の使用とこの例での特定のUnixバージョンによる" ";;; ワイルドカード表記の使用によって作成されたもの" "(namestring"
      "  (translate-pathname \"/usr/dmr/hacks/frob.l\""
      "                      \"/usr/d*/hacks/*.l\""
      "                      \"/usr/d*/backup/hacks/backup-*.*\"))"
      ">  \"/usr/dmr/backup/hacks/backup-frob.l\"" "(namestring"
      "  (translate-pathname \"/usr/dmr/hacks/frob.l\""
      "                      \"/usr/d*/hacks/fr*.l\""
      "                      \"/usr/d*/backup/hacks/backup-*.*\"))"
      "=>  \"/usr/dmr/backup/hacks/backup-ob.l\"" NIL
      ";;; これは上記の例に似ていますが2つの違ったホストを使用しています。" ";;; UがUnixであり、VがVMSです。ファイルタイプの変換と"
      ";;; アルファベットの大文字小文字の表記に注意してください。" "(namestring"
      "  (translate-pathname \"U:/usr/dmr/hacks/frob.l\""
      "                      \"U:/usr/d*/hacks/*.l\""
      "                      \"V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*\"))"
      "=>  \"V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-FROB.LSP\"" "(namestring"
      "  (translate-pathname \"U:/usr/dmr/hacks/frob.l\""
      "                      \"U:/usr/d*/hacks/fr*.l\""
      "                      \"V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*\"))"
      "=>  \"V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-OB.LSP\""))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "truename") "," (CODE1 "merge-pathnames") ","
     (CODE1 "pathname") "," (CODE1 "logical-pathname") "," "20.1. ファイルシステムの説明,"
     "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("ENOUGH-NAMESTRING" . "FUNCTION") *table*) (gethash "ENOUGH-NAMESTRING" *table*))
(setf (gethash "ENSURE-DIRECTORIES-EXIST" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ENSURE-DIRECTORIES-EXIST"))
    (CHAPTER ("## 構文") 2 (CODE1 "ensure-directories-exist") " " (STRONG "pathspec") " "
     (CODE1 "&key") " " (STRONG "verbose") " => " (STRONG "pathspec") ", "
     (STRONG "created"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathspec") " - パス名指定子" EOL1 (STRONG "verbose")
     " - generalized-boolean" EOL1 (STRONG "created") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "指定されたファイルに含まれるディレクトリが" "実際に存在するかどうかをテストし、"
     "もし存在しなかったときは作成するよう試みます。" EOL2 "もし含まれているディレクトリが存在せず、" (STRONG "verbose") "が"
     (STRONG "true") "のときは、" "実装は標準出力にどのようなディレクトリが生成されたかを" "出力することが許されます（しかし必須ではありません）。"
     "もし含まれているディレクトリが存在しているか、" "あるいは" (STRONG "verbose") "が" (STRONG "false") "のときは、"
     "この関数は何も出力しません。" EOL2 "第一返却値は引数の" (STRONG "pathspec") "であり、"
     "この操作が他のファイル操作の式に直接組み込めるようにしています。" "第二返却値の" (STRONG "created") "は、"
     "もし何らかのディレクトリが生成された場合は" (STRONG "true") "です。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "ホストコンピューターのファイルシステム")
    (CHAPTER ("## 例外") 2 (STRONG "pathspec") "のホスト、デバイス、ディレクトリの部分が" "ワイルドカードを含んでいるときは、"
     "型" (CODE1 "file-error") "のエラーが発生します。" EOL2 "もしディレクトリの生成の試行が成功しなかったとき、" "型"
     (CODE1 "file-error") "が通知されますが、" "もしこのような状況が生じたときに" "ファイルシステム内で実際に生じたことは、"
     "生成が全く起こらなかったか、" "あるいはいくつか生成されたか、" "または全ての要求が生成されたか、" "いずれかの場合になるでしょう。")
    (CHAPTER ("## 参考") 2 (CODE1 "probe-file") "," (CODE1 "open") ","
     "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("ENSURE-DIRECTORIES-EXIST" . "FUNCTION") *table*) (gethash "ENSURE-DIRECTORIES-EXIST" *table*))
(setf (gethash "ENSURE-GENERIC-FUNCTION" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ENSURE-GENERIC-FUNCTION"))
    (CHAPTER ("## 構文") 2 (CODE1 "ensure-generic-function") " " (STRONG "function-name")
     "&key " (STRONG "argument-precedence-order") " " (STRONG "declare") " "
     (STRONG "documentation") (STRONG "environment") " "
     (STRONG "generic-function-class") " " (STRONG "lambda-list") (STRONG "method-class")
     " " (STRONG "method-combination") EOL1 "=> " (STRONG "generic-function"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function-name") " - 関数名" EOL2 "キーワード引数は"
     (CODE1 "defgeneric") "の引数に対応しますが、" (CODE1 ":method-class") "と"
     (CODE1 ":generic-function-class") "の引数は、" "名前と同様にクラスオブジェクトを指定できます。" EOL2
     (STRONG "method-combination") " - method-combinationオブジェクト" EOL1
     (STRONG "environment") " - マクロ展開関数の" (CODE1 "&environment") "引数と同じです。"
     "この引数は、コンパイル時と実行時を区別するために使われます。" EOL1 (STRONG "generic-function")
     " - ジェネリック関数オブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "ensure-generic-function") "関数は、"
     "メソッドを持たないグローバルの名前付きジェネリック関数を定義したり、" "グローバルの名前付きジェネリック関数全体に関連する"
     "オプションや宣言を指定・変更するために使われます。" EOL2 "もし" (STRONG "function-name") "がグローバル環境において"
     (CODE1 "fbound") "ではない場合" "新しいジェネリック関数が作成されます。" "もし"
     (CODE1 "(fdefinition function-name)") "が通常の関数か、" "マクロか、特殊オペレーターで存在する場合は、エラーが発せられます。"
     EOL2 "もし" (STRONG "function-name") "がリストの場合は、" (CODE1 "(setf symbol)")
     "の形式でなければなりません。" "もし" (STRONG "function-name") "というジェネリック関数が定義されており、"
     "引数に続く値が違っている場合は、" "ジェネリック関数は" (CODE1 ":argument-precedence-order") ", "
     (CODE1 ":declare") "," (CODE1 ":documentation") ", " (CODE1 ":method-combination")
     "の値を新しいものに修正します。" EOL2 "もし" (STRONG "function-name") "で定義されているジェネリック関数と"
     (CODE1 ":lambda-list") "引数の値が異なっており、" "新しい値が既存の全てのメソッドのラムダリストと合致するか、"
     "あるいはメソッドがそもそも存在しない場合は新しい値に変更されます。" "そうでない場合は、エラーが発せられます。" EOL2
     (STRONG "function-name") "で定義されているジェネリック関数と" (CODE1 ":generic-function-class")
     "引数の値が異なっており、" "かつ新しいジェネリック関数のクラスが古いものと互換性がある場合は、" (CODE1 "change-class") "を呼び出して"
     "ジェネリック関数のクラスを変更します。" "そうでない場合は、エラーが発生します。" EOL2 (STRONG "function-name")
     "で定義されているジェネリック関数と" (CODE1 ":method-class") "引数の値が異なっている場合は、" "新しい値に変更されます。"
     "しかし既に存在しているメソッドは変更されません。")
    (CHAPTER ("## 例文") 2 "なし。")
    (CHAPTER ("## 影響") 2 (STRONG "function-name") "に束縛されている既存の関数。")
    (CHAPTER ("## 例外") 2 "もし" (CODE1 "(fdefinition function-name)") "が通常の関数か、"
     "マクロか、特殊オペレーターで存在する場合は、" "型" (CODE1 "error") "のエラーが発せられます。" EOL2 "もし"
     (STRONG "function-name") "で定義されているジェネリック関数と" (CODE1 ":lambda-list") "引数の値が異なっており、"
     "新しい値が既存の全てのメソッドのラムダリストと合致しない場合は、" "型" (CODE1 "error") "のエラーが発せられます。" EOL2
     (STRONG "function-name") "で定義されているジェネリック関数と" (CODE1 ":generic-function-class")
     "引数の値が異なっており、" "かつ新しいジェネリック関数のクラスが古いものと互換性がない場合は、" "型" (CODE1 "error")
     "のエラーが発せられます。")
    (CHAPTER ("## 参考") 2 (CODE1 "defgeneric")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("ENSURE-GENERIC-FUNCTION" . "FUNCTION") *table*) (gethash "ENSURE-GENERIC-FUNCTION" *table*))
(setf (gethash "EQ" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "EQ"))
    (CHAPTER ("## 構文") 2 (CODE1 "eq") " " (STRONG "x") " " (STRONG "y") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - オブジェクト" EOL1 (STRONG "y") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "もし引数が同じであり同一のオブジェクトであれば" (STRONG "true") "を、" "それ以外は"
     (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(eq 'a 'b) =>  false" "(eq 'a 'a) =>  true" "(eq 3 3)"
      "=>  true" "OR=>  false" "(eq 3 3.0) =>  false" "(eq 3.0 3.0)" "=>  true"
      "OR=>  false" "(eq #c(3 -4) #c(3 -4))" "=>  true" "OR=>  false"
      "(eq #c(3 -4.0) #c(3 -4)) =>  false" "(eq (cons 'a 'b) (cons 'a 'c)) =>  false"
      "(eq (cons 'a 'b) (cons 'a 'b)) =>  false" "(eq '(a . b) '(a . b))" "=>  true"
      "OR=>  false" "(progn (setq x (cons 'a 'b)) (eq x x)) =>  true"
      "(progn (setq x '(a . b)) (eq x x)) =>  true" "(eq #\\A #\\A)" "=>  true"
      "OR=>  false" "(let ((x \"Foo\")) (eq x x)) =>  true" "(eq \"Foo\" \"Foo\")"
      "=>  true" "OR=>  false" "(eq \"Foo\" (copy-seq \"Foo\")) =>  false"
      "(eq \"FOO\" \"foo\") =>  false"
      "(eq \"string-seq\" (copy-seq \"string-seq\")) =>  false" "(let ((x 5)) (eq x x))"
      "=>  true" "OR=>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "eql") "," (CODE1 "equal") "," (CODE1 "equalp") ","
     (CODE1 "=") "," "3.2. コンパイル")
    (CHAPTER ("## 備考") 2 "印字したときに同じに見えるオブジェクトは、" "必ずしも互いに" (CODE1 "eq") "で等しいとは限りません。"
     "印字したシンボルが同じように表示されるものは、" (CODE1 "intern") "関数を使用したものであれば、" "通常は互いに" (CODE1 "eq")
     "で等しくなります。" "しかし、同じ値を持つ数値は" (CODE1 "eq") "で等しい必要はありませんし、" "2つの類似したリストは通常同一ではありません。"
     EOL2 "実装は、いつでも文字と数をコピーすることが許されています。" "その効果のため、Common Lispでは" (CODE1 "eq")
     "の引数の両方が「同じもの」のときでさえ、" "その「もの」が文字と数のときは、返却値が" (STRONG "true") "であることを保証しません。" EOL2
     "Common Lispのほとんどの操作は、" "オブジェクトの比較に" (CODE1 "eq") "ではなく" (CODE1 "eql") "を使っているか、"
     "そうでなければデフォルトで" (CODE1 "eql") "を使い、" "特別に要求されたときだけ" (CODE1 "eq") "を使用します。"
     "しかし、下記に示す操作は" (CODE1 "eql") "ではなく" (CODE1 "eq") "を使うように定義されており、"
     "それらを使用するようなコードで上書きすることはできません。" EOL2
     "|                      |               |             |"
     "|----------------------|---------------|-------------|" "|" (CODE1 "catch")
     "          |" (CODE1 "getf") "    |" (CODE1 "throw") " |" "|" (CODE1 "get")
     "            |" (CODE1 "remf") "    |             |" "|" (CODE1 "get-properties")
     " |" (CODE1 "remprop") " |             |" EOL2 "Figure 5-11. つねにEQLよりEQを好む操作")))
(setf (gethash '("EQ" . "FUNCTION") *table*) (gethash "EQ" *table*))
(setf (gethash "EQL" *table*)
  '("EQL FUNCTION" EOL1 "EQL TYPE-SPECIFIER" EOL1))
(setf (gethash '("EQL" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "EQL"))
    (CHAPTER ("## 構文") 2 (CODE1 "eql") " " (STRONG "x") " " (STRONG "y") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - オブジェクト" EOL1 (STRONG "y") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "eql") "の返却値は、2つのオブジェクト" (CODE1 "x") "と" (CODE1 "y") "が"
     "下記の場合に" (STRONG "true") "になります。" EOL2 "1. もし" (CODE1 "x") "と" (CODE1 "y") "が"
     (CODE1 "eq") "のとき" "2. もし" (CODE1 "x") "と" (CODE1 "y") "が両方とも数であり、同じ型で同じ値のとき"
     "3. もし" (CODE1 "x") "と" (CODE1 "y") "が両方とも文字であり、同じ文字として表現されるとき" EOL2 "それ以外のときは、"
     (CODE1 "eql") "の値は" (STRONG "false") "です。" EOL2 "もし実装が正と負のゼロを違う値としてサポートするときは、"
     (CODE1 "(eql 0.0 -0.0)") "は" (STRONG "false") "が返却します。" "そうでなければ" (CODE1 "-0.0")
     "という構文を読んだとき、" "それは" (CODE1 "0.0") "という値として解釈されるので" (CODE1 "(eql 0.0 -0.0)") "は"
     (STRONG "true") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(eql 'a 'b) =>  false" "(eql 'a 'a) =>  true"
      "(eql 3 3) =>  true" "(eql 3 3.0) =>  false" "(eql 3.0 3.0) =>  true"
      "(eql #c(3 -4) #c(3 -4)) =>  true" "(eql #c(3 -4.0) #c(3 -4)) =>  false"
      "(eql (cons 'a 'b) (cons 'a 'c)) =>  false"
      "(eql (cons 'a 'b) (cons 'a 'b)) =>  false" "(eql '(a . b) '(a . b))" "=>  true"
      "OR=>  false" "(progn (setq x (cons 'a 'b)) (eql x x)) =>  true"
      "(progn (setq x '(a . b)) (eql x x)) =>  true" "(eql #\\A #\\A) =>  true"
      "(eql \"Foo\" \"Foo\")" "=>  true" "OR=>  false"
      "(eql \"Foo\" (copy-seq \"Foo\")) =>  false" "(eql \"FOO\" \"foo\") =>  false")
     EOL2 "通常、" (CODE1 "1.0s0") "と" (CODE1 "1.0d0") "が違うデータの型だと仮定した場合において、"
     (CODE1 "(eql 1.0s0 1.0d0)") "は" (STRONG "false") "です。"
     "しかし実装は、異なった4つの浮動小数の型を提供する必要はなく、" "4つの型をいくつかの小さい型に潰してしまっても許されます。" "そのような実装では"
     (CODE1 "(eql 1.0s0 1.0d0)") "は" (STRONG "true") "になるかもしれません。")
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "eq") "," (CODE1 "equal") "," (CODE1 "equalp") ","
     (CODE1 "=") "," (CODE1 "char="))
    (CHAPTER ("## 備考") 2 (CODE1 "eql") "は" (CODE1 "eq") "と同じですが、" "引数が文字か数の同じ型であり"
     "それらの値を比較するときが違っています。" "したがって、" (CODE1 "eql") "は" "2つのオブジェクトが概念的に等いかどうを言っており、" "一方"
     (CODE1 "eq") "は2つのオブジェクトが" "実装的に同一であるかどうかを言っています。" "このような理由により、"
     "シーケンスを引数として受け取ったオペレーターの叙述部が" "デフォルトで比較を行う際に、" (CODE1 "eq") "ではなく" (CODE1 "eql")
     "を使用します。" EOL2 (CODE1 "eql") "は、2つの浮動小数が同じ値と表現されているときでさえ、" "真にならないかもしれません。"
     (CODE1 "=") "は数学的な値を比較する際に使われます。" EOL2 "2つの複素数は、" "実部が" (CODE1 "eql") "で虚部が"
     (CODE1 "eql") "であれば" (CODE1 "eql") "とみなされます。" "例えば、" (CODE1 "(eql #C(4 5) #C(4 5))")
     "は" (STRONG "true") "であり、" (CODE1 "(eql #C(4 5) #C(4.0 5.0))") "は" (STRONG "false")
     "です。" (CODE1 "(eql #C(5.0 0.0) 5.0)") "は" (STRONG "false") "であり、"
     (CODE1 "(eql #C(5 0) 5)") "は" (STRONG "true") "であることに注意してください。"
     (CODE1 "(eql #C(5 0) 5)") "の場合は、" (CODE1 "#C(5 0)") "が複素数ではなく、" "それは整数" (CODE1 "5")
     "に自動的に変換されます。")))
(setf (gethash '("EQL" . "TYPE-SPECIFIER") *table*)
  '((CHAPTER NIL 0 "Type Specifier " (CODE1 "EQL")) (CHAPTER ("## 型指定子の種類") 2 "結合")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "eql") " " (STRONG "object"))
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "object") " - オブジェクト")
    (CHAPTER ("## 型指定子の定義") 2 (CODE1 "(eql object x)") "が" (STRONG "true") "である全ての"
     (CODE1 "x") "の集合を示します。" EOL2 "引数は要求されます。" "シンボル" (CODE1 "*") "は引数に指定できますが、"
     "しかしそれは自分自身（つまりシンボル" (CODE1 "*") "）を示しているのであって、" "未指定の値を表現しているのではありません。" "シンボルとしての"
     (CODE1 "eql") "は、有効な型指定子ではありません。")))
(setf (gethash "EQUAL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "EQUAL"))
    (CHAPTER ("## 構文") 2 (CODE1 "equal") " " (STRONG "x") " " (STRONG "y") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - オブジェクト" EOL1 (STRONG "y") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "もし" (CODE1 "x") "と" (CODE1 "y") "が構造的に似たオブジェクト（同一構造）なら"
     (STRONG "true") "を返却します。" "オブジェクトは" (CODE1 "equal") "によって下記のように扱われます。" EOL2
     "- シンボル、数、文字" "  - 2つのオブジェクトが、" "    シンボルのときは" (CODE1 "eq") "で、" "    数のときは"
     (CODE1 "eql") "で、" "    文字のときは" (CODE1 "eql") "で比較し、" "    等しいときは" (CODE1 "equal")
     "が" (STRONG "true") "です。" "    <br><br>" EOL2 "- コンス" "  - コンスの" (CODE1 "equal")
     "は、" "    2つの" (CODE1 "car") "が" (CODE1 "equal") "であり、" "    かつ、2つの" (CODE1 "cdr")
     "が" (CODE1 "equal") "のときのように、" "    再帰的に定義されます。" "    <br><br>" EOL2 "- 配列"
     "  - 2つの配列の" (CODE1 "equal") "は、ただ" (CODE1 "eq") "であるかどうかだけですが、"
     "    ただ例外があり、文字列とビット配列は" "    各要素を" (CODE1 "eql") "によって比較します。" "    もし" (CODE1 "x")
     "か" (CODE1 "y") "いずれかがfill-pointerをもつときは、" "    " (CODE1 "equal") "による検査では、"
     "    fill-pointerが要素数を制限します。" "    <br><br>" EOL2 "- パス名" "  - 2つのパス名の"
     (CODE1 "equal") "は、" "    ただ全ての対応する要素が（ホスト、デバイス、など）等しいかどうか比較します。"
     "    しかし各要素内に現れる文字列の比較において" "    大文字と小文字が等しいかどうかは実装依存です。" "    パス名が" (CODE1 "equal")
     "で等しいのであれば、" "    機能的にも等しくなるようにしなければなりません。" "    <br><br>" EOL2
     "- その他（構造体、ハッシュテーブル、インスタンス、など）" "  - 2つのそれ以外のオブジェクトの" (CODE1 "equal") "は、" "    ただ"
     (CODE1 "eq") "によって比較されます。" "    <br><br>" EOL2 (CODE1 "equal") "は、上記で明確に指定されたもの以外の"
     "どんなオブジェクトにも降りては行きません。" "次の図は、前のリストを要約した情報です。" "加えて、図には" (CODE1 "equal")
     "のふるまいの優先順位を載せており、" "上に記載されているものの方が下のものより優先順位は高くなります。" EOL2
     "|型            |ふるまい                  |"
     "|--------------|--------------------------|" "|number        |" (CODE1 "eql")
     "を使用 |" "|character     |" (CODE1 "eql") "を使用 |"
     "|cons          |降りて行く                |" "|bit vector    |降りて行く                |"
     "|string        |降りて行く                |" "|pathname      |機能的に同等              |"
     "|structure     |" (CODE1 "eq") "を使用           |" "|他のarray     |" (CODE1 "eq")
     "を使用           |" "|hash table    |" (CODE1 "eq") "を使用           |" "|他のobject    |"
     (CODE1 "eq") "を使用           |" EOL2 "Figure 5-12. " (CODE1 "equal") "のふるまいの要約と優先順位"
     EOL2 "どのような2つのオブジェクトも、" (CODE1 "eql") "が成り立つなら、" (CODE1 "equal") "もまた成り立ちます。" EOL2
     (CODE1 "equal") "は、" (CODE1 "x") "と" (CODE1 "y") "が循環しているときは、" "おそらく終了に失敗します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(equal 'a 'b) =>  false" "(equal 'a 'a) =>  true"
      "(equal 3 3) =>  true" "(equal 3 3.0) =>  false" "(equal 3.0 3.0) =>  true"
      "(equal #c(3 -4) #c(3 -4)) =>  true" "(equal #c(3 -4.0) #c(3 -4)) =>  false"
      "(equal (cons 'a 'b) (cons 'a 'c)) =>  false"
      "(equal (cons 'a 'b) (cons 'a 'b)) =>  true" "(equal #\\A #\\A) =>  true"
      "(equal #\\A #\\a) =>  false" "(equal \"Foo\" \"Foo\") =>  true"
      "(equal \"Foo\" (copy-seq \"Foo\")) =>  true" "(equal \"FOO\" \"foo\") =>  false"
      "(equal \"This-string\" \"This-string\") =>  true"
      "(equal \"This-string\" \"this-string\") =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "eq") "," (CODE1 "eql") "," (CODE1 "equalp") ","
     (CODE1 "=") "," (CODE1 "string=") "," (CODE1 "string-equal") "," (CODE1 "char=") ","
     (CODE1 "char-equal") "," (CODE1 "tree-equal"))
    (CHAPTER ("## 備考") 2 "オブジェクトの同一性は、" "正しいアルゴリズムによって決められる一意性といった考え方はありません。"
     "この同一性の関数が適切に使われる場合というのは、" "ただ特定のプログラムで必要になったときの文脈でのみ判断できます。"
     "これらの関数はどんな型の引数でも取れますし、" "それらの関数名は非常に一般的に聞こえますが、" (CODE1 "equal") "と"
     (CODE1 "equalp") "は全てのアプリケーションにおいて" "適切に使えるものではありません。" EOL2 "だいたいの考え方として、2つのオブジェクトが"
     (CODE1 "equal") "であるとは、" "ただ印字されたものが同じ表現であるときのみです。")))
(setf (gethash '("EQUAL" . "FUNCTION") *table*) (gethash "EQUAL" *table*))
(setf (gethash "EQUALP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "EQUALP"))
    (CHAPTER ("## 構文") 2 (CODE1 "equalp") " " (STRONG "x") " " (STRONG "y") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - オブジェクト" EOL1 (STRONG "y") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "もし" (CODE1 "x") "と" (CODE1 "y") "が" (CODE1 "equal") "であれば"
     (STRONG "true") "を返却します。" "あるいはそれらの要素がお互い同じ型であり、" "下記に示す場合のときは" (STRONG "true")
     "が返却されます。" EOL2 "- 文字" "  - もし2つの文字が、" (CODE1 "char-equal") "のとき。" "    <br><br>"
     EOL2 "- 数" "  - もし2つの数が、" (CODE1 "=") "で等しいとき。" "    <br><br>" EOL2 "- コンス"
     "  - 2つの" (CODE1 "car") "が" (CODE1 "equalp") "であり、かつ、2つの" (CODE1 "cdr") "が"
     (CODE1 "equalp") "のとき。" "    <br><br>" EOL2 "- 配列" "  - 2つの配列が同じ次元数であり、その次元が一致し、"
     "    対応するアクティブな要素が" (CODE1 "equalp") "のとき。" "    配列の型は、" (CODE1 "specialized")
     "が一致する必要はありません。" "    例えば文字列と一般配列において" "    同じ文字が含まれているときは" (CODE1 "equalp")
     "が成り立ちます。" "    " (CODE1 "equalp") "は文字列を要素対要素で比較し、" "    各文字の大文字小文字を無視するため、" "    "
     (CODE1 "equalp") "で文字列を比較したときは大文字小文字の違いは無視されます。" "    <br><br>" EOL2 "- 構造体"
     "  - 2つの構造体" (CODE1 "S1") "と" (CODE1 "S2") "が、同じクラスであり、" "    " (CODE1 "S1")
     "の各スロットの値と" (CODE1 "S2") "の対応する各スロットの値が" "    " (CODE1 "equalp") "において同一のとき。"
     "    <br><br>" EOL2 "- ハッシュテーブル" "  - " (CODE1 "equalp") "はハッシュテーブルに降りていき、"
     "    最初に各エントリーの数と" (CODE1 ":test") "の関数を比較します。" "    もしこれらが等しいときは、テーブルのキーを"
     (CODE1 ":test") "関数を用いて比較し、" "    そのあとでキーに対応する値を" (CODE1 "equalp") "で再帰的に比較します。"
     "    <br><br>" EOL2 (CODE1 "equalp") "は、上記で明確に指定されたもの以外の" "どんなオブジェクトにも降りては行きません。"
     "次の図は、前のリストを要約した情報です。" "加えて、図には" (CODE1 "equalp") "のふるまいの優先順位を載せており、"
     "上に記載されているものの方が下のものより優先順位は高くなります。" EOL2 "|型            |ふるまい                     |"
     "|--------------|-----------------------------|" "|number        |" (CODE1 "=")
     "を使用               |" "|character     |" (CODE1 "char-equal") "を使用      |"
     "|cons          |降りて行く                   |"
     "|bit vector    |降りて行く                   |"
     "|string        |降りて行く                   |" "|pathname      |" (CODE1 "equal")
     "と同じ           |" "|structure     |降りて行く。上記の記載参照。 |"
     "|他のarray     |降りて行く                   |" "|hash table    |降りて行く。上記の記載参照。 |"
     "|他のobject    |" (CODE1 "eq") "を使用              |" EOL2 "Figure 5-13. "
     (CODE1 "equalp") "のふるまいの要約と優先順位")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(equalp 'a 'b) =>  false" "(equalp 'a 'a) =>  true"
      "(equalp 3 3) =>  true" "(equalp 3 3.0) =>  true" "(equalp 3.0 3.0) =>  true"
      "(equalp #c(3 -4) #c(3 -4)) =>  true" "(equalp #c(3 -4.0) #c(3 -4)) =>  true"
      "(equalp (cons 'a 'b) (cons 'a 'c)) =>  false"
      "(equalp (cons 'a 'b) (cons 'a 'b)) =>  true" "(equalp #\\A #\\A) =>  true"
      "(equalp #\\A #\\a) =>  true" "(equalp \"Foo\" \"Foo\") =>  true"
      "(equalp \"Foo\" (copy-seq \"Foo\")) =>  true" "(equalp \"FOO\" \"foo\") =>  true"
      "(setq array1 (make-array 6 :element-type 'integer"
      "                           :initial-contents '(1 1 1 3 5 7))) "
      "=>  #(1 1 1 3 5 7)" "(setq array2 (make-array 8 :element-type 'integer"
      "                           :initial-contents '(1 1 1 3 5 7 2 6)"
      "                           :fill-pointer 6))" "=>  #(1 1 1 3 5 7)"
      "(equalp array1 array2) =>  true"
      "(setq vector1 (vector 1 1 1 3 5 7)) =>  #(1 1 1 3 5 7)"
      "(equalp array1 vector1) =>  true "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "eq") "," (CODE1 "eql") "," (CODE1 "equal") ","
     (CODE1 "=") "," (CODE1 "string=") "," (CODE1 "string-equal") "," (CODE1 "char=") ","
     (CODE1 "char-equal"))
    (CHAPTER ("## 備考") 2 "オブジェクトの同一性は、" "正しいアルゴリズムによって決められる一意性といった考え方はありません。"
     "この同一性の関数が適切に使われる場合というのは、" "ただ特定のプログラムで必要になったときの文脈でのみ判断できます。"
     "これらの関数はどんな型の引数でも取れますし、" "それらの関数名は非常に一般的に聞こえますが、" (CODE1 "equal") "と"
     (CODE1 "equalp") "は全てのアプリケーションにおいて" "適切に使えるものではありません。")))
(setf (gethash '("EQUALP" . "FUNCTION") *table*) (gethash "EQUALP" *table*))
(setf (gethash "ERROR" *table*)
  '("ERROR FUNCTION" EOL1 "ERROR CONDITION-TYPE" EOL1))
(setf (gethash '("ERROR" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ERROR"))
    (CHAPTER ("## 構文") 2 (CODE1 "error") " " (STRONG "datum") " " (CODE1 "&rest") " "
     (STRONG "arguments") " => " (CODE1 "|"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "datum") ", " (STRONG "arguments")
     " - コンディション指定子であり、標準の型は" (CODE1 "simple-error") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "error") "は、コンディションを効果的に" (CODE1 "signal") "で実行します。" EOL2
     "もしコンディションが捕捉されないときは、" (CODE1 "(invoke-debugger condition)") "が実行されます。"
     (CODE1 "invoke-debugger") "が呼び出された結果、" (CODE1 "error") "は直接戻ることはできず、"
     (CODE1 "error") "からの退出は" "ただハンドラーによる非局所的な遷移の制御か、" "あるいは対話的なデバッガーのコマンドを使うことにのみ"
     "実現できます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun factorial (x)"
      "  (cond ((or (not (typep x 'integer)) (minusp x))"
      "         (error \"~S is not a valid argument to FACTORIAL.\" x))"
      "        ((zerop x) 1)" "        (t (* x (factorial (- x 1))))))" "=>  FACTORIAL"
      "(factorial 20)" "=>  2432902008176640000" "(factorial -1)"
      ">>  Error: -1 is not a valid argument to FACTORIAL."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Return to Lisp Toplevel." ">>  Debug> " " (setq a 'fred)" "=>  FRED"
      " (if (numberp a) (1+ a) (error \"~S is not a number.\" A))"
      ">>  Error: FRED is not a number."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Return to Lisp Toplevel." ">>  Debug> :Continue 1"
      ">>  Return to Lisp Toplevel." NIL "(define-condition not-a-number (error) "
      "                  ((argument :reader not-a-number-argument :initarg :argument))"
      "  (:report (lambda (condition stream)"
      "             (format stream \"~S is not a number.\""
      "                     (not-a-number-argument condition)))))" "=>  NOT-A-NUMBER" NIL
      "(if (numberp a) (1+ a) (error 'not-a-number :argument a))"
      ">>  Error: FRED is not a number."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Return to Lisp Toplevel." ">>  Debug> :Continue 1"
      ">>  Return to Lisp Toplevel."))
    (CHAPTER ("## 副作用") 2 "指定されたコンディションのハンドラーは" "もし起動された場合は副作用を持つかもしれません。"
     "プログラムの実行は停止してデバッガーに入るかもしれません。")
    (CHAPTER ("## 影響") 2 "存在するハンドラーの束縛" EOL2 (CODE1 "*break-on-signals*"))
    (CHAPTER ("## 例外") 2 "もし" (STRONG "datum") "と" (STRONG "arguments")
     "がコンディション指定子ではないときは" "型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "cerror") "," (CODE1 "signal") "," (CODE1 "format") ","
     (CODE1 "ignore-errors") "," (CODE1 "*break-on-signals*") "," (CODE1 "handler-bind")
     "," "9.1. コンディションシステムの説明")
    (CHAPTER ("## 備考") 2 "いくつかの実装では、デバッガーは独立したスタックフレームから" "対話的に戻るためのコマンドを提供しています。"
     "しかしプログラマーは次のようなコードを書くことに" "自身を持たなければなりません。"
     (CODE3 "```lisp" "```" "(defun wargames:no-win-scenario ()"
      "  (if (error \"pushing the button would be stupid.\"))" "  (push-the-button))")
     EOL2 "このシナリオでは、" (CODE1 "error") "から戻って" "ボタンが押される" (CODE1 "push-the-button")
     "ような機会はありません。" EOL2 "このプログラムの意味は明確であり、" "形式的な定理の証明によって「安全」であることが証明されるかもしれませんが、"
     "そのような証明はプログラムが実行されても" "安全であることを保証するものではありません。" "コンパイラにはバグがあり、コンピュータには信号の不具合があり、"
     "人間には常に予測不可能な方法で手動で介入することが知られています。" "このような種類のエラーは、" "コンディションシステムの正式なモデルの範囲を超えていますが、"
     "この例で示唆されているような重大な影響を及ぼしうるコードを書くときに" "真剣に検討すべきことの範囲を超えてはいません。")))
(setf (gethash '("ERROR" . "CONDITION-TYPE") *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "ERROR"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "error") "," (CODE1 "serious-condition") ","
     (CODE1 "condition") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "error") "は、エラーを表現する全てのコンディションを含みます。")))
(setf (gethash "ETYPECASE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "TYPECASE") ", " (CODE1 "CTYPECASE") ", "
     (CODE1 "ETYPECASE"))
    (CHAPTER ("## 構文") 2 (CODE1 "typecase") " " (STRONG "keyform") " " (CODE1 "{")
     (STRONG "normal-clause") (CODE1 "}") "\\* [" (STRONG "otherwise-clause") "] => "
     (STRONG "result\\*") EOL1 (CODE1 "ctypecase") " " (STRONG "keyplace") " "
     (CODE1 "{") (STRONG "normal-clause") (CODE1 "}") "\\* => " (STRONG "result\\*") EOL1
     (CODE1 "etypecase") " " (STRONG "keyform") " " (CODE1 "{") (STRONG "normal-clause")
     (CODE1 "}") "\\* => " (STRONG "result\\*")
     (CODE3 "```" "```" "normal-clause ::= (type form*) "
      "otherwise-clause ::= ({otherwise | t} form*) "
      "clause ::= normal-clause | otherwise-clause "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "keyform") " - フォーム。評価され" (STRONG "test-key")
     "を返却します。" EOL1 (STRONG "keyplace") " - フォーム。評価されて最初に" (STRONG "test-key") "を返却します。"
     EOL1 (STRONG "test-key") " - " (STRONG "keyform") "か" (STRONG "keyplace")
     "が評価されることによって返却されるオブジェクト。" EOL1 (STRONG "type") " - 型指定子" EOL1 (STRONG "form")
     " - 暗黙のprogn" EOL1 (STRONG "result") " - マッチした" (STRONG "clause") "の"
     (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 "これらのマクロは、" (STRONG "test-key") "の型のマッチによって選択された"
     (STRONG "clause") "内の" (STRONG "form") "のボディを条件付きで実行します。" EOL2 (STRONG "keyform")
     "と" (STRONG "keyplace") "が評価されて、" (STRONG "test-key") "が生成されます。" EOL2 "そのあと各"
     (STRONG "normal-clause") "が順番に考慮されます。" "もし" (STRONG "test-key") "が"
     (STRONG "clause") "のどれかの型と同じであれば、" "その" (STRONG "clause") "内の" (STRONG "form")
     "が暗黙のprognとして評価され、" (CODE1 "typecase") "、" (CODE1 "ctypecase") "、"
     (CODE1 "etypecase") "フォームの返却値として" "その多値が返却されます。" EOL2 "これらのマクロは、もし"
     (STRONG "normal-clause") "がマッチしなかったときにだけ、" "動作が違っています。" "違いを下記に示します。" EOL2 "- "
     (CODE1 "typecase") "  - もしマッチする" (STRONG "normal-clause") "が存在せず"
     (STRONG "otherwise-clause") "があるときは、" "    自動的に" (STRONG "otherwise-clause")
     "がマッチします。" "    その" (STRONG "clause") "にある" (STRONG "form") "は暗黙のprognとして評価され、"
     "    その" (STRONG "clause") "内の" (STRONG "form") "は暗黙のprognとして評価され、" "    "
     (CODE1 "typecase") "フォームの返却値としてその多値が返却されます。" "    <br><br>" "    もし"
     (STRONG "otherwise-clause") "がないときは、" "    " (CODE1 "typecase") "は" (CODE1 "nil")
     "を返却します。" "    <br><br>" EOL2 "- " (CODE1 "ctypecase") "  - もしマッチする"
     (STRONG "normal-clause") "が存在しないときは、" "    型" (CODE1 "type-error")
     "の修正可能なエラーが発生します。" "    問題の" (CODE1 "datum") "は" (STRONG "test-key") "であり、" "    "
     (CODE1 "expected type") "は" (CODE1 "(member key1 key2 ...)") "と同等の型です。" "    "
     (CODE1 "store-value") " " (CODE1 "restart") "をエラーの修正に使うことができます。" "    <br><br>"
     "    もし" (CODE1 "store-value") " " (CODE1 "restart") "が起動されたら、" "    その引数は新しい"
     (STRONG "test-key") "であり、" "    " (STRONG "keyplace") "への保存は"
     (CODE1 "(setf keyplace test-key)") "のように行われます。" "    それから" (CODE1 "ctypecase")
     "は最初から始められ、" "    各" (STRONG "clause") "が新しく評価されます。" "    <br><br>" "    もし"
     (CODE1 "store-value") " " (CODE1 "restart") "が対話形式で起動されたら、" "    ユーザーは新しい"
     (STRONG "test-key") "を使用できるような" "    プロンプトが表示されます。" "    <br><br>"
     "    いずれのケースも成立しない場合、" "    " (STRONG "keyplace") "のサブフォームは再度評価されるかもしれません。"
     "    <br><br>" EOL2 "- " (CODE1 "etypecase") "  - もしマッチする" (STRONG "normal-clause")
     "が存在しないときは、" "    型" (CODE1 "type-error") "の修正不可能なエラーが発生します。" "    問題の"
     (CODE1 "datum") "は" (STRONG "test-key") "であり、" "    " (CODE1 "expected type") "は"
     (CODE1 "(member key1 key2 ...)") "と同等の型です。" "    <br><br>" "    "
     (CODE1 "ctypecase") "とは対照的に" (CODE1 "etypecase") "の使用者は、" "    もし"
     (STRONG "normal-clause") "がマッチしなかったら" "    " (CODE1 "etypecase")
     "は戻ってこないという事実に頼っています。" "    <br><br>" EOL2 "3つの全ての場合において、" "指定した型にマッチする"
     (STRONG "clause") "が複数あっても許されます。" "特にその型が何かのサブタイプになっているような場合も同様です。"
     "そのような場合は、もっとも早い適切な" (STRONG "clause") "が選ばれます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";;; (この例で使われているTYPE-OFの部分は" ";;;  実装依存であることに注意して下さい)"
      "(defun what-is-it (x)" "  (format t \"~&~S is ~A.~%\"" "          x (typecase x"
      "              (float \"a float\")"
      "              (null \"a symbol, boolean false, or the empty list\")"
      "              (list \"a list\")"
      "              (t (format nil \"a(n) ~(~A~)\" (type-of x))))))" "=>  WHAT-IS-IT"
      "(map 'nil #'what-is-it '(nil (a b) 7.0 7 box))"
      ">>  NIL is a symbol, boolean false, or the empty list." ">>  (A B) is a list."
      ">>  7.0 is a float." ">>  7 is a(n) integer." ">>  BOX is a(n) symbol." "=>  NIL"
      "(setq x 1/3)" "=>  1/3" "(ctypecase x" "    (integer (* x 4))"
      "    (symbol  (symbol-value x)))"
      ">>  Error: The value of X, 1/3, is neither an integer nor a symbol."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Specify a value to use instead." ">>   2: Return to Lisp Toplevel."
      ">>  Debug> :CONTINUE 1" ">>  Use value: 3.7"
      ">>  Error: The value of X, 3.7, is neither an integer nor a symbol."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Specify a value to use instead." ">>   2: Return to Lisp Toplevel."
      ">>  Debug> :CONTINUE 1" ">>  Use value: 12" "=>  48" "x =>  12"))
    (CHAPTER ("## 影響") 2 (CODE1 "ctypecase") "と" (CODE1 "etypecase") "がエラーを通知したときは、"
     "既存の" (CODE1 "handler") "と" (CODE1 "*debug-io*") "に影響を及ぼす可能性があります。")
    (CHAPTER ("## 例外") 2 (STRONG "normal-clause") "にマッチしなかったときは、" (CODE1 "ccase") "と"
     (CODE1 "ecase") "は" "型" (CODE1 "type-error") "のエラーが発生します。" EOL2 "もしある"
     (STRONG "clause") "がそれより早い" (STRONG "clause") "によって完全にシャドウされ、"
     "決して選択されないような状況であったとき、" "コンパイラーは、型" (CODE1 "style-warning") "の警告を出すかどうか"
     "選択することができます。")
    (CHAPTER ("## 参考") 2 (CODE1 "case") "," (CODE1 "cond") "," (CODE1 "setf") ","
     "5.1. 一般化された参照")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(typecase test-key" "  {(type form*)}*)" "== "
      "(let ((#1=#:g0001 test-key))" "  (cond {((typep #1# 'type) form*)}*))")
     EOL2 (CODE1 "etypecase") "と" (CODE1 "ctypecase") "によって使われる特定のエラーメッセージは、"
     "実装によって変わります。" "そんな中で、エラーメッセージの特定の単語の制御が必要なときは、" (CODE1 "typecase") "の"
     (STRONG "otherwise-clause") "で" "明示的に適切なエラーメッセージを発生させるのが良いでしょう。")))
(setf (gethash '("ETYPECASE" . "MACRO") *table*) (gethash "ETYPECASE" *table*))
(setf (gethash "EVAL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "EVAL"))
    (CHAPTER ("## 構文") 2 (CODE1 "eval") " " (STRONG "form") " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "form") " - フォーム" EOL1 (STRONG "result") " - "
     (STRONG "form") "の評価によって生成された返却値")
    (CHAPTER ("## 定義") 2 "現在の動的環境と" (CODE1 "null") "のレキシカルな環境で、" (STRONG "form")
     "を評価します。" EOL2 (CODE1 "eval") "は評価器のユーザーインターフェイスです。" EOL2 "評価器はマクロの呼び出しを"
     (CODE1 "macroexpand-1") "を使用したかのように展開します。" EOL2 (CODE1 "eval")
     "によって処理されたコードに定数が現れたとき、" "それはコピーされたり合併されたりしません。" (CODE1 "eval") "の実行により返却されたコードが"
     "参照しているオブジェクトは、" "ソースコード上の対応するオブジェクトと" (CODE1 "eql") "で一致します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq form '(1+ a) a 999) =>  999" "(eval form) =>  1000"
      "(eval 'form) =>  (1+ A)"
      "(let ((a '(this would break if eval used local value))) (eval form))" "=>  1000"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "macroexpand-1") "," "3.1.2. 評価の規範")
    (CHAPTER ("## 備考") 2 "シンボルの現在の動的な値を得るには、" (CODE1 "symbol-value") "を使うのと"
     (CODE1 "eval") "を使うのがそれぞれ有効であり同等です" "（そして普通は好ましい）。" EOL2 (CODE1 "eval")
     "フォームは、その引数を2段階の評価で行うことに注意してください。" "最初は、" (STRONG "form") "をどんな呼び出しにも生じる"
     "普通の引数の評価の仕組みで評価します。" "この普通の引数の評価による返却値のオブジェクトが" (STRONG "form") "パラメーターの値になり、"
     "それから" (CODE1 "eval") "フォームの部分として評価されます。" "例えば下記の通り。"
     (CODE3 "```lisp" "```" "(eval (list 'cdr (car '((quote (a . b)) c)))) => b") EOL2
     "引数のフォーム" (CODE1 "(list 'cdr (car '((quote (a . b)) c)))") "は" "通常の方法により評価され、引数"
     (CODE1 "(quote (a . b)))") "を生成します。" "それから" (CODE1 "eval") "はその引数"
     (CODE1 "(cdr (quote (a . b)))") "を評価し" (CODE1 "b") "を生成します。"
     "どのような関数のどんな引数でもすでに一回目の評価が生じているので、" (CODE1 "eval") "は「余分なレベルの評価」が生じたと言われることがあります。")))
(setf (gethash '("EVAL" . "FUNCTION") *table*) (gethash "EVAL" *table*))
(setf (gethash "EVAL-WHEN" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "EVAL-WHEN"))
    (CHAPTER ("## 構文") 2 (CODE1 "eval-when") " (" (STRONG "situation\\*") ") "
     (STRONG "form\\*") " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "situation") " - 次のシンボルのうちのひとつ、"
     (CODE1 ":compile-toplevel") ", " (CODE1 ":load-toplevel") ", " (CODE1 ":execute")
     "," (CODE1 "compile") ", " (CODE1 "load") ", " (CODE1 "eval") "。" EOL2 "ただし"
     (CODE1 "eval") ", " (CODE1 "compile") ", " (CODE1 "load") "の使用は非推奨です。" EOL2
     (STRONG "form") " - 暗黙のprogn" EOL1 (STRONG "result") " - もし" (STRONG "form")
     "が実行されたときはその値を、それ以外は" (CODE1 "nil") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "eval-when") "フォームのボディ部は、" (STRONG "situations")
     "のリスト下にあるときのみ暗黙のprognとして処理します。" EOL2 (CODE1 "compile-file") "で処理しているコード内で"
     (CODE1 "eval-when") "がトップレベルフォームとして現れたとき、" (STRONG "situation") "に"
     (CODE1 ":compile-toplevel") "（あるいは" (CODE1 "compile") "）と" (CODE1 ":load-toplevel")
     "（あるいは" (CODE1 "load") "）を使用することで" "評価を行うかどうかを制御できます。" "3.2.3. ファイルのコンパイルをご確認ください。"
     EOL2 (STRONG "situation") "に" (CODE1 ":execute") "（あるいは" (CODE1 "eval") "）を使用することで"
     (CODE1 "eval-when") "のその他のフォームの評価を行うかどうかを制御できます。" "これは、それらがトップレベルフォームのものではないか、"
     "あるいはコードが" (CODE1 "eval") "か" (CODE1 "compile") "によって処理されたときです。" "もし"
     (CODE1 ":execute") "の" (STRONG "situation") "にそのようなフォームが指定されたとき、" (STRONG "form")
     "のボディ部は暗黙のprognとして処理され、" "それ以外の場合は" (CODE1 "eval-when") "フォームは" (CODE1 "nil")
     "を返却します。" EOL2 (CODE1 "eval-when") "は通常トップレベルフォームに現れますが、"
     "それが非トップレベルフォームとして現れても意味があります。" "しかし、3.2. コンパイルに記載されているコンパイル時の副作用は、" "ただ"
     (CODE1 "eval-when") "がトップレベルフォームに現れたときのみ行われます。")
    (CHAPTER ("## 例文") 2 (CODE1 "eval-when") "のひとつの使用例として、" "コンパイラーがファイルを適切に読み込めるように、"
     "ユーザーが定義したリーダーマクロを使う方法を示します。" "下記のように記載する必要があります。"
     (CODE3 "```lisp" "```" "(eval-when (:compile-toplevel :load-toplevel :execute)"
      "  (set-macro-character #\\$ #'(lambda (stream char)"
      "                               (declare (ignore char))"
      "                               (list 'dollar (read stream))))) =>  T")
     EOL2 "これは" (CODE1 "set-macro-character") "の呼び出しが" "コンパイラーの実行環境内での実行を引き起こし、"
     "それによってリーダーの構文テーブルに修正が起こります。"
     (CODE3 "```lisp" "```" ";;;     このケースではEVAL-WHENはtoplevelではなく、ただ:EXECUTEキーワード"
      ";;;     のみが考慮されます。コンパイル時においてこれらの効果はありません。"
      ";;;     ロード（もしこのLETがトップレベルのとき）か実行時（もしこのLETが"
      ";;;     他のフォームに埋め込まれていて後にならないと呼び出されないとき）、"
      ";;;     これは(SYMBOL-FUNCTION 'FOO1)に1を返却する関数がセットされます。" "(let ((x 1))"
      "  (eval-when (:execute :load-toplevel :compile-toplevel)"
      "    (setf (symbol-function 'foo1) #'(lambda () x))))" NIL
      ";;;     もしこの式がコンパイル時にファイルのtoplevelとしてあらわれたとき、"
      ";;;     これはコンパイル時とロードに(SYMBOL-FUNCTION 'FOO2)に2を返却する" ";;;     関数をセットする効果があります。"
      "(eval-when (:execute :load-toplevel :compile-toplevel)" "  (let ((x 2))"
      "    (eval-when (:execute :load-toplevel :compile-toplevel)"
      "      (setf (symbol-function 'foo2) #'(lambda () x)))))" NIL
      ";;;     もしこの式がコンパイル時にファイルのtoplevelとしてあらわれたとき、"
      ";;;     これはコンパイル時とロードに(SYMBOL-FUNCTION 'FOO2)に3を返却する" ";;;     関数をセットする効果があります。"
      "(eval-when (:execute :load-toplevel :compile-toplevel)"
      "  (setf (symbol-function 'foo3) #'(lambda () 3)))" NIL
      ";;; #4: これはいつでも何もしません。単純にNILを返却します。" "(eval-when (:compile-toplevel)"
      "  (eval-when (:compile-toplevel) " "    (print 'foo4)))" NIL
      ";;;     もしこの式がコンパイル時にファイルのtoplevelとしてあらわれたとき、"
      ";;;     コンパイル時にFOO5が印字されます。もしこのフォームが非toplevelの"
      ";;;     位置に現れたとき、コンパイル時には何も印字されません。" ";;;     文脈に関係なくロード時と実行時は何も印字されません。"
      "(eval-when (:compile-toplevel) " "  (eval-when (:execute)" "    (print 'foo5)))"
      NIL ";;;     もしこの式がコンパイル時にファイルのtoplevelとしてあらわれたとき、"
      ";;;     コンパイル時にFOO6が印字されます。もしこのフォームが非toplevelの"
      ";;;     位置に現れたとき、コンパイル時には何も印字されません。" ";;;     文脈に関係なくロード時と実行時は何も印字されません。"
      "(eval-when (:execute :load-toplevel)" "  (eval-when (:compile-toplevel)"
      "    (print 'foo6)))"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "compile-file") "," "3.2. コンパイル")
    (CHAPTER ("## 備考") 2 (CODE1 "eval-when") "の定義により、下記の論理的な効果が示されます。" EOL2 "- ひとつの"
     (CODE1 "eval-when") "式は、ボディ部が最大で一度実行されます。" EOL2 "- トップレベルフォームで使用されたマクロは、"
     "マクロ展開の中のフォームによって副作用が完了することによって出力されます。" "そのマクロ展開自身には副作用は生じません。" EOL2 "次は悪い例。"
     (CODE3 "```lisp" "```" "(defmacro foo ()" "  (really-foo)" "  `(really-foo))") EOL2
     "次は良い例。"
     (CODE3 "```lisp" "```" "(defmacro foo ()"
      "  `(eval-when (:compile-toplevel :execute :load-toplevel) (really-foo)))")
     EOL2 "この規約を守ることで、マクロが非トップレベルフォームとして現れたときに、" "直感的に動作するようになります。" EOL2 "- "
     (CODE1 "eval-when") "の周りに配置された変数の束縛は確実にその束縛をに捕捉します。" "なぜなら"
     (CODE1 "compile-time-too") "モードは生じないからです" "（例えば、変数束縛の導入は、" (CODE1 "eval-when") "が"
     "トップレベルフォームではないことを意味しているからです）。" EOL2 "例えば下記の文を考えます。"
     (CODE3 "```lisp" "```" "(let ((x 3))"
      "  (eval-when (:execute :load-toplevel :compile-toplevel) (print x)))")
     EOL2 "この文は、" "実行時（例えばロード）に" (CODE1 "3") "を印字します。" "そしてコンパイル時には何も印字しません。"
     (CODE1 "defun") "と" (CODE1 "defmacro") "の展開は、" (CODE1 "eval-when") "を実行することができて、"
     "かつ正しくレキシカルな環境を捕捉することができるということは" "重要なことです。" EOL2 "下記の文"
     (CODE3 "```lisp" "```" "(defun bar (x) (defun foo () (+ x 3)))") EOL2
     "これは、次のように展開されます。"
     (CODE3 "```lisp" "```" "(defun bar (x) " "  (progn (eval-when (:compile-toplevel) "
      "           (compiler::notice-function-definition 'foo '(x)))"
      "         (eval-when (:execute :load-toplevel)"
      "           (setf (symbol-function 'foo) #'(lambda () (+ x 3))))))")
     EOL2 "この展開は、上記のルールに従うと次の同等になります。"
     (CODE3 "```lisp" "```" "(defun bar (x) "
      "  (setf (symbol-function 'foo) #'(lambda () (+ x 3))))")
     EOL2 "これは" (CODE1 "bar") "の定義がトップレベルフォームのものではありません。")))
(setf (gethash '("EVAL-WHEN" . "SPECIAL-OPERATOR") *table*) (gethash "EVAL-WHEN" *table*))
(setf (gethash "EVERY" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "EVERY") ", " (CODE1 "SOME") ", "
     (CODE1 "NOTEVERY") ", " (CODE1 "NOTANY"))
    (CHAPTER ("## 構文") 2 (CODE1 "every") " " (STRONG "predicate") " &rest "
     (STRONG "sequence") "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "some") " "
     (STRONG "predicate") " &rest " (STRONG "sequence") "+ => " (STRONG "result") EOL1
     (CODE1 "notevery") " " (STRONG "predicate") " &rest " (STRONG "sequence") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "notany") " " (STRONG "predicate")
     " &rest " (STRONG "sequence") "+ => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "predicate") " - " (STRONG "sequence")
     "の数だけ引数を受け取る関数指定子" EOL1 (STRONG "sequence") "s - シーケンス" EOL1 (STRONG "result")
     " - オブジェクト" EOL1 (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "every") "、" (CODE1 "some") "、" (CODE1 "notevery") "、"
     (CODE1 "notany") "は、" "引数" (STRONG "predicate") "が" (STRONG "sequence")
     "の要素を満たすかどうかをテストします。" (STRONG "predicate") "の最初の引数は最初の" (STRONG "sequence")
     "の要素であり、" "後続の引数は後続のシーケンスの要素です。" EOL2 (STRONG "predicate") "は、最初は各"
     (STRONG "sequence") "のインデックス0番目の要素で呼び出され、" "そのあと可能であればインデックス1番目の要素で呼ばれ、"
     "以下同様に実行し、終了の基準が満たされるか、" "もっとも短い" (STRONG "sequence") "の終わりに到達するときまで続けられます。" EOL2
     (CODE1 "every") "は、" (STRONG "predicate") "のどれかが" (STRONG "false") "を返却したら、" "すぐに"
     (STRONG "false") "を返却します。" "もし" (STRONG "sequence") "の終わりに到達したら、" (CODE1 "every")
     "は" (STRONG "true") "を返却します。" "したがって" (CODE1 "every") "は、すべての" (STRONG "predicate")
     "が" (STRONG "true") "を返却したときのみ、" (STRONG "true") "を返却します。" EOL2 (CODE1 "some") "は、"
     (STRONG "predicate") "の実行によって返却された" "最初の非" (CODE1 "nil") "を値を返却します。" "もし"
     (STRONG "predicate") "の実行が" (STRONG "true") "を返却することなく" (STRONG "sequence")
     "の終わりに到達したら、" (CODE1 "some") "は" (STRONG "false") "を返却します。" "したがって" (CODE1 "some")
     "は、" "もしどれかの" (STRONG "predicate") "の実行が" (STRONG "true") "を返却したら、" (STRONG "true")
     "を返却します。" EOL2 (CODE1 "notany") "は、" (STRONG "predicate") "のどれかが" (STRONG "true")
     "を返却したら、" "すぐに" (STRONG "false") "を返却します。" "もし" (STRONG "sequence") "の終わりに到達したら、"
     (CODE1 "notany") "は" (STRONG "true") "を返却します。" "したがって" (CODE1 "notany") "は、どの"
     (STRONG "predicate") "も" (STRONG "true") "を返却しない場合にのみ、" (STRONG "true") "を返却します。"
     EOL2 (CODE1 "notevery") "は、" (STRONG "predicate") "のどれかが" (STRONG "false") "を返却したら、"
     "すぐに" (STRONG "true") "を返却します。" "もし" (STRONG "sequence") "の終わりに到達したら、"
     (CODE1 "notevery") "は" (STRONG "false") "を返却します。" "したがって" (CODE1 "notevery")
     "は、すべての" (STRONG "predicate") "が" (STRONG "true") "を返却しない場合にのみ、" (STRONG "true")
     "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(every #'characterp \"abc\") =>  true"
      "(some #'= '(1 2 3 4 5) '(5 4 3 2 1)) =>  true"
      "(notevery #'< '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) =>  false"
      "(notany #'> '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) =>  true "))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "最初の引数がシンボルでも関数でもないときか、" "続く引数のどれかが正常なシーケンスではなかったときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" EOL2 "他の例外が発生する可能性があり、それは" (STRONG "predicate")
     "の性質に依存します。")
    (CHAPTER ("## 参考") 2 (CODE1 "and") "," (CODE1 "or") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```"
      "(notany predicate sequence*) == (not (some predicate sequence*))"
      "(notevery predicate sequence*) == (not (every predicate sequence*))"))))
(setf (gethash '("EVERY" . "FUNCTION") *table*) (gethash "EVERY" *table*))
(setf (gethash "EXPORT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "EXPORT"))
    (CHAPTER ("## 構文") 2 (CODE1 "export") " " (STRONG "symbols") " " (CODE1 "&optional")
     " " (STRONG "package") " => " (CODE1 "t"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbols") " - シンボルのリストの指定子" EOL1 (STRONG "package")
     " - パッケージ指定子。デフォルトは現在のパッケージ。")
    (CHAPTER ("## 定義") 2 (CODE1 "export") "はひとつか複数のシンボルを" (STRONG "package")
     "（直接か間接によってか）内で" "その" (STRONG "package") "の外部シンボルとしてアクセス可能にします。" EOL2 "もしある"
     (STRONG "symbols") "がすでに" (STRONG "package") "の外部シンボルとしてアクセス可能であるとき、"
     (CODE1 "export") "はそのシンボルに対して何の効果も持ちません。" "もし" (STRONG "symbol") "が"
     (STRONG "package") "内に内部シンボルとして存在するときは、" "それは単純に外部の状態に変更されます。" "もしそれが"
     (CODE1 "use-package") "を経由して内部シンボルとして" "アクセス可能であるときは、それは最初にその" (STRONG "package")
     "内で" (CODE1 "import") "され、" "それから" (CODE1 "export") "されます" "（" (STRONG "symbol")
     "は、継承元の" (STRONG "symbol") "がその" (STRONG "package") "で" "使い続けるかどうかに関わらず、"
     (STRONG "package") "に存在されます）。" EOL2 (CODE1 "export") "は、" (STRONG "package") "を"
     (CODE1 "use") "している全てのパッケージで" "各" (STRONG "symbol") "をアクセス可能な状態にします。"
     "そのような全てのパッケージは、名前の衝突チェックが行われます。" "チェックは" (CODE1 "(export s p)") "が実行されたとき、"
     (CODE1 "(package-used-by-list p)") "で得られる各パッケージ" (CODE1 "q") "に対して"
     (CODE1 "(find-symbol (symbol-name s) q)") "で確認します。" "通常の場合、" (CODE1 "export") "は"
     (STRONG "package") "の初期定義のときに行われるため、" (CODE1 "package-used-by-list") "の結果は"
     (CODE1 "nil") "であり" "名前の衝突チェックは無視できることに注意してください。" EOL2 "複数の変更が行われるとき、" "例えば"
     (CODE1 "export") "にシンボルのリストが与えられたとき、" "実装がそれぞれの変更を別々に処理することが許されます。" "そのため、リストの最初の"
     (STRONG "symbol") "以外によって引き起こされる" "名前の衝突から中止しても、" "リストの最初" (STRONG "symbol") "を"
     (CODE1 "unexport") "することはありません。" "しかし、ある" (STRONG "symbol") "の" (CODE1 "export")
     "による名前衝突エラーで中断しても、" "その" (STRONG "symbol") "はあるパッケージからはアクセス可能で、"
     "他のパッケージからはアクセス不能になるようなことはありません。" "処理される" (STRONG "symbol") "のそれぞれについて、"
     (CODE1 "export") "はアトミック操作のように動作します。" EOL2 (CODE1 "export") "の名前の衝突が、"
     (CODE1 "export") "される" (STRONG "symbols") "のひとつと" "新たに" (CODE1 "export")
     "されるシンボルを継承する" (STRONG "package") "に" "すでに存在しているシンボルとの間に生じるとき、" "その衝突は、"
     (CODE1 "export") "されるシンボルを選びもう片方を" (CODE1 "unintern") "するか、" "あるいはすでに存在しているシンボルを選び、"
     "それを" (CODE1 "shadowing-symbol") "にするか" "どちらかで解決できます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(make-package 'temp :use nil) =>  #<PACKAGE \"TEMP\">"
      "(use-package 'temp) =>  T" "(intern \"TEMP-SYM\" 'temp) =>  TEMP::TEMP-SYM, NIL"
      "(find-symbol \"TEMP-SYM\") =>  NIL, NIL"
      "(export (find-symbol \"TEMP-SYM\" 'temp) 'temp) =>  T"
      "(find-symbol \"TEMP-SYM\") =>  TEMP-SYM, :INHERITED"))
    (CHAPTER ("## 副作用") 2 "パッケージシステムは変更されます。") (CHAPTER ("## 影響") 2 "アクセス可能なシンボル")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "symbols") "のどれかが" (STRONG "package")
     "内でアクセス不可のとき、" "型" (CODE1 "package-error") "のエラーが通知されますが、" "これは修正可能であることが許されており、"
     "ユーザーは対話式でシンボルを" (CODE1 "import") "するべきかどうかを指定できます。")
    (CHAPTER ("## 参考") 2 (CODE1 "import") "," (CODE1 "unexport") "," "11.1. パッケージの説明")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("EXPORT" . "FUNCTION") *table*) (gethash "EXPORT" *table*))
(setf (gethash "EXTENDED-CHAR" *table*)
  '((CHAPTER NIL 0 "Type " (CODE1 "EXTENDED-CHAR"))
    (CHAPTER ("## スーパータイプ") 2 (CODE1 "extended-char") ", " (CODE1 "character") ", "
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "extended-char") "は、"
     (CODE1 "(and character (not base-char))") "と同じです。")
    (CHAPTER ("## 備考") 2 "全ての文字が型" (CODE1 "base-char") "である実装では、" "型"
     (CODE1 "extended-char") "は要素が無いかもしれません。")))
(setf (gethash '("EXTENDED-CHAR" . "TYPE") *table*) (gethash "EXTENDED-CHAR" *table*))
(setf (gethash "FBOUNDP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FBOUNDP"))
    (CHAPTER ("## 構文") 2 (CODE1 "fboundp") " " (STRONG "name") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 発音") 2 "[,ef'bandpee]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - 関数名" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "name") "が" (CODE1 "fbound") "なら" (STRONG "true") "を、"
     "それ以外なら" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(fboundp 'car) =>  true" "(fboundp 'nth-value) =>  false"
      "(fboundp 'with-open-file) =>  true" "(fboundp 'unwind-protect) =>  true"
      "(defun my-function (x) x) =>  MY-FUNCTION" "(fboundp 'my-function) =>  true"
      "(let ((saved-definition (symbol-function 'my-function)))"
      "  (unwind-protect (progn (fmakunbound 'my-function)"
      "                         (fboundp 'my-function))"
      "    (setf (symbol-function 'my-function) saved-definition)))" "=>  false"
      "(fboundp 'my-function) =>  true" "(defmacro my-macro (x) `',x) =>  MY-MACRO"
      "(fboundp 'my-macro) =>  true" "(fmakunbound 'my-function) =>  MY-FUNCTION"
      "(fboundp 'my-function) =>  false" "(flet ((my-function (x) x))"
      "  (fboundp 'my-function)) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "name") "が関数名でないとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "symbol-function") "," (CODE1 "fmakunbound") ","
     (CODE1 "fdefinition"))
    (CHAPTER ("## 備考") 2 "どんなシンボルでも" (CODE1 "fbouund") "であれば、" (CODE1 "symbol-function")
     "を呼び出すことができます。" EOL2 (CODE1 "fboundp") "は、よく関数セルにアクセスするときの保護として使われます。" "例えば下記の通り。"
     (CODE3 "```lisp" "```" "(if (fboundp x) (symbol-function x))") EOL2
     "setf-expanderの定義" (CODE1 "F") "は、" (CODE1 "(setf F)") "であらわされるsetf関数の定義にはなりません。")))
(setf (gethash '("FBOUNDP" . "FUNCTION") *table*) (gethash "FBOUNDP" *table*))
(setf (gethash "FDEFINITION" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "FDEFINITION"))
    (CHAPTER ("## 構文") 2 (CODE1 "fdefinition") " " (STRONG "function-name") " => "
     (STRONG "definition") EOL1 "(" (CODE1 "setf") " (" (CODE1 "fdefinition") " "
     (STRONG "function-name") ") " (STRONG "new-definition") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function-name") " - 関数名。" (CODE1 "setf") "ではないときは、"
     "グローバル関数かの" (CODE1 "fbound") "である必要があります。" EOL1 (STRONG "definition") " - "
     (STRONG "function-name") "という名前の現在のグローバル関数の定義" EOL1 (STRONG "new-definition")
     " - 関数")
    (CHAPTER ("## 定義") 2 (CODE1 "fdefinition") "は、" (STRONG "function-name")
     "という名前によって定義された" "現在のグローバル関数にアクセスします。" "定義は、関数かもしれませんし、" "あるいは特殊フォームかマクロを表した"
     "オブジェクトかもしれません。" "もし" (CODE1 "fboundp") "が" (STRONG "true") "であり、" "かつ"
     (STRONG "function-name") "がマクロか特殊フォームのときは、" (CODE1 "fdefinition")
     "の返却値はちゃんと定義できていませんが、" "しかし" (CODE1 "fdefinition") "がエラーを発することはありません。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "function-name") "が関数名でないとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。" EOL2 (CODE1 "setf") "ではない場合、" "もし" (STRONG "function-name") "が"
     (CODE1 "fbound") "ではないときは、" "型" (CODE1 "undefined-function") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "fboundp") "," (CODE1 "fmakunbound") ","
     (CODE1 "macro-function") "," (CODE1 "special-operator-p") ","
     (CODE1 "symbol-function"))
    (CHAPTER ("## 備考") 2 (CODE1 "fdefinition") "は、" (CODE1 "flet") "や" (CODE1 "labels")
     "によって" "生成されたレキシカルな関数名の値にはアクセスできません。" "グローバル環境の値にのみアクセスできます。" EOL2 (CODE1 "setf")
     "は" (CODE1 "fdefinition") "と使うことで、" (STRONG "function-name") "の関数が特殊フォームではないとき、"
     "グローバルな関数定義を置き換えることができます。" (CODE1 "setf") "の" (CODE1 "fdefinition")
     "は、新しい値に関数を要求します。" (STRONG "function-name") "の" (CODE1 "fdefinition") "に、"
     "シンボルか、リストか、" "あるいはマクロか特殊フォームの名前から" (CODE1 "fdefinition") "によって得られる値をセットするのはエラーです。")))
(setf (gethash '("FDEFINITION" . "ACCESSOR") *table*) (gethash "FDEFINITION" *table*))
(setf (gethash "FIFTH" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "FIRST") ", " (CODE1 "SECOND") ", " (CODE1 "THIRD")
     ", " (CODE1 "FOURTH") ", " (CODE1 "FIFTH") "," (CODE1 "SIXTH") ", "
     (CODE1 "SEVENTH") ", " (CODE1 "EIGHTH") ", " (CODE1 "NINTH") ", " (CODE1 "TENTH"))
    (CHAPTER ("## 構文") 2 (CODE1 "first") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "second") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "third") " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fourth")
     " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fifth") " "
     (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "sixth") " " (STRONG "list")
     " => " (STRONG "object") EOL1 (CODE1 "seventh") " " (STRONG "list") " => "
     (STRONG "object") EOL1 (CODE1 "eighth") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "ninth") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "tenth") " " (STRONG "list") " => " (STRONG "object") EOL1 "(" (CODE1 "setf")
     " (" (CODE1 "first") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "second") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "third") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "fourth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "fifth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "sixth") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "seventh") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "eighth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "ninth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "tenth") " " (STRONG "list") ") " (STRONG "new-object")
     ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト、ドットリストと循環リストも受け付けます。" EOL1
     (STRONG "object") ", " (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "関数" (CODE1 "first") ", " (CODE1 "second") ", " (CODE1 "third")
     ", " (CODE1 "fourth") ", " (CODE1 "fifth") "," (CODE1 "sixth") ", "
     (CODE1 "seventh") ", " (CODE1 "eighth") ", " (CODE1 "ninth") ", " (CODE1 "tenth")
     "は、" "それぞれリストの1番目、2番目、3番目、4番目、5番目、" "6番目、7番目、8番目、9番目、10番目の要素にアクセスします。"
     "具体的には次のようになります。"
     (CODE3 "```lisp" "```" "(first list)    ==   (car list)"
      "(second list)   ==   (car (cdr list))" "(third list)    ==   (car (cddr list))"
      "(fourth list)   ==   (car (cdddr list))"
      "(fifth list)    ==   (car (cddddr list))"
      "(sixth list)    ==   (car (cdr (cddddr list)))"
      "(seventh list)  ==   (car (cddr (cddddr list)))"
      "(eighth list)   ==   (car (cdddr (cddddr list)))"
      "(ninth list)    ==   (car (cddddr (cddddr list)))"
      "(tenth list)    ==   (car (cdr (cddddr (cddddr list))))")
     EOL2 (CODE1 "setf") "は、これらの関数を使うことによって" "既存の構成要素を変更することもできます。"
     "上記の等価な関係を用いて同じように適用できます。" "例えば次のようになります。"
     (CODE3 "```lisp" "```"
      "(setf (fifth list) new-object) == (setf (car (cddddr list)) new-object)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst '(1 2 3 (4 5 6) ((V)) vi 7 8 9 10)) "
      "=>  (1 2 3 (4 5 6) ((V)) VI 7 8 9 10)" "(first lst) =>  1" "(tenth lst) =>  10"
      "(fifth lst) =>  ((V))" "(second (fourth lst)) =>  5" "(sixth '(1 2 3)) =>  NIL"
      "(setf (fourth lst) \"four\") =>  \"four\""
      "lst =>  (1 2 3 \"four\" ((V)) VI 7 8 9 10)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "car") "," (CODE1 "nth"))
    (CHAPTER ("## 備考") 2 (CODE1 "first") "は機能的には" (CODE1 "car") "と同じです。" (CODE1 "second")
     "は機能的には" (CODE1 "cadr") "と同じです。" (CODE1 "third") "は機能的には" (CODE1 "caddr") "と同じです。"
     (CODE1 "fourth") "は機能的には" (CODE1 "cadddr") "と同じです。" EOL2 "通常の番号付けは1から開始しますが、"
     (CODE1 "nth") "によって使われる採番は0開始であり、" "次の関係が成り立ちます。"
     (CODE3 "```lisp" "```" "(fifth x) == (nth 4 x)"))))
(setf (gethash '("FIFTH" . "ACCESSOR") *table*) (gethash "FIFTH" *table*))
(setf (gethash "FILE-AUTHOR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FILE-AUTHOR"))
    (CHAPTER ("## 構文") 2 (CODE1 "file-author") " " (STRONG "pathspec") " => "
     (STRONG "author"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathspec") " - パス名指定子" EOL1 (STRONG "author")
     " - 文字列か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (STRONG "pathspec") "によって指定されたファイルの作者の名前を表す文字列を返却するか、"
     "あるいは作者の名前が決定できなかったときは" (CODE1 "nil") "が返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-open-file (stream \">relativity>general.text\")"
      "  (file-author s))" "=>  \"albert\""))
    (CHAPTER ("## 影響") 2 "ホストコンピューターのファイルシステム")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "filespec") "がワイルドカードを含むとき、" "型"
     (CODE1 "file-error") "のエラーが発生します。" EOL2 "もしファイルシステムが要求された処理を実行できなかったときは、" "型"
     (CODE1 "file-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 "25.1.4.2. ユニバーサル時間," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("FILE-AUTHOR" . "FUNCTION") *table*) (gethash "FILE-AUTHOR" *table*))
(setf (gethash "FILE-ERROR" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "FILE-ERROR"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "file-error") "," (CODE1 "error") ","
     (CODE1 "serious-condition") "," (CODE1 "condition") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "file-error") "は、" "開いているか閉じているファイルへの処理中か、"
     "ファイルシステム内の低レベルな同期処理中に発生するような" "エラーコンディションで構成されます。" "「問題を起こしたパス名」は、"
     (CODE1 "make-condition") "の初期化引数" (CODE1 ":pathname") "によって初期化され、" "そしてそれは関数"
     (CODE1 "file-error-pathname") "によってアクセスできます。")
    (CHAPTER ("## 参考") 2 (CODE1 "file-error-pathname") "," (CODE1 "open") ","
     (CODE1 "probe-file") "," (CODE1 "directory") "," (CODE1 "ensure-directories-exist"))))
(setf (gethash '("FILE-ERROR" . "CONDITION-TYPE") *table*) (gethash "FILE-ERROR" *table*))
(setf (gethash "FILE-ERROR-PATHNAME" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FILE-ERROR-PATHNAME"))
    (CHAPTER ("## 構文") 2 (CODE1 "file-error-pathname") " " (STRONG "condition") " => "
     (STRONG "pathspec"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "condition") " - 型" (CODE1 "file-error") "のコンディション"
     EOL1 (STRONG "pathspec") " - パス名指定子")
    (CHAPTER ("## 定義") 2 "型" (CODE1 "file-error") "のコンディションから" "「問題を起こしたパス名」を返却します。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "file-error") "," "9. コンディション")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("FILE-ERROR-PATHNAME" . "FUNCTION") *table*) (gethash "FILE-ERROR-PATHNAME" *table*))
(setf (gethash "FILE-LENGTH" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FILE-LENGTH"))
    (CHAPTER ("## 構文") 2 (CODE1 "file-length") " " (STRONG "stream") " => "
     (STRONG "length"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream") " - ファイルに関連付けられたストリーム" EOL1
     (STRONG "length") " - 非負の整数か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "file-length") "は" (STRONG "stream") "の長さか、"
     "長さが決定できなかったときは" (CODE1 "nil") "を返却します。" EOL2 "バイナリファイルとときは、" "その長さは"
     (STRONG "stream") "の要素の型を単位として計測されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-open-file (s \"decimal-digits.text\" "
      "                   :direction :output :if-exists :error)"
      "  (princ \"0123456789\" s)" "  (truename s))"
      "=>  #P\"A:>Joe>decimal-digits.text.1\""
      "(with-open-file (s \"decimal-digits.text\")" "  (file-length s))" "=>  10"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "stream") "がファイルに関連付けられたストリームではないとき、" "型"
     (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "open")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("FILE-LENGTH" . "FUNCTION") *table*) (gethash "FILE-LENGTH" *table*))
(setf (gethash "FILE-NAMESTRING" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "NAMESTRING") ", " (CODE1 "FILE-NAMESTRING") ", "
     (CODE1 "DIRECTORY-NAMESTRING") "," (CODE1 "HOST-NAMESTRING") ", "
     (CODE1 "ENOUGH-NAMESTRING"))
    (CHAPTER ("## 構文") 2 (CODE1 "namestring") " " (STRONG "pathname") " => "
     (STRONG "namestring") EOL1 (CODE1 "file-namestring") " " (STRONG "pathname") " => "
     (STRONG "namestring") EOL1 (CODE1 "directory-namestring") " " (STRONG "pathname")
     " => " (STRONG "namestring") EOL1 (CODE1 "host-namestring") " " (STRONG "pathname")
     " => " (STRONG "namestring") EOL1 (CODE1 "enough-namestring") " "
     (STRONG "pathname") " " (CODE1 "&optional") " " (STRONG "defaults") " => "
     (STRONG "namestring"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathname") " - パス名指定子" EOL1 (STRONG "defaults")
     " - パス名指定子。" "デフォルトは" (CODE1 "*default-pathname-defaults*") "の値です。" EOL1
     (STRONG "namestring") " - 文字列か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "pathname") "を名前文字列に変換します。"
     (STRONG "pathname") "によって表現される名前は、" "実装依存の基準のフォームに従った" "名前文字列として返却されます。" EOL2
     (CODE1 "namestring") "は、" (STRONG "pathname") "の完全なフォームを返却します。" EOL2
     (CODE1 "file-namestring") "は、" (STRONG "pathname") "の名前とタイプとバージョンの要素だけを返却します。" EOL2
     (CODE1 "directory-namestring") "は、" (STRONG "pathname") "のディレクトリの名前の部分を返却します。" EOL2
     (CODE1 "host-namestring") "は、ホスト名を返却します。" EOL2 (CODE1 "enough-namestring") "は、"
     (STRONG "pathname") "が" (STRONG "defaults") "から相対的に考慮されたものによって、"
     "同一と見なせるのに十分なファイル名である" "省略された名前文字列を返却します。" "これは、全ての場合において次のような関係を要求します。"
     (CODE3 "```lisp" "```"
      "(merge-pathnames (enough-namestring pathname defaults) defaults)"
      "==  (merge-pathnames (parse-namestring pathname nil defaults) defaults)")
     EOL2 (CODE1 "enough-namestring") "の結果は、" "このような基準を満たした最も短い適切な文字列です。" EOL2
     "この3つの短い名前文字列をある順にて結合することによって" "有効な名前文字列を生成することは必ずしも可能ではありません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(namestring \"getty\")            " "=>  \"getty\""
      "(setq q (make-pathname :host \"kathy\" " "                        :directory "
      "                          (pathname-directory *default-pathname-defaults*)"
      "                        :name \"getty\")) "
      "=>  #S(PATHNAME :HOST \"kathy\" :DEVICE NIL :DIRECTORY directory-name "
      "      :NAME \"getty\" :TYPE NIL :VERSION NIL)" "(file-namestring q) =>  \"getty\""
      "(directory-namestring q) =>  directory-name" "(host-namestring q) =>  \"kathy\" "
      ";;; Unix構文の使用とこの例での特定のUnixバージョンによる" ";;; ワイルドカード表記の使用によって作成されたもの" "(namestring"
      "  (translate-pathname \"/usr/dmr/hacks/frob.l\""
      "                      \"/usr/d*/hacks/*.l\""
      "                      \"/usr/d*/backup/hacks/backup-*.*\"))"
      ">  \"/usr/dmr/backup/hacks/backup-frob.l\"" "(namestring"
      "  (translate-pathname \"/usr/dmr/hacks/frob.l\""
      "                      \"/usr/d*/hacks/fr*.l\""
      "                      \"/usr/d*/backup/hacks/backup-*.*\"))"
      "=>  \"/usr/dmr/backup/hacks/backup-ob.l\"" NIL
      ";;; これは上記の例に似ていますが2つの違ったホストを使用しています。" ";;; UがUnixであり、VがVMSです。ファイルタイプの変換と"
      ";;; アルファベットの大文字小文字の表記に注意してください。" "(namestring"
      "  (translate-pathname \"U:/usr/dmr/hacks/frob.l\""
      "                      \"U:/usr/d*/hacks/*.l\""
      "                      \"V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*\"))"
      "=>  \"V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-FROB.LSP\"" "(namestring"
      "  (translate-pathname \"U:/usr/dmr/hacks/frob.l\""
      "                      \"U:/usr/d*/hacks/fr*.l\""
      "                      \"V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*\"))"
      "=>  \"V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-OB.LSP\""))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "truename") "," (CODE1 "merge-pathnames") ","
     (CODE1 "pathname") "," (CODE1 "logical-pathname") "," "20.1. ファイルシステムの説明,"
     "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("FILE-NAMESTRING" . "FUNCTION") *table*) (gethash "FILE-NAMESTRING" *table*))
(setf (gethash "FILE-POSITION" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FILE-POSITION"))
    (CHAPTER ("## 構文") 2 (CODE1 "file-position") " " (STRONG "stream") " => "
     (STRONG "position") EOL1 (CODE1 "file-position") " " (STRONG "stream") " "
     (STRONG "position-spec") " => " (STRONG "success-p"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream") " - ストリーム" EOL1 (STRONG "position-spec")
     " - ファイルの位置指定子" (STRONG "position") " - ファイルの位置か、" (CODE1 "nil") EOL1
     (STRONG "success-p") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "stream") "内の現在の位置について、返却を行うか変更を行います。" EOL2
     (STRONG "position-spec") "が指定されていないとき、" (CODE1 "file-position") "は"
     (STRONG "stream") "の現在のファイルの位置を返却し、" "もしそれが決定できないときは" (CODE1 "nil") "を返却します。" EOL2
     (STRONG "position-spec") "が指定されたとき、" (STRONG "stream") "のファイルの位置が（可能であれば）設定されます。"
     "もし位置の変更が正しく行われたとき、" (CODE1 "file-position") "は" (STRONG "true") "を返却し、"
     "そうでなかったときは" (STRONG "false") "を返却します。" EOL2 (CODE1 "file-position")
     "がひとつの引数のときの返却された整数値は、" "同じファイルに" (STRONG "position-spec") "として使用できるように"
     "受け入れなければなりません。" EOL2 "文字型のファイルのとき、" (CODE1 "read-char") "か" (CODE1 "write-char")
     "の一回の操作による実行は、" "文字セットの変換や（そのような変換には、" "Common Lispの" (CODE1 "#\\Newline")
     "文字と外部のASCII文字である、" "キャリッジリターン・ラインフィードの列のような" "二つの間の変換があります）、" "その他の実装の仕様により、"
     "ファイルの位置が" (CODE1 "1") "より大きな値で増加するかもしれません。" "バイナリファイルのとき、" (CODE1 "read-byte") "か"
     (CODE1 "write-byte") "の全ての操作は、" "ファイルの位置が" (CODE1 "1") "だけ増加します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun tester ()" "  (let ((noticed '()) file-written)"
      "    (flet ((notice (x) (push x noticed) x))"
      "      (with-open-file (s \"test.bin\" "
      "                         :element-type '(unsigned-byte 8)"
      "                         :direction :output"
      "                         :if-exists :error)"
      "         (notice (file-position s)) ;1" "         (write-byte 5 s) "
      "         (write-byte 6 s)" "         (let ((p (file-position s)))"
      "           (notice p) ;2"
      "           (notice (when p (file-position s (1- p))))) ;3"
      "         (write-byte 7 s)" "         (notice (file-position s)) ;4"
      "         (setq file-written (truename s)))"
      "       (with-open-file (s file-written"
      "                          :element-type '(unsigned-byte 8)"
      "                          :direction :input)"
      "         (notice (file-position s)) ;5" "         (let ((length (file-length s)))"
      "           (notice length) ;6" "           (when length"
      "             (dotimes (i length)"
      "               (notice (read-byte s)))))) ;7,..." "       (nreverse noticed))))"
      "=>  tester" "(tester)" "=>  (0 2 T 2 0 2 5 7)" "OR=>  (0 2 NIL 3 0 3 5 6 7)"
      "OR=>  (NIL NIL NIL NIL NIL NIL)"))
    (CHAPTER ("## 副作用") 2 "引数に" (STRONG "position-spec") "が指定されたとき、" (STRONG "stream")
     "のファイル位置はおそらく移動します。")
    (CHAPTER ("## 影響") 2 (CODE1 "file-position") "による返却値は、" "入出力の操作が実行されるたびに単調に増加します。")
    (CHAPTER ("## 例外") 2 (STRONG "position-spec") "が指定されたとき、その値が大きすぎるか、"
     "あるいはその他の理由で適用できなかったときはエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "file-length") "," (CODE1 "file-string-length") ","
     (CODE1 "open"))
    (CHAPTER ("## 備考") 2 "文字ファイルを一定のサイズのレコードの列として表現する実装では、" "例えば"
     (CODE1 "<<レコード番号>>*<最大レコードサイズ>>+<レコード内の文字>>") "のように" "ファイル位置を算出することができるかもしれません。"
     "これは各文字の読み書きに応じて単調に増加するため有効な計算です。" "ただし、各ステップで必ずしも1ずつ増えるわけではありません。"
     "もし、ある整数をレコード番号と文字番号をもとに算出したとき、" "与えられたレコードが指定された文字番号に対して短すぎることが判明すれば、" "その整数値は"
     (CODE1 "file-position") "の" (STRONG "position-spec") "として" "「不適切」とみなされるかもしれません。")))
(setf (gethash '("FILE-POSITION" . "FUNCTION") *table*) (gethash "FILE-POSITION" *table*))
(setf (gethash "FILE-STREAM" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "FILE-STREAM"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "file-stream") "," (CODE1 "stream") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "file-stream") "のオブジェクトは、" "ファイルから直接送受信するストリームです。"
     "そのようなストリームは、" (CODE1 "open") "と" (CODE1 "with-open-file") "によって明に作成されるか、"
     (CODE1 "load") "のようなファイルを処理する関数で暗に作成されます。")
    (CHAPTER ("## 参考") 2 (CODE1 "load") "," (CODE1 "open") "," (CODE1 "with-open-file"))))
(setf (gethash '("FILE-STREAM" . "SYSTEM-CLASS") *table*) (gethash "FILE-STREAM" *table*))
(setf (gethash "FILE-STRING-LENGTH" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FILE-STRING-LENGTH"))
    (CHAPTER ("## 構文") 2 (CODE1 "file-string-length") " " (STRONG "stream") " "
     (STRONG "object") " => " (STRONG "length"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream") " - 文字型のファイルの出力ストリーム" EOL1
     (STRONG "object") " - 文字列か、文字" EOL1 (STRONG "length") " - 非負の整数か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "file-string-length") "は、"
     (CODE1 "(file-position stream)") "について" (STRONG "object") "を書き込んだ後の値と現在の値の差分か、"
     "あるいは決定できなかったときは" (CODE1 "nil") "を返却します。" EOL2 "返却値は呼び出し時の" (STRONG "stream")
     "の現在の状態に対応するため、" (STRONG "stream") "の状態が変化したときに再び呼び出された場合は、" "同じ値ではないかもしれません。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("FILE-STRING-LENGTH" . "FUNCTION") *table*) (gethash "FILE-STRING-LENGTH" *table*))
(setf (gethash "FILE-WRITE-DATE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FILE-WRITE-DATE"))
    (CHAPTER ("## 構文") 2 (CODE1 "file-write-date") " " (STRONG "pathspec") " => "
     (STRONG "date"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathspec") " - パス名指定子" EOL1 (STRONG "date")
     " - ユニバーサル時間か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (STRONG "pathspec") "で指定されたファイルが"
     "最後に書き込みされたとき（または作成されたとき）の時間を、" "ユニバーサル時間として表現したものを返却するか、" "そのような時間が決定できなかったときは"
     (CODE1 "nil") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-open-file (s \"noel.text\" "
      "                   :direction :output :if-exists :error)"
      "  (format s \"~&Dear Santa,~2%I was good this year.  ~"
      "               Please leave lots of toys.~2%Love, Sue~"
      "            ~2%attachments: milk, cookies~%\")" "  (truename s))"
      "=>  #P\"CUPID:/susan/noel.text\"" "(with-open-file (s \"noel.text\")"
      "  (file-write-date s))" "=>  2902600800"))
    (CHAPTER ("## 影響") 2 "ホストコンピューターのファイルシステム" EOL2 (STRONG "pathspec")
     "として名前がついているファイルへの他のユーザー。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "filespec") "がワイルドカードを含むとき、" "型"
     (CODE1 "file-error") "のエラーが発生します。" EOL2 "もしファイルシステムが要求された処理を実行できなかったときは、" "型"
     (CODE1 "file-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "pathname") "," (CODE1 "logical-pathname") ","
     "20.1. ファイルシステムの説明," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("FILE-WRITE-DATE" . "FUNCTION") *table*) (gethash "FILE-WRITE-DATE" *table*))
(setf (gethash "FILL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FILL"))
    (CHAPTER ("## 構文") 2 (CODE1 "fill") " " (STRONG "sequence") " " (STRONG "item")
     " &key " (STRONG "start") " " (STRONG "end") " => " (STRONG "sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "sequence") " - 正常なシーケンス" EOL1 (STRONG "item")
     " - オブジェクト" EOL1 (STRONG "start") ", " (STRONG "end") " - " (STRONG "sequence")
     "の境界インデックス指定子。" "デフォルトは" (STRONG "start") ", " (STRONG "end") "それぞれ" (CODE1 "0") "と"
     (CODE1 "nil") "。")
    (CHAPTER ("## 定義") 2 (STRONG "start") "と" (STRONG "end") "の境界内にある"
     (STRONG "sequence") "の要素を、" (STRONG "item") "に置き換えます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(fill (list 0 1 2 3 4 5) '(444)) =>  ((444) (444) (444) (444) (444) (444))"
      "(fill (copy-seq \"01234\") #\\e :start 3) =>  \"012ee\""
      "(setq x (vector 'a 'b 'c 'd 'e)) =>  #(A B C D E)"
      "(fill x 'z :start 1 :end 3) =>  #(A Z Z D E)" "x =>  #(A Z Z D E)"
      "(fill x 'p) =>  #(P P P P P)" "x =>  #(P P P P P)"))
    (CHAPTER ("## 副作用") 2 (STRONG "sequence") "は破壊的に修正されます。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。" (STRONG "start") "が非負の整数ではないとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。" (STRONG "end") "が非負の整数ではなく" (CODE1 "nil") "でもないとき、" "型"
     (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "replace") "," (CODE1 "nsubstitute"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```"
      "(fill sequence item) == (nsubstitute-if item (constantly t) sequence)"))))
(setf (gethash '("FILL" . "FUNCTION") *table*) (gethash "FILL" *table*))
(setf (gethash "FILL-POINTER" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "FILL-POINTER"))
    (CHAPTER ("## 構文") 2 (CODE1 "fill-pointer") " " (STRONG "vector") " => "
     (STRONG "fill-pointer") EOL1 "(" (CODE1 "setf") " (" (CODE1 "fill-pointer") " "
     (STRONG "vector") ") " (STRONG "new-fill-pointer") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "vector") " - fill-pointerを持った" (CODE1 "vector")
     EOL1 (STRONG "fill-pointer") ", " (STRONG "new-fill-pointer") " - "
     (STRONG "vector") "の有効なfill-pointer")
    (CHAPTER ("## 定義") 2 (STRONG "vector") "のfill-pointerにアクセスします")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq a (make-array 8 :fill-pointer 4)) =>  #(NIL NIL NIL NIL)"
      "(fill-pointer a) =>  4"
      "(dotimes (i (length a)) (setf (aref a i) (* i i))) =>  NIL" "a =>  #(0 1 4 9)"
      "(setf (fill-pointer a) 3) =>  3" "(fill-pointer a) =>  3" "a =>  #(0 1 4)"
      "(setf (fill-pointer a) 8) =>  8" "a =>  #(0 1 4 9 NIL NIL NIL NIL)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "vector") "がfill-pointerを持つ" (CODE1 "vector") "では無かったら、"
     "型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-array") "," (CODE1 "length"))
    (CHAPTER ("## 備考") 2 (CODE1 "vector") "からfill-pointerを削除する操作はありません。")))
(setf (gethash '("FILL-POINTER" . "ACCESSOR") *table*) (gethash "FILL-POINTER" *table*))
(setf (gethash "FIND" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FIND") ", " (CODE1 "FIND-IF") ", "
     (CODE1 "FIND-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "find") " " (STRONG "item") " " (STRONG "sequence")
     " &key " (STRONG "from-end") " " (STRONG "test") " " (STRONG "test-not") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "key") " => " (STRONG "element")
     EOL1 (CODE1 "find-if") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "key")
     " => " (STRONG "element") EOL1 (CODE1 "find-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "key") " => " (STRONG "element"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "sequence")
     " - 正常なシーケンス" EOL1 (STRONG "predicate") " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子"
     EOL1 (STRONG "from-end") " - generalized-boolean、デフォルトは" (STRONG "false") EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "element") " - "
     (STRONG "sequence") "の要素か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "find") "、" (CODE1 "find-if") "、" (CODE1 "find-if-not")
     "は、" (STRONG "start") "と" (STRONG "end") "で囲まれた" (STRONG "sequence") "内で、"
     (STRONG "predicate") "かあるいは" (STRONG "test") ", " (STRONG "test-not")
     "を適宜満たすものを検索します。" EOL2 "もし" (STRONG "from-end") "が" (STRONG "true") "ならば、"
     (STRONG "test") "を満たすもっとも右側の要素が返却されます。" EOL2 "もし" (STRONG "sequence") "に"
     (STRONG "test") "を満たす要素がある場合、" (STRONG "from-end") "によって、" (STRONG "sequence")
     "のもっとも左にあるものか、" "もっとも右にあるものが返却されます。" "それ以外のときは、" (CODE1 "nil") "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(find #\\d \"here are some letters that can be looked at\" :test #'char>)"
      "=>  #\\Space " "(find-if #'oddp '(1 2 3 4 5) :end 3 :from-end t) =>  3"
      "(find-if-not #'complexp                                    "
      "            '#(3.5 2 #C(1.0 0.0) #C(0.0 1.0))" "            :start 2) =>  NIL "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "position") "," "17.2. テスト関数のルール," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "find-if-not") "は非推奨です。")))
(setf (gethash '("FIND" . "FUNCTION") *table*) (gethash "FIND" *table*))
(setf (gethash "FIND-ALL-SYMBOLS" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FIND-ALL-SYMBOLS"))
    (CHAPTER ("## 構文") 2 (CODE1 "find-all-symbols") " " (STRONG "string") " => "
     (STRONG "symbols"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string") " - 文字列指定子" EOL1 (STRONG "symbols")
     " - シンボルのリスト")
    (CHAPTER ("## 定義") 2 (CODE1 "find-all-symbols") "は、全ての登録されているパッケージから、" "名前が（"
     (CODE1 "string=") "にて）" (STRONG "string") "と同じシンボルを検索します。"
     "そのような全てのシンボルはリストとして返却されます。" "リストがどのような順番になるかは実装依存です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(find-all-symbols 'car)" "=>  (CAR)"
      "OR=>  (CAR VEHICLES:CAR)" "OR=>  (VEHICLES:CAR CAR)"
      "(intern \"CAR\" (make-package 'temp :use nil)) =>  TEMP::CAR, NIL"
      "(find-all-symbols 'car)" "=>  (TEMP::CAR CAR)" "OR=>  (CAR TEMP::CAR)"
      "OR=>  (TEMP::CAR CAR VEHICLES:CAR)" "OR=>  (CAR TEMP::CAR VEHICLES:CAR)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "find-symbol")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("FIND-ALL-SYMBOLS" . "FUNCTION") *table*) (gethash "FIND-ALL-SYMBOLS" *table*))
(setf (gethash "FIND-CLASS" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "FIND-CLASS"))
    (CHAPTER ("## 構文") 2 (CODE1 "find-class") " " (STRONG "symbol") " &optional "
     (STRONG "errorp") " " (STRONG "environment") " => " (STRONG "class") EOL1 "("
     (CODE1 "setf") " (" (CODE1 "find-class") " " (STRONG "symbol") " &optional "
     (STRONG "errorp") " " (STRONG "environment") ") " (STRONG "new-class") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - シンボル" EOL1 (STRONG "errorp")
     " - generalized-boolean, デフォルトは" (STRONG "true") "。" EOL1 (STRONG "environment")
     " -- マクロ展開の" (CODE1 "&environment") "と同じであり、" "コンパイル時か実行時かを区別するために使用されます。"
     (CODE1 "&environment") "引数は動的な生存期間であり、" "マクロ展開関数の動的生存期間の外側で" (CODE1 "&environment")
     "引数が参照された場合はの結果は未定義です。" EOL1 (STRONG "class") " - クラスオブジェクトか" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (STRONG "environment") "内の" (STRONG "symbol") "という名前のクラス"
     (STRONG "class") "を返却します。" "もしそのようなクラスが存在しないとき、" (STRONG "errorp") "が"
     (STRONG "false") "なら" (CODE1 "nil") "が返却されます。" "一方、" (STRONG "errorp") "が"
     (STRONG "true") "の場合は、エラーが発生します。" EOL2 "特定の" (STRONG "symbol") "に関連付けられたクラス"
     (STRONG "class") "は、" (CODE1 "setf") "と" (CODE1 "find-class") "を使うことで変更できます。"
     "また、新しいクラスとして" (CODE1 "setf") "に" (CODE1 "nil") "を指定した時は、" "関連したクラスは削除されます。"
     "（しかしクラスオブジェクトそのものには影響しません）" "もしユーザーが、標準で定義されている型指定子のシンボルに"
     "関連付けられているクラスを変更したり削除したりしたときの結果は未定義です。" EOL2 (CODE1 "setf") "で" (CODE1 "find-class")
     "を使用するときに、" "引数の" (STRONG "errorp") "は評価する効果がありますが、返却値は無視されます。" (STRONG "errorp")
     "のこのような使い方が許可されているのは、" "主に" (STRONG "environment") "引数を使用できるようにするためです。" EOL2
     (STRONG "environment") "はコンパイル時か実行時かを区別するために使用されます。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もしそのようなクラスが存在せず、" (STRONG "errorp") "が" (STRONG "true") "の場合は、"
     (CODE1 "find-class") "は、型" (CODE1 "error") "のエラーを通知します。")
    (CHAPTER ("## 参考") 2 (CODE1 "defmacro") ", 4.3.7. 型とクラスの統合")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("FIND-CLASS" . "ACCESSOR") *table*) (gethash "FIND-CLASS" *table*))
(setf (gethash "FIND-IF" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FIND") ", " (CODE1 "FIND-IF") ", "
     (CODE1 "FIND-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "find") " " (STRONG "item") " " (STRONG "sequence")
     " &key " (STRONG "from-end") " " (STRONG "test") " " (STRONG "test-not") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "key") " => " (STRONG "element")
     EOL1 (CODE1 "find-if") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "key")
     " => " (STRONG "element") EOL1 (CODE1 "find-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "key") " => " (STRONG "element"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "sequence")
     " - 正常なシーケンス" EOL1 (STRONG "predicate") " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子"
     EOL1 (STRONG "from-end") " - generalized-boolean、デフォルトは" (STRONG "false") EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "element") " - "
     (STRONG "sequence") "の要素か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "find") "、" (CODE1 "find-if") "、" (CODE1 "find-if-not")
     "は、" (STRONG "start") "と" (STRONG "end") "で囲まれた" (STRONG "sequence") "内で、"
     (STRONG "predicate") "かあるいは" (STRONG "test") ", " (STRONG "test-not")
     "を適宜満たすものを検索します。" EOL2 "もし" (STRONG "from-end") "が" (STRONG "true") "ならば、"
     (STRONG "test") "を満たすもっとも右側の要素が返却されます。" EOL2 "もし" (STRONG "sequence") "に"
     (STRONG "test") "を満たす要素がある場合、" (STRONG "from-end") "によって、" (STRONG "sequence")
     "のもっとも左にあるものか、" "もっとも右にあるものが返却されます。" "それ以外のときは、" (CODE1 "nil") "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(find #\\d \"here are some letters that can be looked at\" :test #'char>)"
      "=>  #\\Space " "(find-if #'oddp '(1 2 3 4 5) :end 3 :from-end t) =>  3"
      "(find-if-not #'complexp                                    "
      "            '#(3.5 2 #C(1.0 0.0) #C(0.0 1.0))" "            :start 2) =>  NIL "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "position") "," "17.2. テスト関数のルール," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "find-if-not") "は非推奨です。")))
(setf (gethash '("FIND-IF" . "FUNCTION") *table*) (gethash "FIND-IF" *table*))
(setf (gethash "FIND-IF-NOT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FIND") ", " (CODE1 "FIND-IF") ", "
     (CODE1 "FIND-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "find") " " (STRONG "item") " " (STRONG "sequence")
     " &key " (STRONG "from-end") " " (STRONG "test") " " (STRONG "test-not") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "key") " => " (STRONG "element")
     EOL1 (CODE1 "find-if") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "key")
     " => " (STRONG "element") EOL1 (CODE1 "find-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "key") " => " (STRONG "element"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "sequence")
     " - 正常なシーケンス" EOL1 (STRONG "predicate") " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子"
     EOL1 (STRONG "from-end") " - generalized-boolean、デフォルトは" (STRONG "false") EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "element") " - "
     (STRONG "sequence") "の要素か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "find") "、" (CODE1 "find-if") "、" (CODE1 "find-if-not")
     "は、" (STRONG "start") "と" (STRONG "end") "で囲まれた" (STRONG "sequence") "内で、"
     (STRONG "predicate") "かあるいは" (STRONG "test") ", " (STRONG "test-not")
     "を適宜満たすものを検索します。" EOL2 "もし" (STRONG "from-end") "が" (STRONG "true") "ならば、"
     (STRONG "test") "を満たすもっとも右側の要素が返却されます。" EOL2 "もし" (STRONG "sequence") "に"
     (STRONG "test") "を満たす要素がある場合、" (STRONG "from-end") "によって、" (STRONG "sequence")
     "のもっとも左にあるものか、" "もっとも右にあるものが返却されます。" "それ以外のときは、" (CODE1 "nil") "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(find #\\d \"here are some letters that can be looked at\" :test #'char>)"
      "=>  #\\Space " "(find-if #'oddp '(1 2 3 4 5) :end 3 :from-end t) =>  3"
      "(find-if-not #'complexp                                    "
      "            '#(3.5 2 #C(1.0 0.0) #C(0.0 1.0))" "            :start 2) =>  NIL "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "position") "," "17.2. テスト関数のルール," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "find-if-not") "は非推奨です。")))
(setf (gethash '("FIND-IF-NOT" . "FUNCTION") *table*) (gethash "FIND-IF-NOT" *table*))
(setf (gethash "FIND-METHOD" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "FIND-METHOD"))
    (CHAPTER ("## 構文") 2 (CODE1 "find-method") " " (STRONG "generic-function") " "
     (STRONG "method-qualifiers") " " (STRONG "specializers") " &optional "
     (STRONG "errorp") EOL1 "=> " (STRONG "method"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "find-method") " (" (STRONG "generic-function") " "
     (CODE1 "standard-generic-function") ")" " " (STRONG "method-qualifiers") " "
     (STRONG "specializers") " &optional " (STRONG "errorp"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "generic-function") " - ジェネリック関数" EOL1
     (STRONG "method-qualifiers") " - リスト" EOL1 (STRONG "specializers") " - リスト" EOL1
     (STRONG "errorp") " - generalized-boolean、デフォルトは" (STRONG "true") EOL1
     (STRONG "method") " - メソッドオブジェクトか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "find-method") "は、" "引数にジェネリック関数を受け取り、"
     "修飾子と特定パラメーターがそれぞれ" (CODE1 "find-method") "の引数" (STRONG "qualifiers") "と"
     (STRONG "specializers") "で" "一致するメソッドオブジェクトを返却します。" (STRONG "method-qualifiers")
     "は、" (STRONG "method") "のメソッド修飾子が含まれます。" "メソッド修飾子の順序は重要です。"
     "この文脈の合致についての定義は、7.6.3. 特定パラメーターと修飾子の合致をご確認ください。" EOL2 (STRONG "specializers")
     "引数は、メソッドの特定パラメーターを含みます。" "この引数は、ジェネリック関数の要求された引数の数と、" "一致する長さでなければならず、"
     "そうでない場合はエラーが発生します。" "つまり、引数の" (STRONG "generic-function") "のデフォルトメソッドを得るためには、"
     "クラス" (CODE1 "t") "を要素とするリストを与える必要があります。" EOL2 "そのようなメソッドが存在せず、" (STRONG "errorp")
     "が" (STRONG "true") "のときは、" (CODE1 "find-method") "はエラーを発生します。" "そのようなメソッドが存在せず、"
     (STRONG "errorp") "が" (STRONG "false") "のときは、" (CODE1 "find-method") "は"
     (CODE1 "nil") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(defmethod some-operation ((a integer) (b float)) (list a b))"
      "=>  #<STANDARD-METHOD SOME-OPERATION (INTEGER FLOAT) 26723357>"
      "(find-method #'some-operation '() (mapcar #'find-class '(integer float)))"
      "=>  #<STANDARD-METHOD SOME-OPERATION (INTEGER FLOAT) 26723357>"
      "(find-method #'some-operation '() (mapcar #'find-class '(integer integer)))"
      ">>  Error: No matching method"
      "(find-method #'some-operation '() (mapcar #'find-class '(integer integer)) nil)"
      "=>  NIL"))
    (CHAPTER ("## 影響") 2 (CODE1 "add-method") "," (CODE1 "defclass") ","
     (CODE1 "defgeneric") "," (CODE1 "defmethod"))
    (CHAPTER ("## 例外") 2 "もし" (STRONG "specializers") "引数の長さが、"
     (STRONG "generic-function") "の要求された引数の数と、" "一致するしていなかったときは、" "型" (CODE1 "error")
     "のエラーが生じます。" EOL2 "そのようなメソッドが存在せず、" (STRONG "errorp") "が" (STRONG "true") "のときは、"
     (CODE1 "find-method") "は型" (CODE1 "error") "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 "7.6.3. 特定パラメーターと修飾子の合致") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("FIND-METHOD" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "FIND-METHOD" *table*))
(setf (gethash "FIND-PACKAGE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FIND-PACKAGE"))
    (CHAPTER ("## 構文") 2 (CODE1 "find-package") " " (STRONG "name") " => "
     (STRONG "package"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - 文字列指定子か、パッケージオブジェクト" EOL1
     (STRONG "package") " - パッケージオブジェクトか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "もし" (STRONG "name") "が文字列指定子のとき、" (CODE1 "find-package")
     "は名前かニックネームが" (STRONG "name") "であるパッケージを探して返却します。" "検索は大文字小文字を区別します。"
     "もしそのようなパッケージがないときは、" (CODE1 "find-package") "は" (CODE1 "nil") "を返却します。" EOL2 "もし"
     (STRONG "name") "がパッケージオブジェクトのときは、" "そのパッケージオブジェクトを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(find-package 'common-lisp) =>  #<PACKAGE \"COMMON-LISP\">"
      "(find-package \"COMMON-LISP-USER\") =>  #<PACKAGE \"COMMON-LISP-USER\">"
      "(find-package 'not-there) =>  NIL"))
    (CHAPTER ("## 副作用") 2 "なし。")
    (CHAPTER ("## 影響") 2 "実装によって作成されたパッケージの集合" EOL2 (CODE1 "defpackage") ","
     (CODE1 "delete-package") "," (CODE1 "make-package") "," (CODE1 "rename-package"))
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "make-package"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("FIND-PACKAGE" . "FUNCTION") *table*) (gethash "FIND-PACKAGE" *table*))
(setf (gethash "FIND-RESTART" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FIND-RESTART"))
    (CHAPTER ("## 構文") 2 (CODE1 "find-restart") " " (STRONG "identifier") " "
     (CODE1 "&optional") " " (STRONG "condition") EOL1 "=> " (STRONG "restart"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "identifier") " - " (CODE1 "nil") "ではなシンボルか、"
     (CODE1 "restart") EOL1 (STRONG "condition") " - コンディションオブジェクトか、" (CODE1 "nil") EOL1
     (STRONG "restart") " - " (CODE1 "restart") "か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "find-restart") "は、現在の動的環境下で特定の" (STRONG "restart")
     "を探します。" EOL2 "もし" (STRONG "condition") "が" (CODE1 "nil") "ではないときは、" "それらの"
     (CODE1 "restart") "は、明に" (STRONG "condition") "と関連付けられているものか、"
     "あるいはどのコンディションにも関連付けられてないものかの" "どちらかのみが集められます。" "これは、排他された" (CODE1 "restart")
     "というのは、" "関連付けられたコンディションの集合が空ではなく、" "その要素に指定した" (STRONG "condition")
     "が含まれていないということです。" "もし" (STRONG "condition") "が" (CODE1 "nil") "のときは、" "全ての"
     (CODE1 "restart") "が集められます。" EOL2 (STRONG "identifier") "がシンボルのとき、"
     "もっとも内側（より最近確立されたもの）の" "その名前の適用可能な" (CODE1 "restart") "が返却されます。" "そのような"
     (CODE1 "restart") "がない場合は" (CODE1 "nil") "です。" EOL2 "もし" (STRONG "identifier")
     "が現在の有効な" (CODE1 "restart") "のときは、" "それが返却されます。" "そうでないときは" (CODE1 "nil")
     "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(restart-case" "    (let ((r (find-restart 'my-restart)))"
      "      (format t \"~S is named ~S\" r (restart-name r)))" "  (my-restart () nil))"
      ">>  #<RESTART 32307325> is named MY-RESTART" "=>  NIL"
      "(find-restart 'my-restart)" "=>  NIL"))
    (CHAPTER ("## 副作用") 2 "なし。")
    (CHAPTER ("## 影響") 2 "存在する" (CODE1 "restart") EOL2 (CODE1 "restart-case") ","
     (CODE1 "restart-bind") "," (CODE1 "with-condition-restarts"))
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "compute-restarts"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(find-restart identifier)"
      "==  (find identifier (compute-restarts) :key :restart-name)")
     EOL2 "匿名の" (CODE1 "restart") "は" (CODE1 "nil") "という名前ですが、" (STRONG "identifier") "に"
     (CODE1 "nil") "を指定したときの結果は未定義です。" "たまにプログラマーは" (STRONG "identifier") "の引数に"
     (CODE1 "nil") "は許されないと主張します。" "そのような場合、" (CODE1 "compute-restarts") "で"
     "おそらく似たような効果を行うことができます。")))
(setf (gethash '("FIND-RESTART" . "FUNCTION") *table*) (gethash "FIND-RESTART" *table*))
(setf (gethash "FIND-SYMBOL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FIND-SYMBOL"))
    (CHAPTER ("## 構文") 2 (CODE1 "find-symbol") " " (STRONG "string") " "
     (CODE1 "&optional") " " (STRONG "package") " => " (STRONG "symbol") ", "
     (STRONG "status"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string") " - 文字列" EOL1 (STRONG "package")
     " - パッケージ指定子。デフォルトは現在のパッケージ。" EOL1 (STRONG "symbol") " - " (STRONG "package")
     "でアクセス可能なシンボルか、" (CODE1 "nil") EOL1 (STRONG "status") " - 次のどれか。"
     (CODE1 ":inherited") ", " (CODE1 ":external") ", " (CODE1 ":internal") ", "
     (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "find-symbol") "は、" (STRONG "package") "内の"
     (STRONG "string") "という名前のシンボルの" "場所を返却します。" "もし" (STRONG "string") "という名前のシンボルが"
     (STRONG "package") "内で" "直接のものかか継承によるものかのものが見つかったときは、" "そのシンボルが最初の値として返却されます。"
     "2番目の値は下記のようなものが返却されます。" EOL2 "- " (CODE1 ":internal") "  - もしそのシンボルが内部シンボルとして"
     (STRONG "package") "に現れているとき" EOL2 "- " (CODE1 ":external") "  - もしそのシンボルが外部シンボルとして"
     (STRONG "package") "に現れているとき" EOL2 "- " (CODE1 ":inherited") "  - もしそのシンボルが"
     (STRONG "package") "の" (CODE1 "use-package") "を通して継承されており、" "    しかし"
     (STRONG "package") "内には現れてないとき" EOL2 "もし" (STRONG "package") "にはそのようなシンボルが無かったときは、"
     "両方とも" (CODE1 "nil") "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(find-symbol \"NEVER-BEFORE-USED\") =>  NIL, NIL"
      "(find-symbol \"NEVER-BEFORE-USED\") =>  NIL, NIL"
      "(intern \"NEVER-BEFORE-USED\") =>  NEVER-BEFORE-USED, NIL"
      "(intern \"NEVER-BEFORE-USED\") =>  NEVER-BEFORE-USED, :INTERNAL"
      "(find-symbol \"NEVER-BEFORE-USED\") =>  NEVER-BEFORE-USED, :INTERNAL"
      "(find-symbol \"never-before-used\") =>  NIL, NIL"
      "(find-symbol \"CAR\" 'common-lisp-user) =>  CAR, :INHERITED"
      "(find-symbol \"CAR\" 'common-lisp) =>  CAR, :EXTERNAL"
      "(find-symbol \"NIL\" 'common-lisp-user) =>  NIL, :INHERITED"
      "(find-symbol \"NIL\" 'common-lisp) =>  NIL, :EXTERNAL"
      "(find-symbol \"NIL\" (prog1 (make-package \"JUST-TESTING\" :use '())"
      "                          (intern \"NIL\" \"JUST-TESTING\")))"
      "=>  JUST-TESTING::NIL, :INTERNAL" "(export 'just-testing::nil 'just-testing)"
      "(find-symbol \"NIL\" 'just-testing) =>  JUST-TESTING:NIL, :EXTERNAL"
      "(find-symbol \"NIL\" \"KEYWORD\")" "=>  NIL, NIL" "OR=>  :NIL, :EXTERNAL"
      "(find-symbol (symbol-name :nil) \"KEYWORD\") =>  :NIL, :EXTERNAL"))
    (CHAPTER ("## 副作用") 2 "なし。")
    (CHAPTER ("## 影響") 2 (CODE1 "intern") "," (CODE1 "import") "," (CODE1 "export") ","
     (CODE1 "use-package") "," (CODE1 "unintern") "," (CODE1 "unexport") ","
     (CODE1 "unuse-package"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "intern") "," (CODE1 "find-all-symbols"))
    (CHAPTER ("## 備考") 2 (CODE1 "find-symbol") "は操作としては" (CODE1 "intern") "と同等ですが、"
     "新しいシンボルを決して生成しない所が違っています。")))
(setf (gethash '("FIND-SYMBOL" . "FUNCTION") *table*) (gethash "FIND-SYMBOL" *table*))
(setf (gethash "FINISH-OUTPUT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FINISH-OUTPUT") ", " (CODE1 "FORCE-OUTPUT") ", "
     (CODE1 "CLEAR-OUTPUT"))
    (CHAPTER ("## 構文") 2 (CODE1 "finish-output") " " (CODE1 "&optional") " "
     (STRONG "output-stream") " => " (CODE1 "nil") EOL1 (CODE1 "force-output") " "
     (CODE1 "&optional") " " (STRONG "output-stream") " => " (CODE1 "nil") EOL1
     (CODE1 "clear-output") " " (CODE1 "&optional") " " (STRONG "output-stream") " => "
     (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "output-stream") " - 出力ストリーム指定子。デフォルトは標準出力。")
    (CHAPTER ("## 定義") 2 (CODE1 "finish-output") ", " (CODE1 "force-output") ", "
     (CODE1 "clear-output") "は、" "バッファされた出力ストリームの内部状態を制御します。" EOL2
     (CODE1 "finish-output") "は、" "出力バッファの全てを" (STRONG "output-stream") "に送り、"
     "その宛先に届くことを確認しようと試み、" "それから返却が行われます。" EOL2 (CODE1 "force-output") "は、"
     "内部バッファの全てを空にしようと処理を開始しますが、" "完了を待たずに応答の返却を行います。" EOL2 (CODE1 "clear-output") "は、"
     "できるだけ少ない出力が宛先に届くようにするために、" "進行中の実施していない出力操作を中止しようとします。" EOL2 "もしこれらの操作のどれかが"
     (STRONG "output-stream") "に対して" "実施するものがないときは何もしません。" "これらの関数の詳しい動作は実装依存です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; 実装A" "(progn (princ \"am i seen?\") (clear-output))"
      "=>  NIL" NIL ";; 実装B" "(progn (princ \"am i seen?\") (clear-output))"
      ">>  am i seen?" "=>  NIL"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 (CODE1 "*standard-output*"))
    (CHAPTER ("## 例外") 2 (STRONG "output-stream") "がストリーム指定子ではなかったとき、" "型"
     (CODE1 "type-error") "のエラーが通知されるべきです。")
    (CHAPTER ("## 参考") 2 (CODE1 "clear-input")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("FINISH-OUTPUT" . "FUNCTION") *table*) (gethash "FINISH-OUTPUT" *table*))
(setf (gethash "FIRST" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "FIRST") ", " (CODE1 "SECOND") ", " (CODE1 "THIRD")
     ", " (CODE1 "FOURTH") ", " (CODE1 "FIFTH") "," (CODE1 "SIXTH") ", "
     (CODE1 "SEVENTH") ", " (CODE1 "EIGHTH") ", " (CODE1 "NINTH") ", " (CODE1 "TENTH"))
    (CHAPTER ("## 構文") 2 (CODE1 "first") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "second") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "third") " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fourth")
     " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fifth") " "
     (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "sixth") " " (STRONG "list")
     " => " (STRONG "object") EOL1 (CODE1 "seventh") " " (STRONG "list") " => "
     (STRONG "object") EOL1 (CODE1 "eighth") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "ninth") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "tenth") " " (STRONG "list") " => " (STRONG "object") EOL1 "(" (CODE1 "setf")
     " (" (CODE1 "first") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "second") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "third") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "fourth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "fifth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "sixth") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "seventh") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "eighth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "ninth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "tenth") " " (STRONG "list") ") " (STRONG "new-object")
     ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト、ドットリストと循環リストも受け付けます。" EOL1
     (STRONG "object") ", " (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "関数" (CODE1 "first") ", " (CODE1 "second") ", " (CODE1 "third")
     ", " (CODE1 "fourth") ", " (CODE1 "fifth") "," (CODE1 "sixth") ", "
     (CODE1 "seventh") ", " (CODE1 "eighth") ", " (CODE1 "ninth") ", " (CODE1 "tenth")
     "は、" "それぞれリストの1番目、2番目、3番目、4番目、5番目、" "6番目、7番目、8番目、9番目、10番目の要素にアクセスします。"
     "具体的には次のようになります。"
     (CODE3 "```lisp" "```" "(first list)    ==   (car list)"
      "(second list)   ==   (car (cdr list))" "(third list)    ==   (car (cddr list))"
      "(fourth list)   ==   (car (cdddr list))"
      "(fifth list)    ==   (car (cddddr list))"
      "(sixth list)    ==   (car (cdr (cddddr list)))"
      "(seventh list)  ==   (car (cddr (cddddr list)))"
      "(eighth list)   ==   (car (cdddr (cddddr list)))"
      "(ninth list)    ==   (car (cddddr (cddddr list)))"
      "(tenth list)    ==   (car (cdr (cddddr (cddddr list))))")
     EOL2 (CODE1 "setf") "は、これらの関数を使うことによって" "既存の構成要素を変更することもできます。"
     "上記の等価な関係を用いて同じように適用できます。" "例えば次のようになります。"
     (CODE3 "```lisp" "```"
      "(setf (fifth list) new-object) == (setf (car (cddddr list)) new-object)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst '(1 2 3 (4 5 6) ((V)) vi 7 8 9 10)) "
      "=>  (1 2 3 (4 5 6) ((V)) VI 7 8 9 10)" "(first lst) =>  1" "(tenth lst) =>  10"
      "(fifth lst) =>  ((V))" "(second (fourth lst)) =>  5" "(sixth '(1 2 3)) =>  NIL"
      "(setf (fourth lst) \"four\") =>  \"four\""
      "lst =>  (1 2 3 \"four\" ((V)) VI 7 8 9 10)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "car") "," (CODE1 "nth"))
    (CHAPTER ("## 備考") 2 (CODE1 "first") "は機能的には" (CODE1 "car") "と同じです。" (CODE1 "second")
     "は機能的には" (CODE1 "cadr") "と同じです。" (CODE1 "third") "は機能的には" (CODE1 "caddr") "と同じです。"
     (CODE1 "fourth") "は機能的には" (CODE1 "cadddr") "と同じです。" EOL2 "通常の番号付けは1から開始しますが、"
     (CODE1 "nth") "によって使われる採番は0開始であり、" "次の関係が成り立ちます。"
     (CODE3 "```lisp" "```" "(fifth x) == (nth 4 x)"))))
(setf (gethash '("FIRST" . "ACCESSOR") *table*) (gethash "FIRST" *table*))
(setf (gethash "FLET" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "FLET") ", " (CODE1 "LABELS") ", "
     (CODE1 "MACROLET"))
    (CHAPTER ("## 構文") 2 (CODE1 "flet") " ((" (STRONG "function-name") " "
     (STRONG "lambda-list") " [[" (STRONG "local-declaration\\*") " " (CODE1 "|") " "
     (STRONG "local-documentation") "]] " (STRONG "local-form\\*") ")\\*)" " "
     (STRONG "declaration\\*") " " (STRONG "form\\*") EOL1 "=> " (STRONG "result\\*")
     EOL2 (CODE1 "labels") " ((" (STRONG "function-name") " " (STRONG "lambda-list")
     " [[" (STRONG "local-declaration\\*") " " (CODE1 "|") " "
     (STRONG "local-documentation") "]] " (STRONG "local-form\\*") ")\\*)" " "
     (STRONG "declaration") " " (STRONG "form\\*") " " (STRONG "declaration\\*") " "
     (STRONG "form\\*") EOL1 "=> " (STRONG "result\\*") EOL2 (CODE1 "macrolet") " (("
     (STRONG "name") " " (STRONG "lambda-list") " [[" (STRONG "local-declaration\\*") " "
     (CODE1 "|") " " (STRONG "local-documentation") "]] " (STRONG "local-form\\*")
     ")\\*)" " " (STRONG "declaration\\*") " " (STRONG "form\\*") EOL1 "=> "
     (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function-name") " - 関数名" EOL1 (STRONG "name")
     " - シンボル" EOL1 (STRONG "lambda-list") " - ラムダリスト。" (CODE1 "flet") "と"
     (CODE1 "labels") "は通常のラムダリスト。" (CODE1 "macrolet") "はマクロラムダリスト。" EOL1
     (STRONG "local-declaration") " - 宣言式。評価されません。" EOL1 (STRONG "declaration")
     " - 宣言式。評価されません。" EOL1 (STRONG "local-documentation") " - 文字列。評価されません。" EOL1
     (STRONG "local-form") ", " (STRONG "form") " - 暗黙のprogn" EOL1 (STRONG "result")
     " - " (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "flet") "、" (CODE1 "labels") "、" (CODE1 "macrolet") "は、"
     "ローカル関数とローカルマクロを定義し、" "そのローカルな定義を使い" (STRONG "form") "を実行します。" (STRONG "form")
     "は、現れた順に実行します。" EOL2 (CODE1 "flet") "と" (CODE1 "labels") "によって作成された各関数と、"
     (CODE1 "macrolet") "によって作成された各マクロの" "それぞれのボディ部の" (STRONG "form") "（ただしラムダリストは除く）は、"
     "必要に応じて、" (STRONG "function-name") "の関数の" (CODE1 "block") "名か" (STRONG "name")
     "を用いて、" "暗黙の" (CODE1 "block") "に囲まれます。" EOL2 "ローカル関数とマクロの定義部のリストと、" (CODE1 "flet")
     "および" (CODE1 "labels") "のボディ部" (STRONG "form") "間における" (STRONG "declaration")
     "のスコープは、" "ローカルの関数定義の本体が含まれません。" "ただし例外は" (CODE1 "labels") "の、" (CODE1 "inline") "、"
     (CODE1 "notinline") "、" (CODE1 "ftype") "宣言であり、" "これらはローカルの関数定義を参照し、"
     "そのローカル関数の本体に適用します。" "つまり、これらの宣言のスコープは、" "関数名として影響を与える範囲と同じです。" "これらの"
     (STRONG "declaration") "のスコープには、" (CODE1 "macrolet") "で定義されたマクロ展開数の本体は含まれません。" EOL2
     "- " (CODE1 "flet") "  - " (CODE1 "flet") "は、ローカルに名前がある関数を定義し、"
     "    それらの定義を束縛とともに一連の" (STRONG "form") "を実行します。" "    そのようなローカル関数はいくつでも定義できます。"
     "    <br><br>" "    名前が束縛されたスコープは、ただボディ部のみ含まれます。" "    " (CODE1 "flet") "のボディ部内では、"
     "    " (CODE1 "flet") "によって定義された" (STRONG "function-name") "という名前は、"
     "    同名のグローバルに宣言されたものではなく、" "    ローカルに宣言された関数が参照されます。" "    " (CODE1 "flet")
     "のスコープ内では、" "    " (CODE1 "flet") "によって定義されている" "    " (STRONG "function-name")
     "という名前の、" "    グローバルのsetf-expanderの定義は適用されません。" "    これは、"
     (CODE1 "(defmethod (setf f) ...)") "ではなく、" "    " (CODE1 "(defsetf f ...)")
     "に適用されることに注意してください。" "    <br><br>" "    " (CODE1 "flet")
     "によって定義された関数名は、レキシカルな環境内のものであり、" "    それらのローカルな定義は、ただ" (CODE1 "flet")
     "本体内でのみ保持されます。" "    関数定義の束縛は、" (CODE1 "flet") "本体でのみ見ることができ、"
     "    それらの定義自身では見ることができません。" "    関数定義内において、" "    ローカルの関数名で定義されているものを探すときは、" "    "
     (CODE1 "flet") "の外側で定義された関数かマクロが参照されます。" "    " (CODE1 "flet")
     "は、局所的にグローバル関数名を隠蔽することができ、" "    その新しい定義は、グローバルな定義を参照することができます。" "    <br><br>"
     "    どんな" (STRONG "local-documentation") "も、" "    対応するローカル関数（もし実際に作成されたとき）に、"
     "    ドキュメント文字として割り当てます。" "    <br><br>" EOL2 "- " (CODE1 "labels") "  - "
     (CODE1 "labels") "は、" (CODE1 "flet") "と同じですが、" "    " (CODE1 "labels")
     "の場合は定義された関数名のスコープが、" "    ボディ部と同じように関数定義自身にも囲まれるところが違っています。" "    <br><br>" EOL2
     "- " (CODE1 "macrolet") "  - " (CODE1 "macrolet") "は、" (CODE1 "defmacro")
     "と同じフォーマットで、" "    ローカルマクロの定義を確立します。" "    <br><br>" "    " (CODE1 "macrolet")
     "の内部では、" "    " (CODE1 "macrolet") "によって定義されている" "    " (STRONG "function-name")
     "という名前の、" "    グローバルのsetf-expanderの定義は適用されません。" "    そうではなく、" (CODE1 "setf")
     "はマクロフォームを展開し、" "    結果のフォームを再帰的に処理します。" "    <br><br>" "    " (CODE1 "macrolet")
     "によって定義されたマクロ展開関数は、" "    " (CODE1 "macrolet") "のフォームに現れる、"
     "    レキシカルな環境によって定義されたものです。" "    宣言と、" (CODE1 "macrolet") "と"
     (CODE1 "symbol-macrolet") "の定義は、" "    " (CODE1 "macrolet") "内の、ローカルマクロ定義に影響を及ぼします。"
     "    しかしもしローカルマクロ定義から" "    レキシカルな環境内で見ることができる" "    ローカルな変数か関数を参照したときの結果は未定義です。"
     "    <br><br>" "    どんな" (STRONG "local-documentation") "も、" "    対応するローカルマクロ関数に、"
     "    ドキュメント文字として割り当てます。" "    <br><br>")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun foo (x flag)" "  (macrolet ((fudge (z)"
      "                ; パラメーターxとflagはこの時点ではアクセス不可です。"
      "                ; flagの参照はグローバル変数の名前になります。"
      "                ` (if flag (* ,z ,z) ,z)))" "   ; パラメーターxとflagは、ここではアクセス可能です。"
      "    (+ x" "       (fudge x)" "       (fudge (+ x 1)))))" "== "
      "(defun foo (x flag)" "  (+ x" "     (if flag (* x x) x)"
      "     (if flag (* (+ x 1) (+ x 1)) (+ x 1))))")
     EOL2 "これは、マクロ展開が行われた後です。" (CODE1 "x") "と" (CODE1 "flag") "の発生は、" "関数" (CODE1 "foo")
     "のパラメータを合法的に参照しています。" "なぜなら、これらのパラメータは、" "マクロが呼ばれて展開が生成された場所では" "見ることができるからです。"
     (CODE3 "```lisp" "```" "(flet ((flet1 (n) (+ n n)))"
      "   (flet ((flet1 (n) (+ 2 (flet1 n))))" "     (flet1 2))) =>  6" NIL
      "(defun dummy-function () 'top-level) =>  DUMMY-FUNCTION "
      "(funcall #'dummy-function) =>  TOP-LEVEL " "(flet ((dummy-function () 'shadow)) "
      "     (funcall #'dummy-function)) =>  SHADOW "
      "(eq (funcall #'dummy-function) (funcall 'dummy-function))" "=>  true "
      "(flet ((dummy-function () 'shadow))" "  (eq (funcall #'dummy-function)"
      "      (funcall 'dummy-function)))" "=>  false " NIL "(defun recursive-times (k n)"
      "  (labels ((temp (n) " "             (if (zerop n) 0 (+ k (temp (1- n))))))"
      "    (temp n))) =>  RECURSIVE-TIMES" "(recursive-times 2 3) =>  6" NIL
      "(defmacro mlets (x &environment env) " "   (let ((form `(babbit ,x)))"
      "     (macroexpand form env))) =>  MLETS"
      "(macrolet ((babbit (z) `(+ ,z ,z))) (mlets 5)) =>  10"
      "(flet ((safesqrt (x) (sqrt (abs x))))" " ;; `safesqrt`関数は、二か所で使用されます。"
      "  (safesqrt (apply #'+ (map 'list #'safesqrt '(1 2 3 4 5 6)))))" "=>  3.291173"
      "(defun integer-power (n k)     " "  (declare (integer n))         "
      "  (declare (type (integer 0 *) k))" "  (labels ((expt0 (x k a)"
      "             (declare (integer x a) (type (integer 0 *) k))"
      "             (cond ((zerop k) a)"
      "                   ((evenp k) (expt1 (* x x) (floor k 2) a))"
      "                   (t (expt0 (* x x) (floor k 2) (* x a)))))"
      "           (expt1 (x k a)"
      "             (declare (integer x a) (type (integer 0 *) k))"
      "             (cond ((evenp k) (expt1 (* x x) (floor k 2) a))"
      "                   (t (expt0 (* x x) (floor k 2) (* x a))))))"
      "   (expt0 n k 1))) =>  INTEGER-POWER" "(defun example (y l)"
      "  (flet ((attach (x)" "           (setq l (append l (list x)))))"
      "    (declare (inline attach))" "    (dolist (x y)" "      (unless (null (cdr x))"
      "        (attach x)))" "    l))" NIL
      "(example '((a apple apricot) (b banana) (c cherry) (d) (e))"
      "         '((1) (2) (3) (4 2) (5) (6 3 2)))"
      "=>  ((1) (2) (3) (4 2) (5) (6 3 2) (A APPLE APRICOT) (B BANANA) (C CHERRY))"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "declare") "," (CODE1 "defmacro") "," (CODE1 "defun") ","
     (CODE1 "documentation") "," (CODE1 "let") "," "3.1. 評価,"
     "3.4.11. ドキュメント文字と宣言の文脈的な作用")
    (CHAPTER ("## 備考") 2 (CODE1 "flet") "では、再帰関数を定義することはできません。" (CODE1 "labels")
     "は、互いに再帰呼出できる関数を定義するのに使うことができます。" EOL2 "もし" (CODE1 "macrolet") "がトップレベルフォームのとき、"
     "ボディ部" (STRONG "form") "もまたトップレベルフォームとして処理されます。" "3.2.3. ファイルのコンパイルをご確認ください。")))
(setf (gethash '("FLET" . "SPECIAL-OPERATOR") *table*) (gethash "FLET" *table*))
(setf (gethash "FMAKUNBOUND" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FMAKUNBOUND"))
    (CHAPTER ("## 構文") 2 (CODE1 "fmakunbound") " " (STRONG "name") " => "
     (STRONG "name"))
    (CHAPTER ("## 発音") 2 "[,ef'makuhn,band] or [,ef'maykuhn,band]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - 関数名")
    (CHAPTER ("## 定義") 2 "グローバル環境での" (STRONG "name") "の関数かマクロの定義を削除します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun add-some (x) (+ x 19)) =>  ADD-SOME"
      "(fboundp 'add-some) =>  true" "(flet ((add-some (x) (+ x 37)))"
      "   (fmakunbound 'add-some)" "   (add-some 1)) =>  38"
      "(fboundp 'add-some) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "name") "が関数名でないとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。" EOL2 (STRONG "name") "が特殊オペレーターのときの結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "fboundp") "," (CODE1 "makunbound"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("FMAKUNBOUND" . "FUNCTION") *table*) (gethash "FMAKUNBOUND" *table*))
(setf (gethash "FORCE-OUTPUT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FINISH-OUTPUT") ", " (CODE1 "FORCE-OUTPUT") ", "
     (CODE1 "CLEAR-OUTPUT"))
    (CHAPTER ("## 構文") 2 (CODE1 "finish-output") " " (CODE1 "&optional") " "
     (STRONG "output-stream") " => " (CODE1 "nil") EOL1 (CODE1 "force-output") " "
     (CODE1 "&optional") " " (STRONG "output-stream") " => " (CODE1 "nil") EOL1
     (CODE1 "clear-output") " " (CODE1 "&optional") " " (STRONG "output-stream") " => "
     (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "output-stream") " - 出力ストリーム指定子。デフォルトは標準出力。")
    (CHAPTER ("## 定義") 2 (CODE1 "finish-output") ", " (CODE1 "force-output") ", "
     (CODE1 "clear-output") "は、" "バッファされた出力ストリームの内部状態を制御します。" EOL2
     (CODE1 "finish-output") "は、" "出力バッファの全てを" (STRONG "output-stream") "に送り、"
     "その宛先に届くことを確認しようと試み、" "それから返却が行われます。" EOL2 (CODE1 "force-output") "は、"
     "内部バッファの全てを空にしようと処理を開始しますが、" "完了を待たずに応答の返却を行います。" EOL2 (CODE1 "clear-output") "は、"
     "できるだけ少ない出力が宛先に届くようにするために、" "進行中の実施していない出力操作を中止しようとします。" EOL2 "もしこれらの操作のどれかが"
     (STRONG "output-stream") "に対して" "実施するものがないときは何もしません。" "これらの関数の詳しい動作は実装依存です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; 実装A" "(progn (princ \"am i seen?\") (clear-output))"
      "=>  NIL" NIL ";; 実装B" "(progn (princ \"am i seen?\") (clear-output))"
      ">>  am i seen?" "=>  NIL"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 (CODE1 "*standard-output*"))
    (CHAPTER ("## 例外") 2 (STRONG "output-stream") "がストリーム指定子ではなかったとき、" "型"
     (CODE1 "type-error") "のエラーが通知されるべきです。")
    (CHAPTER ("## 参考") 2 (CODE1 "clear-input")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("FORCE-OUTPUT" . "FUNCTION") *table*) (gethash "FORCE-OUTPUT" *table*))
(setf (gethash "FORMATTER" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "FORMATTER"))
    (CHAPTER ("## 構文") 2 (CODE1 "formatter") " " (STRONG "control-string") " => "
     (STRONG "function"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "control-string") " - " (CODE1 "format")
     "文字列。評価されません。" EOL1 (STRONG "function") " - 関数")
    (CHAPTER ("## 定義") 2 "次の式と同等の動作をする関数を返却します。"
     (CODE3 "```lisp" "```" "#'(lambda (*standard-output* &rest arguments)"
      "    (apply #'format t control-string arguments)" "    arguments-tail)")
     EOL2 "ここで" (STRONG "arguments-tail") "とは、" "もし" (STRONG "control-string") "にいくつかの"
     (CODE1 "format") "指示があるとき" "次に処理される引数が" (CODE1 "car") "になる引数の末尾か、"
     "あるいはもっとも最近に処理された引数のあとに" "もう引数がない場合は" (CODE1 "nil") "です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(funcall (formatter \"~&~A~A\") *standard-output* 'a 'b 'c)"
      ">>  AB" "=>  (C)" NIL "(format t (formatter \"~&~A~A\") 'a 'b 'c)" ">>  AB"
      "=>  NIL"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "引数が有効な" (CODE1 "format") "文字列ではないとき、" "（マクロ展開時か実行時かにおいて）"
     "エラーが通知されるかもしれません。")
    (CHAPTER ("## 参考") 2 (CODE1 "format")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("FORMATTER" . "MACRO") *table*) (gethash "FORMATTER" *table*))
(setf (gethash "FOURTH" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "FIRST") ", " (CODE1 "SECOND") ", " (CODE1 "THIRD")
     ", " (CODE1 "FOURTH") ", " (CODE1 "FIFTH") "," (CODE1 "SIXTH") ", "
     (CODE1 "SEVENTH") ", " (CODE1 "EIGHTH") ", " (CODE1 "NINTH") ", " (CODE1 "TENTH"))
    (CHAPTER ("## 構文") 2 (CODE1 "first") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "second") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "third") " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fourth")
     " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fifth") " "
     (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "sixth") " " (STRONG "list")
     " => " (STRONG "object") EOL1 (CODE1 "seventh") " " (STRONG "list") " => "
     (STRONG "object") EOL1 (CODE1 "eighth") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "ninth") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "tenth") " " (STRONG "list") " => " (STRONG "object") EOL1 "(" (CODE1 "setf")
     " (" (CODE1 "first") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "second") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "third") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "fourth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "fifth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "sixth") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "seventh") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "eighth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "ninth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "tenth") " " (STRONG "list") ") " (STRONG "new-object")
     ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト、ドットリストと循環リストも受け付けます。" EOL1
     (STRONG "object") ", " (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "関数" (CODE1 "first") ", " (CODE1 "second") ", " (CODE1 "third")
     ", " (CODE1 "fourth") ", " (CODE1 "fifth") "," (CODE1 "sixth") ", "
     (CODE1 "seventh") ", " (CODE1 "eighth") ", " (CODE1 "ninth") ", " (CODE1 "tenth")
     "は、" "それぞれリストの1番目、2番目、3番目、4番目、5番目、" "6番目、7番目、8番目、9番目、10番目の要素にアクセスします。"
     "具体的には次のようになります。"
     (CODE3 "```lisp" "```" "(first list)    ==   (car list)"
      "(second list)   ==   (car (cdr list))" "(third list)    ==   (car (cddr list))"
      "(fourth list)   ==   (car (cdddr list))"
      "(fifth list)    ==   (car (cddddr list))"
      "(sixth list)    ==   (car (cdr (cddddr list)))"
      "(seventh list)  ==   (car (cddr (cddddr list)))"
      "(eighth list)   ==   (car (cdddr (cddddr list)))"
      "(ninth list)    ==   (car (cddddr (cddddr list)))"
      "(tenth list)    ==   (car (cdr (cddddr (cddddr list))))")
     EOL2 (CODE1 "setf") "は、これらの関数を使うことによって" "既存の構成要素を変更することもできます。"
     "上記の等価な関係を用いて同じように適用できます。" "例えば次のようになります。"
     (CODE3 "```lisp" "```"
      "(setf (fifth list) new-object) == (setf (car (cddddr list)) new-object)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst '(1 2 3 (4 5 6) ((V)) vi 7 8 9 10)) "
      "=>  (1 2 3 (4 5 6) ((V)) VI 7 8 9 10)" "(first lst) =>  1" "(tenth lst) =>  10"
      "(fifth lst) =>  ((V))" "(second (fourth lst)) =>  5" "(sixth '(1 2 3)) =>  NIL"
      "(setf (fourth lst) \"four\") =>  \"four\""
      "lst =>  (1 2 3 \"four\" ((V)) VI 7 8 9 10)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "car") "," (CODE1 "nth"))
    (CHAPTER ("## 備考") 2 (CODE1 "first") "は機能的には" (CODE1 "car") "と同じです。" (CODE1 "second")
     "は機能的には" (CODE1 "cadr") "と同じです。" (CODE1 "third") "は機能的には" (CODE1 "caddr") "と同じです。"
     (CODE1 "fourth") "は機能的には" (CODE1 "cadddr") "と同じです。" EOL2 "通常の番号付けは1から開始しますが、"
     (CODE1 "nth") "によって使われる採番は0開始であり、" "次の関係が成り立ちます。"
     (CODE3 "```lisp" "```" "(fifth x) == (nth 4 x)"))))
(setf (gethash '("FOURTH" . "ACCESSOR") *table*) (gethash "FOURTH" *table*))
(setf (gethash "FRESH-LINE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "TERPRI") ", " (CODE1 "FRESH-LINE"))
    (CHAPTER ("## 構文") 2 (CODE1 "terpri") " " (CODE1 "&optional") " "
     (STRONG "output-stream") " => " (CODE1 "nil") EOL1 (CODE1 "fresh-line") " "
     (CODE1 "&optional") " " (STRONG "output-stream") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "output-stream") " - 出力ストリーム指定子。標準は標準出力。" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "terpri") "は、" (STRONG "output-stream") "に改行"
     (CODE1 "newline") "を出力します。" EOL2 (CODE1 "fresh-line") "は" (CODE1 "terpri")
     "と似ていますが、" "もし" (STRONG "output-stream") "が行の始まりに位置していないときのみ" "改行" (CODE1 "newline")
     "を出力します。" "何らかの理由でこのような状況が決定できないときは、" "改行" (CODE1 "newline") "は常に出力します。"
     (CODE1 "fresh-line") "は、改行" (CODE1 "newline") "が出力されたとき" (STRONG "true") "を返却し、"
     "それ以外のときは" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-output-to-string (s)"
      "   (write-string \"some text\" s)" "   (terpri s)" "   (terpri s)"
      "   (write-string \"more text\" s))" "=>  \"some text" NIL "more text\""
      "(with-output-to-string (s)" "   (write-string \"some text\" s)"
      "   (fresh-line s)" "   (fresh-line s)" "   (write-string \"more text\" s))"
      "=>  \"some text" "more text\""))
    (CHAPTER ("## 副作用") 2 (STRONG "output-stream") "は修正されます。")
    (CHAPTER ("## 影響") 2 (CODE1 "*standard-output*") "," (CODE1 "*terminal-io*"))
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 (CODE1 "terpri") "の効果は下記の同等です。"
     (CODE3 "```lisp" "```" "(write-char #\\Newline output-stream)"))))
(setf (gethash '("FRESH-LINE" . "FUNCTION") *table*) (gethash "FRESH-LINE" *table*))
(setf (gethash "FTYPE" *table*)
  '((CHAPTER NIL 0 "Declaration " (CODE1 "FTYPE"))
    (CHAPTER ("## 構文") 2 "(" (CODE1 "ftype") " " (STRONG "type") " "
     (STRONG "function-name\\*") ")")
    (CHAPTER ("## 引数") 2 (STRONG "function-name") " - 関数名" EOL1 (STRONG "type")
     " - 型指定子")
    (CHAPTER ("## 有効な文脈") 2 (CODE1 "declare") "と" (CODE1 "proclaim"))
    (CHAPTER ("## 影響する束縛の型") 2 "関数")
    (CHAPTER ("## 定義") 2 (STRONG "function-name") "という名前の関数に対して、関数の型" (STRONG "type")
     "を指定します。" "例えば下記の通り。"
     (CODE3 "```lisp" "```" "(declare (ftype (function (integer list) t) ith)"
      "         (ftype (function (number) float) sine cosine))")
     EOL2 "もしあるひとつの関数が宣言されており、" "その関数がレキシカルにローカル定義を持っているとき" "（" (CODE1 "flet") "か"
     (CODE1 "labels") "によって作成されたもの）、" "その宣言はグローバル関数定義ではなく、ローカルの関数定義に適用されます。"
     (CODE1 "ftype") "宣言は変数の束縛には適用しません" "（" (CODE1 "type") "をご確認ください）。" EOL2
     (STRONG "function-name") "のレキシカルな束縛に現れたものは、" "マクロ定義には適用しません" "（これは" (CODE1 "ftype")
     "が各関数名の関数定義について" (CODE1 "function") "の特定のサブタイプを宣言するからであり、"
     "マクロはそのような関数を表すものではないためです）。" EOL2 (CODE1 "ftype") "宣言は、自由宣言と境界宣言のどちらも使えます。"
     (CODE1 "flet") "か" (CODE1 "labels") "フォーム本体の前に現れた" "関数の" (CODE1 "ftype") "宣言は、"
     "関数の境界宣言として定義されます。" "その他の文脈の宣言は自由宣言です。")
    (CHAPTER ("## 参考") 2 (CODE1 "declare") "," (CODE1 "declaim") "," (CODE1 "proclaim"))))
(setf (gethash '("FTYPE" . "DECLARATION") *table*) (gethash "FTYPE" *table*))
(setf (gethash "FUNCALL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FUNCALL"))
    (CHAPTER ("## 構文") 2 (CODE1 "funcall") " " (STRONG "function") " &rest "
     (STRONG "args") " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function") " - 関数指定子" EOL1 (STRONG "args") " - "
     (STRONG "function") "の引数" EOL1 (STRONG "result") " - " (STRONG "function") "の返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "funcall") "は、" (STRONG "args") "を引数に"
     (STRONG "function") "を実行します。" "もし" (STRONG "function") "がシンボルなら、"
     (STRONG "function") "をグローバル環境下の関数の値として探したものを" "強制的に変換します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(funcall #'+ 1 2 3) =>  6" "(funcall 'car '(1 2 3)) =>  1"
      "(funcall 'position 1 '(1 2 3 2 1) :start 1) =>  4" "(cons 1 2) =>  (1 . 2)"
      "(flet ((cons (x y) `(kons ,x ,y)))" "  (let ((cons (symbol-function '+)))"
      "    (funcall #'cons" "             (funcall 'cons 1 2)"
      "             (funcall cons 1 2))))" "=>  (KONS (1 . 2) 3)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "function") "がシンボルであり、" "それがグローバル定義の関数を持たなかったときか、"
     "あるいはグローバルなマクロか特殊オペレーターであったときは、" "型" (CODE1 "undefined-function") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "apply") "," (CODE1 "function") "," "3.1. 評価")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(funcall function arg1 arg2 ...)"
      "==  (apply function arg1 arg2 ... nil)"
      "==  (apply function (list arg1 arg2 ...))")
     EOL2 (CODE1 "funcall") "と通常の関数呼び出しの違いは、" "前者はフォームの通常の評価によって" (STRONG "function")
     "を取得しますが、" "後者は普通に起こる関数の位置の特別な解釈によって得られます。")))
(setf (gethash '("FUNCALL" . "FUNCTION") *table*) (gethash "FUNCALL" *table*))
(setf (gethash "FUNCTION" *table*)
  '("FUNCTION SPECIAL-OPERATOR" EOL1 "FUNCTION SYSTEM-CLASS" EOL1))
(setf (gethash '("FUNCTION" . "SPECIAL-OPERATOR") *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "FUNCTION"))
    (CHAPTER ("## 構文") 2 (CODE1 "function") " " (STRONG "name") " => "
     (STRONG "function"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - 関数名か、ラムダ式" EOL1 (STRONG "function")
     " - 関数オブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "function") "の値は、" "現在のレキシカルな環境における、" (STRONG "name")
     "の関数値です。" EOL2 "もし" (STRONG "name") "が関数名のとき、その名前の関数定義は、" (CODE1 "flet") "、"
     (CODE1 "labels") "、" (CODE1 "macrolet") "で囲まれた" "レキシカルな内部に確立されたものがもしあるのであれば、"
     "それが対応します。" "そうではないときは、その関数名のグローバルな関数定義が返却されます。" EOL2 "もし" (STRONG "name")
     "がラムダ式のとき、レキシカルクロージャーが返却されます。" "同じ束縛の集合のクロージャーが複数生成されるような状況では、" "それぞれの生成されたクロージャーは"
     (CODE1 "eq") "になるかもしれませんし、ならないかもしれません。" EOL2 (CODE1 "function")
     "フォームが現れるレキシカルな環境において、" "対応する関数が存在しない" (STRONG "function-name") "を"
     (CODE1 "function") "で使用した時はエラーが発生します。" "とくに、マクロか特殊フォームを示すシンボルを" (CODE1 "function")
     "で使用した時はエラーになります。" "実装は、パフォーマンスの理由からこのエラーを通知しないことを選択できますが、"
     "しかし使いやすいからと言ってエラー通知を怠るように定義することは許されません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun adder (x) (function (lambda (y) (+ x y))))") EOL2
     (CODE1 "(adder 3)") "の結果は、" (CODE1 "3") "と引数を加算する関数です。"
     (CODE3 "```lisp" "```" "(setq add3 (adder 3))" "(funcall add3 5) =>  8") EOL2
     "これが動作する理由は、" (CODE1 "function") "がラムダ式のクロージャーを生成しているからであり、" "制御が関数" (CODE1 "addr")
     "から返却された後でさえ、" "変数" (CODE1 "x") "の値" (CODE1 "3") "を参照することができます。")
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "defun") "," (CODE1 "fdefinition") "," (CODE1 "flet") ","
     (CODE1 "labels") "," (CODE1 "symbol-function") "," "3.1.2.1.1. フォームとしてのシンボル,"
     "2.4.8.2. シャープサイン シングルクォート," "22.1.3.13. 他のオブジェクトの印字")
    (CHAPTER ("## 備考") 2 (CODE1 "#'name") "という表記が、" (CODE1 "(function name)")
     "の略語として使われます。")))
(setf (gethash '("FUNCTION" . "SYSTEM-CLASS") *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "FUNCTION"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "function") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "関数" (CODE1 "function") "とは、適切な数の引数を供給することで"
     "実行されるコードを表現したオブジェクトです。" "関数は、" (CODE1 "function") " 特殊フォームか、" "関数への"
     (CODE1 "coerce") "か、" "関数への" (CODE1 "compile") "によって生成されます。" "関数は、"
     (CODE1 "funcall") "か" (CODE1 "apply") "か" (CODE1 "multiple-value-call") "の"
     "第一引数として使用することによって直接起動できます。")
    (CHAPTER ("## 型指定子の種類") 2 "特定可能")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "function") " [" (STRONG "arg-typespec") " ["
     (STRONG "value-typespec") "]]"
     (CODE3 "```" "```" "arg-typespec ::= (typespec*  "
      "                  [&optional typespec*]  " "                  [&rest typespec]  "
      "                  [&key (keyword typespec)*]) "))
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "typespec") " - 型指定子" EOL1
     (STRONG "value-typespec") " - 型指定子")
    (CHAPTER ("## 型指定子の定義") 2 "リスト形式の" (CODE1 "function") "型指定子は"
     "宣言でのみ使用することができ、区別されません。" "この型の要素は、" (STRONG "arg-typespec")
     "によって指定された関数が受け付ける引数の型と、" (STRONG "value-type") "によって指定された返却値の型の集まりです。"
     "引数の型のリストには、" (CODE1 "&optional") ", " (CODE1 "&rest") ", " (CODE1 "&key") ", "
     (CODE1 "&allow-other-keys") "の印を" "表すことができます。" "この型指定子が提供する" (CODE1 "&rest")
     "は実際の各引数の型を表しており、" "続く変数の型ではありません。" EOL2 (CODE1 "&key") "パラメーターはフォーム"
     (CODE1 "(keyword type)") "のリストとして" "指定されなければなりません。" (STRONG "keyword")
     "は、呼び出しのときの実際の引数とし指定される" "正当なキーワード名のシンボルである必要があります。" "これは通常" (CODE1 "KEYWORD")
     "パッケージ内のシンボルですが、" "どんなシンボルでも指定できます。" (CODE1 "&key") "が" (CODE1 "function")
     "の型指定子のラムダリストに" "与えられたときは、" "その与えられたキーワードパラメーターは" (CODE1 "&allow-other-keys")
     "が現れてないのであれば" "徹底的に調査されます。" (CODE1 "&allow-other-keys") "は、他のキーワード引数が実際に"
     "指定されるかもしれないことを意味しており、" "実際に指定されたときでも使用できます。" "例えば、関数" (CODE1 "make-list")
     "の型は下記のように表すことができます。"
     (CODE3 "```lisp" "```" "(function ((integer 0) &key (:initial-element t)) list)")
     EOL2 (STRONG "value-type") "は、多値の型を示すために、" (CODE1 "values") "型指定子を使うことができます。" EOL2
     "下記の宣言フォームを考えます。"
     (CODE3 "```lisp" "```" "(ftype (function (arg0-type arg1-type ...) val-type) f)")
     EOL2 "この宣言のスコープ内にある" "全ての" (CODE1 "(f arg0 arg1 ...)") "フォームは" "下記と同等になります。"
     (CODE3 "```lisp" "```"
      "(the val-type (f (the arg0-type arg0) (the arg1-type arg1) ...))")
     EOL2 "これは、もし引数のどれかが指定された型と一致していないか、" "返却値が指定した型と一致していなかったときの結果は未定義です。"
     "とくに引数のどれかが正しく型と一致していないときは、" "返却値が指定した型であるという保証はありません。" EOL2 "したがって、関数への"
     (CODE1 "ftype") "宣言は関数呼び出しの記述であり、" "実際の関数定義に対するものではありません。" EOL2 "下記の宣言フォームを考えます。"
     (CODE3 "```lisp" "```"
      "(type (function (arg0-type arg1-type ...) val-type) fn-valued-variable)")
     EOL2 "この宣言の解釈は次のようになります。" "宣言のスコープ内では、もし" (CODE1 "fn-valued-variable") "の値が"
     "指定した型の引数で呼ばれなかったときの結果は未定義です。" "正しく呼び出されたときの返却値の型は" (CODE1 "val-type") "になるでしょう。"
     EOL2 "変数の型宣言がネストされたときは、" "下記のように、暗黙的に型の共通部分が宣言されます。" EOL2 "- 次の2つの" (CODE1 "ftype")
     "宣言を考えます。"
     (CODE3 "```lisp" "```" "(ftype (function (arg0-type1 arg1-type1 ...) val-type1) f)"
      "(ftype (function (arg0-type2 arg1-type2 ...) val-type2) f)")
     EOL2 "もしこれらの宣言の両方に効果があるときは、" "それらの宣言で囲まれた共通部分内では、" (CODE1 "f") "の呼び出しは下記のような"
     (CODE1 "f") "の宣言であるかのように扱われます。"
     (CODE3 "```lisp" "```"
      "(ftype (function ((and arg0-type1 arg0-type2) (and arg1-type1 arg1-type2 ...) ...)"
      "                  (and val-type1 val-type2)) " "       f)")
     EOL2 "これは、ひとつを無視するか、" "あるいは全ての" (CODE1 "ftype") "を有効にするか、" "どちらでも許されます。" EOL2
     "- もし2つ（あるいはもっと）の型宣言が変数に対して効果を持っており、" "それらは両方とも" (CODE1 "function") "の宣言であるとき、"
     "それらの宣言は同じように結び付けられます。")))
(setf (gethash "FUNCTION-KEYWORDS" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "FUNCTION-KEYWORDS"))
    (CHAPTER ("## 構文") 2 (CODE1 "function-keywords") " " (STRONG "method") " => "
     (STRONG "keys") ", " (STRONG "allow-other-keys-p"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "function-keywords") " (" (STRONG "method") " "
     (CODE1 "standard-method") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "method") " - メソッド" EOL1 (STRONG "keys") " - リスト"
     EOL1 (STRONG "allow-other-keys-p") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "メソッドのキーワードパラメーター指定子を返却します。" EOL2 "返却値は2つあります。"
     "第一返却値は暗に名付けられたキーワードのリストであり、" "第二返却値はメソッド定義時に" (CODE1 "&allow-other-keys")
     "の指定があったかどうかの" "ブール値です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defmethod gf1 ((a integer) &optional (b 2)"
      "                &key (c 3) ((:dee d) 4) e ((eff f)))" "  (list a b c d e f))"
      "=>  #<STANDARD-METHOD GF1 (INTEGER) 36324653>"
      "(find-method #'gf1 '() (list (find-class 'integer))) "
      "=>  #<STANDARD-METHOD GF1 (INTEGER) 36324653>" "(function-keywords *)"
      "=>  (:C :DEE :E EFF), false" "(defmethod gf2 ((a integer))"
      "  (list a b c d e f))" "=>  #<STANDARD-METHOD GF2 (INTEGER) 42701775>"
      "(function-keywords (find-method #'gf1 '() (list (find-class 'integer))))"
      "=>  (), false" "(defmethod gf3 ((a integer) &key b c d &allow-other-keys)"
      "  (list a b c d e f))" "(function-keywords *)" "=>  (:B :C :D), true"))
    (CHAPTER ("## 影響") 2 (CODE1 "defmethod")) (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "defmethod")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("FUNCTION-KEYWORDS" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "FUNCTION-KEYWORDS" *table*))
(setf (gethash "FUNCTION-LAMBDA-EXPRESSION" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FUNCTION-LAMBDA-EXPRESSION"))
    (CHAPTER ("## 構文") 2 (CODE1 "function-lambda-expression") " " (STRONG "function")
     EOL1 "=> " (STRONG "lambda-expression") ", " (STRONG "closure-p") ", "
     (STRONG "name"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function") " - 関数" EOL1
     (STRONG "lambda-expression") " - ラムダ式か、" (CODE1 "nil") EOL1 (STRONG "closure-p")
     " - generalized-boolean" EOL1 (STRONG "name") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "下記に示すような、" (STRONG "function") "の情報を返却します。" EOL2 "第一返却値である"
     (STRONG "lambda-expression") "は、" (STRONG "function") "が定義されたラムダ式か、"
     "もし情報が利用できないときは" (CODE1 "nil") "です。" "ラムダ式は何らかの方法で前処理されているかもしれませんが、" "しかし"
     (CODE1 "compile") "や" (CODE1 "function") "の引数としては" "適切のままであるべきです。" "実装は、どんな"
     (STRONG "function") "の" (STRONG "lambda-expression") "でも" (CODE1 "nil")
     "を返却するのは正当です。" EOL2 "第二返却値の" (STRONG "closure-p") "は、" (STRONG "function") "の定義が"
     (CODE1 "null") "のレキシカルな環境で囲まれていたか、" "あるいは" (STRONG "function") "の定義が何らかの非"
     (CODE1 "null") "のレキシカルな環境で囲まれた" "非" (CODE1 "nil") "の環境下であれば、" (CODE1 "nil")
     "が返却されます" "（注釈：非" (CODE1 "null") "のレキシカルな環境とは、" "グローバル環境から何の追加情報もないレキシカルな環境のことです）。"
     "実装は、どんな" (STRONG "function") "の" (STRONG "closure-p") "でも、" (STRONG "true")
     "を返却するのは正当です。" EOL2 "第三返却値" (STRONG "name") "は、関数の名前です。" "名前はデバッグ時にのみ使われ、" "それは、例えば"
     (CODE1 "defun") "や" (CODE1 "function") "の" "名前として使われるのに有効である必要はありません。" "慣例として、"
     (CODE1 "nil") "は" (STRONG "function") "が名前を持たないことを意味します。" "実装は、どんな"
     (STRONG "function") "の" (STRONG "name") "でも、" (CODE1 "nil") "を返却するのは正当です。")
    (CHAPTER ("## 例文") 2 "下記の例はいくつか可能性のある返却値を示していますが、" "しかし全てを網羅することを意図してはいません。"
     (CODE3 "```lisp" "```" "(function-lambda-expression #'(lambda (x) x))"
      "=>  NIL, false, NIL" "OR=>  NIL, true, NIL" "OR=>  (LAMBDA (X) X), true, NIL"
      "OR=>  (LAMBDA (X) X), false, NIL" NIL "(function-lambda-expression"
      "   (funcall #'(lambda () #'(lambda (x) x))))" "=>  NIL, false, NIL"
      "OR=>  NIL, true, NIL" "OR=>  (LAMBDA (X) X), true, NIL"
      "OR=>  (LAMBDA (X) X), false, NIL" " " "(function-lambda-expression "
      "   (funcall #'(lambda (x) #'(lambda () x)) nil))" "=>  NIL, true, NIL"
      "OR=>  (LAMBDA () X), true, NIL" "NOT=>  NIL, false, NIL"
      "NOT=>  (LAMBDA () X), false, NIL" "  " "(flet ((foo (x) x))"
      "  (setf (symbol-function 'bar) #'foo)" "  (function-lambda-expression #'bar))"
      "=>  NIL, false, NIL" "OR=>  NIL, true, NIL"
      "OR=>  (LAMBDA (X) (BLOCK FOO X)), true, NIL"
      "OR=>  (LAMBDA (X) (BLOCK FOO X)), false, FOO"
      "OR=>  (SI::BLOCK-LAMBDA FOO (X) X), false, FOO" " " "(defun foo ()"
      "  (flet ((bar (x) x))" "    #'bar))" "(function-lambda-expression (foo))"
      "=>  NIL, false, NIL" "OR=>  NIL, true, NIL"
      "OR=>  (LAMBDA (X) (BLOCK BAR X)), true, NIL"
      "OR=>  (LAMBDA (X) (BLOCK BAR X)), true, (:INTERNAL FOO 0 BAR)"
      "OR=>  (LAMBDA (X) (BLOCK BAR X)), false, \"BAR in FOO\""))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 "実装は全ての場合において、自由に" (CODE1 "nil, true, nil") "を返却することができますが、"
     (CODE1 "compile") "か" (CODE1 "eval") "の呼び出しによって引数が作成された場合"
     "（コンパイルされたファイルのロードによって生成されたものとは反対に）は、" "第一返却値にラムダ式を返却することが推奨されています。")))
(setf (gethash '("FUNCTION-LAMBDA-EXPRESSION" . "FUNCTION") *table*) (gethash "FUNCTION-LAMBDA-EXPRESSION" *table*))
(setf (gethash "FUNCTIONP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "FUNCTIONP"))
    (CHAPTER ("## 構文") 2 (CODE1 "functionp") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が型" (CODE1 "function") "なら" (STRONG "true")
     "を、" "それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(functionp 'append) =>  false"
      "(functionp #'append) =>  true" "(functionp (symbol-function 'append)) =>  true"
      "(flet ((f () 1)) (functionp #'f)) =>  true"
      "(functionp (compile nil '(lambda () 259))) =>  true" "(functionp nil) =>  false"
      "(functionp 12) =>  false" "(functionp '(lambda (x) (* x x))) =>  false"
      "(functionp #'(lambda (x) (* x x))) =>  true"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(functionp object) == (typep object 'function)"))))
(setf (gethash '("FUNCTIONP" . "FUNCTION") *table*) (gethash "FUNCTIONP" *table*))
(setf (gethash "GENERIC-FUNCTION" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "GENERIC-FUNCTION"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "generic-function") "," (CODE1 "function") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "ジェネリック関数は、" "指定された引数のクラスか同一性に依存した振る舞いを持つ関数のことです。"
     "ジェネリック関数オブジェクトは、" "メソッド、ラムダリスト、" (CODE1 "method-combination") "の型、"
     "そしてその他の情報を含みます。" "メソッドは、クラス指定の振る舞いと、" "メソッドが特定されたジェネリック関数の操作を定義します。"
     "起動したとき、ジェネリック関数は" "その引数のクラスと同一性をもとに集められた" "メソッドの部分集合を実行します。" EOL2
     "ジェネリック関数は通常の関数を使用するかのように" "同じ方法で使うことができます。" "特にジェネリック関数は、" (CODE1 "funcall") "と"
     (CODE1 "apply") "の" "引数としても使用することができ、" "グローバルかローカルの名前としても与えられます。")))
(setf (gethash '("GENERIC-FUNCTION" . "SYSTEM-CLASS") *table*) (gethash "GENERIC-FUNCTION" *table*))
(setf (gethash "GENSYM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "GENSYM"))
    (CHAPTER ("## 構文") 2 (STRONG "gensym") " &optional " (STRONG "x") " => "
     (STRONG "new-symbol"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - 文字列か、非負の整数。" "複雑な動作をするので下記をご確認ください。" EOL1
     (STRONG "new-symbol") " - 新しい、" (CODE1 "unintern") "なシンボル")
    (CHAPTER ("## 定義") 2 (CODE1 "make-symbol") "が呼ばれたかように、" "新しく、" (CODE1 "unintern")
     "なシンボルが作成し返却されます。" "（" (CODE1 "gensym") "と" (CODE1 "make-symbol") "の唯一の違いは、" "どのように"
     (STRONG "new-symbol") "の名前を決めるかです）" EOL2 (STRONG "new-symbol") "の名前は、" "標準では"
     (CODE1 "\"G\"") "のプレフィックスと、" "標準では" (CODE1 "*gensym-counter*") "の値を"
     "10進数の数で表現したサフィックスを、" "順に結合したものになります。" EOL2 "もし" (STRONG "x") "が与えられ、それが文字列のときは、"
     "その" (CODE1 "gensym") "が呼ばれたときのみ、" (CODE1 "\"G\"") "の代わりのプレフィックスとして使われます。" EOL2 "もし"
     (STRONG "x") "が与えられ、それが整数のときは、" "その" (CODE1 "gensym") "が呼ばれたときのみ、"
     (CODE1 "*gensym-counter*") "の値の代わりとして、" "サフィックスの整数値として使われます。" EOL2
     "明にサフィックスが与えられなかった場合は、" "実行後に" (CODE1 "*gensym-counter*") "がインクリメントされます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq sym1 (gensym)) =>  #:G3142"
      "(symbol-package sym1) =>  NIL" "(setq sym2 (gensym 100)) =>  #:G100"
      "(setq sym3 (gensym 100)) =>  #:G100" "(eq sym2 sym3) =>  false"
      "(find-symbol \"G100\") =>  NIL, NIL" "(gensym \"T\") =>  #:T3143"
      "(gensym) =>  #:G3144"))
    (CHAPTER ("## 副作用") 2 (CODE1 "*gensym-counter*") "はインクリメントされるかもしれません。")
    (CHAPTER ("## 影響") 2 (CODE1 "*gensym-counter*"))
    (CHAPTER ("## 例外") 2 "もし" (STRONG "x") "が文字列でも、非負の整数でもなければ、" "型" (CODE1 "type-error")
     "のエラーが発せられます。")
    (CHAPTER ("## 参考") 2 (CODE1 "gentemp") "," (CODE1 "*gensym-counter*"))
    (CHAPTER ("## 備考") 2 (CODE1 "gensym") "の引数に数値を渡す機能は非推奨になり、" "明示的に"
     (CODE1 "*gensym-counter*") "を束縛するのが" "様式上好まれるようになりました。"
     "（オプション引数の多少奇妙な慣習は、本来の歴史的なものであり、" "主に古いLispの方言との互換性のためにサポートされています。"
     "現代のコードでは、引数に文字列のプレフィックスのみを" "使用することが推奨されています。" "しかし、一般的には、" "より柔軟に"
     (STRONG "new-symbol") "の名前を制御したいのであれば、" "代わりに" (CODE1 "make-symbol")
     "の使用を検討してください。）")))
(setf (gethash '("GENSYM" . "FUNCTION") *table*) (gethash "GENSYM" *table*))
(setf (gethash "GENTEMP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "GENTEMP"))
    (CHAPTER ("## 構文") 2 (CODE1 "gentemp") " &optional " (STRONG "prefix") " "
     (STRONG "package") " => " (STRONG "new-symbol"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "prefix") " - 文字列。デフォルトは" (CODE1 "\"T\"") EOL1
     (STRONG "package") " - パッケージ指定子。デフォルトは現在のパッケージ。" EOL1 (STRONG "new-symbol")
     " - 新しい、" (CODE1 "intern") "なシンボル")
    (CHAPTER ("## 定義") 2 (CODE1 "gentemp") "は、指定された" (STRONG "package") "に"
     (CODE1 "intern") "されている新しいシンボルを作成し返却します。" "そのシンボルは、これまで" (STRONG "package") "で"
     "アクセスできなかったものであることが保証されます。" "それは、" (CODE1 "bound") "でも" (CODE1 "fbound") "でもなく、"
     (CODE1 "null") "のプロパティリストを持ちます。" EOL2 (STRONG "new-symbol") "の名前は、"
     (STRONG "prefix") "と、" (CODE1 "gentemp") "によってのみ使用される" "内部のカウンターからなるサフィックスを、"
     "それぞれ結合して作成します。" "（もしその名前のシンボルが" (STRONG "package") "内ですでにアクセス可能の場合は、"
     (STRONG "package") "内でまだアクセスされてないシンボル名を生成するまで、" "カウンターは必要な回数だけインクリメントされます。）")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(gentemp) =>  T1298" "(gentemp \"FOO\") =>  FOO1299"
      "(find-symbol \"FOO1300\") =>  NIL, NIL" "(gentemp \"FOO\") =>  FOO1300"
      "(find-symbol \"FOO1300\") =>  FOO1300, :INTERNAL"
      "(intern \"FOO1301\") =>  FOO1301, :INTERNAL" "(gentemp \"FOO\") =>  FOO1302"
      "(gentemp) =>  T1303"))
    (CHAPTER ("## 副作用") 2 "内部カウンターは、一回かあるいは複数回インクリメントされます。")
    (CHAPTER ("## 影響") 2 "内部カウンターの現在の状態と、" (STRONG "package") "の現在の状態。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "prefix") "が文字列ではないときは、" "型" (CODE1 "type-error")
     "のエラーが発生します。" "もし" (STRONG "package") "がパッケージ指定子ではないときは、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "gensym"))
    (CHAPTER ("## 備考") 2 "関数" (CODE1 "gentemp") "は非推奨です。" EOL2 "もし" (STRONG "package")
     "が" (CODE1 "KEYWORD") "パッケージのときは、" "その結果は" (STRONG "package") "の外部シンボルです。"
     "その他の場合は、" (STRONG "package") "の内部シンボルです。" EOL2 (CODE1 "gentemp") "の内部カウンターは、"
     (CODE1 "gensym") "が使用する" (CODE1 "*gensym-counter*") "カウンターとは独立しています。"
     (CODE1 "gentemp") "の内部カウンターにアクセスする方法はありません。" EOL2 (CODE1 "gentemp")
     "が以前存在しないシンボルを作成したからといって、" "未来にわたってもそのようなシンボルが見えないわけではありません。"
     "（例えばデータファイルでは、違うセッション内の同じプログラムによって、" "作成されるかもしれません。）" "このため、このシンボルは、"
     (CODE1 "gensym") "によって生成されたものと同じような意味で、" "真にユニークであるということではありません。"
     "特に自動でコード生成を行うようなプログラムでは、" "そのように生成されたシンボルに" "グローバルな属性（例えば" (CODE1 "special")
     "宣言）を付与して" "ファイルに書き込まないよう注意する必要があります。" "なぜならそのようなグローバルの属性は、" "違うセッション内においては終わっており、"
     "別の日の、別の目的で自動的に生成された" "別のシンボルに適用されているかもしれないからです。")))
(setf (gethash '("GENTEMP" . "FUNCTION") *table*) (gethash "GENTEMP" *table*))
(setf (gethash "GET" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "GET"))
    (CHAPTER ("## 構文") 2 (CODE1 "get") " " (STRONG "symbol") " " (STRONG "indicator")
     " &optional " (STRONG "default") " => " (STRONG "value") EOL1 "(" (CODE1 "setf")
     " (" (CODE1 "get") " " (STRONG "symbol") " " (STRONG "indicator") " &optional "
     (STRONG "default") ") " (STRONG "new-value") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - シンボル" EOL1 (STRONG "indicator")
     " - オブジェクト" EOL1 (STRONG "default") " - オブジェクト。デフォルトは" (CODE1 "nil") "。" EOL1
     (STRONG "value") " - もしプロパティが存在していたらその値のオブジェクトを、" "それ以外の場合は" (STRONG "default") "。"
     EOL1 (STRONG "new-value") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "get") "は、" (STRONG "symbol") "のプロパティリストから"
     (STRONG "indicator") "と同一の標識のプロパティを探し、" "対応するプロパティの値を返却します。" "標識に対して複数のプロパティがあるときは、"
     (CODE1 "get") "は最初のプロパティを使います。" "標識に対するプロパティが存在しないときは、" (STRONG "default")
     "が返却されます。" EOL2 (CODE1 "get") "の" (CODE1 "setf") "は、" (STRONG "symbol")
     "のプロパティリストに、" "すでに標識が存在するときは、" "新しいオブジェクトを関連付けます。" "もし存在しなかったときは、新しい関連を作成します。"
     "標識に対して複数のプロパティがあるときは、" (CODE1 "get") "の" (CODE1 "setf") "は最初のプロパティに"
     (STRONG "new-value") "を関連付けます。" (CODE1 "get") "フォームを" (CODE1 "setf") "の"
     (CODE1 "place") "で使うとき、" "引数" (STRONG "default") "が通常の左から右へ評価されるルールに従って評価され、"
     (STRONG "value") "は無視されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun make-person (first-name last-name)"
      "  (let ((person (gensym \"PERSON\")))"
      "    (setf (get person 'first-name) first-name)"
      "    (setf (get person 'last-name) last-name)" "    person)) =>  MAKE-PERSON"
      "(defvar *john* (make-person \"John\" \"Dow\")) =>  *JOHN*"
      "*john* =>  #:PERSON4603"
      "(defvar *sally* (make-person \"Sally\" \"Jones\")) =>  *SALLY*"
      "(get *john* 'first-name) =>  \"John\"" "(get *sally* 'last-name) =>  \"Jones\""
      "(defun marry (man woman married-name)" "  (setf (get man 'wife) woman)"
      "  (setf (get woman 'husband) man)" "  (setf (get man 'last-name) married-name)"
      "  (setf (get woman 'last-name) married-name)" "  married-name) =>  MARRY"
      "(marry *john* *sally* \"Dow-Jones\") =>  \"Dow-Jones\""
      "(get *john* 'last-name) =>  \"Dow-Jones\""
      "(get (get *john* 'wife) 'first-name) =>  \"Sally\"" "(symbol-plist *john*)"
      ">  (WIFE #:PERSON4604 LAST-NAME \"Dow-Jones\" FIRST-NAME \"John\")"
      "(defmacro age (person &optional (default ''thirty-something)) "
      "  `(get ,person 'age ,default)) =>  AGE" "(age *john*) =>  THIRTY-SOMETHING"
      "(age *john* 20) =>  20" "(setf (age *john*) 25) =>  25" "(age *john*) =>  25"
      "(age *john* 20) =>  25"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "symbol") "がシンボルではないとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "getf") "," (CODE1 "symbol-plist") "," (CODE1 "remprop"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(get x y) ==  (getf (symbol-plist x) y)") EOL2 (CODE1 "get")
     "は" (STRONG "indicator") "のテストに" (CODE1 "eql") "ではなく" (CODE1 "eq") "を用いるため、"
     "移植しやすいコードとして、" (STRONG "indicator") "に数と文字を使うことは推奨されません。" "そのため、そのような"
     (STRONG "indicator") "を使ったときの効果は" "実装依存です。" EOL2 (CODE1 "get") "を使用して、存在しないプロパティと"
     "値がデフォルトであるプロパティを区別する方法はありません。" "しかし、" (CODE1 "get-properties") "を利用できます。")))
(setf (gethash '("GET" . "ACCESSOR") *table*) (gethash "GET" *table*))
(setf (gethash "GET-OUTPUT-STREAM-STRING" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "GET-OUTPUT-STREAM-STRING"))
    (CHAPTER ("## 構文") 2 (CODE1 "get-output-stream-string") " "
     (CODE1 "string-output-stream") " => " (STRONG "string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string-output-stream") " - ストリーム" EOL1
     (STRONG "string") " - 文字列")
    (CHAPTER ("## 定義") 2 (STRONG "string-output-stream") "に出力された文字を順番に全て含む文字列を返却します。"
     "この操作は" (STRONG "string-output-stream") "上の文字をクリアするので、" (STRONG "string") "には"
     (CODE1 "get-output-stream-string") "が" "最後に呼び出された以降のものか、" "あるいは"
     (STRONG "string-output-stream") "が作成された以降のものから、" "最新のものまでに生じた出力のみが含まれます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq a-stream (make-string-output-stream)"
      "       a-string \"abcdefghijklm\") =>  \"abcdefghijklm\""
      "(write-string a-string a-stream) =>  \"abcdefghijklm\""
      "(get-output-stream-string a-stream) =>  \"abcdefghijklm\""
      "(get-output-stream-string a-stream) =>  \"\""))
    (CHAPTER ("## 副作用") 2 (STRONG "string-output-stream") "はクリアされます。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "string-output-stream") "がクローズされていたときの結果は未定義です。" EOL2
     (STRONG "string-output-stream") "が" (CODE1 "make-string-output-stream") "によって"
     "生成されたものではないときの結果は未定義です。" EOL2 (STRONG "string-output-stream") "が"
     (CODE1 "with-output-to-string") "か" (CODE1 "format") "によって暗黙的に生成されたもののときの結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-string-output-stream")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("GET-OUTPUT-STREAM-STRING" . "FUNCTION") *table*) (gethash "GET-OUTPUT-STREAM-STRING" *table*))
(setf (gethash "GET-PROPERTIES" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "GET-PROPERTIES"))
    (CHAPTER ("## 構文") 2 (CODE1 "get-properties") " " (STRONG "plist") " "
     (STRONG "indicator-list") " => " (STRONG "indicator") ", " (STRONG "value") ", "
     (STRONG "tail"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "plist") " - プロパティリスト" EOL1
     (STRONG "indicator-list") " - 通常のリスト（" (CODE1 "indicator") "のリスト）" EOL1
     (STRONG "indicator") " - オブジェクト、" (STRONG "indicator-list") "の要素" EOL1
     (STRONG "value") " - オブジェクト" EOL1 (STRONG "tail") " - リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "get-properties") "は、複数のプロパティリストのエントリーを"
     "一度にすべて探すために使われます。" EOL2 "それは、" (STRONG "plist") "から" (STRONG "indicator-list")
     "内のオブジェクトのひとつと" "同一な" (CODE1 "indicator") "をもつ、最初のエントリーを探します。"
     "もし、そのようなエントリーが見つかったら、" "返却値の" (STRONG "indicator") "と" (STRONG "value") "は、"
     "それぞれプロパティの値に関連づいたプロパティの" (CODE1 "indicator") "であり、" "返却値" (STRONG "tail")
     "は、エントリーが見つかった" "最初の" (STRONG "plist") "の末尾（その" (CODE1 "car") "は"
     (STRONG "indicator") "）です。" "もし、そのようなエントリーが見つからなかったら、" (STRONG "indicator") ", "
     (STRONG "value") ", " (STRONG "tail") "はすべて" (CODE1 "nil") "です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq x '()) =>  NIL"
      "(setq *indicator-list* '(prop1 prop2)) =>  (PROP1 PROP2)"
      "(getf x 'prop1) =>  NIL" "(setf (getf x 'prop1) 'val1) =>  VAL1"
      "(eq (getf x 'prop1) 'val1) =>  true"
      "(get-properties x *indicator-list*) =>  PROP1, VAL1, (PROP1 VAL1)"
      "x =>  (PROP1 VAL1)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "get") "," (CODE1 "getf")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("GET-PROPERTIES" . "FUNCTION") *table*) (gethash "GET-PROPERTIES" *table*))
(setf (gethash "GET-SETF-EXPANSION" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "GET-SETF-EXPANSION"))
    (CHAPTER ("## 構文") 2 (CODE1 "get-setf-expansion") " " (STRONG "place") " &optional "
     (STRONG "environment") EOL1 "=> " (STRONG "vars") ", " (STRONG "vals") ", "
     (STRONG "store-vars") ", " (STRONG "writer-form") ", " (STRONG "reader-form"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "place") " - " (CODE1 "place") EOL1
     (STRONG "environment") " - 環境オブジェクト" EOL1 (STRONG "vars") ", " (STRONG "vals") ", "
     (STRONG "store-vars") ", " (STRONG "writer-form") ", " (STRONG "reader-form")
     " - setfの展開")
    (CHAPTER ("## 定義") 2 (STRONG "environment") "下における" (STRONG "place")
     "のsetfの展開を構築するための" "5つの値を返却します。" "5.1.1.2. Setfの展開をご確認ください。" EOL2
     (STRONG "environment") "が与えられなかったか、あるいは" (CODE1 "nil") "のときは、" "環境は" (CODE1 "null")
     "のレキシカルな環境です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(get-setf-expansion 'x)"
      "=>  NIL, NIL, (#:G0001), (SETQ X #:G0001), X " NIL ";;; これはPOPに似たマクロ" NIL
      " (defmacro xpop (place &environment env)"
      "   (multiple-value-bind (dummies vals new setter getter)"
      "                        (get-setf-expansion place env)"
      "      `(let* (,@(mapcar #'list dummies vals) (,(car new) ,getter))"
      "         (if (cdr new) (error \"Can't expand this.\"))"
      "         (prog1 (car ,(car new))"
      "                (setq ,(car new) (cdr ,(car new)))" "                ,setter))))"
      " " " (defsetf frob (x) (value) " "     `(setf (car ,x) ,value)) =>  FROB"
      ";;; 下記の例はエラー、エラーはマクロ展開時に発生する" " (flet ((frob (x) (cdr x)))  ;不正"
      "   (xpop (frob z)))")
     " ")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "defsetf") "," (CODE1 "define-setf-expander") ","
     (CODE1 "setf"))
    (CHAPTER ("## 備考") 2 "compound-formの操作" (CODE1 "f") "がsetf展開を持たないなら"
     (CODE1 "(setf f)") "のように展開されるので、" "どのようなcompound-formも有効な" (CODE1 "place") "になります。")))
(setf (gethash '("GET-SETF-EXPANSION" . "FUNCTION") *table*) (gethash "GET-SETF-EXPANSION" *table*))
(setf (gethash "GETF" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "GETF"))
    (CHAPTER ("## 構文") 2 (CODE1 "getf") " " (STRONG "plist") " " (STRONG "indicator")
     " &optional " (STRONG "default") " => " (STRONG "value") EOL1 "(" (CODE1 "setf")
     " (" (CODE1 "getf") " " (STRONG "place") " " (STRONG "indicator") " &optional "
     (STRONG "default") ") " (STRONG "new-value") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "plist") " - プロパティリスト" EOL1 (STRONG "place") " - "
     (CODE1 "place") "、プロパティリストの値" EOL1 (STRONG "indicator") " - オブジェクト" EOL1
     (STRONG "default") " - オブジェクト、デフォルトは" (CODE1 "nil") EOL1 (STRONG "value")
     " - オブジェクト" EOL1 (STRONG "new-value") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "getf") "は、" (STRONG "plist") "のプロパティリストから"
     (STRONG "indicator") "と同一の標識のプロパティを探し、" "対応するプロパティの値を返却します。" "標識に対して複数のプロパティがあるときは、"
     (CODE1 "getf") "は最初のプロパティを使います。" "標識に対するプロパティが存在しないときは、" (STRONG "default")
     "が返却されます。" EOL2 (CODE1 "getf") "の" (CODE1 "setf") "は、" (STRONG "place")
     "に保存されているプロパティリストに、" "すでに標識が存在するときは、" "新しいオブジェクトを関連付けます。"
     "もし存在しなかったときは、新しい関連を作成します。" "標識に対して複数のプロパティがあるときは、" (CODE1 "getf") "の"
     (CODE1 "setf") "は最初のプロパティに" (STRONG "new-value") "を関連付けます。" (CODE1 "getf") "フォームを"
     (CODE1 "setf") "の" (CODE1 "place") "で使うとき、" "引数" (STRONG "default")
     "が通常の左から右へ評価されるルールに従って評価され、" (STRONG "value") "は無視されます。" EOL2 (CODE1 "getf") "の"
     (CODE1 "setf") "は、" (STRONG "place") "自身の値を書き込むのか、" (STRONG "place")
     "に保存されているリスト構造の" (CODE1 "car") "と" (CODE1 "cdr") "の" "どの部分でも修正することが許されます。")
    (CHAPTER ("## Examples:") 2
     (CODE3 "```lisp" "```" "(setq x '()) =>  NIL" "(getf x 'prop1) =>  NIL"
      "(getf x 'prop1 7) =>  7" "(getf x 'prop1) =>  NIL"
      "(setf (getf x 'prop1) 'val1) =>  VAL1" "(eq (getf x 'prop1) 'val1) =>  true"
      "(getf x 'prop1) =>  VAL1" "(getf x 'prop1 7) =>  VAL1" "x =>  (PROP1 VAL1)" NIL
      ";; この例は実装による変化が許されている" "(setq foo (list 'a 'b 'c 'd 'e 'f)) =>  (A B C D E F)"
      "(setq bar (cddr foo)) =>  (C D E F)" "(remf foo 'c) =>  true" "foo =>  (A B E F)"
      "bar" "=>  (C D E F)" "OR=>  (C)" "OR=>  (NIL)" "OR=>  (C NIL)" "OR=>  (C D)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "get") "," (CODE1 "get-properties") "," (CODE1 "setf")
     "," "5.1.2.2. " (CODE1 "place") "としての関数呼び出しフォーム")
    (CHAPTER ("## 備考") 2 (CODE1 "getf") "を使用した場合、" "プロパティフォームの不在と"
     "デフォルト値の区別をつけることができません。" (CODE1 "get-properties") "をご確認ください。" EOL2 (CODE1 "setf")
     "の状況下で、" (CODE1 "getf") "の" (STRONG "default") "引数を指定することは、" "あまり興味が持たれません。"
     "これが重要になるのは、" (CODE1 "push") "や" (CODE1 "incf") "のようなマクロであり、" (STRONG "place")
     "引数で読み込みと書き込みの両方が求められるときです" "そのような文脈において、" (STRONG "default") "引数は、"
     "読み込みの状況によって供給され、" "それは書き込む状況によっても同様に" "構文として有効でなければなりません。" "例えば下記の通り。"
     (CODE3 "```lisp" "```" "(let ((plist '()))" "  (incf (getf plist 'count 0))"
      "  plist) =>  (COUNT 1)"))))
(setf (gethash '("GETF" . "ACCESSOR") *table*) (gethash "GETF" *table*))
(setf (gethash "GETHASH" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "GETHASH"))
    (CHAPTER ("## 構文") 2 (CODE1 "gethash") " " (STRONG "key") " " (STRONG "hash-table")
     " " (CODE1 "&optional") " " (STRONG "default") " => " (STRONG "value") ", "
     (STRONG "present-p") EOL1 "(" (CODE1 "setf") " (" (CODE1 "gethash") " "
     (STRONG "key") " " (STRONG "hash-table") " " (CODE1 "&optional") " "
     (STRONG "default") ") " (STRONG "new-value") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "key") " - オブジェクト" EOL1 (STRONG "hash-table")
     " - ハッシュテーブル" EOL1 (STRONG "default") " - オブジェクト。デフォルトは" (CODE1 "nil") "。" EOL1
     (STRONG "value") " - オブジェクト" EOL1 (STRONG "present-p") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "value") "は、" (STRONG "hash-table") "の中にある、" "キーが"
     (STRONG "key") "と" (STRONG "hash-table") "の等価テストで" "等しいとされたもののオブジェクトです。"
     "そのようなエントリーが存在しないときは、" (STRONG "value") "は" (STRONG "default") "になります。" EOL2
     "もしエントリーが見つかったときは" (STRONG "present-p") "は" (STRONG "true") "であり、" "それ以外は"
     (STRONG "false") "です。" EOL2 (CODE1 "setf") "の" (CODE1 "gethash") "の使用は、"
     "与えられたキーに関連付けられた値を修正するときか" "あるいは新しいエントリーを追加するときに使用されます。" (CODE1 "gethash") "フォームが"
     (CODE1 "setf") "の" (CODE1 "place") "で使用された場合、" (STRONG "default") "が与えられたときは"
     "通常の左から右への評価ルールに従って評価されますが、" "その値は無視されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32206334>"
      "(gethash 1 table) =>  NIL, false" "(gethash 1 table 2) =>  2, false"
      "(setf (gethash 1 table) \"one\") =>  \"one\""
      "(setf (gethash 2 table \"two\") \"two\") =>  \"two\""
      "(gethash 1 table) =>  \"one\", true" "(gethash 2 table) =>  \"two\", true"
      "(gethash nil table) =>  NIL, false" "(setf (gethash nil table) nil) =>  NIL "
      "(gethash nil table) =>  NIL, true"
      "(defvar *counters* (make-hash-table)) =>  *COUNTERS*"
      "(gethash 'foo *counters*) =>  NIL, false"
      "(gethash 'foo *counters* 0) =>  0, false"
      "(defmacro how-many (obj) `(values (gethash ,obj *counters* 0))) =>  HOW-MANY"
      "(defun count-it (obj) (incf (how-many obj))) =>  COUNT-IT"
      "(dolist (x '(bar foo foo bar bar baz)) (count-it x))" "(how-many 'foo) =>  2"
      "(how-many 'bar) =>  3" "(how-many 'quux) =>  0"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "remhash"))
    (CHAPTER ("## 備考") 2 "第二返却値である" (STRONG "present-p") "は、" "エントリーの不在か、"
     (STRONG "default") "の値を持つエントリーの存在かを、" "区別するときに使用できます。")))
(setf (gethash '("GETHASH" . "ACCESSOR") *table*) (gethash "GETHASH" *table*))
(setf (gethash "GO" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "GO"))
    (CHAPTER ("## 構文") 2 (CODE1 "go") " " (STRONG "tag") " =>" (CODE1 "|"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "tag") " - " (CODE1 "go") "のタグ")
    (CHAPTER ("## 定義") 2 (CODE1 "go") "は、" (CODE1 "tagbody") "フォームによって囲まれたボディ部にある"
     (STRONG "tag") "と" (CODE1 "eql") "で一致するタグによってラベル付けされている場所に" "制御を移します。"
     "もしボディ部にそのような" (STRONG "tag") "が存在しないときは、" "レキシカルに含まれる" (CODE1 "tagbody")
     "フォームがもしあるなら、" "同じように検査されます。" "いくつかのタグが" (STRONG "tag") "と" (CODE1 "eql")
     "で一致するときは、" (CODE1 "go") "が含まれる場所から、" "一致する" (STRONG "tag") "を含んだもっとも内側の"
     (CODE1 "tagbody") "フォームの" "いずれかに制御が移されます。" (CODE1 "go") "の場所からレキシカルに見ることができる"
     (STRONG "tag") "が" "存在しないときの結果は未定義です。" EOL2 (CODE1 "go")
     "によって開始される制御の遷移の実行についての説明は、" "5.2. 終了地点への制御の遷移をご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(tagbody" "  (setq val 2)" "  (go lp)" "  (incf val 3)"
      "  lp (incf val 4)) =>  NIL" "val =>  6 ")
     EOL2 "下記の例は、" (CODE1 "go") "が実行される前に" (CODE1 "tagbody") "が通常の終了を行っているためエラーです。"
     (CODE3 "```lisp" "```" "(let ((a nil)) "
      "  (tagbody t (setq a #'(lambda () (go t))))" "  (funcall a))")
     EOL2 "下記の例は、" (CODE1 "go") "が実行される前に" (CODE1 "tagbody") "が上を通過しているためエラーです。"
     (CODE3 "```lisp" "```" "(funcall (block nil"
      "           (tagbody a (return #'(lambda () (go a))))))"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "tagbody")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("GO" . "SPECIAL-OPERATOR") *table*) (gethash "GO" *table*))
(setf (gethash "GRAPHIC-CHAR-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "GRAPHIC-CHAR-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "graphic-char-p") " " (STRONG "character") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " - 文字" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "character") "が図形文字の場合は" (STRONG "true") "を、それ以外は"
     (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(graphic-char-p #\\G) =>  true"
      "(graphic-char-p #\\#) =>  true" "(graphic-char-p #\\Space) =>  true"
      "(graphic-char-p #\\Newline) =>  false"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "character") "が文字ではなかったら、型" (CODE1 "type-error")
     "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 (CODE1 "read") ", 2.1. 文字の構文, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("GRAPHIC-CHAR-P" . "FUNCTION") *table*) (gethash "GRAPHIC-CHAR-P" *table*))
(setf (gethash "HANDLER-BIND" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "HANDLER-BIND"))
    (CHAPTER ("## 構文") 2 (CODE1 "handler-bind") " (" (CODE1 "{") (STRONG "binding")
     (CODE1 "}") "\\*) " (STRONG "form\\*") " => " (STRONG "result\\*")
     (CODE3 "```" "```" "binding::= (type handler) "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "type") " - 型指定子" EOL1 (STRONG "handler")
     " - フォーム。評価されたら" (STRONG "handler-function") "を生成します。" EOL1
     (STRONG "handler-function") " - ひとつの引数を取る関数指定子" EOL1 (STRONG "form") " - 暗黙のprogn"
     EOL1 (STRONG "result") " - " (STRONG "form") "による返却値")
    (CHAPTER ("## 定義") 2 (STRONG "handler") "が束縛されている効果がある" "動的環境の下で" (STRONG "form")
     "を評価します。" EOL2 "各" (STRONG "handler") "は評価されて" (STRONG "handler-function")
     "にならなければならず、" (STRONG "form") "を評価している間は、" "指定された" (STRONG "type")
     "のコンディションが捕捉されたときに" "その関数が使用されます" "この関数はひとつの引数を受け取れなければならず、"
     "その引数には通知されたコンディションが渡されます。" EOL2 "もし複数の" (STRONG "handler") "の束縛が指定されたとき、"
     (STRONG "handler") "の束縛は、順番に上から下へ" "（視覚的に" (CODE1 "typecase") "に似た方法で）"
     "マッチするものを探します。" "もし適切な型が見つかったときは、" "その関連するハンドラーは、" "これらの" (STRONG "handler")
     "の束縛が見えないような動的環境下で" "（再帰的なエラーを回避するため）実行されます。" "もし" (STRONG "handler") "が下がると、他に続く"
     (STRONG "handler") "を探します。" EOL2 "もし適切な" (STRONG "handler") "が無かったときは、"
     "動的に囲まれた部分から他のハンドラを探します。" "もし外側にも" (STRONG "handler") "がなかったときは、" (CODE1 "signal")
     "は戻るか、あるいは" (CODE1 "error") "はデバッガーに入ります。")
    (CHAPTER ("## 例文") 2 "下記のコードは、もしボディ部で" (CODE1 "unbound") "な変数のエラーが通知されたら"
     "（そしてハンドラーの介入が無かったら）、" "最初の関数が呼ばれます。"
     (CODE3 "```lisp" "```" "(handler-bind ((unbound-variable #'(lambda ...))"
      "               (error #'(lambda ...)))" "  ...)")
     EOL2 "もしそれ以外の何らかのエラーが通知されたら、" "二番目の関数が呼び出されます。" "いずれの場合も、関連する関数のコードを実行している間委は、"
     "どちらのハンドラーもアクティブになりません。"
     (CODE3 "```lisp" "```" "(defun trap-error-handler (condition)"
      "  (format *error-output* \"~&~A~&\" condition)" "  (throw 'trap-errors nil))" NIL
      "(defmacro trap-errors (&rest forms)" "  `(catch 'trap-errors"
      "     (handler-bind ((error #'trap-error-handler))" "       ,@forms)))" NIL
      "(list (trap-errors (signal \"Foo.\") 1)" "      (trap-errors (error  \"Bar.\") 2)"
      "      (+ 1 2))" ">>  Bar." "=>  (1 NIL 3)")
     EOL2 (CODE1 "\"FOO\"") "は印刷されませんが、" "これは" (CODE1 "signal") "によって"
     (CODE1 "simple-condition") "を通知したためであり、" "型" (CODE1 "error") "ではないため、"
     (CODE1 "trap-errors") "によって用意された" (CODE1 "error") "のハンドラーが" "トリガーされないのです。")
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "handler-case")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("HANDLER-BIND" . "MACRO") *table*) (gethash "HANDLER-BIND" *table*))
(setf (gethash "HANDLER-CASE" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "HANDLER-CASE"))
    (CHAPTER ("## 構文") 2 (CODE1 "handler-case") " " (STRONG "expression") " [["
     (CODE1 "{") (STRONG "error-clause") (CODE1 "}") "\\* " (CODE1 "|") " "
     (STRONG "no-error-clause") "]]" " => " (STRONG "result\\*")
     (CODE3 "```" "```" "clause::= error-clause | no-error-clause "
      "error-clause::= (typespec ([var]) declaration* form*) "
      "no-error-clause::= (:no-error lambda-list declaration* form*) "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "expression") " - フォーム" EOL1 (STRONG "typespec")
     " - 型指定子" EOL1 (STRONG "var") " - 変数名" EOL1 (STRONG "lambda-list") " - 通常のラムダリスト"
     EOL1 (STRONG "declaration") " - 宣言式。評価されません。" EOL1 (STRONG "form") " - フォーム" EOL1
     (STRONG "result") " - 通常の状況では" (STRONG "expression") "の評価による結果が返却されます。"
     "例外的な状況では制御が" (STRONG "clause") "に遷移したときに、" (STRONG "clause") "内の最後の"
     (STRONG "form") "の値が返却されます。")
    (CHAPTER ("## 定義") 2 (CODE1 "handler-case") "は" "様々なハンドラーがアクティブになっている動的環境下で"
     (STRONG "expression") "を実行します。" "各" (STRONG "error-clause") "は、"
     "どのようなコンディションを捕捉するのか、" (STRONG "typespec") "でマッチされたものとして指定します。"
     (STRONG "no-error-clause") "は、制御が通常の返却をしたときに" "特定のアクションを指定することが許されます。" EOL2 "もし"
     (STRONG "expression") "が実行中に" (STRONG "error-clause") "に適用できるコンディションが通知されたとき"
     "（例えば、" (CODE1 "(typep condition 'typespec)") "が" (STRONG "true") "になるような" "何らかの"
     (STRONG "condition") "）、" "さらにその型のコンディションが介入できるハンドラーがないときは、" "関係する"
     (STRONG "error-clause") "の" "ボディ部に制御が遷移します。" "このような場合、動的な状態を適切に巻き戻し、" "（つまり"
     (STRONG "expression") "周りに確立されたハンドラーは" "もうアクティブではありません）、" (STRONG "var")
     "に通知されたコンディションを束縛します。" "もし複数の場合が提供されたときは、" "そのような場合は並列にアクセスされます。" "例えば次のような場合、"
     (CODE3 "```lisp" "```" "(handler-case form" "  (typespec1 (var1) form1)"
      "  (typespec2 (var2) form2))")
     EOL2 "もし最初の" (STRONG "clause") "が（" (STRONG "form1") "が含まれているもの）選ばれたとき、"
     "2番目のハンドラーは見ることができません（そしてその反対も同様）。" EOL2 (STRONG "clause") "は上から下に順番に検索されます。" "もし"
     (STRONG "typespec") "間で重複する型があるときは、" (STRONG "classe") "の早い方が選択されます。" EOL2 "もし"
     (STRONG "var") "が必要ないときは、それは省略できます。" "つまり" (STRONG "clause") "は次のようなもの"
     (CODE3 "```lisp" "```" "(typespec (var) (declare (ignore var)) form)") EOL2 "これを"
     (CODE1 "(typespec () form)") "のように書くことができます。" EOL2 "もし" (STRONG "form") "がない"
     (STRONG "clause") "が選択されたとき、" "このような場合は" (CODE1 "handler-case") "は" (CODE1 "nil")
     "を返却します。" "もし" (STRONG "expression") "の実行が普通に返却され、" (STRONG "no-error-clause")
     "がないときは、" (CODE1 "handler-case") "は" (STRONG "expression") "の結果が返却されます。" "もし"
     (STRONG "expression") "の実行が普通に返却され、" (STRONG "no-error-clause") "があるときは、" "返却値は"
     (STRONG "no-error-clause") "から" (CODE1 "(lambda lambda-list form*)") "の"
     "生成によって定義された関数の引数として使用され、" "その関数の呼び出しの値が" (CODE1 "handler-case") "による返却値になります。"
     "この呼び出しの時点では、" (STRONG "expression") "周りに確立されたハンドラーは" "もうアクティブではありません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun assess-condition (condition)"
      "  (handler-case (signal condition)"
      "    (warning () \"Lots of smoke, but no fire.\")"
      "    ((or arithmetic-error control-error cell-error stream-error)"
      "       (condition)" "      (format nil \"~S looks especially bad.\" condition))"
      "    (serious-condition (condition)"
      "      (format nil \"~S looks serious.\" condition))"
      "    (condition () \"Hardly worth mentioning.\")))" "=>  ASSESS-CONDITION"
      "(assess-condition (make-condition 'stream-error :stream *terminal-io*))"
      "=>  \"#<STREAM-ERROR 12352256> looks especially bad.\""
      "(define-condition random-condition (condition) () "
      "  (:report (lambda (condition stream)" "             (declare (ignore condition))"
      "             (princ \"Yow\" stream))))" "=>  RANDOM-CONDITION"
      "(assess-condition (make-condition 'random-condition))"
      "=>  \"Hardly worth mentioning.\""))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "handler-bind") "," (CODE1 "ignore-errors") ","
     "9.1. コンディションシステムの説明")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(handler-case form" "  (type1 (var1) . body1)"
      "  (type2 (var2) . body2) ...)")
     EOL2 "上記の式はおおよそ下記のものと同等です。"
     (CODE3 "```lisp" "```" "(block #1=#:g0001" "  (let ((#2=#:g0002 nil))"
      "    (tagbody" "      (handler-bind ((type1 #'(lambda (temp)"
      "                                      (setq #1# temp)"
      "                                      (go #3=#:g0003)))"
      "                     (type2 #'(lambda (temp)"
      "                                      (setq #2# temp)"
      "                                      (go #4=#:g0004))) ...)"
      "      (return-from #1# form))"
      "        #3# (return-from #1# (let ((var1 #2#)) . body1))"
      "        #4# (return-from #1# (let ((var2 #2#)) . body2)) ...)))")
     (CODE3 "```lisp" "```" "(handler-case form" "  (type1 (var1) . body1)" "  ..."
      "  (:no-error (varN-1 varN-2 ...) . bodyN))")
     EOL2 "上記の式はおおよそ下記のものと同等です。"
     (CODE3 "```lisp" "```" "(block #1=#:error-return"
      " (multiple-value-call #'(lambda (varN-1 varN-2 ...) . bodyN)"
      "    (block #2=#:normal-return" "      (return-from #1#"
      "        (handler-case (return-from #2# form)"
      "          (type1 (var1) . body1) ...)))))"))))
(setf (gethash '("HANDLER-CASE" . "MACRO") *table*) (gethash "HANDLER-CASE" *table*))
(setf (gethash "HASH-TABLE" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "HASH-TABLE"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "hash-table") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "ハッシュテーブルは、何らかのオブジェクト（キーとして）を" "関連付けられたオブジェクト（値として）を"
     "対応付ける方法を提供します。")
    (CHAPTER ("## 参考") 2 "18.1. ハッシュテーブルの説明," "22.1.3.13. 他のオブジェクトの印字")
    (CHAPTER ("## 備考") 2 "このオブジェクトの意図は、"
     "The Art of Computer Programming, Volume 3 (pp506-549)という書籍の、"
     "6.4章「Hashing」に記載されている" "ハッシュの仕組みを用いてこのマッピングを実装することです。" "このような意図はありますが、仕様に適合した実装は"
     "マッピングを実装するために特定の技術を使用することは要求しません。")))
(setf (gethash '("HASH-TABLE" . "SYSTEM-CLASS") *table*) (gethash "HASH-TABLE" *table*))
(setf (gethash "HASH-TABLE-COUNT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "HASH-TABLE-COUNT"))
    (CHAPTER ("## 構文") 2 (CODE1 "hash-table-count") " " (STRONG "hash-table") " => "
     (STRONG "count"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "hash-table") " - ハッシュテーブル" EOL1 (STRONG "count")
     " - 非負の整数")
    (CHAPTER ("## 定義") 2 (STRONG "hash-table") "のエントリーの数を返却します。" "もし"
     (STRONG "hash-table") "がちょうど作成されたときか、" "新しい状態にクリアされた（" (CODE1 "clrhash")
     "をご確認ください）ときは、" "エントリー数は" (CODE1 "0") "です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32115135>"
      "(hash-table-count table) =>  0"
      "(setf (gethash 57 table) \"fifty-seven\") =>  \"fifty-seven\""
      "(hash-table-count table) =>  1"
      "(dotimes (i 100) (setf (gethash i table) i)) =>  NIL"
      "(hash-table-count table) =>  100"))
    (CHAPTER ("## 副作用") 2 "なし。")
    (CHAPTER ("## 影響") 2 (CODE1 "clrhash") "," (CODE1 "remhash") "," (CODE1 "setf") "の"
     (CODE1 "gethash"))
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "hash-table-size"))
    (CHAPTER ("## 備考") 2 "下記の関係は機能的には正しいですが、" "実際の" (CODE1 "hash-table-count")
     "はおそらくもっと高速です。"
     (CODE3 "```lisp" "```" "(hash-table-count table) == "
      "(loop for value being the hash-values of table count t) == " "(let ((total 0))"
      "  (maphash #'(lambda (key value)" "               (declare (ignore key value))"
      "               (incf total))" "           table)" "  total)"))))
(setf (gethash '("HASH-TABLE-COUNT" . "FUNCTION") *table*) (gethash "HASH-TABLE-COUNT" *table*))
(setf (gethash "HASH-TABLE-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "HASH-TABLE-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "hash-table-p") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が型" (CODE1 "hash-table") "であったら"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32511220>"
      "(hash-table-p table) =>  true" "(hash-table-p 37) =>  false"
      "(hash-table-p '((a . 1) (b . 2))) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(hash-table-p object) == (typep object 'hash-table)"))))
(setf (gethash '("HASH-TABLE-P" . "FUNCTION") *table*) (gethash "HASH-TABLE-P" *table*))
(setf (gethash "HASH-TABLE-REHASH-SIZE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "HASH-TABLE-REHASH-SIZE"))
    (CHAPTER ("## 構文") 2 (CODE1 "hash-table-rehash-size") " " (STRONG "hash-table")
     " => " (STRONG "rehash-size"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "hash-table") " - ハッシュテーブル" EOL1
     (STRONG "rehash-size") " - 型" (CODE1 "(or (integer 1 *) (float (1.0) *))") "の実数。")
    (CHAPTER ("## 定義") 2 (STRONG "hash-table") "の現在の再ハッシュサイズを返却します。" "これは"
     (CODE1 "make-hash-table") "を呼び出すときに、" (STRONG "hash-table")
     "の現在の状態に対応するものを保有するハッシュテーブルを" "生成するときに使用するのが適しています。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq table (make-hash-table :size 100 :rehash-size 1.4))"
      "=>  #<HASH-TABLE EQL 0/100 2556371>" "(hash-table-rehash-size table) =>  1.4"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "hash-table") "がハッシュテーブルではないとき、" "型"
     (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-hash-table") ","
     (CODE1 "hash-table-rehash-threshold"))
    (CHAPTER ("## 備考") 2 "もしハッシュテーブルが整数のresize-hashで生成されたとき、" "その返却値は整数となり、"
     (STRONG "hash-table") "が再ハッシュされるとき、" "成長レートが加算的に行われることを示しています。" "他に返却値が浮動小数のときは、"
     (STRONG "hash-table") "が再ハッシュされるとき、" "成長レートが乗算で行われることを示しています。"
     "しかしこれらの値は実装に対してただ助言するだけのものであり、" "実際に" (STRONG "hash-table") "の再ハッシュによって成長する量は"
     "実装依存です。")))
(setf (gethash '("HASH-TABLE-REHASH-SIZE" . "FUNCTION") *table*) (gethash "HASH-TABLE-REHASH-SIZE" *table*))
(setf (gethash "HASH-TABLE-REHASH-THRESHOLD" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "HASH-TABLE-REHASH-THRESHOLD"))
    (CHAPTER ("## 構文") 2 (CODE1 "hash-table-rehash-threshold") " " (STRONG "hash-table")
     " => " (STRONG "rehash-threshold"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "hash-table") " - ハッシュテーブル" EOL1
     (STRONG "rehash-threshold") " - 型" (CODE1 "(real 0 1)") "の実数。")
    (CHAPTER ("## 定義") 2 (STRONG "hash-table") "の現在の再ハッシュのしきい値を返却します。" "これは"
     (CODE1 "make-hash-table") "を呼び出すときに、" (STRONG "hash-table")
     "の現在の状態に対応するものを保有するハッシュテーブルを" "生成するときに使用するのが適しています。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq table (make-hash-table :size 100 :rehash-threshold 0.5))"
      "=>  #<HASH-TABLE EQL 0/100 2562446>"
      "(hash-table-rehash-threshold table) =>  0.5"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "hash-table") "がハッシュテーブルではないとき、" "型"
     (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-hash-table") "," (CODE1 "hash-table-rehash-size"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("HASH-TABLE-REHASH-THRESHOLD" . "FUNCTION") *table*) (gethash "HASH-TABLE-REHASH-THRESHOLD" *table*))
(setf (gethash "HASH-TABLE-SIZE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "HASH-TABLE-SIZE"))
    (CHAPTER ("## 構文") 2 (CODE1 "hash-table-size") " " (STRONG "hash-table") " => "
     (STRONG "size"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "hash-table") " - ハッシュテーブル" EOL1 (STRONG "size")
     " - 非負の整数")
    (CHAPTER ("## 定義") 2 (STRONG "hash-table") "の現在のサイズを返却します。" "これは"
     (CODE1 "make-hash-table") "を呼び出すときに、" (STRONG "hash-table")
     "の現在の状態に対応するものを保有するハッシュテーブルを" "生成するときに使用するのが適しています。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "hash-table") "がハッシュテーブルではないとき、" "型"
     (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "hash-table-count") "," (CODE1 "make-hash-table"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("HASH-TABLE-SIZE" . "FUNCTION") *table*) (gethash "HASH-TABLE-SIZE" *table*))
(setf (gethash "HASH-TABLE-TEST" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "HASH-TABLE-TEST"))
    (CHAPTER ("## 構文") 2 (CODE1 "hash-table-test") " " (STRONG "hash-table") " => "
     (STRONG "test"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "hash-table") " - ハッシュテーブル" EOL1 (STRONG "test")
     " - 関数指定子。" "標準では4つのハッシュテーブルのテスト関数が用意されており" "（" (CODE1 "make-hash-table")
     "をご確認ください）、" (STRONG "test") "は常にシンボルが返却されます。" "もし実装が追加のテストを許容するときは、"
     "そのようなテストが関数オブジェクトと関数名のどちらで返却されるかは" "実装依存です。")
    (CHAPTER ("## 定義") 2 (STRONG "hash-table") "がキーの比較に使用するテストを返却します。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "hash-table") "がハッシュテーブルではないとき、" "型"
     (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-hash-table")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("HASH-TABLE-TEST" . "FUNCTION") *table*) (gethash "HASH-TABLE-TEST" *table*))
(setf (gethash "HOST-NAMESTRING" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "NAMESTRING") ", " (CODE1 "FILE-NAMESTRING") ", "
     (CODE1 "DIRECTORY-NAMESTRING") "," (CODE1 "HOST-NAMESTRING") ", "
     (CODE1 "ENOUGH-NAMESTRING"))
    (CHAPTER ("## 構文") 2 (CODE1 "namestring") " " (STRONG "pathname") " => "
     (STRONG "namestring") EOL1 (CODE1 "file-namestring") " " (STRONG "pathname") " => "
     (STRONG "namestring") EOL1 (CODE1 "directory-namestring") " " (STRONG "pathname")
     " => " (STRONG "namestring") EOL1 (CODE1 "host-namestring") " " (STRONG "pathname")
     " => " (STRONG "namestring") EOL1 (CODE1 "enough-namestring") " "
     (STRONG "pathname") " " (CODE1 "&optional") " " (STRONG "defaults") " => "
     (STRONG "namestring"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathname") " - パス名指定子" EOL1 (STRONG "defaults")
     " - パス名指定子。" "デフォルトは" (CODE1 "*default-pathname-defaults*") "の値です。" EOL1
     (STRONG "namestring") " - 文字列か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "pathname") "を名前文字列に変換します。"
     (STRONG "pathname") "によって表現される名前は、" "実装依存の基準のフォームに従った" "名前文字列として返却されます。" EOL2
     (CODE1 "namestring") "は、" (STRONG "pathname") "の完全なフォームを返却します。" EOL2
     (CODE1 "file-namestring") "は、" (STRONG "pathname") "の名前とタイプとバージョンの要素だけを返却します。" EOL2
     (CODE1 "directory-namestring") "は、" (STRONG "pathname") "のディレクトリの名前の部分を返却します。" EOL2
     (CODE1 "host-namestring") "は、ホスト名を返却します。" EOL2 (CODE1 "enough-namestring") "は、"
     (STRONG "pathname") "が" (STRONG "defaults") "から相対的に考慮されたものによって、"
     "同一と見なせるのに十分なファイル名である" "省略された名前文字列を返却します。" "これは、全ての場合において次のような関係を要求します。"
     (CODE3 "```lisp" "```"
      "(merge-pathnames (enough-namestring pathname defaults) defaults)"
      "==  (merge-pathnames (parse-namestring pathname nil defaults) defaults)")
     EOL2 (CODE1 "enough-namestring") "の結果は、" "このような基準を満たした最も短い適切な文字列です。" EOL2
     "この3つの短い名前文字列をある順にて結合することによって" "有効な名前文字列を生成することは必ずしも可能ではありません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(namestring \"getty\")            " "=>  \"getty\""
      "(setq q (make-pathname :host \"kathy\" " "                        :directory "
      "                          (pathname-directory *default-pathname-defaults*)"
      "                        :name \"getty\")) "
      "=>  #S(PATHNAME :HOST \"kathy\" :DEVICE NIL :DIRECTORY directory-name "
      "      :NAME \"getty\" :TYPE NIL :VERSION NIL)" "(file-namestring q) =>  \"getty\""
      "(directory-namestring q) =>  directory-name" "(host-namestring q) =>  \"kathy\" "
      ";;; Unix構文の使用とこの例での特定のUnixバージョンによる" ";;; ワイルドカード表記の使用によって作成されたもの" "(namestring"
      "  (translate-pathname \"/usr/dmr/hacks/frob.l\""
      "                      \"/usr/d*/hacks/*.l\""
      "                      \"/usr/d*/backup/hacks/backup-*.*\"))"
      ">  \"/usr/dmr/backup/hacks/backup-frob.l\"" "(namestring"
      "  (translate-pathname \"/usr/dmr/hacks/frob.l\""
      "                      \"/usr/d*/hacks/fr*.l\""
      "                      \"/usr/d*/backup/hacks/backup-*.*\"))"
      "=>  \"/usr/dmr/backup/hacks/backup-ob.l\"" NIL
      ";;; これは上記の例に似ていますが2つの違ったホストを使用しています。" ";;; UがUnixであり、VがVMSです。ファイルタイプの変換と"
      ";;; アルファベットの大文字小文字の表記に注意してください。" "(namestring"
      "  (translate-pathname \"U:/usr/dmr/hacks/frob.l\""
      "                      \"U:/usr/d*/hacks/*.l\""
      "                      \"V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*\"))"
      "=>  \"V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-FROB.LSP\"" "(namestring"
      "  (translate-pathname \"U:/usr/dmr/hacks/frob.l\""
      "                      \"U:/usr/d*/hacks/fr*.l\""
      "                      \"V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*\"))"
      "=>  \"V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-OB.LSP\""))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "truename") "," (CODE1 "merge-pathnames") ","
     (CODE1 "pathname") "," (CODE1 "logical-pathname") "," "20.1. ファイルシステムの説明,"
     "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("HOST-NAMESTRING" . "FUNCTION") *table*) (gethash "HOST-NAMESTRING" *table*))
(setf (gethash "IDENTITY" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "IDENTITY"))
    (CHAPTER ("## 構文") 2 (CODE1 "identity") " " (STRONG "object") " => "
     (STRONG "object"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "引数の" (STRONG "object") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(identity 101) =>  101"
      "(mapcan #'identity (list (list 1 2 3) '(4 5 6))) =>  (1 2 3 4 5 6)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 (CODE1 "identity") "は、引数として関数を必要とする関数での使用を意図しています。" EOL2
     (CODE1 "(eql x (identity x))") "は、" (CODE1 "x") "が全ての可能性のある値に対して" (STRONG "true")
     "を返却します。" "しかし" (CODE1 "(eq x (identity x))") "は、" (CODE1 "x") "が数か文字の場合は"
     (STRONG "false") "になるかもしれません。" EOL2 (CODE1 "identity") "は、次のように定義できます。"
     (CODE3 "```lisp" "```" "(defun identity (x) x)"))))
(setf (gethash '("IDENTITY" . "FUNCTION") *table*) (gethash "IDENTITY" *table*))
(setf (gethash "IF" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "IF"))
    (CHAPTER ("## 構文") 2 (CODE1 "if") " " (STRONG "test-form") " " (STRONG "then-form")
     " [" (STRONG "else-form") "] => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "test-form") " - フォーム" EOL1 (STRONG "then-form")
     " - フォーム" EOL1 (STRONG "else-form") " - フォーム、デフォルトは" (CODE1 "nil") "。" EOL1
     (STRONG "result") " - もし" (STRONG "test-form") "が" (STRONG "true") "のときは、"
     (STRONG "then-form") "の返却値です。" "それ以外は" (STRONG "else-form") "の返却値です。")
    (CHAPTER ("## 定義") 2 (CODE1 "if") "は" (STRONG "test-form") "単体に依存したフォームの実行を行います。"
     EOL2 "最初に" (STRONG "test-form") "が評価されます。" "もしその値が" (STRONG "true") "のときは、"
     (STRONG "then-form") "が選ばれます。" "そうでないときは、" (STRONG "else-form") "が選ばれます。"
     "選ばれたフォームのどちらかが評価されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(if t 1) =>  1" "(if nil 1 2) =>  2 " "(defun test ()"
      "  (dolist (truth-value '(t nil 1 (a b c)))"
      "    (if truth-value (print 'true) (print 'false))"
      "    (prin1 truth-value))) =>  TEST" "(test)" ">>  TRUE T" ">>  FALSE NIL"
      ">>  TRUE 1" ">>  TRUE (A B C)" "=>  NIL"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "cond") "," (CODE1 "unless") "," (CODE1 "when"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(if test-form then-form else-form)"
      "== (cond (test-form then-form) (t else-form))"))))
(setf (gethash '("IF" . "SPECIAL-OPERATOR") *table*) (gethash "IF" *table*))
(setf (gethash "IGNORABLE" *table*)
  '((CHAPTER NIL 0 "Declaration " (CODE1 "IGNORE") ", " (CODE1 "IGNORABLE"))
    (CHAPTER ("## 構文") 2 "(" (CODE1 "ignore") "    " (CODE1 "{") (STRONG "var") " "
     (CODE1 "|") " (" (CODE1 "function") " " (STRONG "fn") ")" (CODE1 "}") "\\*)" EOL1
     "(" (CODE1 "ignorable") " " (CODE1 "{") (STRONG "var") " " (CODE1 "|") " ("
     (CODE1 "function") " " (STRONG "fn") ")" (CODE1 "}") "\\*)")
    (CHAPTER ("## 引数") 2 (STRONG "var") " - 変数名" EOL1 (STRONG "fn") " - 関数名")
    (CHAPTER ("## 有効な文脈") 2 (CODE1 "declare")) (CHAPTER ("## 影響する束縛の型") 2 "変数、関数")
    (CHAPTER ("## 定義") 2 (CODE1 "ignore") "と" (CODE1 "ignorable") "は、" (STRONG "var")
     "への変数束縛と" (STRONG "fn") "への関数束縛に対する値への参照に関する宣言です。" EOL2 (CODE1 "ignore")
     "宣言は、宣言のスコープ内において" "その束縛が示す値への参照が生じないことを指定します。" "そのような宣言のスコープ内において、" "コンパイラーは、 "
     (STRONG "var") "や" (STRONG "fn") "や" (CODE1 "special") "の" (STRONG "var") "の"
     "値の参照が生じているものについて警告を発生させるのが望ましいです。" EOL2 (CODE1 "ignorable") "宣言は、宣言のスコープ内において"
     "その束縛が示す値への参照が生じているか、" "または生じていないことを指定します。" "そのような宣言のスコープ内において、" "コンパイラーは、 "
     (STRONG "var") "や" (STRONG "fn") "や" (CODE1 "special") "の" (STRONG "var") "の"
     "値の参照が生じていないものについて警告を発生させないことが望ましいです。" EOL2 (CODE1 "ignore") "か" (CODE1 "ignorable")
     "宣言のスコープ範囲外では、" "コンパイラーは、 " (STRONG "var") "や" (STRONG "fn") "や" (CODE1 "special")
     "の" (STRONG "var") "の" "値の参照が生じていないものについて警告を発生させることが望ましいです。" EOL2
     "「使用している」か「使用されていない」のような警告については、" "型" (CODE1 "style-warning") "にすることが望ましく、"
     "これはプログラムの意味に影響を及ぼしません。" EOL2 (CODE1 "with-open-file") ","
     (CODE1 "with-open-stream") "," (CODE1 "with-input-from-string") ","
     (CODE1 "with-output-to-string") "によって確立される" "ストリームの変数と、"
     "全ての繰り返しの変数は、常に「使用されている」ものとして宣言されます。" (CODE1 "(declare (ignore v))") "という宣言の変数"
     (CODE1 "v") "が使用されたときの" "結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "declare"))))
(setf (gethash '("IGNORABLE" . "DECLARATION") *table*) (gethash "IGNORABLE" *table*))
(setf (gethash "IGNORE" *table*)
  '((CHAPTER NIL 0 "Declaration " (CODE1 "IGNORE") ", " (CODE1 "IGNORABLE"))
    (CHAPTER ("## 構文") 2 "(" (CODE1 "ignore") "    " (CODE1 "{") (STRONG "var") " "
     (CODE1 "|") " (" (CODE1 "function") " " (STRONG "fn") ")" (CODE1 "}") "\\*)" EOL1
     "(" (CODE1 "ignorable") " " (CODE1 "{") (STRONG "var") " " (CODE1 "|") " ("
     (CODE1 "function") " " (STRONG "fn") ")" (CODE1 "}") "\\*)")
    (CHAPTER ("## 引数") 2 (STRONG "var") " - 変数名" EOL1 (STRONG "fn") " - 関数名")
    (CHAPTER ("## 有効な文脈") 2 (CODE1 "declare")) (CHAPTER ("## 影響する束縛の型") 2 "変数、関数")
    (CHAPTER ("## 定義") 2 (CODE1 "ignore") "と" (CODE1 "ignorable") "は、" (STRONG "var")
     "への変数束縛と" (STRONG "fn") "への関数束縛に対する値への参照に関する宣言です。" EOL2 (CODE1 "ignore")
     "宣言は、宣言のスコープ内において" "その束縛が示す値への参照が生じないことを指定します。" "そのような宣言のスコープ内において、" "コンパイラーは、 "
     (STRONG "var") "や" (STRONG "fn") "や" (CODE1 "special") "の" (STRONG "var") "の"
     "値の参照が生じているものについて警告を発生させるのが望ましいです。" EOL2 (CODE1 "ignorable") "宣言は、宣言のスコープ内において"
     "その束縛が示す値への参照が生じているか、" "または生じていないことを指定します。" "そのような宣言のスコープ内において、" "コンパイラーは、 "
     (STRONG "var") "や" (STRONG "fn") "や" (CODE1 "special") "の" (STRONG "var") "の"
     "値の参照が生じていないものについて警告を発生させないことが望ましいです。" EOL2 (CODE1 "ignore") "か" (CODE1 "ignorable")
     "宣言のスコープ範囲外では、" "コンパイラーは、 " (STRONG "var") "や" (STRONG "fn") "や" (CODE1 "special")
     "の" (STRONG "var") "の" "値の参照が生じていないものについて警告を発生させることが望ましいです。" EOL2
     "「使用している」か「使用されていない」のような警告については、" "型" (CODE1 "style-warning") "にすることが望ましく、"
     "これはプログラムの意味に影響を及ぼしません。" EOL2 (CODE1 "with-open-file") ","
     (CODE1 "with-open-stream") "," (CODE1 "with-input-from-string") ","
     (CODE1 "with-output-to-string") "によって確立される" "ストリームの変数と、"
     "全ての繰り返しの変数は、常に「使用されている」ものとして宣言されます。" (CODE1 "(declare (ignore v))") "という宣言の変数"
     (CODE1 "v") "が使用されたときの" "結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "declare"))))
(setf (gethash '("IGNORE" . "DECLARATION") *table*) (gethash "IGNORE" *table*))
(setf (gethash "IGNORE-ERRORS" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "IGNORE-ERRORS"))
    (CHAPTER ("## 構文") 2 (CODE1 "ignore-errors") " " (STRONG "form\\*") " => "
     (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "form") " - 暗黙のprogn" EOL1 (STRONG "result")
     " - 通常の状態のときは" (STRONG "form") "の返却値です。" "例外の状態のときは2つの多値である" (CODE1 "nil")
     "とコンディションが返却されます。")
    (CHAPTER ("## 定義") 2 (CODE1 "ignore-errors") "は型" (CODE1 "error") "のコンディションによる"
     "デバッガーへの入場を禁止するときに使われます。" EOL2 "とくに" (CODE1 "ignore-errors") "は型" (CODE1 "error")
     "の" "コンディションのハンドラーが確立された動的環境下で" (STRONG "form") "を実行し、" "もし該当するものが起動されたとき、"
     "そのようなコンディションは、" (CODE1 "ignore-errors") "フォームから" (CODE1 "nil") "と通知されたコンディションを"
     "2つの多値で返却することによって処理されます。" EOL2 "もし" (STRONG "form") "から通常の返却が生じたときは、" "そのどのような返却値も"
     (CODE1 "ignore-errors") "によって返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun load-init-file (program)" "  (let ((win nil))"
      "    (ignore-errors ;もし失敗してもデバッガーに入らない"
      "      (load (merge-pathnames (make-pathname :name program :type :lisp)"
      "                             (user-homedir-pathname)))" "      (setq win t))"
      "    (unless win (format t \"~&Init file failed to load.~%\"))" "    win))" NIL
      "(load-init-file \"no-such-program\")" ">>  Init file failed to load." "NIL"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "handler-case") "," "9.1. コンディションシステムの説明")
    (CHAPTER ("## 備考") 2 (CODE3 "```lisp" "```" "(ignore-errors . forms)") EOL2
     "これは下記のものと同等です。　"
     (CODE3 "```lisp" "```" "(handler-case (progn . forms)"
      "  (error (condition) (values nil condition)))")
     EOL2 "例外の状況では第二返却値がコンディションであるので、" "通常の場合は第二返却値を省略するか" (CODE1 "nil") "にして、"
     "2つの状況を区別できるようにするのが一般的です（ただし必須ではありません）。")))
(setf (gethash '("IGNORE-ERRORS" . "MACRO") *table*) (gethash "IGNORE-ERRORS" *table*))
(setf (gethash "IMPORT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "IMPORT"))
    (CHAPTER ("## 構文") 2 (CODE1 "import") " " (STRONG "symbols") " " (CODE1 "&optional")
     " " (STRONG "package") " => " (CODE1 "t"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbols") " - シンボルのリストの指定子" EOL1 (STRONG "package")
     " - パッケージ指定子。デフォルトは現在のパッケージ。")
    (CHAPTER ("## 定義") 2 (CODE1 "import") "は、" (STRONG "symbol") "か" (STRONG "symbols")
     "を" (STRONG "package") "の内部に追加し、" "存在するシンボルに対して、" (STRONG "package") "に現れているか、"
     "それにアクセス可能かという点について" "名前の衝突チェックを行います。" "いったん" (STRONG "symbols") "が"
     (CODE1 "import") "されると、" "それらはLispリーダーを使うときに" (CODE1 "import") "された"
     (STRONG "package") "内では" "パッケージの接頭辞を使うことなく参照できます。" EOL2 (CODE1 "import")
     "を行おうとしたときに" (CODE1 "import") "される" (STRONG "symbol") "と" "他の" (STRONG "package")
     "から継承されたシンボルの間で" "名前の衝突が生じたとき、" "それは" (CODE1 "import") "される" (STRONG "symbol") "を選び"
     "それを" (CODE1 "shadowing") "シンボルにするか、" "あるいはすでにアクセス可能なシンボルを選び" (CODE1 "import")
     "を実行しないかのどちらかで解決できます。" (CODE1 "import") "を行おうとしたときに" (STRONG "package")
     "の内部にシンボルがすでに表れていたため" "名前の衝突が生じたときは、" "そのシンボルを" (CODE1 "unintern") "するか、" "あるいは"
     (CODE1 "import") "を実行しないかのどちらかで解決できます。" EOL2 (CODE1 "import") "されるシンボルは、現在のパッケージから"
     "自動的には" (CODE1 "export") "されませんが、" "しかしそれがすでに外部として存在しているときは、"
     "それが外部であることが変更されることはありません。" "もし" (CODE1 "import") "されるどんなシンボルでも" "ホームパッケージを持ってなかったら"
     "（つまり" (CODE1 "(symbol-package symbol) => nil") "）、" (CODE1 "import") "はその"
     (STRONG "symbol") "のホームパッケージを" (STRONG "package") "にセットします。" EOL2 "もし"
     (STRONG "symbol") "がすでに" (CODE1 "import") "しようとしている" (STRONG "package")
     "に存在しているときは、" (CODE1 "import") "は何も効果がありません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(import 'common-lisp::car (make-package 'temp :use nil)) =>  T"
      "(find-symbol \"CAR\" 'temp) =>  CAR, :INTERNAL"
      "(find-symbol \"CDR\" 'temp) =>  NIL, NIL ")
     EOL2 (CODE1 "(import 'editor:buffer)") "というフォームは、" (CODE1 "EDITOR") "というパッケージ内にある"
     (CODE1 "BUFFER") "という名前の外部のシンボル" "（このシンボルはそのフォームを" "Lispリーダーによって読み込んだときに配置される）"
     "を受け取り、" "現在のパッケージに内部シンボルとして追加します。" "その結果、このシンボル" (CODE1 "buffer")
     "は現在のパッケージに現れるようになります。")
    (CHAPTER ("## 副作用") 2 "パッケージシステムは変更されます。") (CHAPTER ("## 影響") 2 "パッケージシステムの現在の状態。")
    (CHAPTER ("## 例外") 2 "もし" (CODE1 "import") "されるどの" (STRONG "symbols") "も、"
     (STRONG "package") "内のアクセス可能な別のシンボル（" (CODE1 "eql") "判定による）と" "同じ名前であったとき（"
     (CODE1 "string=") "判定による）、" "それが" (STRONG "package") "の" (CODE1 "shadowing")
     "シンボルとの衝突であったとしても、" (CODE1 "import") "は型" (CODE1 "package-error")
     "の修正可能なエラーを通知します。")
    (CHAPTER ("## 参考") 2 (CODE1 "shadow") "," (CODE1 "export"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("IMPORT" . "FUNCTION") *table*) (gethash "IMPORT" *table*))
(setf (gethash "IN-PACKAGE" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "IN-PACKAGE"))
    (CHAPTER ("## 構文") 2 (CODE1 "in-package") " " (STRONG "name") " => "
     (STRONG "package"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - 文字列指定子。評価されません。" EOL1 (STRONG "package")
     " - " (STRONG "name") "という名前のパッケージ")
    (CHAPTER ("## 定義") 2 (STRONG "name") "というパッケージを現在のパッケージにします。" "つまり"
     (CODE1 "*package*") "の値にパッケージを設定します。" "もしそのようなパッケージが存在しないときは、" "型"
     (CODE1 "package-error") "のエラーが発生します。" EOL2 "全ての" (CODE1 "in-package") "の実行は"
     "トップレベルフォームにとして呼ばれたときは、" "コンパイル時もまた実行されます。")
    (CHAPTER ("## 例文") 2 "なし。")
    (CHAPTER ("## 副作用") 2 "変数" (CODE1 "*package*") "にに代入されます。" "もし" (CODE1 "in-package")
     "フォームがトップレベルフォームならば、" "代入はコンパイル時にも行われます。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "指定したパッケージが存在しないときは、" "型" (CODE1 "package-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "*package*")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("IN-PACKAGE" . "MACRO") *table*) (gethash "IN-PACKAGE" *table*))
(setf (gethash "INITIALIZE-INSTANCE" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "INITIALIZE-INSTANCE"))
    (CHAPTER ("## 構文") 2 (CODE1 "initialize-instance") " " (STRONG "instance") " &rest "
     (STRONG "initargs") " &key &allow-other-keys => " (STRONG "instance"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "initialize-instance") " (" (STRONG "instance") " "
     (CODE1 "standard-object") ") &rest " (STRONG "initargs"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "instance") " - オブジェクト" EOL1 (STRONG "initargs")
     " - デフォルトの初期化引数リスト")
    (CHAPTER ("## 定義") 2 "新しく作成された" (STRONG "instance") "を初期化するために、"
     (CODE1 "make-instance") "によって呼び出されます。" "ジェネリック関数は、新しい" (STRONG "instance") "と"
     "デフォルトの初期化引数リストで呼び出されます。" EOL2 (CODE1 "initialize-instance")
     "のシステムが提供するプライマリメソッドでは、" (STRONG "instance") "のスロットを、対応する" (STRONG "initargs")
     "の値と、" "スロットの" (CODE1 ":initform") "フォームで初期化します。" "これはジェネリック関数"
     (CODE1 "shared-initialize") "を" "次の引数で呼び出すことによって行われます。" (STRONG "instance") "、"
     (CODE1 "t") "（これは初期化引数が与えられないすべてのスロットが、" "それらの" (CODE1 ":initform")
     "フォームに従って初期化されるべきことを示します）、" "および" (STRONG "initargs") "です。" EOL2 "プログラマーは、"
     (CODE1 "initialize-instance") "にメソッドを定義して、"
     "インスタンスが初期化されたときに実行されるアクションを指定することができます。" "もし" (CODE1 "after") "メソッドのみが定義された場合、"
     "それらはシステムが提供するプライマリメソッドの初期化後に実行されるため、" (CODE1 "initialize-instance")
     "のデフォルトの動作を妨げることはありません。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "shared-initialize") "," (CODE1 "make-instance") ","
     (CODE1 "slot-boundp") "," (CODE1 "slot-makunbound") "," "7.1. オブジェクトの作成と初期化,"
     "7.1.4. 初期化引数の規則," "7.1.2. 初期化引数の有効性の宣言")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("INITIALIZE-INSTANCE" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "INITIALIZE-INSTANCE" *table*))
(setf (gethash "INLINE" *table*)
  '((CHAPTER NIL 0 "Declaration " (CODE1 "INLINE") ", " (CODE1 "NOTINLINE"))
    (CHAPTER ("## 構文") 2 "(" (CODE1 "inline") " " (STRONG "function-name\\*") ")" EOL1
     "(" (CODE1 "notinline") " " (STRONG "function-name\\*") ")")
    (CHAPTER ("## 引数") 2 (STRONG "function-name") " - 関数名")
    (CHAPTER ("## 有効な文脈") 2 (CODE1 "declare") "か" (CODE1 "proclaim"))
    (CHAPTER ("## 影響する束縛の型") 2 "関数")
    (CHAPTER ("## 定義") 2 (CODE1 "inline") "は、" (STRONG "function-name") "という名前の関数に対して、"
     "コンパイラーがインラインで呼び出すようなコードを" "生成するのが望ましいと指定します。" "つまり、" (STRONG "function-name")
     "で指定されたコードは、" "呼び出す処理を「行中」に現れるように、" "その場所に呼出処理を統合する必要があります。"
     "コンパイラーがこの宣言を無視するのは自由です。" (CODE1 "inline") "宣言は決して変数束縛を行いません。" EOL2
     "もしあるひとつの関数が宣言されており、" "その関数がレキシカルにローカル定義を持っているとき" "（" (CODE1 "flet") "か"
     (CODE1 "labels") "によって作成されたもの）、" "その宣言はグローバル関数定義ではなく、" "ローカルの関数定義の方に適用されます。" EOL2
     "もし仕様に適合した実装において、" "ユーザー定義関数のインラインの展開が要求されていないとき、" "これらの実装は下記の規範のように認識しようとします。" EOL2
     "定義された関数" (CODE1 "f") "は、標準では" (CODE1 "inline") "ではありません。" "しかし"
     (CODE1 "(declare (inline f))") "宣言内では" (CODE1 "F") "がローカルで" (CODE1 "inline")
     "になります。" "前のものも含めて定義の列が次のような場合を考えます。"
     (CODE3 "```lisp" "```" "(declaim (inline f))" "(defun f ...)"
      "(declaim (notinline f))")
     EOL2 (CODE1 "defun") "フォームの前にある" (CODE1 "inline") "の" (CODE1 "proclamation") "は、"
     "コンパイラーに、インライン展開が必要な時のための" "情報を保存する機会を保証します。" "そして" (CODE1 "defun") "フォームの後にある"
     (CODE1 "notinline") "の" (CODE1 "proclamation") "は、" (CODE1 "f")
     "がどこでもインライン展開しないよう抑制します。" EOL2 (CODE1 "notinline") "は、" (STRONG "function-name")
     "という名前の関数に対して、" "インラインコンパイルが望ましくないと指定します。" "コンパイラーはこの宣言を無視してはいけません。"
     "この指定の関数の呼び出しは、" "ラインの外のサブルーチンを呼び出すように実装しなければなりません。" EOL2 "もしあるひとつの関数が宣言されており、"
     "その関数がレキシカルにローカル定義を持っているとき" "（" (CODE1 "flet") "か" (CODE1 "labels") "によって作成されたもの）、"
     "その宣言はグローバル関数定義ではなく、ローカルの関数定義に適用されます。" EOL2 (STRONG "function-name")
     "コンパイラーマクロが現れたとき、" (CODE1 "notinline") "宣言はコンパイラーマクロの使用を禁止します。" (CODE1 "inline")
     "宣言はコンパイラーマクロの使用を勧めるようにします。" (CODE1 "inline") "と" (CODE1 "notinline") "宣言は、"
     "レキシカルに見える" (STRONG "function-name") "の定義が" "マクロ定義であったときは効果がありません。" EOL2
     (CODE1 "inline") "と" (CODE1 "notinline") "宣言は、自由宣言と境界宣言のどちらも使えます。" (CODE1 "flet")
     "か" (CODE1 "labels") "フォーム本体の前に現れた" "関数の" (CODE1 "inline") "と" (CODE1 "notinline")
     "宣言は、" "関数の境界宣言として定義されます。" "その他の文脈の宣言は自由宣言です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; グローバルに宣言された関数DISPATCHはオープンコードであり、"
      ";; もし実装がinlineをサポートしているのであれば、" ";; NOTINLINEの宣言をこの効果で上書きします。"
      "(declaim (inline dispatch))"
      "(defun dispatch (x) (funcall (get (car x) 'dispatch) x))" ";; これはinlineを推奨する例です。"
      "(defun top-level-1 () (dispatch (read-command)))" ";; これはinlineを禁止する例です。"
      "(defun top-level-2 ()" "  (declare (notinline dispatch))"
      "  (dispatch (read-command)))" ";; これはinlineを禁止する例です。"
      "(declaim (notinline dispatch))" "(defun top-level-3 () (dispatch (read-command)))"
      ";; これはinlineを推奨する例です。" "(defun top-level-4 () " "  (declare (inline dispatch))"
      "  (dispatch (read-command)))"))
    (CHAPTER ("## 参考") 2 (CODE1 "declare") "," (CODE1 "declaim") "," (CODE1 "proclaim"))))
(setf (gethash '("INLINE" . "DECLARATION") *table*) (gethash "INLINE" *table*))
(setf (gethash "INPUT-STREAM-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "INPUT-STREAM-P") ", " (CODE1 "OUTPUT-STREAM-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "input-stream-p") " " (STRONG "stream") " => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "output-stream-p") " " (STRONG "stream")
     " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream") " - ストリーム" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "input-stream-p") "は、" (STRONG "stream") "が入力ストリームのときは"
     (STRONG "true") "を、" "それ以外のときは" (STRONG "false") "を返却します。" EOL2
     (CODE1 "output-stream-p") "は、" (STRONG "stream") "が出力ストリームのときは" (STRONG "true") "を、"
     "それ以外のときは" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(input-stream-p *standard-input*) =>  true"
      "(input-stream-p *terminal-io*) =>  true"
      "(input-stream-p (make-string-output-stream)) =>  false" NIL
      "(output-stream-p *standard-output*) =>  true"
      "(output-stream-p *terminal-io*) =>  true"
      "(output-stream-p (make-string-input-stream \"jr\")) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "stream") "がストリームではないときは、" "型" (CODE1 "type-error")
     "のエラーを発生させるべきです。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("INPUT-STREAM-P" . "FUNCTION") *table*) (gethash "INPUT-STREAM-P" *table*))
(setf (gethash "INTERACTIVE-STREAM-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "INTERACTIVE-STREAM-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "interactive-stream-p") " " (STRONG "stream") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream") " - ストリーム" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "stream") "が対話式ストリームのときは" (STRONG "true") "を、"
     "それ以外のときは" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(when (> measured limit)"
      "  (let ((error (round (* (- measured limit) 100)" "                      limit)))"
      "    (unless (if (interactive-stream-p *query-io*)"
      "                (yes-or-no-p \"The frammis is out of tolerance by ~D%.~@"
      "                              Is it safe to proceed? \" error)"
      "                (< error 15))  ;15% is acceptable"
      "      (error \"The frammis is out of tolerance by ~D%.\" error))))"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "stream") "がストリームではないときは、" "型" (CODE1 "type-error")
     "のエラーを発生させるべきです。")
    (CHAPTER ("## 参考") 2 "21.1. ストリームの説明") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("INTERACTIVE-STREAM-P" . "FUNCTION") *table*) (gethash "INTERACTIVE-STREAM-P" *table*))
(setf (gethash "INTERN" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "INTERN"))
    (CHAPTER ("## 構文") 2 (CODE1 "intern") " " (STRONG "string") " " (CODE1 "&optional")
     " " (STRONG "package") " => " (STRONG "symbol") ", " (STRONG "status"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string") " - 文字列" EOL1 (STRONG "package")
     " - パッケージ指定子。デフォルトは現在のパッケージ。" EOL1 (STRONG "symbol") " - シンボル" EOL1
     (STRONG "status") " - 次のうちのどれか、" (CODE1 ":inherited") ", " (CODE1 ":external") ", "
     (CODE1 ":internal") ", " (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "intern") "は、" (STRONG "package") "に" (STRONG "string")
     "という名前のシンボルを挿入します。" "もし" (STRONG "package") "に" (STRONG "string") "という同じ名前のシンボルが"
     "すでにアクセス可能であったときは、それが返却されます。" (STRONG "package") "にそのようなシンボルがアクセス可能になっていないときは、"
     "新しいシンボルを指定した名前で作成し、" (STRONG "package") "へ内部シンボルとして挿入するか、" "もし" (STRONG "package")
     "が" (CODE1 "KEYWORD") "パッケージであったときは" "外部シンボルとして挿入します。" "作成されたシンボルのホームパッケージは"
     (STRONG "package") "になります。" EOL2 (CODE1 "intern") "の最初の返却値" (STRONG "symbol") "は"
     "検索されたものか作成されたシンボルです。" "2番目の返却値" (STRONG "status") "は次の値になります。" EOL2 "- "
     (CODE1 ":internal") "  - シンボルは" (STRONG "package") "に内部シンボルとしてあるものが見つかった。"
     "    <br><br>" EOL2 "- " (CODE1 ":external") "  - シンボルは外部シンボルとしてあるものが見つかった。"
     "    <br><br>" EOL2 "- " (CODE1 ":inherited") "  - シンボルは" (CODE1 "use-package")
     "経由で継承されているものが見つかった" "  （これはシンボルが内部のものであることを意味します）。" "    <br><br>" EOL2 "- "
     (CODE1 "nil") "  - シンボルは見つからなかったので作成した。" "    <br><br>" "    新しいシンボルの名前が"
     (STRONG "string") "になるかそれのコピーになるかは" "    実装依存です。" "    このような新しくシンボルが作成された状況で"
     "    いったん文字列が" (CODE1 "intern") "の引数" (STRONG "string") "のとして与えらえれたとき、"
     "    続いてその文字列を変更しようとしたときの結果は未定義です。" "    <br><br>")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(in-package \"COMMON-LISP-USER\") =>  #<PACKAGE \"COMMON-LISP-USER\">"
      "(intern \"Never-Before\") =>  |Never-Before|, NIL"
      "(intern \"Never-Before\") =>  |Never-Before|, :INTERNAL "
      "(intern \"NEVER-BEFORE\" \"KEYWORD\") =>  :NEVER-BEFORE, NIL"
      "(intern \"NEVER-BEFORE\" \"KEYWORD\") =>  :NEVER-BEFORE, :EXTERNAL"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "find-symbol") "," (CODE1 "read") "," (CODE1 "symbol")
     "," (CODE1 "unintern") "," "2.3.4. トークンとしてのシンボル")
    (CHAPTER ("## 備考") 2 (CODE1 "intern") "が名前の衝突チェックを行う必要はなく、"
     "なぜなら指定した名前のシンボルがすでにアクセス可能であるときに" "新しいシンボルを作成するようなことはないからです。")))
(setf (gethash '("INTERN" . "FUNCTION") *table*) (gethash "INTERN" *table*))
(setf (gethash "INTERSECTION" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "INTERSECTION") ", " (CODE1 "NINTERSECTION"))
    (CHAPTER ("## 構文") 2 (CODE1 "intersection") " " (STRONG "list-1") " "
     (STRONG "list-2") " &key " (STRONG "key") " " (STRONG "test") " "
     (STRONG "test-not") " => " (STRONG "result-list") EOL1 (CODE1 "nintersection") " "
     (STRONG "list-1") " " (STRONG "list-2") " &key " (STRONG "key") " " (STRONG "test")
     " " (STRONG "test-not") " => " (STRONG "result-list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list-1") " - 通常のリスト" EOL1 (STRONG "list-2")
     " - 通常のリスト" EOL1 (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test-not") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "result-list") " - リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "intersection") "と" (CODE1 "nintersection") "は、"
     (STRONG "list-1") "と" (STRONG "list-2") "の両方に含まれるすべての要素を含むリストを返却します。" EOL2
     (CODE1 "nintersection") "は、" (CODE1 "intersection") "の破壊的バージョンです。" "それは同じ操作を行いますが、"
     (STRONG "list-1") "はそのセルを使って結果を構築するときに、" "破壊するかもしれません。" (STRONG "list-2")
     "は破壊されません。" EOL2 (CODE1 "intersection") "の操作は、次のように定義されます。" (STRONG "list-1")
     "のひとつの要素と、" (STRONG "list-2") "のひとつの要素からなる、" "全ての順序付けされたペアに対して、" (CODE1 ":test") "か"
     (CODE1 ":test-not") "を使ってテストが満たされるかどうかを決定します。" (CODE1 ":test") "か"
     (CODE1 ":test-not") "の関数の最初の要素は" (STRONG "list-1") "の要素であり、" "二番目の引数は"
     (STRONG "list-2") "の要素です。" "もし" (CODE1 ":test") "と" (CODE1 ":test-not")
     "が指定されなかったときは、" (CODE1 "eql") "を使用します。" "もし同じ関数呼び出し内において、" (CODE1 ":test") "と"
     (CODE1 ":test-not") "の両方が指定された場合はエラーです。" EOL2 "もし" (CODE1 ":key") "に" (CODE1 "nil")
     "ではない値で与えられたときは、" "リストの要素をテストする部分を引き出すときに使われます。" (CODE1 ":key") "関数の引数は、"
     (STRONG "list-1") "か" (STRONG "list-2") "の要素であり、" (CODE1 ":key")
     "関数は通常与えられた要素の部分を返却します。" "もし" (CODE1 ":key") "が与えられないか、あるいは" (CODE1 "nil")
     "が指定されたとき、" (STRONG "list-1") "と" (STRONG "list-2") "の要素が使われます。" EOL2
     "テストが満たされたすべてのペアは、" "そのペアの2つの要素のうち正確にひとつが結果に格納されます。" "どちらかのリストのある要素と、"
     "他方のリストとのテストが満たされなかったときは、" "その要素は結果のリストに現れません。" "もしリストのいずれかに重複する要素がある場合、"
     "結果には重複が生じるかもしれません。" EOL2 "どんな方法で引数の順番を変えたとしても、" "結果の要素の順番に反映できる保証はありません。"
     "結果のリストは、適切であれば、" (STRONG "list-1") "か" (STRONG "list-2") "のどちらかとセルを共有するか、" "あるいは"
     (CODE1 "eq") "になる可能性があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq list1 (list 1 1 2 3 4 a b c \"A\" \"B\" \"C\" \"d\")"
      "      list2 (list 1 4 5 b c d \"a\" \"B\" \"c\" \"D\")) "
      " =>  (1 4 5 B C D \"a\" \"B\" \"c\" \"D\")"
      "(intersection list1 list2) =>  (C B 4 1 1)"
      "(intersection list1 list2 :test 'equal) =>  (\"B\" C B 4 1 1)"
      "(intersection list1 list2 :test #'equalp) =>  (\"d\" \"C\" \"B\" \"A\" C B 4 1 1) "
      "(nintersection list1 list2) =>  (1 1 4 B C)"
      "list1 =>  implementation-dependent ;e.g.,  (1 1 4 B C)"
      "list2 =>  implementation-dependent ;e.g.,  (1 4 5 B C D \"a\" \"B\" \"c\" \"D\")"
      "(setq list1 (copy-list '((1 . 2) (2 . 3) (3 . 4) (4 . 5))))"
      "=>  ((1 . 2) (2 . 3) (3 . 4) (4 . 5)) "
      "(setq list2 (copy-list '((1 . 3) (2 . 4) (3 . 6) (4 . 8))))"
      "=>  ((1 . 3) (2 . 4) (3 . 6) (4 . 8)) "
      "(nintersection list1 list2 :key #'cdr) =>  ((2 . 3) (3 . 4)) "
      "list1 =>  implementation-dependent ;e.g.,  ((1 . 2) (2 . 3) (3 . 4)) "
      "list2 =>  implementation-dependent ;e.g.,  ((1 . 3) (2 . 4) (3 . 6) (4 . 8)) "))
    (CHAPTER ("## 副作用") 2 (CODE1 "nintersection") "は" (STRONG "list-1") "を変更できますが、"
     (STRONG "list-2") "はそうではありません。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list-1") "と" (STRONG "list-2") "が通常のリストではないとき、" "型"
     (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "union") "," "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 (CODE1 "nintersection")
     "の副作用は必要ないため、" "移植可能なコードにおいては副作用のみを期待した姿勢で使うべきではありません。")))
(setf (gethash '("INTERSECTION" . "FUNCTION") *table*) (gethash "INTERSECTION" *table*))
(setf (gethash "INVALID-METHOD-ERROR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "INVALID-METHOD-ERROR"))
    (CHAPTER ("## 構文") 2 (CODE1 "invalid-method-error") " " (STRONG "method") " "
     (STRONG "format-control") " " (CODE1 "&rest") " " (STRONG "args") " => 実装依存")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "method") " - メソッド" EOL1 (STRONG "format-control")
     " - format-control" EOL1 (STRONG "args") " - " (STRONG "format-control") "に対応する"
     (CODE1 "format") "の引数")
    (CHAPTER ("## 定義") 2 (CODE1 "invalid-method-error") "関数は、" "適用可能な" (STRONG "method")
     "の修飾子が、" (CODE1 "method-combination") "の型に対して有効ではなかったとき、" "型" (CODE1 "error")
     "のエラーを通知する際に使用します。" "エラーメッセージは、" (STRONG "format-control") "と" (STRONG "args") "を"
     (CODE1 "format") "に使って構築します。" "実装はエラーメッセージに追加で文脈的な情報を" "追加する必要があるかもしれないので、"
     (CODE1 "invalid-method-error") "は" (CODE1 "method-combination") "関数の"
     "動的エクステント内でのみ呼び出すことができます。" EOL2 "あるメソッドが" (CODE1 "define-method-combination")
     "フォームの" "全ての修飾子か" (CODE1 "predicate") "を満たさなかったときは、" "自動的に"
     (CODE1 "invalid-method-error") "関数が呼ばれます。" (CODE1 "method-combination") "関数は、"
     "もし適用できないメソッドに遭遇した場合は、" "明確に" (CODE1 "invalid-method-error") "を呼び出さなければならないという"
     "追加の制約があることを意味しています。" EOL2 (CODE1 "invalid-method-error") "が呼び出し元へ戻るのか、" "あるいは"
     (CODE1 "throw") "を経由して退出するかどうかは、" "実装依存です。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "デバッガーに入るかもしれません。")
    (CHAPTER ("## 影響") 2 (CODE1 "*break-on-signals*")) (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "define-method-combination")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("INVALID-METHOD-ERROR" . "FUNCTION") *table*) (gethash "INVALID-METHOD-ERROR" *table*))
(setf (gethash "INVOKE-DEBUGGER" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "INVOKE-DEBUGGER"))
    (CHAPTER ("## 構文") 2 (CODE1 "invoke-debugger") " " (STRONG "condition") " => "
     (CODE1 "|"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "condition") " - コンディションオブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "invoke-debugger") "は、" (STRONG "condition")
     "とともにデバッガーへ入ろうと試みます。" EOL2 "もし" (CODE1 "*debugger-hook*") "が" (CODE1 "nil")
     "ではないとき、" "その値は関数（あるいは関数の名前）で無ければならず、" "標準のデバッガーに入る前に呼び出されます。" "その関数が呼び出されるときに"
     (CODE1 "*debugger-hook*") "には" (CODE1 "nil") "が束縛され、" "その関数は2つの引数として"
     (STRONG "condition") "と、" (CODE1 "nil") "を束縛する前の" (CODE1 "*debugger-hook*")
     "の値が渡されます。" "もしその関数が普通に終わったとき、標準のデバッガーに入ります。" EOL2 "標準のデバッガーは決して直接戻りません。" "戻るときは、"
     (CODE1 "restart") "関数を使用したような" "ただ非局所的な遷移の制御のみで起こります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(ignore-errors ;通常はデバッガーに入るのを抑制する"
      "  (handler-bind ((error #'invoke-debugger)) ;しかしここは強制的にデバッガーに入る"
      "    (error \"Foo.\")))" "Debug: Foo."
      "To continue, type :CONTINUE followed by an option number:"
      " 1: Return to Lisp Toplevel." "Debug>"))
    (CHAPTER ("## 副作用") 2 (CODE1 "*debugger-hook*") "は" (CODE1 "nil") "に束縛され、"
     "プログラムの実行は中止となり、" "デバッガーに入ります。")
    (CHAPTER ("## 影響") 2 (CODE1 "*debug-io*") "," (CODE1 "*debugger-hook*") ",")
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "error") "," (CODE1 "break"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("INVOKE-DEBUGGER" . "FUNCTION") *table*) (gethash "INVOKE-DEBUGGER" *table*))
(setf (gethash "INVOKE-RESTART" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "INVOKE-RESTART"))
    (CHAPTER ("## 構文") 2 (CODE1 "invoke-restart") " " (STRONG "restart") " "
     (CODE1 "&rest") " " (STRONG "arguments") " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "restart") " - " (CODE1 "restart") "指定子" EOL1
     (STRONG "argument") " - オブジェクト" EOL1 (STRONG "result") " - " (STRONG "restart")
     "に関係づいた関数による返却値（もしあるなら）。")
    (CHAPTER ("## 定義") 2 (STRONG "restart") "に関連づいた関数を引数" (STRONG "arguments")
     "とともに呼び出します。" (STRONG "restart") "は現在の動的環境下で有効なものでなければなりません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun add3 (x) (check-type x number) (+ x 3))" NIL
      "(foo 'seven)" ">>  Error: The value SEVEN was not of type NUMBER."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Specify a different value to use." ">>   2: Return to Lisp Toplevel."
      ">>  Debug> (invoke-restart 'store-value 7)" "=>  10"))
    (CHAPTER ("## 副作用") 2 (CODE1 "restart") "によって非局所的な背にの制御が行われるかもしれません。")
    (CHAPTER ("## 影響") 2 "存在する" (CODE1 "restart") "。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "restart") "が有効でないときは、" "型" (CODE1 "control-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "find-restart") "," (CODE1 "restart-bind") ","
     (CODE1 "restart-case") "," (CODE1 "invoke-restart-interactively"))
    (CHAPTER ("## 備考") 2 "もっとも一般的には、" (CODE1 "invoke-restart") "はハンドラーの中で使用されます。"
     "それは明示的に使用されるかもしれませんし、" "または暗黙的に" (CODE1 "invoke-restart-interactively") "か"
     (CODE1 "restart") "関数を通して使用されるかもしれません。" EOL2 (CODE1 "restart") "関数あは"
     (CODE1 "invoke-restart") "を呼び出しますし、" "逆もまた成り立ちます。" "これは、" (CODE1 "invoke-restart")
     "が原始的な機能を提供しており、" (CODE1 "restasrt") "関数は本質ではない「糖衣構文」です。")))
(setf (gethash '("INVOKE-RESTART" . "FUNCTION") *table*) (gethash "INVOKE-RESTART" *table*))
(setf (gethash "INVOKE-RESTART-INTERACTIVELY" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "INVOKE-RESTART-INTERACTIVELY"))
    (CHAPTER ("## 構文") 2 (CODE1 "invoke-restart-interactively") " " (STRONG "restart")
     " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "restart") " - " (CODE1 "restart") "指定子" EOL1
     (STRONG "result") " - " (STRONG "restart") "に関係づいた関数による返却値（もしあるなら）。")
    (CHAPTER ("## 定義") 2 (CODE1 "invoke-restart-interactively") "は、" (CODE1 "restart")
     "に関連づいた関数を呼び出し、" "呼び出しに必要な引数はプロンプトによって問い合わせます。" (STRONG "restart")
     "は現在の動的環境下で有効なものでなければなりません。" EOL2 (CODE1 "invoke-restart-interactively") "は、"
     "引数の問い合わせを" (CODE1 "restart-case") "の" (CODE1 ":interactive") "キーワードか、"
     (CODE1 "restart-bind") "の" (CODE1 ":interactive-function") "キーワードで"
     "提供されたコードを実行することで行います。" EOL2 "もしそのようなオプションが" "対応する" (CODE1 "restart-bind") "と"
     (CODE1 "restart-case") "に" "指定されなかったときは、" "もし" (CODE1 "restart")
     "が要求引数を取っていたときの結果は未定義です。" "もし引数がオプションであるときは、" "リストの" (CODE1 "nil") "が使用されます。" EOL2
     "いったん引数が決定すると、" (CODE1 "invoke-restart-interactively") "は" "次のように実行を行います。"
     (CODE3 "```lisp" "```" "(apply #'invoke-restart restart arguments)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun add3 (x) (check-type x number) (+ x 3))" NIL
      "(add3 'seven)" ">>  Error: The value SEVEN was not of type NUMBER."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Specify a different value to use." ">>   2: Return to Lisp Toplevel."
      ">>  Debug> (invoke-restart-interactively 'store-value)"
      ">>  Type a form to evaluate and use: 7" "=>  10"))
    (CHAPTER ("## 副作用") 2 "もし必要な引数の問い合わせが生じると、" "キーボードなどのタイプによる入力が生じます（"
     (CODE1 "query-io") "上で）。" EOL2 (CODE1 "restart") "によって非局所的な遷移の制御が行われるかもしれません。")
    (CHAPTER ("## 影響") 2 (CODE1 "*query-io*") EOL2 "有効な" (CODE1 "restart"))
    (CHAPTER ("## 例外") 2 (STRONG "restart") "が有効なものでないときは、" "型" (CODE1 "control-error")
     "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 (CODE1 "find-restart") "," (CODE1 "invoke-restart") ","
     (CODE1 "restart-case") "," (CODE1 "restart-bind"))
    (CHAPTER ("## 備考") 2 (CODE1 "invoke-restart-interactively") "は" "デバッガーの内部で使用されますし、"
     "他の移植可能な対話式デバッグツールが実装されて、" "使用されるかもしれません。")))
(setf (gethash '("INVOKE-RESTART-INTERACTIVELY" . "FUNCTION") *table*) (gethash "INVOKE-RESTART-INTERACTIVELY" *table*))
(setf (gethash "KEYWORD" *table*)
  '((CHAPTER NIL 0 "Type " (CODE1 "KEYWORD"))
    (CHAPTER ("## スーパータイプ") 2 (CODE1 "keyword") "," (CODE1 "symbol") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "keyword") "は、" (CODE1 "KEYWORD") "パッケージに"
     (CODE1 "intern") "されている" "全てのシンボルを含みます。" EOL2 (CODE1 "KEYWORD") "パッケージにシンボルを"
     (CODE1 "intern") "すると、" "自動的に次の3つの効果が得られます。" EOL2 "1. シンボルは自分自身を束縛する" "2. シンボルは"
     (CODE1 "KEYWORD") "パッケージの外部シンボルになる" "3. シンボルは定数の変数になる")
    (CHAPTER ("## 参考") 2 (CODE1 "keywordp"))))
(setf (gethash '("KEYWORD" . "TYPE") *table*) (gethash "KEYWORD" *table*))
(setf (gethash "KEYWORDP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "KEYWORDP"))
    (CHAPTER ("## 構文") 2 (CODE1 "keywordp") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "もし" (STRONG "object") "が型" (CODE1 "keyword") "なら"
     (STRONG "true") "を、" "それ以外なら" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(keywordp 'elephant) =>  false" "(keywordp 12) =>  false"
      "(keywordp :test) =>  true" "(keywordp ':test) =>  true" "(keywordp nil) =>  false"
      "(keywordp :nil) =>  true" "(keywordp '(:test)) =>  false"
      "(keywordp \"hello\") =>  false" "(keywordp \":hello\") =>  false"
      "(keywordp '&optional) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "constantp") "," (CODE1 "keyword") "," (CODE1 "symbolp")
     "," (CODE1 "symbol-package"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("KEYWORDP" . "FUNCTION") *table*) (gethash "KEYWORDP" *table*))
(setf (gethash "LABELS" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "FLET") ", " (CODE1 "LABELS") ", "
     (CODE1 "MACROLET"))
    (CHAPTER ("## 構文") 2 (CODE1 "flet") " ((" (STRONG "function-name") " "
     (STRONG "lambda-list") " [[" (STRONG "local-declaration\\*") " " (CODE1 "|") " "
     (STRONG "local-documentation") "]] " (STRONG "local-form\\*") ")\\*)" " "
     (STRONG "declaration\\*") " " (STRONG "form\\*") EOL1 "=> " (STRONG "result\\*")
     EOL2 (CODE1 "labels") " ((" (STRONG "function-name") " " (STRONG "lambda-list")
     " [[" (STRONG "local-declaration\\*") " " (CODE1 "|") " "
     (STRONG "local-documentation") "]] " (STRONG "local-form\\*") ")\\*)" " "
     (STRONG "declaration") " " (STRONG "form\\*") " " (STRONG "declaration\\*") " "
     (STRONG "form\\*") EOL1 "=> " (STRONG "result\\*") EOL2 (CODE1 "macrolet") " (("
     (STRONG "name") " " (STRONG "lambda-list") " [[" (STRONG "local-declaration\\*") " "
     (CODE1 "|") " " (STRONG "local-documentation") "]] " (STRONG "local-form\\*")
     ")\\*)" " " (STRONG "declaration\\*") " " (STRONG "form\\*") EOL1 "=> "
     (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function-name") " - 関数名" EOL1 (STRONG "name")
     " - シンボル" EOL1 (STRONG "lambda-list") " - ラムダリスト。" (CODE1 "flet") "と"
     (CODE1 "labels") "は通常のラムダリスト。" (CODE1 "macrolet") "はマクロラムダリスト。" EOL1
     (STRONG "local-declaration") " - 宣言式。評価されません。" EOL1 (STRONG "declaration")
     " - 宣言式。評価されません。" EOL1 (STRONG "local-documentation") " - 文字列。評価されません。" EOL1
     (STRONG "local-form") ", " (STRONG "form") " - 暗黙のprogn" EOL1 (STRONG "result")
     " - " (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "flet") "、" (CODE1 "labels") "、" (CODE1 "macrolet") "は、"
     "ローカル関数とローカルマクロを定義し、" "そのローカルな定義を使い" (STRONG "form") "を実行します。" (STRONG "form")
     "は、現れた順に実行します。" EOL2 (CODE1 "flet") "と" (CODE1 "labels") "によって作成された各関数と、"
     (CODE1 "macrolet") "によって作成された各マクロの" "それぞれのボディ部の" (STRONG "form") "（ただしラムダリストは除く）は、"
     "必要に応じて、" (STRONG "function-name") "の関数の" (CODE1 "block") "名か" (STRONG "name")
     "を用いて、" "暗黙の" (CODE1 "block") "に囲まれます。" EOL2 "ローカル関数とマクロの定義部のリストと、" (CODE1 "flet")
     "および" (CODE1 "labels") "のボディ部" (STRONG "form") "間における" (STRONG "declaration")
     "のスコープは、" "ローカルの関数定義の本体が含まれません。" "ただし例外は" (CODE1 "labels") "の、" (CODE1 "inline") "、"
     (CODE1 "notinline") "、" (CODE1 "ftype") "宣言であり、" "これらはローカルの関数定義を参照し、"
     "そのローカル関数の本体に適用します。" "つまり、これらの宣言のスコープは、" "関数名として影響を与える範囲と同じです。" "これらの"
     (STRONG "declaration") "のスコープには、" (CODE1 "macrolet") "で定義されたマクロ展開数の本体は含まれません。" EOL2
     "- " (CODE1 "flet") "  - " (CODE1 "flet") "は、ローカルに名前がある関数を定義し、"
     "    それらの定義を束縛とともに一連の" (STRONG "form") "を実行します。" "    そのようなローカル関数はいくつでも定義できます。"
     "    <br><br>" "    名前が束縛されたスコープは、ただボディ部のみ含まれます。" "    " (CODE1 "flet") "のボディ部内では、"
     "    " (CODE1 "flet") "によって定義された" (STRONG "function-name") "という名前は、"
     "    同名のグローバルに宣言されたものではなく、" "    ローカルに宣言された関数が参照されます。" "    " (CODE1 "flet")
     "のスコープ内では、" "    " (CODE1 "flet") "によって定義されている" "    " (STRONG "function-name")
     "という名前の、" "    グローバルのsetf-expanderの定義は適用されません。" "    これは、"
     (CODE1 "(defmethod (setf f) ...)") "ではなく、" "    " (CODE1 "(defsetf f ...)")
     "に適用されることに注意してください。" "    <br><br>" "    " (CODE1 "flet")
     "によって定義された関数名は、レキシカルな環境内のものであり、" "    それらのローカルな定義は、ただ" (CODE1 "flet")
     "本体内でのみ保持されます。" "    関数定義の束縛は、" (CODE1 "flet") "本体でのみ見ることができ、"
     "    それらの定義自身では見ることができません。" "    関数定義内において、" "    ローカルの関数名で定義されているものを探すときは、" "    "
     (CODE1 "flet") "の外側で定義された関数かマクロが参照されます。" "    " (CODE1 "flet")
     "は、局所的にグローバル関数名を隠蔽することができ、" "    その新しい定義は、グローバルな定義を参照することができます。" "    <br><br>"
     "    どんな" (STRONG "local-documentation") "も、" "    対応するローカル関数（もし実際に作成されたとき）に、"
     "    ドキュメント文字として割り当てます。" "    <br><br>" EOL2 "- " (CODE1 "labels") "  - "
     (CODE1 "labels") "は、" (CODE1 "flet") "と同じですが、" "    " (CODE1 "labels")
     "の場合は定義された関数名のスコープが、" "    ボディ部と同じように関数定義自身にも囲まれるところが違っています。" "    <br><br>" EOL2
     "- " (CODE1 "macrolet") "  - " (CODE1 "macrolet") "は、" (CODE1 "defmacro")
     "と同じフォーマットで、" "    ローカルマクロの定義を確立します。" "    <br><br>" "    " (CODE1 "macrolet")
     "の内部では、" "    " (CODE1 "macrolet") "によって定義されている" "    " (STRONG "function-name")
     "という名前の、" "    グローバルのsetf-expanderの定義は適用されません。" "    そうではなく、" (CODE1 "setf")
     "はマクロフォームを展開し、" "    結果のフォームを再帰的に処理します。" "    <br><br>" "    " (CODE1 "macrolet")
     "によって定義されたマクロ展開関数は、" "    " (CODE1 "macrolet") "のフォームに現れる、"
     "    レキシカルな環境によって定義されたものです。" "    宣言と、" (CODE1 "macrolet") "と"
     (CODE1 "symbol-macrolet") "の定義は、" "    " (CODE1 "macrolet") "内の、ローカルマクロ定義に影響を及ぼします。"
     "    しかしもしローカルマクロ定義から" "    レキシカルな環境内で見ることができる" "    ローカルな変数か関数を参照したときの結果は未定義です。"
     "    <br><br>" "    どんな" (STRONG "local-documentation") "も、" "    対応するローカルマクロ関数に、"
     "    ドキュメント文字として割り当てます。" "    <br><br>")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun foo (x flag)" "  (macrolet ((fudge (z)"
      "                ; パラメーターxとflagはこの時点ではアクセス不可です。"
      "                ; flagの参照はグローバル変数の名前になります。"
      "                ` (if flag (* ,z ,z) ,z)))" "   ; パラメーターxとflagは、ここではアクセス可能です。"
      "    (+ x" "       (fudge x)" "       (fudge (+ x 1)))))" "== "
      "(defun foo (x flag)" "  (+ x" "     (if flag (* x x) x)"
      "     (if flag (* (+ x 1) (+ x 1)) (+ x 1))))")
     EOL2 "これは、マクロ展開が行われた後です。" (CODE1 "x") "と" (CODE1 "flag") "の発生は、" "関数" (CODE1 "foo")
     "のパラメータを合法的に参照しています。" "なぜなら、これらのパラメータは、" "マクロが呼ばれて展開が生成された場所では" "見ることができるからです。"
     (CODE3 "```lisp" "```" "(flet ((flet1 (n) (+ n n)))"
      "   (flet ((flet1 (n) (+ 2 (flet1 n))))" "     (flet1 2))) =>  6" NIL
      "(defun dummy-function () 'top-level) =>  DUMMY-FUNCTION "
      "(funcall #'dummy-function) =>  TOP-LEVEL " "(flet ((dummy-function () 'shadow)) "
      "     (funcall #'dummy-function)) =>  SHADOW "
      "(eq (funcall #'dummy-function) (funcall 'dummy-function))" "=>  true "
      "(flet ((dummy-function () 'shadow))" "  (eq (funcall #'dummy-function)"
      "      (funcall 'dummy-function)))" "=>  false " NIL "(defun recursive-times (k n)"
      "  (labels ((temp (n) " "             (if (zerop n) 0 (+ k (temp (1- n))))))"
      "    (temp n))) =>  RECURSIVE-TIMES" "(recursive-times 2 3) =>  6" NIL
      "(defmacro mlets (x &environment env) " "   (let ((form `(babbit ,x)))"
      "     (macroexpand form env))) =>  MLETS"
      "(macrolet ((babbit (z) `(+ ,z ,z))) (mlets 5)) =>  10"
      "(flet ((safesqrt (x) (sqrt (abs x))))" " ;; `safesqrt`関数は、二か所で使用されます。"
      "  (safesqrt (apply #'+ (map 'list #'safesqrt '(1 2 3 4 5 6)))))" "=>  3.291173"
      "(defun integer-power (n k)     " "  (declare (integer n))         "
      "  (declare (type (integer 0 *) k))" "  (labels ((expt0 (x k a)"
      "             (declare (integer x a) (type (integer 0 *) k))"
      "             (cond ((zerop k) a)"
      "                   ((evenp k) (expt1 (* x x) (floor k 2) a))"
      "                   (t (expt0 (* x x) (floor k 2) (* x a)))))"
      "           (expt1 (x k a)"
      "             (declare (integer x a) (type (integer 0 *) k))"
      "             (cond ((evenp k) (expt1 (* x x) (floor k 2) a))"
      "                   (t (expt0 (* x x) (floor k 2) (* x a))))))"
      "   (expt0 n k 1))) =>  INTEGER-POWER" "(defun example (y l)"
      "  (flet ((attach (x)" "           (setq l (append l (list x)))))"
      "    (declare (inline attach))" "    (dolist (x y)" "      (unless (null (cdr x))"
      "        (attach x)))" "    l))" NIL
      "(example '((a apple apricot) (b banana) (c cherry) (d) (e))"
      "         '((1) (2) (3) (4 2) (5) (6 3 2)))"
      "=>  ((1) (2) (3) (4 2) (5) (6 3 2) (A APPLE APRICOT) (B BANANA) (C CHERRY))"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "declare") "," (CODE1 "defmacro") "," (CODE1 "defun") ","
     (CODE1 "documentation") "," (CODE1 "let") "," "3.1. 評価,"
     "3.4.11. ドキュメント文字と宣言の文脈的な作用")
    (CHAPTER ("## 備考") 2 (CODE1 "flet") "では、再帰関数を定義することはできません。" (CODE1 "labels")
     "は、互いに再帰呼出できる関数を定義するのに使うことができます。" EOL2 "もし" (CODE1 "macrolet") "がトップレベルフォームのとき、"
     "ボディ部" (STRONG "form") "もまたトップレベルフォームとして処理されます。" "3.2.3. ファイルのコンパイルをご確認ください。")))
(setf (gethash '("LABELS" . "SPECIAL-OPERATOR") *table*) (gethash "LABELS" *table*))
(setf (gethash "LAMBDA" *table*)
  '("LAMBDA MACRO" EOL1 "LAMBDA SYMBOL" EOL1))
(setf (gethash '("LAMBDA" . "MACRO") *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "LAMBDA"))
    (CHAPTER ("## 構文") 2 (CODE1 "lambda") " " (STRONG "lambda-list") " [["
     (STRONG "declaration\\*") " " (CODE1 "|") " " (STRONG "documentation") "]] "
     (STRONG "form\\*") " => " (STRONG "function"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "lambda-list") " - 通常のラムダリスト" EOL1
     (STRONG "declaration") " - 宣言式。評価されません。" EOL1 (STRONG "documentation")
     " - 文字列。評価されません。" EOL1 (STRONG "form") " - フォーム" EOL1 "function - 関数")
    (CHAPTER ("## 定義") 2 "ラムダ式を呼び出すための" (CODE1 "function") "の特殊フォームの" "短縮形を提供します。"
     (CODE3 "```lisp" "```"
      "   (lambda lambda-list [[declaration* | documentation]] form*)"
      "==  (function (lambda lambda-list [[declaration* | documentation]] form*))"
      "==  #'(lambda lambda-list [[declaration* | documentation]] form*)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(funcall (lambda (x) (+ x 3)) 4) =>  7"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "lambda") "（シンボル）")
    (CHAPTER ("## 備考") 2 "このマクロは下記のように定義できます。"
     (CODE3 "```lisp" "```" "(defmacro lambda (&whole form &rest bvl-decls-and-body)"
      "  (declare (ignore bvl-decls-and-body))" "  `#',form)"))))
(setf (gethash '("LAMBDA" . "SYMBOL") *table*)
  '((CHAPTER NIL 0 "Symbol " (CODE1 "LAMBDA"))
    (CHAPTER ("## 構文") 2 (CODE1 "lambda") " " (STRONG "lambda-list") " [["
     (STRONG "declaration\\*") " " (CODE1 "|") " " (STRONG "documentation") "]] "
     (STRONG "form\\*"))
    (CHAPTER ("## 引数") 2 (STRONG "lambda-list") " - 通常のラムダリスト" EOL1
     (STRONG "declaration") " - 宣言式。評価されません。" EOL1 (STRONG "documentation")
     " - 文字列。評価されません。" EOL1 (STRONG "form") " - フォーム")
    (CHAPTER ("## 定義") 2 "ラムダ式とはリストであり、" "関数名を配置するという特定の文脈下で、" "間接的に確立された関数名を参照するのではなく、"
     "直接その振る舞いを定義することで関数を表すことができます。" EOL2 (STRONG "documentation") "は実際に生成された"
     (STRONG "function") "に対して、" "ドキュメント文字を割り当てます。")
    (CHAPTER ("## 参考") 2 (CODE1 "function") "," (CODE1 "documentation") ","
     "3.1.3. ラムダ式," "3.1.2.1.2.4. ラムダフォーム," "3.4.11. ドキュメント文字と宣言の文脈的な作用")
    (CHAPTER ("## 備考") 2 "下記のようなラムダフォームは、"
     (CODE3 "```lisp" "```" "((lambda lambda-list . body) . arguments)") EOL2
     "意味的には次のフォームと同等です。"
     (CODE3 "```lisp" "```" "(funcall #'(lambda lambda-list . body) . arguments)"))))
(setf (gethash "LAMBDA-LIST-KEYWORDS" *table*)
  '((CHAPTER NIL 0 "Constant Variable " (CODE1 "LAMBDA-LIST-KEYWORDS"))
    (CHAPTER ("## 定数値") 2 "リストであり、その要素は実装依存です。" "しかし、少なくとも次のシンボルは含める必要があります。"
     (CODE1 "&allow-other-keys") ", " (CODE1 "&aux") ", " (CODE1 "&body") ", "
     (CODE1 "&environment") "," (CODE1 "&key") ", " (CODE1 "&optional") ", "
     (CODE1 "&rest") ", " (CODE1 "&whole") "。")
    (CHAPTER ("## 定義") 2 "実装で使われるすべてのラムダリストキーワードのリストです。" "マクロ定義フォームでのみ使われるものも追加で含まれます。")
    (CHAPTER ("## 例文") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "defun") "," (CODE1 "flet") "," (CODE1 "defmacro") ","
     (CODE1 "macrolet") "," "3.1.2. 評価の規範")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("LAMBDA-LIST-KEYWORDS" . "CONSTANT-VARIABLE") *table*) (gethash "LAMBDA-LIST-KEYWORDS" *table*))
(setf (gethash "LAMBDA-PARAMETERS-LIMIT" *table*)
  '((CHAPTER NIL 0 "Constant Variable " (CODE1 "LAMBDA-PARAMETERS-LIMIT"))
    (CHAPTER ("## 定数値") 2 "実装依存であり、" (CODE1 "50") "より小さくはありません。")
    (CHAPTER ("## Description:") 2 "正の整数であり、" "ひとつのラムダリストに現れることができる、"
     "パラメーターの名前の数の排他的上限値です。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "call-arguments-limit"))
    (CHAPTER ("## 備考") 2 "実装は、" (CODE1 "lambda-parameters-limit") "の値を"
     "可能な限り大きくすることをお勧めします。")))
(setf (gethash '("LAMBDA-PARAMETERS-LIMIT" . "CONSTANT-VARIABLE") *table*) (gethash "LAMBDA-PARAMETERS-LIMIT" *table*))
(setf (gethash "LAST" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "LAST"))
    (CHAPTER ("## 構文") 2 (CODE1 "last") " " (STRONG "list") " &optional " (STRONG "n")
     " => " (STRONG "tail"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト。ドットリストは受け付けますが、循環リストは受け付けません。" EOL1
     (STRONG "n") " - 非負の整数。デフォルトは" (CODE1 "1") "。" EOL1 (STRONG "tail") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "last") "は、" (STRONG "list") "の最後の" (STRONG "n") "個のコンス"
     "（最後の" (STRONG "n") "要素ではありません）を返却します" "もし" (STRONG "list") "が" (CODE1 "()") "なら、"
     (CODE1 "last") "は" (CODE1 "()") "を返却します。" EOL2 "もし" (STRONG "n") "が" (CODE1 "0")
     "のとき、" (STRONG "list") "を終端しているアトムが返却されます。" "もし" (STRONG "n") "が、" (STRONG "list")
     "のコンスセルの数以上のとき、" (STRONG "list") "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(last nil) =>  NIL" "(last '(1 2 3)) =>  (3)"
      "(last '(1 2 . 3)) =>  (2 . 3)" "(setq x (list 'a 'b 'c 'd)) =>  (A B C D)"
      "(last x) =>  (D)" "(rplacd (last x) (list 'e 'f)) x =>  (A B C D E F)"
      "(last x) =>  (F)" NIL "(last '(a b c))   =>  (C)" NIL "(last '(a b c) 0) =>  ()"
      "(last '(a b c) 1) =>  (C)" "(last '(a b c) 2) =>  (B C)"
      "(last '(a b c) 3) =>  (A B C)" "(last '(a b c) 4) =>  (A B C)" NIL
      "(last '(a . b) 0) =>  B" "(last '(a . b) 1) =>  (A . B)"
      "(last '(a . b) 2) =>  (A . B)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list") "が循環リストのときの結果は未定義です。" (STRONG "n")
     "が非負の整数ではないとき、" "型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "butlast") "," (CODE1 "nth"))
    (CHAPTER ("## 備考") 2 "下記のコードは、" (CODE1 "last") "の定義です。"
     (CODE3 "```lisp" "```" "(defun last (list &optional (n 1))"
      "  (check-type n (integer 0))" "  (do ((l list (cdr l))" "       (r list)"
      "       (i 0 (+ i 1)))" "      ((atom l) r)" "    (if (>= i n) (pop r))))"))))
(setf (gethash '("LAST" . "FUNCTION") *table*) (gethash "LAST" *table*))
(setf (gethash "LDIFF" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "LDIFF") ", " (CODE1 "TAILP"))
    (CHAPTER ("## 構文") 2 (CODE1 "ldiff") " " (STRONG "list") " " (STRONG "object") " => "
     (STRONG "result-list") EOL1 (CODE1 "tailp") " " (STRONG "object") " "
     (STRONG "list") " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト。ドットリストを受け付けます。" EOL1
     (STRONG "object") " - オブジェクト" EOL1 (STRONG "result-list") " - リスト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が" (STRONG "list") "のどれかの末尾と等しいとき、"
     (CODE1 "tailp") "は" (STRONG "true") "を返却し、それ以外は" (STRONG "false") "を返却します。" EOL2
     (STRONG "object") "が" (STRONG "list") "のどれかの末尾と等しいとき、" (CODE1 "ldiff") "は、"
     (STRONG "list") "のリスト構造の中で、" (STRONG "object") "より前にある要素を" "新しいリストとして返却します。"
     "それ以外のときは、" (STRONG "list") "のコピーを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(let ((lists '#((a b c) (a b c . d))))"
      "  (dotimes (i (length lists)) ()" "    (let ((list (aref lists i)))"
      "      (format t \"~2&list=~S ~21T(tailp object list)~"
      "                 ~44T(ldiff list object)~%\" list)"
      "        (let ((objects (vector list (cddr list) (copy-list (cddr list))"
      "                               '(f g h) '() 'd 'x)))"
      "          (dotimes (j (length objects)) ()"
      "            (let ((object (aref objects j)))"
      "              (format t \"~& object=~S ~21T~S ~44T~S\""
      "                      object (tailp object list) (ldiff list object))))))))"
      ">>  " ">>  list=(A B C)         (tailp object list)    (ldiff list object)"
      ">>   object=(A B C)      T                      NIL"
      ">>   object=(C)          T                      (A B)"
      ">>   object=(C)          NIL                    (A B C)"
      ">>   object=(F G H)      NIL                    (A B C)"
      ">>   object=NIL          T                      (A B C)"
      ">>   object=D            NIL                    (A B C)"
      ">>   object=X            NIL                    (A B C)" ">>  "
      ">>  list=(A B C . D)     (tailp object list)    (ldiff list object)"
      ">>   object=(A B C . D)  T                      NIL"
      ">>   object=(C . D)      T                      (A B)"
      ">>   object=(C . D)      NIL                    (A B C . D)"
      ">>   object=(F G H)      NIL                    (A B C . D)"
      ">>   object=NIL          NIL                    (A B C . D)"
      ">>   object=D            T                      (A B C)"
      ">>   object=X            NIL                    (A B C . D)" "=>  NIL"))
    (CHAPTER ("## 副作用") 2 (CODE1 "ldiff") "と" (CODE1 "tailp") "は、どちらも引数を修正しません。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list") "が通常のリストでもドットリストでもないときは、" "型"
     (CODE1 "type-error") "のエラーを発生させる準備をする必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "set-difference"))
    (CHAPTER ("## 備考") 2 "もし" (STRONG "list") "が循環リストのとき、" (STRONG "object") "が実際に"
     (STRONG "list") "の末尾である場合にのみ、" (CODE1 "tailp") "は確実に値を返却します。" "その他の結果は未定義であり、"
     "ある実装では循環を検出して" (STRONG "false") "を返却しますが、" "ある実装ではそのような状況を検出しませんので、" "このような場合、"
     (CODE1 "tailp") "は値を返却することなく、" "ただ無限にループするかもしれません。" EOL2 (CODE1 "tailp")
     "は次のように定義できます。"
     (CODE3 "```lisp" "```" "(defun tailp (object list)" "  (do ((list list (cdr list)))"
      "      ((atom list) (eql list object))" "     (if (eql object list)"
      "         (return t))))")
     EOL2 "そして" (CODE1 "ldiff") "は次のようになります。"
     (CODE3 "```lisp" "```" "(defun ldiff (list object)" "  (do ((list list (cdr list))"
      "       (r '() (cons (car list) r)))" "      ((atom list)"
      "       (if (eql list object) (nreverse r) (nreconc r list)))"
      "    (when (eql object list)" "      (return (nreverse r)))))"))))
(setf (gethash '("LDIFF" . "FUNCTION") *table*) (gethash "LDIFF" *table*))
(setf (gethash "LENGTH" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "LENGTH"))
    (CHAPTER ("## 構文") 2 (CODE1 "length") " " (STRONG "sequence") " => " (STRONG "n"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "sequence") " - 正常なシーケンス" EOL1 (STRONG "n")
     " - 非負の整数")
    (CHAPTER ("## 定義") 2 (STRONG "sequence") "の要素数を返却します。" EOL2 "もし" (STRONG "sequence")
     "がfill-pointerを持つ" (CODE1 "vector") "のとき、" "fill-pointerで指定された有効な長さが返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(length \"abc\") =>  3"
      "(setq str (make-array '(3) :element-type 'character "
      "                           :initial-contents \"abc\""
      "                           :fill-pointer t)) =>  \"abc\"" "(length str) =>  3"
      "(setf (fill-pointer str) 2) =>  2" "(length str) =>  2"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "list-length") "," (CODE1 "sequence"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("LENGTH" . "FUNCTION") *table*) (gethash "LENGTH" *table*))
(setf (gethash "LET" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "LET") ", " (CODE1 "LET*"))
    (CHAPTER ("## 構文") 2 (CODE1 "let") " (" (CODE1 "{") (STRONG "var") " " (CODE1 "|")
     " (" (STRONG "var") " [" (STRONG "init-form") "])" (CODE1 "}") "\\*) "
     (STRONG "declaration\\*") " " (STRONG "form\\*") " => " (STRONG "result\\*") EOL1
     (CODE1 "let*") " (" (CODE1 "{") (STRONG "var") " " (CODE1 "|") " (" (STRONG "var")
     " [" (STRONG "init-form") "])" (CODE1 "}") "\\*) " (STRONG "declaration\\*") " "
     (STRONG "form\\*") " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - シンボル" EOL1 (STRONG "init-form") " - フォーム"
     EOL1 (STRONG "declaration") " - 宣言式、評価はされません。" EOL1 (STRONG "form") " - フォーム" EOL1
     (STRONG "result") " - " (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "let") "と" (CODE1 "let*") "は、" "新しい変数の束縛を作成し、"
     "それらの束縛を使用した一連の" (STRONG "form") "を実行します。" (CODE1 "let") "は束縛を並行して行い、"
     (CODE1 "let*") "はそれらを連続で行います。" EOL2 "次のフォームは、"
     (CODE3 "```lisp" "```" "(let ((var1 init-form-1)" "      (var2 init-form-2)"
      "      ..." "      (varm init-form-m))" "  declaration1" "  declaration2" "  ..."
      "  declarationp" "  form1" "  form2" "  ..." "  formn)")
     EOL2 "最初に式" (STRONG "init-form-1") ", " (STRONG "init-form-2") ", ...,"
     "をこの順番で評価し、返却値を保存します。" "そのあと、全ての変数" (CODE1 "varj") "に対応する値を束縛します。"
     "各束縛はレキシカルに行われますが、" (CODE1 "special") "宣言があるときは逆になります。" (CODE1 "formk")
     "の式はその順番で評価されます。" "最後以外のすべての値は無視されます。" "（つまり" (CODE1 "let") "のボディ部は、暗黙のprognです）"
     EOL2 (CODE1 "let*") "は" (CODE1 "let") "に似ていますが、" "変数の束縛が並行ではなく、"
     "連続に行われるところが違っています。" (CODE1 "let*") "では、 " (STRONG "var") "の" (STRONG "init-form")
     "の式は、" "前に束縛された" (CODE1 "vars") "を参照することができます。" EOL2 "次のフォームは、"
     (CODE3 "```lisp" "```" "(let* ((var1 init-form-1)" "       (var2 init-form-2)"
      "       ..." "       (varm init-form-m))" "  declaration1" "  declaration2" "  ..."
      "  declarationp" "  form1" "  form2" "  ..." "  formn)")
     EOL2 "最初に" (STRONG "init-form-1") "を評価し、" "そのあと" (STRONG "var1") "にその値を束縛し、" "そのあと"
     (STRONG "init-form-2") "を評価し、" "そのあと" (STRONG "var2") "にその値を束縛し、" "くり返します。"
     (CODE1 "formk") "の式はその順番で評価されます。" "最後以外のすべての値は無視されます。" "（つまり" (CODE1 "let*")
     "のボディ部は、暗黙のprognです）" EOL2 (CODE1 "let") "と" (CODE1 "let*") "の両方は、" "もし"
     (STRONG "var") "に関連する" (STRONG "init-form") "が無かったときは、" (STRONG "var") "は"
     (CODE1 "nil") "で初期化されます。" EOL2 "特殊フォームの" (CODE1 "let") "は、" "どんな初期化フォームも"
     "名前の束縛のスコープに含まれないという性質があります。" (CODE1 "let*") "の変数のスコープは、"
     "それ以降の変数の束縛には残りの初期値フォームが含まれます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq a 'top) =>  TOP"
      "(defun dummy-function () a) =>  DUMMY-FUNCTION" "(let ((a 'inside) (b a))"
      "   (format nil \"~S ~S ~S\" a b (dummy-function))) =>  \"INSIDE TOP TOP\" "
      "(let* ((a 'inside) (b a))"
      "   (format nil \"~S ~S ~S\" a b (dummy-function))) =>  \"INSIDE INSIDE TOP\" "
      "(let ((a 'inside) (b a))" "   (declare (special a))"
      "   (format nil \"~S ~S ~S\" a b (dummy-function))) =>  \"INSIDE TOP INSIDE\"")
     EOL2 "次のコードは正しくありません。"
     (CODE3 "```lisp" "```" "(let (x)" "  (declare (integer x))" "  (setq x (gcd y z))"
      "  ...)")
     EOL2 (CODE1 "x") "はそれが使用される前に実際に値は代入されますし、" "その代入される値は宣言された整数の型ですが、" (CODE1 "x")
     "が初期化されるときに" (CODE1 "nil") "が使われるので、" "宣言の型に違反しています。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "progv")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("LET" . "SPECIAL-OPERATOR") *table*) (gethash "LET" *table*))
(setf (gethash "LET*" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "LET") ", " (CODE1 "LET*"))
    (CHAPTER ("## 構文") 2 (CODE1 "let") " (" (CODE1 "{") (STRONG "var") " " (CODE1 "|")
     " (" (STRONG "var") " [" (STRONG "init-form") "])" (CODE1 "}") "\\*) "
     (STRONG "declaration\\*") " " (STRONG "form\\*") " => " (STRONG "result\\*") EOL1
     (CODE1 "let*") " (" (CODE1 "{") (STRONG "var") " " (CODE1 "|") " (" (STRONG "var")
     " [" (STRONG "init-form") "])" (CODE1 "}") "\\*) " (STRONG "declaration\\*") " "
     (STRONG "form\\*") " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - シンボル" EOL1 (STRONG "init-form") " - フォーム"
     EOL1 (STRONG "declaration") " - 宣言式、評価はされません。" EOL1 (STRONG "form") " - フォーム" EOL1
     (STRONG "result") " - " (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "let") "と" (CODE1 "let*") "は、" "新しい変数の束縛を作成し、"
     "それらの束縛を使用した一連の" (STRONG "form") "を実行します。" (CODE1 "let") "は束縛を並行して行い、"
     (CODE1 "let*") "はそれらを連続で行います。" EOL2 "次のフォームは、"
     (CODE3 "```lisp" "```" "(let ((var1 init-form-1)" "      (var2 init-form-2)"
      "      ..." "      (varm init-form-m))" "  declaration1" "  declaration2" "  ..."
      "  declarationp" "  form1" "  form2" "  ..." "  formn)")
     EOL2 "最初に式" (STRONG "init-form-1") ", " (STRONG "init-form-2") ", ...,"
     "をこの順番で評価し、返却値を保存します。" "そのあと、全ての変数" (CODE1 "varj") "に対応する値を束縛します。"
     "各束縛はレキシカルに行われますが、" (CODE1 "special") "宣言があるときは逆になります。" (CODE1 "formk")
     "の式はその順番で評価されます。" "最後以外のすべての値は無視されます。" "（つまり" (CODE1 "let") "のボディ部は、暗黙のprognです）"
     EOL2 (CODE1 "let*") "は" (CODE1 "let") "に似ていますが、" "変数の束縛が並行ではなく、"
     "連続に行われるところが違っています。" (CODE1 "let*") "では、 " (STRONG "var") "の" (STRONG "init-form")
     "の式は、" "前に束縛された" (CODE1 "vars") "を参照することができます。" EOL2 "次のフォームは、"
     (CODE3 "```lisp" "```" "(let* ((var1 init-form-1)" "       (var2 init-form-2)"
      "       ..." "       (varm init-form-m))" "  declaration1" "  declaration2" "  ..."
      "  declarationp" "  form1" "  form2" "  ..." "  formn)")
     EOL2 "最初に" (STRONG "init-form-1") "を評価し、" "そのあと" (STRONG "var1") "にその値を束縛し、" "そのあと"
     (STRONG "init-form-2") "を評価し、" "そのあと" (STRONG "var2") "にその値を束縛し、" "くり返します。"
     (CODE1 "formk") "の式はその順番で評価されます。" "最後以外のすべての値は無視されます。" "（つまり" (CODE1 "let*")
     "のボディ部は、暗黙のprognです）" EOL2 (CODE1 "let") "と" (CODE1 "let*") "の両方は、" "もし"
     (STRONG "var") "に関連する" (STRONG "init-form") "が無かったときは、" (STRONG "var") "は"
     (CODE1 "nil") "で初期化されます。" EOL2 "特殊フォームの" (CODE1 "let") "は、" "どんな初期化フォームも"
     "名前の束縛のスコープに含まれないという性質があります。" (CODE1 "let*") "の変数のスコープは、"
     "それ以降の変数の束縛には残りの初期値フォームが含まれます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq a 'top) =>  TOP"
      "(defun dummy-function () a) =>  DUMMY-FUNCTION" "(let ((a 'inside) (b a))"
      "   (format nil \"~S ~S ~S\" a b (dummy-function))) =>  \"INSIDE TOP TOP\" "
      "(let* ((a 'inside) (b a))"
      "   (format nil \"~S ~S ~S\" a b (dummy-function))) =>  \"INSIDE INSIDE TOP\" "
      "(let ((a 'inside) (b a))" "   (declare (special a))"
      "   (format nil \"~S ~S ~S\" a b (dummy-function))) =>  \"INSIDE TOP INSIDE\"")
     EOL2 "次のコードは正しくありません。"
     (CODE3 "```lisp" "```" "(let (x)" "  (declare (integer x))" "  (setq x (gcd y z))"
      "  ...)")
     EOL2 (CODE1 "x") "はそれが使用される前に実際に値は代入されますし、" "その代入される値は宣言された整数の型ですが、" (CODE1 "x")
     "が初期化されるときに" (CODE1 "nil") "が使われるので、" "宣言の型に違反しています。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "progv")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("LET*" . "SPECIAL-OPERATOR") *table*) (gethash "LET*" *table*))
(setf (gethash "LIST" *table*)
  '("LIST FUNCTION" EOL1 "LIST SYSTEM-CLASS" EOL1))
(setf (gethash '("LIST" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "LIST") ", " (CODE1 "LIST*"))
    (CHAPTER ("## 構文") 2 (CODE1 "list") " &rest " (STRONG "objects") " => "
     (STRONG "list") EOL1 (CODE1 "list*") " &rest " (STRONG "objects+") " => "
     (STRONG "result"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "list") " - リスト"
     EOL1 (STRONG "result") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "list") "は、引数" (STRONG "objects") "を含むリストを返却します。" EOL2
     (CODE1 "list*") "は" (CODE1 "list") "と似ていますが、" (CODE1 "list") "の最後の引数は、最後のコンスの"
     (CODE1 "car") "になるのに対し、" (CODE1 "list*") "の最後の引数は、最後のコンスの" (CODE1 "cdr")
     "になるのが違っています。" "したがって、" (CODE1 "list*") "の呼び出しは、" "同じ数の引数の" (CODE1 "list")
     "の呼び出しより、" "つねに1つ少ないコンスで生成されます。" EOL2 "もし" (CODE1 "list*") "の最後の要素がリストのときは、"
     (CODE1 "list*") "の先行した引数の要素が前の方に追加された、" "新たなリストを構築する効果があります。" EOL2 (CODE1 "list*")
     "がただひとつの" (STRONG "object") "を受け取った場合、" "それがリストかどうかに関わらず、その" (STRONG "object")
     "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(list 1) =>  (1)" "(list* 1) =>  1" "(setq a 1) =>  1"
      "(list a 2) =>  (1 2)" "'(a 2) =>  (A 2)" "(list 'a 2) =>  (A 2)"
      "(list* a 2) =>  (1 . 2)" "(list) =>  NIL ;i.e.,  ()" "(setq a '(1 2)) =>  (1 2)"
      "(eq a (list* a)) =>  true" "(list 3 4 'a (car '(b . c)) (+ 6 -2)) =>  (3 4 A B 4)"
      "(list* 'a 'b 'c 'd) ==  (cons 'a (cons 'b (cons 'c 'd))) =>  (A B C . D)"
      "(list* 'a 'b 'c '(d e f)) =>  (A B C D E F)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "cons"))
    (CHAPTER ("## 備考") 2 (CODE3 "```lisp" "```" "(list* x) ==  x"))))
(setf (gethash '("LIST" . "SYSTEM-CLASS") *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "LIST"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "list") "," (CODE1 "sequence") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "リストは、コンスの連鎖であり、" "各コンスの" (CODE1 "car") "がリストの要素、" "各コンスの"
     (CODE1 "cdr") "が次の接続のリンクか、" "あるいは終端のアトムです。" EOL2 "通常のリストとは、終端が空のリスト" (CODE1 "()")
     "であり、" "空のリスト自身が通常のリストであるという、" "コンスの連鎖です。" "ドットリストとは、終端が空ではなくアトムであるリストです。"
     "循環リストとは、どれかのコンスが、" "後のコンスの" (CODE1 "cdr") "に接続されているような" "終端がないコンスの連鎖のことです。" EOL2
     "ドットリストと循環リストもまたリストですが、" "本仕様では、普通は修飾子がない「リスト」という単語を" "通常のリストという意味として使います。" "とはいえ、型"
     (CODE1 "list") "に、" "ドットリストと循環リストが含まれるのは間違いありません。" EOL2 "リストの各要素にはコンスがあります。"
     "空リストは要素を持たず、コンスではありません。" EOL2 "型" (CODE1 "cons") "と" (CODE1 "null") "は、" "型"
     (CODE1 "list") "の完全な分割です。")
    (CHAPTER ("## 参考") 2 "2.4.1. 左括弧," "22.1.3.5. リストとコンスの印字")))
(setf (gethash "LIST*" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "LIST") ", " (CODE1 "LIST*"))
    (CHAPTER ("## 構文") 2 (CODE1 "list") " &rest " (STRONG "objects") " => "
     (STRONG "list") EOL1 (CODE1 "list*") " &rest " (STRONG "objects+") " => "
     (STRONG "result"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "list") " - リスト"
     EOL1 (STRONG "result") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "list") "は、引数" (STRONG "objects") "を含むリストを返却します。" EOL2
     (CODE1 "list*") "は" (CODE1 "list") "と似ていますが、" (CODE1 "list") "の最後の引数は、最後のコンスの"
     (CODE1 "car") "になるのに対し、" (CODE1 "list*") "の最後の引数は、最後のコンスの" (CODE1 "cdr")
     "になるのが違っています。" "したがって、" (CODE1 "list*") "の呼び出しは、" "同じ数の引数の" (CODE1 "list")
     "の呼び出しより、" "つねに1つ少ないコンスで生成されます。" EOL2 "もし" (CODE1 "list*") "の最後の要素がリストのときは、"
     (CODE1 "list*") "の先行した引数の要素が前の方に追加された、" "新たなリストを構築する効果があります。" EOL2 (CODE1 "list*")
     "がただひとつの" (STRONG "object") "を受け取った場合、" "それがリストかどうかに関わらず、その" (STRONG "object")
     "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(list 1) =>  (1)" "(list* 1) =>  1" "(setq a 1) =>  1"
      "(list a 2) =>  (1 2)" "'(a 2) =>  (A 2)" "(list 'a 2) =>  (A 2)"
      "(list* a 2) =>  (1 . 2)" "(list) =>  NIL ;i.e.,  ()" "(setq a '(1 2)) =>  (1 2)"
      "(eq a (list* a)) =>  true" "(list 3 4 'a (car '(b . c)) (+ 6 -2)) =>  (3 4 A B 4)"
      "(list* 'a 'b 'c 'd) ==  (cons 'a (cons 'b (cons 'c 'd))) =>  (A B C . D)"
      "(list* 'a 'b 'c '(d e f)) =>  (A B C D E F)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "cons"))
    (CHAPTER ("## 備考") 2 (CODE3 "```lisp" "```" "(list* x) ==  x"))))
(setf (gethash '("LIST*" . "FUNCTION") *table*) (gethash "LIST*" *table*))
(setf (gethash "LIST-ALL-PACKAGES" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "LIST-ALL-PACKAGES"))
    (CHAPTER ("## 構文") 2 (CODE1 "list-all-packages") " " (CODE1 "<引数なし>") " => "
     (STRONG "packages"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "packages") " - パッケージオブジェクトのリスト")
    (CHAPTER ("## 定義") 2 (CODE1 "list-all-packages") "は" "全ての登録されているパッケージの"
     "新しいリストを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(let ((before (list-all-packages)))"
      "   (make-package 'temp)"
      "   (set-difference (list-all-packages) before)) =>  (#<PACKAGE \"TEMP\">)"))
    (CHAPTER ("## 副作用") 2 "なし。")
    (CHAPTER ("## 影響") 2 (CODE1 "defpackage") "," (CODE1 "delete-package") ","
     (CODE1 "make-package"))
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("LIST-ALL-PACKAGES" . "FUNCTION") *table*) (gethash "LIST-ALL-PACKAGES" *table*))
(setf (gethash "LIST-LENGTH" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "LIST-LENGTH"))
    (CHAPTER ("## 構文") 2 (CODE1 "list-length") " " (STRONG "list") " => "
     (STRONG "length"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - 通常のリストか循環リスト" EOL1 (STRONG "length")
     " - 非負の整数か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (STRONG "list") "が通常のリストなら、" (STRONG "list") "の長さを返却します。"
     (STRONG "list") "が循環リストなら、" (CODE1 "nil") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(list-length '(a b c d)) =>  4"
      "(list-length '(a (b c) d)) =>  3" "(list-length '()) =>  0"
      "(list-length nil) =>  0" "(defun circular-list (&rest elements)"
      "  (let ((cycle (copy-list elements))) " "    (nconc cycle cycle)))"
      "(list-length (circular-list 'a 'b)) =>  NIL"
      "(list-length (circular-list 'a)) =>  NIL" "(list-length (circular-list)) =>  0"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list") "が通常のリストでも循環リストでもないときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "length"))
    (CHAPTER ("## 備考") 2 (CODE1 "list-length") "は次のように実装できます。"
     (CODE3 "```lisp" "```" "(defun list-length (x)  "
      "  (do ((n 0 (+ n 2))           ;カウンター。"
      "       (fast x (cddr fast))    ;Fastポインター: 2つ進める。"
      "       (slow x (cdr slow)))    ;Slowポインター: 1つ進める。" "      (nil)"
      "    ;; もしfastポインターが終了なら、カウントを返却する。" "    (when (endp fast) (return n))"
      "    (when (endp (cdr fast)) (return (+ n 1)))" "	;; もしfastポインターがslotポインターと同じなら"
      "	;; 循環リストから抜け出せていない。" "	;; （深い特性の話をすると：もし循環リストにはまったのなら"
      "	;;   fastポインターはやがてslotポインターと等しくなるだろう。" "	;;   このような事実がこの実装を正当化する。）"
      "    (when (and (eq fast slow) (> n 0)) (return nil))))"))))
(setf (gethash '("LIST-LENGTH" . "FUNCTION") *table*) (gethash "LIST-LENGTH" *table*))
(setf (gethash "LISTEN" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "LISTEN"))
    (CHAPTER ("## 構文") 2 (CODE1 "listen") " " (CODE1 "&optional") " "
     (STRONG "input-stream") " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "input-stream") " - 入力ストリーム指定子。デフォルトは標準入力。" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "input-stream") "から即座に利用可能な文字があるときは" (STRONG "true")
     "を、" "それ以外は" (STRONG "false") "を返却します。" (STRONG "input-stream") "が非対話式であるとき、"
     (CODE1 "listen") "はファイルの終わりではないときに" (STRONG "true") "を返却します。" "もしファイルの終わりに遭遇したとき、"
     (CODE1 "listen") "は" (STRONG "false") "を返却します。" (CODE1 "listen") "は、"
     (STRONG "input-stream") "がキーボードのような対話式デバイスから" "文字を取得するときに使われることを意図しています。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(progn (unread-char (read-char)) (list (listen) (read-char)))" ">>  1"
      "=>  (T #\\1)" "(progn (clear-input) (listen))" "=>  NIL ;あなたが非常に速いタイピストでもない限り！"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 (CODE1 "*standard-input*"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "interactive-stream-p") "," (CODE1 "read-char-no-hang"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("LISTEN" . "FUNCTION") *table*) (gethash "LISTEN" *table*))
(setf (gethash "LISTP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "LISTP"))
    (CHAPTER ("## 構文") 2 (CODE1 "listp") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が" (CODE1 "list") "の型ならば" (STRONG "true")
     "を、" "それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(listp nil) =>  true" "(listp (cons 1 2)) =>  true"
      "(listp (make-array 6)) =>  false" "(listp t) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "consp"))
    (CHAPTER ("## 備考") 2 "もし" (STRONG "object") "がコンスなら、" (CODE1 "listp") "は"
     (STRONG "object") "が通常のリストかどうか確認せず、" "どんな種類のリストでも" (STRONG "true") "を返却します。"
     (CODE3 "```lisp" "```"
      "(listp object) ==  (typep object 'list) ==  (typep object '(or cons null))"))))
(setf (gethash '("LISTP" . "FUNCTION") *table*) (gethash "LISTP" *table*))
(setf (gethash "LOAD-LOGICAL-PATHNAME-TRANSLATIONS" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "LOAD-LOGICAL-PATHNAME-TRANSLATIONS"))
    (CHAPTER ("## 構文") 2 (CODE1 "load-logical-pathname-translations") " " (STRONG "host")
     " => " (STRONG "just-loaded"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "host") " - 文字列" EOL1 (STRONG "just-loaded")
     " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "host") "という名前の論理ホストがまだ定義されていなかったら、" "その定義を検索してロードします。"
     "検索の性質の特性は実装定義です。" EOL2 "もし" (STRONG "host") "がすでに定義されていたときは、" "検索とロードは行われず"
     (STRONG "false") "が返却されます。" "もし" (STRONG "host") "がまだ定義されておらず、" "定義の検索とロードに成功したときは"
     (STRONG "true") "が返却されます。" "それ以外の場合はエラーが発生します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(translate-logical-pathname \"hacks:weather;barometer.lisp.newest\")"
      ">>  Error: The logical host HACKS is not defined."
      "(load-logical-pathname-translations \"HACKS\")"
      ">>  ;; Loading SYS:SITE;HACKS.TRANSLATIONS" ">>  ;; Loading done." "=>  true"
      "(translate-logical-pathname \"hacks:weather;barometer.lisp.newest\")"
      "=>  #P\"HELIUM:[SHARED.HACKS.WEATHER]BAROMETER.LSP;0\""
      "(load-logical-pathname-translations \"HACKS\")" "=>  false"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "定義が見つからなかったときは、" "型" (CODE1 "error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "logical-pathname"))
    (CHAPTER ("## 備考") 2 "論理パス名の定義はただ実装を作成する人によってだけではなく、" "むしろプログラマーによって作成されます。"
     "そのような場合は、検索する処理をドキュメント化することが重要になります。" "例えば実装者はどこか特定の名前がついたディレクトリに配置されている" "「"
     (STRONG "host") ".translations」と呼ばれるファイルが見つかったら、" "それが" (STRONG "host")
     "の定義である様にすることができます。")))
(setf (gethash '("LOAD-LOGICAL-PATHNAME-TRANSLATIONS" . "FUNCTION") *table*) (gethash "LOAD-LOGICAL-PATHNAME-TRANSLATIONS" *table*))
(setf (gethash "LOAD-TIME-VALUE" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "LOAD-TIME-VALUE"))
    (CHAPTER ("## 構文") 2 (CODE1 "load-time-value") " " (STRONG "form") " &optional "
     (STRONG "read-only-p") " => " (STRONG "object"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "form") " - フォーム。下記の説明に従って評価されます。" EOL1
     (STRONG "read-only-p") " - ブール値。評価されません。" EOL1 (STRONG "object") " - "
     (STRONG "form") "の評価の結果の主値")
    (CHAPTER ("## 定義") 2 (CODE1 "load-time-value") "は、その式が実行環境に入るまで" (STRONG "form")
     "の評価を遅らせる仕組みを提供します。" "3.2. コンパイルをご確認ください。" EOL2 (STRONG "read-only-p")
     "は、結果を定数オブジェクトとみなすかどうかを指示します。" "もし" (CODE1 "t") "のとき結果は読み込み専用の値となり、"
     "実装が適用可能であれば、読み込み専用の領域にコピーするか、" "あるいは同時に他のプログラムからの似た定数オブジェクトと合併します。" "もし"
     (CODE1 "nil") "のとき（デフォルト）は、" "結果はコピーも合併もされません。" "それは修正される可能性のあるデータとして扱われます。" EOL2
     "もし" (CODE1 "load-time-value") "の式が" (CODE1 "compile-file") "によって処理されるとき、"
     "コンパイラーは、まず" (STRONG "form") "をマクロ展開や機械語コードへの変換など、" "通常の方法で処理します。そのとき、"
     (STRONG "form") "のロード実行時に" (CODE1 "null") "のレキシカルな環境であるように配置します。"
     "評価の結果は、実行時にはリテラルオブジェクトのように扱われます。" "ファイル読み込み時には、" (STRONG "form")
     "の実行はただ一度だけ行われることが保証されます。" "しかしその評価順がファイル内のトップレベルフォームの評価順を" "遵守するかどうかは実装依存です。" EOL2
     (CODE1 "compile") "によってコンパイルされた関数上に" (CODE1 "load-time-value") "があらわれたとき、" "その"
     (STRONG "form") "はコンパイル時に" (CODE1 "null") "のレキシカルな環境として評価されます。" "コンパイル時に評価されたその結果は、"
     "コンパイルされたコード上ではリテラルオブジェクトとして扱われます。" EOL2 "もし" (CODE1 "load-time-value") "の式が"
     (CODE1 "eval") "によって処理されるとき、" "その" (STRONG "form") "は" (CODE1 "null")
     "のレキシカルな環境によって評価され、" "ひとつの値が返却されます。" (CODE1 "eval")
     "による式の処理の一部か全体を暗黙的にコンパイルするような実装では、" (STRONG "form") "がたった一度だけ評価されるときにコンパイル処理が行われます。"
     EOL2 "もし" (CODE1 "(load-time-value form)") "という同じリストが" "評価時かコンパイル時に複数現れたとき、"
     (STRONG "form") "の評価がただ一度だけ行われるか、" "あるいは複数行われるかは実装依存です。"
     "これは、式が評価とコンパイル時で部分構造を共有するときと、" "同じフォームを" (CODE1 "eval") "か" (CODE1 "compile")
     "で複数回実行したときの、" "両方の場合で生じます。" (CODE1 "eval") "による" (CODE1 "load-time-value") "の式は"
     "同一の場所を複数参照したり複数評価できるので、" "各実行が新しいオブジェクトとを返却するか、" "あるいは別の何かの実行によって生成された"
     "同じオブジェクトを返却するのかは" "実装依存です。" "ユーザーはこの返却値のオブジェクトを破壊的に修正するときには、" "注意する必要があります。" EOL2
     "同一ではないが" (CODE1 "equal") "で等しい" "2つの" (CODE1 "(load-time-value form)") "というリストを"
     "評価かコンパイルするとき、" "それらの値は常に違った" (STRONG "form") "の評価になります。" "それらの値は"
     (STRONG "read-only-p") "が" (CODE1 "t") "でもなければ、" "合併されません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";;; INCR1関数は違うイメージでも常に同じ値を返却します。"
      ";;; INCR2関数は与えられたイメージ上で常に同じ値を返却します。" ";;; イメージによっては変更された値になるかもしれません。"
      "(defun incr1 (x) (+ x #.(random 17)))"
      "(defun incr2 (x) (+ x (load-time-value (random 17))))" NIL
      ";;; FOO1-REF関数はロード時に利用可能になった*FOO-ARRAYS*の" ";;; 最初の要素のさらにn番目の要素を参照します。"
      ";;; これは配列を例えばSET-FOO1-REFなどで変更することが許されます。" ";;; FOO1-REFは更新された値を見るでしょう。"
      "(defvar *foo-arrays* (list (make-array 7) (make-array 8)))"
      "(defun foo1-ref (n) (aref (load-time-value (first *my-arrays*) nil) n))"
      "(defun set-foo1-ref (n val) "
      "  (setf (aref (load-time-value (first *my-arrays*) nil) n) val))" NIL
      ";;; BAR1-REF関数はロード時に利用可能になった*FOO-ARRAYS*の" ";;; 最初の要素のさらにn番目の要素を参照します。"
      ";;; プログラマーにはこの配列が読み込み専用で扱われるという約束があるので" ";;; システムはその配列のコピーも合併も行いません。"
      "(defvar *bar-arrays* (list (make-array 7) (make-array 8)))"
      "(defun bar1-ref (n) (aref (load-time-value (first *my-arrays*) t) n))" NIL
      ";;; このLOAD-TIME-VALUEにはNILが指定されていますが、" ";;; 指定した配列が合併されることを許します。"
      ";;; なぜならそのオブジェクトはコンストラクターによって生成されたものではなく"
      ";;; リテラルの配列として記載されているので、すでに読み込み専用だからです。"
      ";;; ユーザープログラムは、配列vを読み込み専用として扱わなければなりません。" "(defun baz-ref (n)"
      "  (let ((v (load-time-value #(A B C) nil)))" "    (values (svref v n) v)))" NIL
      ";;; このLOAD-TIME-VALUEは、指定された配列が、外側の状況でNILが指定されたものと"
      ";;; 内側の状況でTが指定されたものとで、合併することが許されます。" ";;; ユーザープログラムは、配列vを読み込み専用として扱わなければなりません。"
      "(defun baz-ref (n)"
      "  (let ((v (load-time-value (load-time-value (vector 1 2 3) t) nil)))"
      "    (values (svref v n) v)))"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "compile-file") "," (CODE1 "compile") "," (CODE1 "eval")
     "," "3.2.2.2. 小さなコンパイル," "3.2. コンパイル")
    (CHAPTER ("## 備考") 2 (CODE1 "load-time-value") "は、クォートされた構造の外側の"
     "「評価による」位置に現れる必要があります。" "このような状況では、" "クォートされた構造の内側で" (CODE1 "load-time-value")
     "を使って" "呼び出されるようにしたいときは、" "おそらくバッククォートリーダーマクロを呼び出します。" "2.4.6. バッククォートをご確認ください。"
     EOL2 "もしオブジェクトが既に読み込み専用であったときは、" (STRONG "read-only-p") "に" (CODE1 "nil") "を指定しても、"
     "そのオブジェクトを強制的に修正可能にするわけではありません。" "この操作は、変更可能なオブジェクトに対して" "読み取り専用にする命令ではないと言っています。")))
(setf (gethash '("LOAD-TIME-VALUE" . "SPECIAL-OPERATOR") *table*) (gethash "LOAD-TIME-VALUE" *table*))
(setf (gethash "LOCALLY" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "LOCALLY"))
    (CHAPTER ("## 構文") 2 (CODE1 "locally") " " (STRONG "declaration\\*") " "
     (STRONG "form\\*") " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "declaration") " - 宣言式。評価されません。" EOL1
     (STRONG "form") " - 暗黙のprogn" EOL1 (STRONG "result") " - " (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 "与えられた" (STRONG "declaration") "の効果があるレキシカル環境下で、" "一連の"
     (STRONG "form") "のボディ部を評価します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun sample-function (y)  ;このyはspecialと見なされる"
      "  (declare (special y))                                "
      "  (let ((y t))              ;このyはレキシカルと見なされる" "    (list y"
      "          (locally (declare (special y))" "            ;; この次のyはspecialと見なされる"
      "            y))))" "=>  SAMPLE-FUNCTION" "(sample-function nil) =>  (T NIL) "
      "(setq x '(1 2 3) y '(4 . 5)) =>  (4 . 5)" NIL ";;; 下記の宣言は特に使いやすい指定ではありません。"
      ";;; これらはただLOCALLYを使った正しい宣言の構文の例です。"
      "(locally (declare (inline floor) (notinline car cdr))"
      "         (declare (optimize space))" "   (floor (car x) (cdr y))) =>  0, 1"
      ";;; この例はlocally定義による特定のOPTIMIZEの設定を持った" ";;; 関数定義の例を示したものです。"
      "(locally (declare (optimize (safety 3) (space 3) (speed 0)))"
      "  (defun frob (w x y &optional (z (foo x y)))" "    (mumble x y z w)))" "=>  FROB"
      NIL ";;; これは前回の例と同じですが、最適化の設定がその後に続く" ";;; 同じコンパイルユニット内の定義に有効であることが違っています。"
      "(declaim (optimize (safety 3) (space 3) (speed 0)))"
      "(defun frob (w x y &optional (z (foo x y)))" "  (mumble x y z w))" "=>  FROB"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "declare"))
    (CHAPTER ("## 備考") 2 (CODE1 "locally") "の" (CODE1 "special") "宣言の使用は、"
     "変数の束縛ではなく変数への参照に影響します。" EOL2 "もし" (CODE1 "locally") "フォームがトップレベルフォームであれば、"
     (STRONG "form") "本体もまたトップレベルフォームとして処理されます。" "3.2.3. ファイルのコンパイルをご確認ください。")))
(setf (gethash '("LOCALLY" . "SPECIAL-OPERATOR") *table*) (gethash "LOCALLY" *table*))
(setf (gethash "LOGICAL-PATHNAME" *table*)
  '("LOGICAL-PATHNAME FUNCTION" EOL1 "LOGICAL-PATHNAME SYSTEM-CLASS" EOL1))
(setf (gethash '("LOGICAL-PATHNAME" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "LOGICAL-PATHNAME"))
    (CHAPTER ("## 構文") 2 (CODE1 "logical-pathname") " " (STRONG "pathspec") " => "
     (STRONG "logical-pathname"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathspec") " - 論理パス名か、論理パス名の名前文字か、ストリーム" EOL1
     (STRONG "logical-pathname") " - 論理パス名")
    (CHAPTER ("## 定義") 2 (CODE1 "logical-pathname") "は" (STRONG "pathspec") "を論理パス名へ変換し、"
     "新しい論理パス名を返却します。" "もし" (STRONG "pathspec") "が論理パス名の名前文字列であるときは、"
     "それはホストの要素と合わせてコロンが続くものを含まなければなりません。" "もし" (STRONG "pathspec") "がストリームのときは、" "それは"
     (CODE1 "pathname") "が論理パス名を返却するような" "ものでなければなりません。" EOL2 "もし" (STRONG "pathspec")
     "がストリームのとき、" "そのストリームは開いているものか閉じているものを指定できます。" (CODE1 "logical-pathname") "は"
     "ファイルがクローズされたあとのものについては、" "ファイルが開いているときに実行されたものと同じ論理パス名を返却します。" "もし"
     (STRONG "pathspec") "がストリームであり、" (CODE1 "make-two-way-stream") ","
     (CODE1 "make-echo-stream") "," (CODE1 "make-broadcast-stream") ","
     (CODE1 "make-concatenated-stream") "," (CODE1 "make-string-input-stream") ","
     (CODE1 "make-string-output-stream") "によって作成されたもののときはエラーが発生します。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "pathspec") "が正しく指定されなかったときは、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "logical-pathname") ","
     (CODE1 "translate-logical-pathname") "," "19.3. 論理パス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("LOGICAL-PATHNAME" . "SYSTEM-CLASS") *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "LOGICAL-PATHNAME"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "logical-pathname") "," (CODE1 "pathname") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "パス名は、使用する名前文字列の構文は実装依存であり、" "それが保有する要素の値も実装依存です。"
     "論理パス名はファイル名を直接参照しません。")
    (CHAPTER ("## 参考") 2 "20.1. ファイルシステムの説明," "2.4.8.14. シャープサイン P," "22.1.3.11. "
     (CODE1 "pathname") "の印字")))
(setf (gethash "LOGICAL-PATHNAME-TRANSLATIONS" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "LOGICAL-PATHNAME-TRANSLATIONS"))
    (CHAPTER ("## 構文") 2 (CODE1 "logical-pathname-translations") " " (STRONG "host")
     " => " (STRONG "translations") EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "logical-pathname-translations") " " (STRONG "host") ") "
     (STRONG "new-translations") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "host") " - 論理ホスト指定子" EOL1 (STRONG "translations")
     ", " (STRONG "new-translations") " - リスト")
    (CHAPTER ("## 定義") 2 "ホストの変換リストを返却します。" "各変換は、少なくとも2つの要素のリストであり、" "それぞれを"
     (STRONG "from-wildcard") "と" (STRONG "to-wildcard") "とします。" "追加の要素は処理系定義です。"
     (STRONG "from-wildcard") "はホストが" (STRONG "host") "の論理パス名です。" (STRONG "to-wildcard")
     "はパス名です。" EOL2 (CODE1 "(setf (logical-pathname-translations host) translations)")
     "は、" "論理パス名のホストの変換リストを設定します。" "もし" (STRONG "host")
     "が以前に論理パス名のホストとして使用されていない文字列のときは、" "新しい論理パス名のホストが定義されます。"
     "そうではないときは、既存のホスト変換が置き換えられます。" "論理パス名のホストの名前は、" (CODE1 "string-equal") "で比較されます。"
     EOL2 "変換リストが設定されたとき、" "各" (STRONG "from-wildcard") "は、" "ホストが" (STRONG "host")
     "の論理パス名か、" "あるいは論理パス名の名前文字が" (CODE1 "(parse-namestring string host)")
     "によって構文解析されるときに" (STRONG "host") "が" (CODE1 "parse-namestring") "によって定義された"
     "適切なオブジェクトとして表現されたものになることができます。" "もし" (STRONG "to-wildcard") "が論理パス名に変換されるとき、"
     (CODE1 "translate-logical-pathname") "は" "これを使用するたびに変換手順が繰り返し実行されます。" EOL2
     (STRONG "host") "は論理パス名のホストの要素か、" (CODE1 "setf") "の"
     (CODE1 "logical-pathname-translations") "によって" "論理ホスト名のホスト名として定義された文字列のどちらかです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";;; 論理パス名のホストの設定の非常にシンプルな例です。"
      ";;; ファイルシステム周辺の制限による変換は必要なく、" ";;; 変換は全て指定した物理的なディレクトリをルートとした"
      ";;; 論理ファイルシステムに含まれるツリーになります。" ";;; 右側の名前文字列の構文は実装依存です。"
      "(setf (logical-pathname-translations \"foo\")"
      "      '((\"**;*.*.*\"              \"MY-LISPM:>library>foo>**>\")))" NIL
      ";;; 論理パス名を使用したサンプルです。" ";;; 返却値は実装依存です。"
      "(translate-logical-pathname \"foo:bar;baz;mum.quux.3\")"
      "=>  #P\"MY-LISPM:>library>foo>bar>baz>mum.quux.3\"" NIL
      ";;; もっと複雑な例であり、ファイルが2つのファイルサーバと" ";;; いくつかの違ったディレクトリに解かれています。これはUnixでは"
      ";;; サポートされていないディレクトリの:WILD-INFERIORSがあり、" ";;; 各ディレクトリの階層は個別に変換される必要があります。"
      ";;; ファイル名とタイプは、.MAILから.MBXへのもの以外は" ";;; 変換の必要がありません。" ";;; 右側の名前文字列の構文は実装依存です。"
      "(setf (logical-pathname-translations \"prog\")"
      "      '((\"RELEASED;*.*.*\"        \"MY-UNIX:/sys/bin/my-prog/\")"
      "        (\"RELEASED;*;*.*.*\"      \"MY-UNIX:/sys/bin/my-prog/*/\")"
      "        (\"EXPERIMENTAL;*.*.*\"    \"MY-UNIX:/usr/Joe/development/prog/\")"
      "        (\"EXPERIMENTAL;DOCUMENTATION;*.*.*\""
      "                                 \"MY-VAX:SYS$DISK:[JOE.DOC]\")"
      "        (\"EXPERIMENTAL;*;*.*.*\"  \"MY-UNIX:/usr/Joe/development/prog/*/\")"
      "        (\"MAIL;**;*.MAIL\"        \"MY-VAX:SYS$DISK:[JOE.MAIL.PROG...]*.MBX\")))"
      NIL ";;; 論理パス名を使用したサンプルです。" ";;; 返却値は実装依存です。"
      "(translate-logical-pathname \"prog:mail;save;ideas.mail.3\")"
      "=>  #P\"MY-VAX:SYS$DISK:[JOE.MAIL.PROG.SAVE]IDEAS.MBX.3\"" NIL
      ";;; 3つのファイルmain.lisp, auxiliary.lisp, documentation.lispで使われた"
      ";;; プログラムの変換例です。これらの変換はソフトウェアの提供者の例として" ";;; 提示されるかもしれません。" NIL
      ";;; Unixで使用する長いファイル名" "(setf (logical-pathname-translations \"prog\")"
      "      '((\"CODE;*.*.*\"             \"/lib/prog/\")))" NIL ";;; 論理パス名を使用したサンプルです。"
      ";;; 返却値は実装依存です。" "(translate-logical-pathname \"prog:code;documentation.lisp\")"
      "=>  #P\"/lib/prog/documentation.lisp\"" NIL
      ";;; Unixで使用する14文字のファイル名と、タイプとして.lispを使用"
      "(setf (logical-pathname-translations \"prog\")"
      "      '((\"CODE;DOCUMENTATION.*.*\" \"/lib/prog/docum.*\")"
      "        (\"CODE;*.*.*\"             \"/lib/prog/\")))" NIL ";;; 論理パス名を使用したサンプルです。"
      ";;; 返却値は実装依存です。" "(translate-logical-pathname \"prog:code;documentation.lisp\")"
      "=>  #P\"/lib/prog/docum.lisp\"" NIL ";;; Unixで使用する14文字のファイル名と、タイプとして.lを使用。"
      ";;; 2番目の変換はコンパイルされたファイルタイプ.bへ短くする。"
      "(setf (logical-pathname-translations \"prog\")"
      "      `((\"**;*.LISP.*\"            ,(logical-pathname \"PROG:**;*.L.*\"))"
      "        (,(compile-file-pathname (logical-pathname \"PROG:**;*.LISP.*\"))"
      "                                  ,(logical-pathname \"PROG:**;*.B.*\"))"
      "        (\"CODE;DOCUMENTATION.*.*\" \"/lib/prog/documentatio.*\")"
      "        (\"CODE;*.*.*\"             \"/lib/prog/\")))" NIL ";;; 論理パス名を使用したサンプルです。"
      ";;; 返却値は実装依存です。" "(translate-logical-pathname \"prog:code;documentation.lisp\")"
      "=>  #P\"/lib/prog/documentatio.l\"" NIL ";;; Crayで使用する6文字の名前と、ディレクトリ・タイプ・バージョンなし。"
      "(setf (logical-pathname-translations \"prog\")"
      "      (let ((l '((\"MAIN\" \"PGMN\")" "                 (\"AUXILIARY\" \"PGAUX\")"
      "                 (\"DOCUMENTATION\" \"PGDOC\")))"
      "            (logpath (logical-pathname \"prog:code;\"))"
      "            (phypath (pathname \"XXX\")))" "        (append"
      "          ;; ソースファイルの変換" "          (mapcar #'(lambda (x)"
      "                      (let ((log (first x))"
      "                            (phy (second x)))"
      "                        (list (make-pathname :name log"
      "                                             :type \"LISP\""
      "                                             :version :wild"
      "                                             :defaults logpath)"
      "                              (make-pathname :name phy"
      "                                             :defaults phypath))))"
      "                  l)" "          ;; コンパイルされたファイルの変換"
      "          (mapcar #'(lambda (x)" "                      (let* ((log (first x))"
      "                             (phy (second x))"
      "                             (com (compile-file-pathname"
      "                                    (make-pathname :name log"
      "                                                   :type \"LISP\""
      "                                                   :version :wild"
      "                                                   :defaults logpath))))"
      "                        (setq phy (concatenate 'string phy \"B\"))"
      "                        (list com"
      "                              (make-pathname :name phy"
      "                                             :defaults phypath))))"
      "                  l))))" NIL ";;; 論理パス名を使用したサンプルです。" ";;; 返却値は実装依存です。"
      "(translate-logical-pathname \"prog:code;documentation.lisp\")" "=>  #P\"PGDOC\""))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "host") "が正しく与えられなかったら、型" (CODE1 "type-error")
     "がエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "logical-pathname") "," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "実装は論理パス名のホストを操作するための" "例えば追加で変換の規則やオプションなどを指定した"
     "追加の関数を定義できます。")))
(setf (gethash '("LOGICAL-PATHNAME-TRANSLATIONS" . "ACCESSOR") *table*) (gethash "LOGICAL-PATHNAME-TRANSLATIONS" *table*))
(setf (gethash "LOOP" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "LOOP"))
    (CHAPTER ("## 構文") 2 "単純な" (CODE1 "loop") "フォーム:" EOL1 (CODE1 "loop") " "
     (STRONG "compound-form\\*") " => " (STRONG "result\\*") EOL2 "拡張された" (CODE1 "loop")
     "フォーム:" EOL1 (CODE1 "loop") " [" (STRONG "name-clause") "] " (CODE1 "{")
     (STRONG "variable-clause") (CODE1 "}") "\\* " (CODE1 "{") (STRONG "main-clause")
     (CODE1 "}") "\\*" EOL1 "=> " (STRONG "result\\*")
     (CODE3 "```" "```" "name-clause::= named name "
      "variable-clause::= with-clause | initial-final | for-as-clause "
      "with-clause::= with var1 [type-spec] [= form1] {and var2 [type-spec] [= form2]}* "
      "main-clause::= unconditional | accumulation | conditional | termination-test | initial-final "
      "initial-final::= initially compound-form+ | finally compound-form+ "
      "unconditional::= {do | doing} compound-form+ | return {form | it} "
      "accumulation::= list-accumulation | numeric-accumulation "
      "list-accumulation::= {collect | collecting | append | appending | nconc | nconcing} {form | it}  "
      "                     [into simple-var] "
      "numeric-accumulation::= {count | counting | sum | summing | } "
      "                         maximize | maximizing | minimize | minimizing {form | it} "
      "                        [into simple-var] [type-spec] "
      "conditional::= {if | when | unless} form selectable-clause {and selectable-clause}*  "
      "               [else selectable-clause {and selectable-clause}*]  "
      "               [end] "
      "selectable-clause::= unconditional | accumulation | conditional "
      "termination-test::= while form | until form | repeat form | always form | never form | thereis form "
      "for-as-clause::= {for | as} for-as-subclause {and for-as-subclause}* "
      "for-as-subclause::= for-as-arithmetic | for-as-in-list | for-as-on-list | for-as-equals-then | "
      "                    for-as-across | for-as-hash | for-as-package "
      "for-as-arithmetic::= var [type-spec] for-as-arithmetic-subclause "
      "for-as-arithmetic-subclause::= arithmetic-up | arithmetic-downto | arithmetic-downfrom "
      "arithmetic-up::= [[{from | upfrom} form1 |   {to | upto | below} form2 |   by form3]]+ "
      "arithmetic-downto::= [[{ {from form1} }1  |   { { {downto | above} form2} }1  |   by form3]] "
      "arithmetic-downfrom::= [[{ {downfrom form1} }1  |   {to | downto | above} form2 |   by form3]] "
      "for-as-in-list::= var [type-spec] in form1 [by step-fun] "
      "for-as-on-list::= var [type-spec] on form1 [by step-fun] "
      "for-as-equals-then::= var [type-spec] = form1 [then form2] "
      "for-as-across::= var [type-spec] across vector "
      "for-as-hash::= var [type-spec] being {each | the}  "
      "               { {hash-key | hash-keys} {in | of} hash-table  "
      "                [using (hash-value other-var)] |  "
      "                {hash-value | hash-values} {in | of} hash-table  "
      "                [using (hash-key other-var)]} "
      "for-as-package::= var [type-spec] being {each | the}  "
      "                  {symbol | symbols | "
      "                   present-symbol | present-symbols | "
      "                   external-symbol | external-symbols} "
      "                  [{in | of} package] "
      "type-spec::= simple-type-spec | destructured-type-spec "
      "simple-type-spec::= fixnum | float | t | nil "
      "destructured-type-spec::= of-type d-type-spec "
      "d-type-spec::= type-specifier | (d-type-spec . d-type-spec) " "var::= d-var-spec "
      "var1::= d-var-spec " "var2::= d-var-spec " "other-var::= d-var-spec "
      "d-var-spec::= simple-var | nil | (d-var-spec . d-var-spec) "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "compound-form") " - compound-form" EOL1
     (STRONG "name") " - シンボル" EOL1 (STRONG "simple-var") " - シンボル（変数名）" EOL1
     (STRONG "form") ", " (STRONG "form1") ", " (STRONG "form2") ", " (STRONG "form3")
     " - フォーム" EOL1 (STRONG "step-fun") " - ひとつの引数を取る関数に評価されるフォーム" EOL1 (STRONG "vector")
     " - " (CODE1 "vector") "に評価されるフォーム" EOL1 (STRONG "hash-table")
     " - ハッシュテーブルに評価されるフォーム" EOL1 (STRONG "package") " - パッケージ指定子に評価されるフォーム" EOL1
     (STRONG "type-specifier") " - 型指定子。" "これは原始的な型指定子でも合成された型指定子のどちらかであり、"
     "それは分配される様式を正式に構文解析するような" "いくつか追加された複雑な機能が導入されているかもしれません。"
     "詳しくは6.1.1.7. 分配をご確認ください。" EOL1 (STRONG "result") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "詳細は6.1. 繰り返しの機能をご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; LOOPの単純なフォームの例" "(defun sqrt-advisor ()"
      "  (loop (format t \"~&Number: \")"
      "        (let ((n (parse-integer (read-line) :junk-allowed t)))"
      "          (when (not n) (return))"
      "          (format t \"~&The square root of ~D is ~D.~%\" n (sqrt n)))))"
      "=>  SQRT-ADVISOR" " (sqrt-advisor)" ">>  Number: 5<NEWLINE>"
      ">>  The square root of 5 is 2.236068." ">>  Number: 4<NEWLINE>"
      ">>  The square root of 4 is 2." ">>  Number: done<NEWLINE>" "=>  NIL" NIL
      ";; LOOPの拡張されたフォームの例" "(defun square-advisor ()"
      "  (loop as n = (progn (format t \"~&Number: \")"
      "                      (parse-integer (read-line) :junk-allowed t))"
      "        while n"
      "        do (format t \"~&The square of ~D is ~D.~%\" n (* n n))))"
      "=>  SQUARE-ADVISOR" " (square-advisor)" ">>  Number: 4<NEWLINE>"
      ">>  The square of 4 is 16." ">>  Number: 23<NEWLINE>"
      ">>  The square of 23 is 529." ">>  Number: done<NEWLINE>" "=>  NIL" NIL
      ";; LOOPの拡張されたフォームの別の例" "(loop for n from 1 to 10" "      when (oddp n)"
      "        collect n)" "=>  (1 3 5 7 9)"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "do") "," (CODE1 "dolist") "," (CODE1 "dotimes") ","
     (CODE1 "return") "," (CODE1 "go") "," (CODE1 "throw") "," "6.1.1.7. 分配")
    (CHAPTER ("## 備考") 2 "単純な" (CODE1 "loop") "フォームの中では" (CODE1 "loop-finish")
     "を使用することはできませんが、" "それ以外で単純な" (CODE1 "loop") "フォームは、" "拡張された" (CODE1 "loop")
     "フォームと下記のような関係があります。"
     (CODE3 "```lisp" "```" "(loop compound-form*) ==  (loop do compound-form*)"))))
(setf (gethash '("LOOP" . "MACRO") *table*) (gethash "LOOP" *table*))
(setf (gethash "LOOP-FINISH" *table*)
  '((CHAPTER NIL 0 "Local Macro " (CODE1 "LOOP-FINISH"))
    (CHAPTER ("## 構文") 2 (CODE1 "loop-finish") " " (CODE1 "<引数なし>") " => " (CODE1 "|"))
    (CHAPTER ("## 定義") 2 (CODE1 "loop-finish") "マクロは、" "拡張された" (CODE1 "loop") "フォームの中で"
     "レキシカルに使用することができ、" "そのフォームを「普通に」終了させます。" "つまり、文脈的に最も内側の拡張された" (CODE1 "loop") "フォームを"
     "繰り返しの終わりの位置に遷移させます。" "これはどんな" (CODE1 "finally") "項の実行も許しますし、" "蓄積された結果の返却も行われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; loopは終了しますが、蓄積されたcountは返却されます。"
      "(loop for i in '(1 2 3 stop-here 4 5 6)" "      when (symbolp i) do (loop-finish)"
      "      count i)" "=>  3" " " ";; 前のloopは次のものと同等です。"
      "(loop for i in '(1 2 3 stop-here 4 5 6)" "      until (symbolp i)"
      "      count i)" "=>  3" NIL ";; LOOP-FINISHはさまざまな状況に使用できますが、"
      ";; 最も必要とされるのはloopがトップレベルで行うもの" ";; （UNTILかWHENが同様なものとして使われる）を使用せずに"
      ":; 退出が必要となるような状況があった場合や、" ";; または終了の必要性が検出されてから実際に終了が行われるまでに"
      ";; 何らかの計算が行われなければならないような場合です。" "(defun tokenize-sentence (string)"
      "  (macrolet ((add-word (wvar svar)" "               `(when ,wvar"
      "                  (push (coerce (nreverse ,wvar) 'string) ,svar)"
      "                  (setq ,wvar nil))))"
      "    (loop with word = '() and sentence = '() and endpos = nil"
      "          for i below (length string)"
      "          do (let ((char (aref string i)))" "               (case char"
      "                 (#\\Space (add-word word sentence))"
      "                 (#\\. (setq endpos (1+ i)) (loop-finish))"
      "                 (otherwise (push char word))))"
      "          finally (add-word word sentence)"
      "                  (return (values (nreverse sentence) endpos)))))"
      "=>  TOKENIZE-SENTENCE" NIL
      "(tokenize-sentence \"this is a sentence. this is another sentence.\")"
      "=>  (\"this\" \"is\" \"a\" \"sentence\"), 19" NIL
      "(tokenize-sentence \"this is a sentence\")"
      "=>  (\"this\" \"is\" \"a\" \"sentence\"), NIL"))
    (CHAPTER ("## 副作用") 2 "遷移制御") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "グローバル環境において" (CODE1 "loop-finish") "が" (CODE1 "fbound")
     "かどうかは実装依存です。" "しかし" (CODE1 "loop-finish") "を再定義したりシャドウすることについては、"
     (CODE1 "COMMON-LISP") "パッケージのシンボルを" "グローバル環境下において" (CODE1 "fbound") "するようなことと"
     "同等の制限があります。" (CODE1 "loop-finish") "を" (CODE1 "loop") "の外で使用したときの結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "loop") "," "6.1. 繰り返しの機能") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("LOOP-FINISH" . "LOCA-MACRO") *table*) (gethash "LOOP-FINISH" *table*))
(setf (gethash "LOWER-CASE-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "UPPER-CASE-P") ", " (CODE1 "LOWER-CASE-P") ", "
     (CODE1 "BOTH-CASE-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "upper-case-p") " " (STRONG "character") " => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "lower-case-p") " " (STRONG "character")
     " => " (STRONG "generalized-boolean") EOL1 (CODE1 "both-case-p") " "
     (STRONG "character") " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " - 文字" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は、" (STRONG "character") "のケースをテストします。" EOL2
     (CODE1 "upper-case-p") "は、" (STRONG "character") "が大文字の場合は" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 (CODE1 "lower-case-p") "は、"
     (STRONG "character") "が小文字の場合は" (STRONG "true") "を、" "それ以外は" (STRONG "false")
     "を返却します。" EOL2 (CODE1 "both-case-p") "は、" (STRONG "character") "にケースがある場合は"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(upper-case-p #\\A) =>  true"
      "(upper-case-p #\\a) =>  false" "(both-case-p #\\a) =>  true"
      "(both-case-p #\\5) =>  false" "(lower-case-p #\\5) =>  false"
      "(upper-case-p #\\5) =>  false" ";; 次の例では、#\\Bellという文字が定義されている処理系を前提にしている。"
      "(lower-case-p #\\Bell) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "character") "が文字ではなかったら、型" (CODE1 "type-error")
     "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 (CODE1 "char-upcase") ", " (CODE1 "char-downcase")
     ", 13.1.4.3. 文字のケース, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("LOWER-CASE-P" . "FUNCTION") *table*) (gethash "LOWER-CASE-P" *table*))
(setf (gethash "MACRO-FUNCTION" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "MACRO-FUNCTION"))
    (CHAPTER ("## 構文") 2 (CODE1 "macro-function") " " (STRONG "symbol") " &optional "
     (STRONG "environment") " => " (STRONG "function") EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "macro-function") " " (STRONG "symbol") " &optional " (STRONG "environment")
     ") " (STRONG "new-function") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - シンボル" EOL1 (STRONG "environment")
     " - 環境オブジェクト" EOL1 (STRONG "function") " - マクロ関数か、" (CODE1 "nil") EOL1
     (STRONG "new-function") " - マクロ関数")
    (CHAPTER ("## 定義") 2 "指定された" (STRONG "environment") "下で、" (STRONG "symbol")
     "がマクロとして定義されている関数を持っているかどうかを決定します。" EOL2 "もしマクロ展開関数であれば、それは2つの引数の関数が返却されます。"
     (STRONG "symbol") "がレキシカルな環境内の" (STRONG "environment") "に関数が定義されていないか、"
     "あるいはその定義がマクロではなかったときは、" (CODE1 "macro-function") "は" (CODE1 "nil") "を返却します。" EOL2
     (STRONG "symbol") "は" (CODE1 "macro-function") "と" (CODE1 "special-operator-p") "の"
     "両方が" (STRONG "true") "になることが可能です。" EOL2 "マクロ定義は、Common Lispの標準の特殊フォームのみを理解できる"
     "プログラムによって使うことができるようにしなければなりません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defmacro macfun (x) '(macro-function 'macfun)) =>  MACFUN "
      "(not (macro-function 'macfun)) =>  false " "(macrolet ((foo (&environment env)"
      "              (if (macro-function 'bar env)" "                 ''yes"
      "                 ''no)))" "   (list (foo)" "         (macrolet ((bar () :beep))"
      "            (foo))))" NIL "=>  (NO YES)"))
    (CHAPTER ("## 影響") 2 (CODE1 "(setf macro-function)") "," (CODE1 "defmacro") ","
     (CODE1 "macrolet"))
    (CHAPTER ("## 例外") 2 (CODE1 "setf") "で" (CODE1 "macro-function") "を使用するときに、"
     (STRONG "environment") "が" (CODE1 "nil") "ではなかったときの結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "defmacro") "," "3.1. 評価")
    (CHAPTER ("## 備考") 2 (CODE1 "setf") "は" (CODE1 "macro-function") "と共に使うことで、"
     "シンボルのグローバル関数定義としてマクロを導入できます。" "例えば下記の通り。"
     (CODE3 "```lisp" "```" "(setf (macro-function symbol) fn)") EOL2
     "導入するされる値は、2つの引数を受け取る" (STRONG "function") "でなければなりません。" "引数はマクロコール全体と、環境オブジェクトであり、"
     "呼び出されるとその展開を計算します。" "この操作の実行は、" (STRONG "symbol") "にグローバル関数定義として"
     "マクロを一つだけ持たせることであり、" "以前のマクロ定義や関数定義は失われます。")))
(setf (gethash '("MACRO-FUNCTION" . "ACCESSOR") *table*) (gethash "MACRO-FUNCTION" *table*))
(setf (gethash "MACROEXPAND" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MACROEXPAND") ", " (CODE1 "MACROEXPAND-1"))
    (CHAPTER ("## 構文") 2 (CODE1 "macroexpand") " " (STRONG "form") " &optional "
     (STRONG "env") " => " (STRONG "expansion") ", " (STRONG "expanded-p") EOL1
     (CODE1 "macroexpand-1") " " (STRONG "form") " &optional " (STRONG "env") " => "
     (STRONG "expansion") ", " (STRONG "expanded-p"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "form") " - フォーム" EOL1 (STRONG "env")
     " - 環境オブジェクト。デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "expansion") " - フォーム" EOL1
     (STRONG "expanded-p") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "macroexpand") "と" (CODE1 "macroexpand-1") "は、マクロを展開します。"
     EOL2 "もし" (STRONG "form") "がマクロフォームであれば、" (CODE1 "macroexpand-1")
     "は一度だけマクロフォームを呼び出して展開します。" EOL2 (CODE1 "macroexpand") "は、マクロフォームではなくなるまで"
     (STRONG "form") "を繰り返し展開します。" "実際に" (CODE1 "macroexpand") "は、"
     (CODE1 "macroexpand-1") "を第二返却値が" (CODE1 "nil") "になるまで" "繰り返し呼び出します。" EOL2 "もし"
     (STRONG "form") "がマクロフォームならば、" (STRONG "expansion") "はマクロ展開の結果であり、"
     (STRONG "expanded-p") "は" (STRONG "true") "です。" "それ以外のときは、" (STRONG "expansion")
     "は与えられた" (STRONG "form") "そのものであり、" (STRONG "expanded-p") "は" (STRONG "false") "です。"
     EOL2 "マクロ展開は次のようにして行われます。" EOL2 (CODE1 "macroexpand-1") "は、" (STRONG "form")
     "がマクロフォームであると決定すると、" "適用可能なマクロかシンボルマクロの展開関数を取得します。" (CODE1 "*macroexpand-hook*")
     "の値は関数であることを強制し、" "3つの引数を持つ関数として呼び出しを行います。" "引数は展開関数と" (STRONG "form") "と"
     (STRONG "env") "です。" "この呼び出しによって得られた値は、" (STRONG "form") "の展開として受け取ります。" EOL2
     "グローバル環境下のマクロ定義に加えて、" (STRONG "env") "内に定義されている" (CODE1 "macrolet") "と"
     (CODE1 "symbol-macrolet") "によって確立された" "ローカルマクロも考慮されます。" "もし" (STRONG "form")
     "のみが引数に指定されたときは、" "環境は" (CODE1 "null") "として効果があり、" "ただ" (CODE1 "defmacro")
     "によって確立された" "グローバルマクロの定義のみが考慮されます。" "マクロ定義はローカル関数の定義によってシャドウされます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defmacro alpha (x y) `(beta ,x ,y)) =>  ALPHA"
      "(defmacro beta (x y) `(gamma ,x ,y)) =>  BETA"
      "(defmacro delta (x y) `(gamma ,x ,y)) =>  EPSILON"
      "(defmacro expand (form &environment env)"
      "  (multiple-value-bind (expansion expanded-p)" "      (macroexpand form env)"
      "    `(values ',expansion ',expanded-p))) =>  EXPAND"
      "(defmacro expand-1 (form &environment env)"
      "  (multiple-value-bind (expansion expanded-p)" "      (macroexpand-1 form env)"
      "    `(values ',expansion ',expanded-p))) =>  EXPAND-1" NIL ";; 単純なグローバル環境の実行例"
      "(macroexpand-1 '(alpha a b)) =>  (BETA A B), true"
      "(expand-1 (alpha a b)) =>  (BETA A B), true"
      "(macroexpand '(alpha a b)) =>  (GAMMA A B), true"
      "(expand (alpha a b)) =>  (GAMMA A B), true"
      "(macroexpand-1 'not-a-macro) =>  NOT-A-MACRO, false"
      "(expand-1 not-a-macro) =>  NOT-A-MACRO, false"
      "(macroexpand '(not-a-macro a b)) =>  (NOT-A-MACRO A B), false"
      "(expand (not-a-macro a b)) =>  (NOT-A-MACRO A B), false" NIL ";; レキシカル環境の実行例"
      "(macrolet ((alpha (x y) `(delta ,x ,y)))"
      "  (macroexpand-1 '(alpha a b))) =>  (BETA A B), true"
      "(macrolet ((alpha (x y) `(delta ,x ,y)))"
      "  (expand-1 (alpha a b))) =>  (DELTA A B), true"
      "(macrolet ((alpha (x y) `(delta ,x ,y)))"
      "  (macroexpand '(alpha a b))) =>  (GAMMA A B), true"
      "(macrolet ((alpha (x y) `(delta ,x ,y)))"
      "  (expand (alpha a b))) =>  (GAMMA A B), true"
      "(macrolet ((beta (x y) `(epsilon ,x ,y)))"
      "  (expand (alpha a b))) =>  (EPSILON A B), true" "(let ((x (list 1 2 3)))"
      "  (symbol-macrolet ((a (first x)))" "    (expand a))) =>  (FIRST X), true"
      "(let ((x (list 1 2 3)))" "  (symbol-macrolet ((a (first x)))"
      "    (macroexpand 'a))) =>  A, false" "(symbol-macrolet ((b (alpha x y)))"
      "  (expand-1 b)) =>  (ALPHA X Y), true" "(symbol-macrolet ((b (alpha x y)))"
      "  (expand b)) =>  (GAMMA X Y), true" "(symbol-macrolet ((b (alpha x y))"
      "                  (a b))" "  (expand-1 a)) =>  B, true"
      "(symbol-macrolet ((b (alpha x y))" "                  (a b))"
      "  (expand a)) =>  (GAMMA X Y), true" NIL ";; シャドウの例"
      "(flet ((beta (x y) (+ x y)))" "  (expand (alpha a b))) =>  (BETA A B), true"
      "(macrolet ((alpha (x y) `(delta ,x ,y)))" "  (flet ((alpha (x y) (+ x y)))"
      "    (expand (alpha a b)))) =>  (ALPHA A B), false" "(let ((x (list 1 2 3)))"
      "  (symbol-macrolet ((a (first x)))" "    (let ((a x))"
      "      (expand a)))) =>  A, false"))
    (CHAPTER ("## 影響") 2 (CODE1 "defmacro") "," "(" (CODE1 "setf") " "
     (CODE1 "macro-function") ")," (CODE1 "macrolet") "," (CODE1 "symbol-macrolet"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "*macroexpand-hook*") "," (CODE1 "defmacro") "," "("
     (CODE1 "setf") " " (CODE1 "macro-function") ")," (CODE1 "macrolet") ","
     (CODE1 "symbol-macrolet") "," "3.1. 評価")
    (CHAPTER ("## 備考") 2 (CODE1 "macroexpand") "と" (CODE1 "macroexpand-1") "のどちらも、"
     "マクロフォーム内にあるサブフォームの" (STRONG "form") "やマクロを" "明に展開するようなことはしません。" "しかしそのような展開は"
     "意味解析や実装のマクロ展開によって" "暗黙的に行われることがあります。")))
(setf (gethash '("MACROEXPAND" . "FUNCTION") *table*) (gethash "MACROEXPAND" *table*))
(setf (gethash "MACROEXPAND-1" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MACROEXPAND") ", " (CODE1 "MACROEXPAND-1"))
    (CHAPTER ("## 構文") 2 (CODE1 "macroexpand") " " (STRONG "form") " &optional "
     (STRONG "env") " => " (STRONG "expansion") ", " (STRONG "expanded-p") EOL1
     (CODE1 "macroexpand-1") " " (STRONG "form") " &optional " (STRONG "env") " => "
     (STRONG "expansion") ", " (STRONG "expanded-p"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "form") " - フォーム" EOL1 (STRONG "env")
     " - 環境オブジェクト。デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "expansion") " - フォーム" EOL1
     (STRONG "expanded-p") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "macroexpand") "と" (CODE1 "macroexpand-1") "は、マクロを展開します。"
     EOL2 "もし" (STRONG "form") "がマクロフォームであれば、" (CODE1 "macroexpand-1")
     "は一度だけマクロフォームを呼び出して展開します。" EOL2 (CODE1 "macroexpand") "は、マクロフォームではなくなるまで"
     (STRONG "form") "を繰り返し展開します。" "実際に" (CODE1 "macroexpand") "は、"
     (CODE1 "macroexpand-1") "を第二返却値が" (CODE1 "nil") "になるまで" "繰り返し呼び出します。" EOL2 "もし"
     (STRONG "form") "がマクロフォームならば、" (STRONG "expansion") "はマクロ展開の結果であり、"
     (STRONG "expanded-p") "は" (STRONG "true") "です。" "それ以外のときは、" (STRONG "expansion")
     "は与えられた" (STRONG "form") "そのものであり、" (STRONG "expanded-p") "は" (STRONG "false") "です。"
     EOL2 "マクロ展開は次のようにして行われます。" EOL2 (CODE1 "macroexpand-1") "は、" (STRONG "form")
     "がマクロフォームであると決定すると、" "適用可能なマクロかシンボルマクロの展開関数を取得します。" (CODE1 "*macroexpand-hook*")
     "の値は関数であることを強制し、" "3つの引数を持つ関数として呼び出しを行います。" "引数は展開関数と" (STRONG "form") "と"
     (STRONG "env") "です。" "この呼び出しによって得られた値は、" (STRONG "form") "の展開として受け取ります。" EOL2
     "グローバル環境下のマクロ定義に加えて、" (STRONG "env") "内に定義されている" (CODE1 "macrolet") "と"
     (CODE1 "symbol-macrolet") "によって確立された" "ローカルマクロも考慮されます。" "もし" (STRONG "form")
     "のみが引数に指定されたときは、" "環境は" (CODE1 "null") "として効果があり、" "ただ" (CODE1 "defmacro")
     "によって確立された" "グローバルマクロの定義のみが考慮されます。" "マクロ定義はローカル関数の定義によってシャドウされます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defmacro alpha (x y) `(beta ,x ,y)) =>  ALPHA"
      "(defmacro beta (x y) `(gamma ,x ,y)) =>  BETA"
      "(defmacro delta (x y) `(gamma ,x ,y)) =>  EPSILON"
      "(defmacro expand (form &environment env)"
      "  (multiple-value-bind (expansion expanded-p)" "      (macroexpand form env)"
      "    `(values ',expansion ',expanded-p))) =>  EXPAND"
      "(defmacro expand-1 (form &environment env)"
      "  (multiple-value-bind (expansion expanded-p)" "      (macroexpand-1 form env)"
      "    `(values ',expansion ',expanded-p))) =>  EXPAND-1" NIL ";; 単純なグローバル環境の実行例"
      "(macroexpand-1 '(alpha a b)) =>  (BETA A B), true"
      "(expand-1 (alpha a b)) =>  (BETA A B), true"
      "(macroexpand '(alpha a b)) =>  (GAMMA A B), true"
      "(expand (alpha a b)) =>  (GAMMA A B), true"
      "(macroexpand-1 'not-a-macro) =>  NOT-A-MACRO, false"
      "(expand-1 not-a-macro) =>  NOT-A-MACRO, false"
      "(macroexpand '(not-a-macro a b)) =>  (NOT-A-MACRO A B), false"
      "(expand (not-a-macro a b)) =>  (NOT-A-MACRO A B), false" NIL ";; レキシカル環境の実行例"
      "(macrolet ((alpha (x y) `(delta ,x ,y)))"
      "  (macroexpand-1 '(alpha a b))) =>  (BETA A B), true"
      "(macrolet ((alpha (x y) `(delta ,x ,y)))"
      "  (expand-1 (alpha a b))) =>  (DELTA A B), true"
      "(macrolet ((alpha (x y) `(delta ,x ,y)))"
      "  (macroexpand '(alpha a b))) =>  (GAMMA A B), true"
      "(macrolet ((alpha (x y) `(delta ,x ,y)))"
      "  (expand (alpha a b))) =>  (GAMMA A B), true"
      "(macrolet ((beta (x y) `(epsilon ,x ,y)))"
      "  (expand (alpha a b))) =>  (EPSILON A B), true" "(let ((x (list 1 2 3)))"
      "  (symbol-macrolet ((a (first x)))" "    (expand a))) =>  (FIRST X), true"
      "(let ((x (list 1 2 3)))" "  (symbol-macrolet ((a (first x)))"
      "    (macroexpand 'a))) =>  A, false" "(symbol-macrolet ((b (alpha x y)))"
      "  (expand-1 b)) =>  (ALPHA X Y), true" "(symbol-macrolet ((b (alpha x y)))"
      "  (expand b)) =>  (GAMMA X Y), true" "(symbol-macrolet ((b (alpha x y))"
      "                  (a b))" "  (expand-1 a)) =>  B, true"
      "(symbol-macrolet ((b (alpha x y))" "                  (a b))"
      "  (expand a)) =>  (GAMMA X Y), true" NIL ";; シャドウの例"
      "(flet ((beta (x y) (+ x y)))" "  (expand (alpha a b))) =>  (BETA A B), true"
      "(macrolet ((alpha (x y) `(delta ,x ,y)))" "  (flet ((alpha (x y) (+ x y)))"
      "    (expand (alpha a b)))) =>  (ALPHA A B), false" "(let ((x (list 1 2 3)))"
      "  (symbol-macrolet ((a (first x)))" "    (let ((a x))"
      "      (expand a)))) =>  A, false"))
    (CHAPTER ("## 影響") 2 (CODE1 "defmacro") "," "(" (CODE1 "setf") " "
     (CODE1 "macro-function") ")," (CODE1 "macrolet") "," (CODE1 "symbol-macrolet"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "*macroexpand-hook*") "," (CODE1 "defmacro") "," "("
     (CODE1 "setf") " " (CODE1 "macro-function") ")," (CODE1 "macrolet") ","
     (CODE1 "symbol-macrolet") "," "3.1. 評価")
    (CHAPTER ("## 備考") 2 (CODE1 "macroexpand") "と" (CODE1 "macroexpand-1") "のどちらも、"
     "マクロフォーム内にあるサブフォームの" (STRONG "form") "やマクロを" "明に展開するようなことはしません。" "しかしそのような展開は"
     "意味解析や実装のマクロ展開によって" "暗黙的に行われることがあります。")))
(setf (gethash '("MACROEXPAND-1" . "FUNCTION") *table*) (gethash "MACROEXPAND-1" *table*))
(setf (gethash "MACROLET" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "FLET") ", " (CODE1 "LABELS") ", "
     (CODE1 "MACROLET"))
    (CHAPTER ("## 構文") 2 (CODE1 "flet") " ((" (STRONG "function-name") " "
     (STRONG "lambda-list") " [[" (STRONG "local-declaration\\*") " " (CODE1 "|") " "
     (STRONG "local-documentation") "]] " (STRONG "local-form\\*") ")\\*)" " "
     (STRONG "declaration\\*") " " (STRONG "form\\*") EOL1 "=> " (STRONG "result\\*")
     EOL2 (CODE1 "labels") " ((" (STRONG "function-name") " " (STRONG "lambda-list")
     " [[" (STRONG "local-declaration\\*") " " (CODE1 "|") " "
     (STRONG "local-documentation") "]] " (STRONG "local-form\\*") ")\\*)" " "
     (STRONG "declaration") " " (STRONG "form\\*") " " (STRONG "declaration\\*") " "
     (STRONG "form\\*") EOL1 "=> " (STRONG "result\\*") EOL2 (CODE1 "macrolet") " (("
     (STRONG "name") " " (STRONG "lambda-list") " [[" (STRONG "local-declaration\\*") " "
     (CODE1 "|") " " (STRONG "local-documentation") "]] " (STRONG "local-form\\*")
     ")\\*)" " " (STRONG "declaration\\*") " " (STRONG "form\\*") EOL1 "=> "
     (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function-name") " - 関数名" EOL1 (STRONG "name")
     " - シンボル" EOL1 (STRONG "lambda-list") " - ラムダリスト。" (CODE1 "flet") "と"
     (CODE1 "labels") "は通常のラムダリスト。" (CODE1 "macrolet") "はマクロラムダリスト。" EOL1
     (STRONG "local-declaration") " - 宣言式。評価されません。" EOL1 (STRONG "declaration")
     " - 宣言式。評価されません。" EOL1 (STRONG "local-documentation") " - 文字列。評価されません。" EOL1
     (STRONG "local-form") ", " (STRONG "form") " - 暗黙のprogn" EOL1 (STRONG "result")
     " - " (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "flet") "、" (CODE1 "labels") "、" (CODE1 "macrolet") "は、"
     "ローカル関数とローカルマクロを定義し、" "そのローカルな定義を使い" (STRONG "form") "を実行します。" (STRONG "form")
     "は、現れた順に実行します。" EOL2 (CODE1 "flet") "と" (CODE1 "labels") "によって作成された各関数と、"
     (CODE1 "macrolet") "によって作成された各マクロの" "それぞれのボディ部の" (STRONG "form") "（ただしラムダリストは除く）は、"
     "必要に応じて、" (STRONG "function-name") "の関数の" (CODE1 "block") "名か" (STRONG "name")
     "を用いて、" "暗黙の" (CODE1 "block") "に囲まれます。" EOL2 "ローカル関数とマクロの定義部のリストと、" (CODE1 "flet")
     "および" (CODE1 "labels") "のボディ部" (STRONG "form") "間における" (STRONG "declaration")
     "のスコープは、" "ローカルの関数定義の本体が含まれません。" "ただし例外は" (CODE1 "labels") "の、" (CODE1 "inline") "、"
     (CODE1 "notinline") "、" (CODE1 "ftype") "宣言であり、" "これらはローカルの関数定義を参照し、"
     "そのローカル関数の本体に適用します。" "つまり、これらの宣言のスコープは、" "関数名として影響を与える範囲と同じです。" "これらの"
     (STRONG "declaration") "のスコープには、" (CODE1 "macrolet") "で定義されたマクロ展開数の本体は含まれません。" EOL2
     "- " (CODE1 "flet") "  - " (CODE1 "flet") "は、ローカルに名前がある関数を定義し、"
     "    それらの定義を束縛とともに一連の" (STRONG "form") "を実行します。" "    そのようなローカル関数はいくつでも定義できます。"
     "    <br><br>" "    名前が束縛されたスコープは、ただボディ部のみ含まれます。" "    " (CODE1 "flet") "のボディ部内では、"
     "    " (CODE1 "flet") "によって定義された" (STRONG "function-name") "という名前は、"
     "    同名のグローバルに宣言されたものではなく、" "    ローカルに宣言された関数が参照されます。" "    " (CODE1 "flet")
     "のスコープ内では、" "    " (CODE1 "flet") "によって定義されている" "    " (STRONG "function-name")
     "という名前の、" "    グローバルのsetf-expanderの定義は適用されません。" "    これは、"
     (CODE1 "(defmethod (setf f) ...)") "ではなく、" "    " (CODE1 "(defsetf f ...)")
     "に適用されることに注意してください。" "    <br><br>" "    " (CODE1 "flet")
     "によって定義された関数名は、レキシカルな環境内のものであり、" "    それらのローカルな定義は、ただ" (CODE1 "flet")
     "本体内でのみ保持されます。" "    関数定義の束縛は、" (CODE1 "flet") "本体でのみ見ることができ、"
     "    それらの定義自身では見ることができません。" "    関数定義内において、" "    ローカルの関数名で定義されているものを探すときは、" "    "
     (CODE1 "flet") "の外側で定義された関数かマクロが参照されます。" "    " (CODE1 "flet")
     "は、局所的にグローバル関数名を隠蔽することができ、" "    その新しい定義は、グローバルな定義を参照することができます。" "    <br><br>"
     "    どんな" (STRONG "local-documentation") "も、" "    対応するローカル関数（もし実際に作成されたとき）に、"
     "    ドキュメント文字として割り当てます。" "    <br><br>" EOL2 "- " (CODE1 "labels") "  - "
     (CODE1 "labels") "は、" (CODE1 "flet") "と同じですが、" "    " (CODE1 "labels")
     "の場合は定義された関数名のスコープが、" "    ボディ部と同じように関数定義自身にも囲まれるところが違っています。" "    <br><br>" EOL2
     "- " (CODE1 "macrolet") "  - " (CODE1 "macrolet") "は、" (CODE1 "defmacro")
     "と同じフォーマットで、" "    ローカルマクロの定義を確立します。" "    <br><br>" "    " (CODE1 "macrolet")
     "の内部では、" "    " (CODE1 "macrolet") "によって定義されている" "    " (STRONG "function-name")
     "という名前の、" "    グローバルのsetf-expanderの定義は適用されません。" "    そうではなく、" (CODE1 "setf")
     "はマクロフォームを展開し、" "    結果のフォームを再帰的に処理します。" "    <br><br>" "    " (CODE1 "macrolet")
     "によって定義されたマクロ展開関数は、" "    " (CODE1 "macrolet") "のフォームに現れる、"
     "    レキシカルな環境によって定義されたものです。" "    宣言と、" (CODE1 "macrolet") "と"
     (CODE1 "symbol-macrolet") "の定義は、" "    " (CODE1 "macrolet") "内の、ローカルマクロ定義に影響を及ぼします。"
     "    しかしもしローカルマクロ定義から" "    レキシカルな環境内で見ることができる" "    ローカルな変数か関数を参照したときの結果は未定義です。"
     "    <br><br>" "    どんな" (STRONG "local-documentation") "も、" "    対応するローカルマクロ関数に、"
     "    ドキュメント文字として割り当てます。" "    <br><br>")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun foo (x flag)" "  (macrolet ((fudge (z)"
      "                ; パラメーターxとflagはこの時点ではアクセス不可です。"
      "                ; flagの参照はグローバル変数の名前になります。"
      "                ` (if flag (* ,z ,z) ,z)))" "   ; パラメーターxとflagは、ここではアクセス可能です。"
      "    (+ x" "       (fudge x)" "       (fudge (+ x 1)))))" "== "
      "(defun foo (x flag)" "  (+ x" "     (if flag (* x x) x)"
      "     (if flag (* (+ x 1) (+ x 1)) (+ x 1))))")
     EOL2 "これは、マクロ展開が行われた後です。" (CODE1 "x") "と" (CODE1 "flag") "の発生は、" "関数" (CODE1 "foo")
     "のパラメータを合法的に参照しています。" "なぜなら、これらのパラメータは、" "マクロが呼ばれて展開が生成された場所では" "見ることができるからです。"
     (CODE3 "```lisp" "```" "(flet ((flet1 (n) (+ n n)))"
      "   (flet ((flet1 (n) (+ 2 (flet1 n))))" "     (flet1 2))) =>  6" NIL
      "(defun dummy-function () 'top-level) =>  DUMMY-FUNCTION "
      "(funcall #'dummy-function) =>  TOP-LEVEL " "(flet ((dummy-function () 'shadow)) "
      "     (funcall #'dummy-function)) =>  SHADOW "
      "(eq (funcall #'dummy-function) (funcall 'dummy-function))" "=>  true "
      "(flet ((dummy-function () 'shadow))" "  (eq (funcall #'dummy-function)"
      "      (funcall 'dummy-function)))" "=>  false " NIL "(defun recursive-times (k n)"
      "  (labels ((temp (n) " "             (if (zerop n) 0 (+ k (temp (1- n))))))"
      "    (temp n))) =>  RECURSIVE-TIMES" "(recursive-times 2 3) =>  6" NIL
      "(defmacro mlets (x &environment env) " "   (let ((form `(babbit ,x)))"
      "     (macroexpand form env))) =>  MLETS"
      "(macrolet ((babbit (z) `(+ ,z ,z))) (mlets 5)) =>  10"
      "(flet ((safesqrt (x) (sqrt (abs x))))" " ;; `safesqrt`関数は、二か所で使用されます。"
      "  (safesqrt (apply #'+ (map 'list #'safesqrt '(1 2 3 4 5 6)))))" "=>  3.291173"
      "(defun integer-power (n k)     " "  (declare (integer n))         "
      "  (declare (type (integer 0 *) k))" "  (labels ((expt0 (x k a)"
      "             (declare (integer x a) (type (integer 0 *) k))"
      "             (cond ((zerop k) a)"
      "                   ((evenp k) (expt1 (* x x) (floor k 2) a))"
      "                   (t (expt0 (* x x) (floor k 2) (* x a)))))"
      "           (expt1 (x k a)"
      "             (declare (integer x a) (type (integer 0 *) k))"
      "             (cond ((evenp k) (expt1 (* x x) (floor k 2) a))"
      "                   (t (expt0 (* x x) (floor k 2) (* x a))))))"
      "   (expt0 n k 1))) =>  INTEGER-POWER" "(defun example (y l)"
      "  (flet ((attach (x)" "           (setq l (append l (list x)))))"
      "    (declare (inline attach))" "    (dolist (x y)" "      (unless (null (cdr x))"
      "        (attach x)))" "    l))" NIL
      "(example '((a apple apricot) (b banana) (c cherry) (d) (e))"
      "         '((1) (2) (3) (4 2) (5) (6 3 2)))"
      "=>  ((1) (2) (3) (4 2) (5) (6 3 2) (A APPLE APRICOT) (B BANANA) (C CHERRY))"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "declare") "," (CODE1 "defmacro") "," (CODE1 "defun") ","
     (CODE1 "documentation") "," (CODE1 "let") "," "3.1. 評価,"
     "3.4.11. ドキュメント文字と宣言の文脈的な作用")
    (CHAPTER ("## 備考") 2 (CODE1 "flet") "では、再帰関数を定義することはできません。" (CODE1 "labels")
     "は、互いに再帰呼出できる関数を定義するのに使うことができます。" EOL2 "もし" (CODE1 "macrolet") "がトップレベルフォームのとき、"
     "ボディ部" (STRONG "form") "もまたトップレベルフォームとして処理されます。" "3.2.3. ファイルのコンパイルをご確認ください。")))
(setf (gethash '("MACROLET" . "SPECIAL-OPERATOR") *table*) (gethash "MACROLET" *table*))
(setf (gethash "MAKE-ARRAY" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-ARRAY"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-array") " " (STRONG "dimensions") " "
     (CODE1 "&key") " " (STRONG "element-type") " " (STRONG "initial-element") " "
     (STRONG "initial-contents") " " (STRONG "adjustable") " " (STRONG "fill-pointer")
     " " (STRONG "displaced-to") " " (STRONG "displaced-index-offset") EOL1 " => "
     (STRONG "new-array"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "dimensions") " - 有効な配列の大きさのリストの指定子" EOL1
     (STRONG "element-type") " - 型指定子。デフォルトは" (CODE1 "t") "。" EOL1
     (STRONG "initial-element") " - オブジェクト" EOL1 (STRONG "initial-contents") " - オブジェクト"
     EOL1 (STRONG "adjustable") " - generalized-boolean。デフォルトは" (CODE1 "nil") "。" EOL1
     (STRONG "fill-pointer") " - 作成される配列の有効なfill-pointerか、" (CODE1 "t") "か、"
     (CODE1 "nil") "。" "デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "displaced-to") " - 配列か、"
     (CODE1 "nil") "。" "デフォルトは" (CODE1 "nil") "。" "もし" (STRONG "initial-element") "か"
     (STRONG "initial-contents") "が指定されたら、" "このオプションは指定できません。" EOL1
     (STRONG "displaced-index-offset") " - " (STRONG "displaced-to") "の有効な配列の"
     (CODE1 "row-major") "インデックス。" "デフォルトは" (CODE1 "0") "。" "もし" (STRONG "displaced-to")
     "に" (CODE1 "nil") "が指定されたら、" "このオプションは指定できません。" EOL1 (STRONG "new-array") " - 配列")
    (CHAPTER ("## 定義") 2 (STRONG "element-type") "によって与えられた要素の型を収容できるような、"
     "特定化した型によって構築された配列を生成して返却します。" "もし" (STRONG "dimension") "が" (CODE1 "nil") "のときは、"
     "ゼロ次元の配列を生成します。" EOL2 (STRONG "dimension") "は新しい配列の次元の表現です。" EOL2
     (STRONG "element-type") "は" (STRONG "new-array") "が格納できる要素の型を示します。"
     (STRONG "new-array") "は実際には" (STRONG "element-type") "をアップグレードした結果の"
     "型のオブジェクトを格納します。" "15.1.2.1. 配列のアップグレードをご確認ください。" EOL2 "もし"
     (STRONG "initial-element") "が指定されたとき、" "それは" (STRONG "new-array")
     "の各要素の初期値として使用されます。" "もし" (STRONG "initial-element") "が指定されたら、" "それは指定された"
     (STRONG "element-type") "の型でなければなりません。" "もし" (CODE1 ":initial-contents") "が指定されたか、"
     (STRONG "displaced-to") "が" (CODE1 "nil") "ではないかの" "どちらかのときに"
     (STRONG "initial-element") "は指定できません。" "もし" (STRONG "initial-element") "が指定されず、"
     "さらに" (STRONG "initial-contents") "が指定されず" (STRONG "displaced-to") "が" (CODE1 "nil")
     "のときは、" (STRONG "new-array") "の初期化されなかった要素が" "後で読み込まれたときの結果は未定義です。" EOL2
     (STRONG "initial-contents") "は配列の内容を初期化するときに使用します。" "例えば次の通り。"
     (CODE3 "```lisp" "```" "(make-array '(4 2 3) :initial-contents"
      "            '(((a b c) (1 2 3))" "             ((d e f) (3 1 2))"
      "             ((g h i) (2 3 1))" "             ((j k l) (0 0 0))))")
     EOL2 (STRONG "initial-contents") "はシーケンスの構造をネストして構築されます。"
     "その構造の階層の数は、配列のランクと等しくなければなりません。" "ネストされた構造の各葉の部分は、" "与えられた" (STRONG "element-type")
     "の型でなければなりません。" "もし配列がゼロ次元のとき、" (STRONG "initial-contents") "はひとつの要素を指定します。"
     "その他の場合は、" (STRONG "initial-contents") "は最初の次元と" "等しい長さのシーケンスでなければなりません。"
     "そのシーケンスの各要素は、残りの次元の配列に対する" "ネストされた構造でなければならず、以下同様です。" "もし"
     (CODE1 ":initial-element") "が指定されたか、" (STRONG "displaced-to") "が" (CODE1 "nil")
     "ではないかの" "どちらかのときに" (STRONG "initial-contents") "は指定できません。" "もし"
     (STRONG "initial-contents") "が指定されず、" "さらに" (STRONG "initial-element") "が指定されず"
     (STRONG "displaced-to") "が" (CODE1 "nil") "のときは、" (STRONG "new-array")
     "の初期化されなかった要素が" "後で読み込まれたときの結果は未定義です。" EOL2 "もし" (STRONG "adjustable") "が"
     (CODE1 "nil") "ではないとき、" "配列は" (CODE1 "adjustable") "と表現されます（また、実際に"
     (CODE1 "adjustable") "です）。" "その他の場合は、配列は" (CODE1 "adjustable") "と表現されません"
     "（また、配列が実際に" (CODE1 "adjustable") "かどうかは実装依存です）。" EOL2 "もし" (STRONG "fill-pointer")
     "が" (CODE1 "nil") "ではないとき、" "配列は一次元で無ければならず、つまり配列は" (CODE1 "vector") "でなければなりません。"
     "もし" (STRONG "fill-pointer") "が" (CODE1 "t") "のとき、" (CODE1 "vector")
     "の長さがfill-pointerの初期化に使用されます。" "もし" (STRONG "fill-pointer") "が整数のとき、" "それが"
     (CODE1 "vector") "のfill-pointerの初期値になります。" EOL2 "もし" (STRONG "displaced-to") "が"
     (CODE1 "nil") "ではないとき、" (CODE1 "make-array") "は" (STRONG "displaced-to") "を"
     (CODE1 "displaced") "の配列の参照先とした" (CODE1 "displaced") "配列を作成します。" "このような場合、"
     (STRONG "displaced-to") "の実際の配列の要素の型と、" "作成される配列の実際の配列の要素の型が"
     "型として等しくなかったときの結果は未定義です。" "もし" (STRONG "displaced-to") "が" (CODE1 "nil") "のとき、"
     "配列は" (CODE1 "displaced") "の配列ではありません。" EOL2 (STRONG "displaced-index-offset")
     "は、配列のオフセットのインデックスになります。" "配列" (CODE1 "A") "が" (CODE1 "make-array") "の引数"
     (CODE1 ":displaced-to") "として与えられ、" "配列" (CODE1 "B") "が生成されたとき、" "配列" (CODE1 "B")
     "は配列" (CODE1 "A") "へ" (CODE1 "displaced") "していると言われます。"
     "その配列のすべての要素数を、配列の全サイズと呼びますが、" "それは全ての次元の積として計算されます。" (CODE1 "A") "の全サイズは、"
     (CODE1 "B") "の全サイズに" (STRONG "displaced-index-offset") "として指定された" "オフセット"
     (CODE1 "n") "を加えた合計よりも小さくてはいけません。" (CODE1 "displaced") "の効果は、" "配列" (CODE1 "B")
     "は自分自身では何の要素も持たず、" "しかしかわりに自分自身のアクセスが配列" (CODE1 "A") "へのアクセスに対応します。"
     "この対応はそれらの両方に対して" (CODE1 "row-major") "オーダーの要素を取るような一次元の配列として扱われ、" "配列" (CODE1 "B")
     "の要素" (CODE1 "k") "へのアクセスが、" "配列" (CODE1 "A") "の要素" (CODE1 "k+n") "へのアクセスに対応されます。"
     EOL2 "もし" (CODE1 "make-array") "が、" (STRONG "adjustable") ", "
     (STRONG "fill-pointer") ", " (STRONG "displaced-to") "それぞれ" (CODE1 "nil")
     "として呼び出されたとき、" "その結果は" (CODE1 "simple-array") "になります。" "もし" (CODE1 "make-array")
     "が、" (STRONG "adjustable") ", " (STRONG "fill-pointer") ", " (STRONG "displaced-to")
     "のうちのどれかひとつ以上が" (STRONG "true") "のとき、" "結果の配列が" (CODE1 "simple-array")
     "かどうかは実装依存です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(make-array 5) ;; 一次元で5つの要素の配列を作成"
      "(make-array '(3 4) :element-type '(mod 16))"
      "               ;; 二次元3,4の各要素4bitの配列を作成"
      "(make-array 5 :element-type 'single-float) ;; single-floatの配列を作成"
      "(make-array nil :initial-element nil) =>  #0ANIL"
      "(make-array 4 :initial-element nil) =>  #(NIL NIL NIL NIL)" "(make-array '(2 4) "
      "             :element-type '(unsigned-byte 2) "
      "             :initial-contents '((0 1 2 3) (3 2 1 0)))"
      "=>  #2A((0 1 2 3) (3 2 1 0))" "(make-array 6"
      "             :element-type 'character " "             :initial-element #\\a "
      "             :fill-pointer 3) =>  \"aaa\"")
     EOL2 "下記は" (CODE1 "displaced") "配列の作成の例です。"
     (CODE3 "```lisp" "```" "(setq a (make-array '(4 3))) "
      "=>  #<ARRAY 4x3 simple 32546632>" "(dotimes (i 4)" "  (dotimes (j 3)"
      "    (setf (aref a i j) (list i 'x j '= (* i j)))))" "=>  NIL"
      "(setq b (make-array 8 :displaced-to a"
      "                      :displaced-index-offset 2))"
      "=>  #<ARRAY 8 indirect 32550757>" "(dotimes (i 8)"
      "  (print (list i (aref b i))))" ">>  (0 (0 X 2 = 0)) " ">>  (1 (1 X 0 = 0)) "
      ">>  (2 (1 X 1 = 1)) " ">>  (3 (1 X 2 = 2)) " ">>  (4 (2 X 0 = 0)) "
      ">>  (5 (2 X 1 = 2)) " ">>  (6 (2 X 2 = 4)) " ">>  (7 (3 X 0 = 0)) " "=>  NIL")
     EOL2 "最後の例は配列が" (CODE1 "row-major") "オーダーで格納する効果に依存しています。"
     (CODE3 "```lisp" "```" "(setq a1 (make-array 50))" "=>  #<ARRAY 50 simple 32562043>"
      "(setq b1 (make-array 20 :displaced-to a1 :displaced-index-offset 10))"
      "=>  #<ARRAY 20 indirect 32563346>" "(length b1) =>  20" NIL
      "(setq a2 (make-array 50 :fill-pointer 10))"
      "=>  #<ARRAY 50 fill-pointer 10 46100216>"
      "(setq b2 (make-array 20 :displaced-to a2 :displaced-index-offset 10))"
      "=>  #<ARRAY 20 indirect 46104010>" "(length a2) =>  10" "(length b2) =>  20" NIL
      "(setq a3 (make-array 50 :fill-pointer 10))"
      "=>  #<ARRAY 50 fill-pointer 10 46105663>"
      "(setq b3 (make-array 20 :displaced-to a3 :displaced-index-offset 10"
      "                         :fill-pointer 5))"
      "=>  #<ARRAY 20 indirect, fill-pointer 5 46107432>" "(length a3) =>  10"
      "(length b3) =>  5"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "adjustable-array-p") "," (CODE1 "aref") ","
     (CODE1 "arrayp") "," (CODE1 "array-element-type") "," (CODE1 "array-rank-limit") ","
     (CODE1 "array-dimension-limit") "," (CODE1 "fill-pointer") ","
     (CODE1 "upgraded-array-element-type"))
    (CHAPTER ("## 備考") 2 (CODE1 "adjustable-array-p") "が絶対に" (STRONG "false") "を返却するような"
     "配列を作成する特定の方法はありません。" (CODE1 "simple-array") "ではない配列を作成する特定の方法はありません。")))
(setf (gethash '("MAKE-ARRAY" . "FUNCTION") *table*) (gethash "MAKE-ARRAY" *table*))
(setf (gethash "MAKE-BROADCAST-STREAM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-BROADCAST-STREAM"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-broadcast-stream") " " (CODE1 "&rest") " "
     (STRONG "stream") " => " (STRONG "broadcast-stream"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream") " - 出力ストリーム" EOL1
     (STRONG "broadcast-stream") " - " (CODE1 "broadcast") "ストリーム")
    (CHAPTER ("## 定義") 2 (CODE1 "broadcast") "ストリームを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq a-stream (make-string-output-stream)"
      "       b-stream (make-string-output-stream)) =>  #<String Output Stream>"
      "(format (make-broadcast-stream a-stream b-stream)"
      "         \"this will go to both streams\") =>  NIL"
      "(get-output-stream-string a-stream) =>  \"this will go to both streams\""
      " (get-output-stream-string b-stream) =>  \"this will go to both streams\""))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "stream") "のどれかが出力ストリームではないときは、" "型"
     (CODE1 "type-error") "のエラーを通知するべきです。")
    (CHAPTER ("## 参考") 2 (CODE1 "broadcast-stream-streams")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAKE-BROADCAST-STREAM" . "FUNCTION") *table*) (gethash "MAKE-BROADCAST-STREAM" *table*))
(setf (gethash "MAKE-CONCATENATED-STREAM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-CONCATENATED-STREAM"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-concatenated-stream") " " (CODE1 "&rest") " "
     (STRONG "input-stream") " => " (STRONG "concatenated-stream"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "input-stream") " - 入力ストリーム" EOL1
     (STRONG "concatenated-stream") " - " (CODE1 "concatenated") "ストリーム")
    (CHAPTER ("## 定義") 2 "初期値が指定された" (STRONG "input-stream") "に関連付けられた"
     (CODE1 "concatenated") "ストリームを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(read (make-concatenated-stream"
      "        (make-string-input-stream \"1\")"
      "        (make-string-input-stream \"2\"))) =>  12"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "引数のどれかが入力ストリームではないときは、" "型" (CODE1 "type-error")
     "のエラーを通知するべきです。")
    (CHAPTER ("## 参考") 2 (CODE1 "concatenated-stream-streams"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAKE-CONCATENATED-STREAM" . "FUNCTION") *table*) (gethash "MAKE-CONCATENATED-STREAM" *table*))
(setf (gethash "MAKE-CONDITION" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-CONDITION"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-condition") " " (STRONG "type") " " (CODE1 "&rest")
     " " (STRONG "slot-initializations") " => " (STRONG "condition"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "type") " - 型指定子（" (CODE1 "condition") "のサブタイプ）"
     EOL1 (STRONG "slot-initializations") " - 初期化引数リスト" EOL1 (STRONG "condition")
     " - コンディション")
    (CHAPTER ("## 定義") 2 "型が" (STRONG "type") "でスロットの初期値が"
     (STRONG "slot-initializations") "の" "コンディションを構築して返却します。" "新しく作成されたコンディションが返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defvar *oops-count* 0)" NIL
      "(setq a (make-condition 'simple-error"
      "                        :format-control \"This is your ~:R error.\""
      "                        :format-arguments (list (incf *oops-count*))))"
      "=>  #<SIMPLE-ERROR 32245104>" NIL "(format t \"~&~A~%\" a)"
      ">>  This is your first error." "=>  NIL" NIL "(error a)"
      ">>  Error: This is your first error."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Return to Lisp Toplevel." ">>  Debug> "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "定義されたコンディションの型の集合")
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "define-condition") "," "9.1. コンディションシステムの説明")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAKE-CONDITION" . "FUNCTION") *table*) (gethash "MAKE-CONDITION" *table*))
(setf (gethash "MAKE-ECHO-STREAM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-ECHO-STREAM"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-echo-stream") " " (STRONG "input-stream") " "
     (STRONG "output-stream") " => " (STRONG "echo-stream"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "input-stream") " - ストリーム" EOL1
     (STRONG "output-stream") " - ストリーム" EOL1 (STRONG "echo-stream") " - " (CODE1 "echo")
     "ストリーム")
    (CHAPTER ("## 定義") 2 "取得は" (STRONG "input-stream") "からの入力で、" "送信は"
     (STRONG "output-stream") "からの出力で構成される" (CODE1 "echo") "ストリームを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(let ((out (make-string-output-stream)))"
      "   (with-open-stream " "       (s (make-echo-stream"
      "           (make-string-input-stream \"this-is-read-and-echoed\")"
      "           out))" "     (read s)" "     (format s \" * this-is-direct-output\")"
      "     (get-output-stream-string out)))"
      "=>  \"this-is-read-and-echoed * this-is-direct-output\""))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "echo-stream-input-stream") ","
     (CODE1 "echo-stream-output-stream") "," (CODE1 "make-two-way-stream"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAKE-ECHO-STREAM" . "FUNCTION") *table*) (gethash "MAKE-ECHO-STREAM" *table*))
(setf (gethash "MAKE-HASH-TABLE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-HASH-TABLE"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-hash-table") " " (CODE1 "&key") " " (STRONG "test")
     " " (STRONG "size") " " (STRONG "rehash-size") " " (STRONG "rehash-threshold")
     " => " (STRONG "hash-table"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "test") " - 関数" (CODE1 "eq") ", " (CODE1 "eql") ", "
     (CODE1 "equal") ", " (CODE1 "equalp") "のうちの" "ひとつに対する指定子。" "デフォルトは" (CODE1 "eql")
     "。" EOL1 (STRONG "size") " - 非負の整数。デフォルトは実装依存。" EOL1 (STRONG "rehash-size") " - 型"
     (CODE1 "(or (integer 1 *) (float (1.0) *))") "の実数。" "デフォルトは実装依存。" EOL1
     (STRONG "rehash-threshold") " - 型" (CODE1 "(real 0 1)") "の実数。" "デフォルトは実装依存。" EOL1
     (STRONG "hash-table") " - ハッシュテーブル")
    (CHAPTER ("## 定義") 2 "新しいハッシュテーブルを作成し返却します。" EOL2 (STRONG "test")
     "は、キーをどのように比較するかを決定します。" "もし" (STRONG "hash-table") "内の何らかのエントリーのキーが" "あるオブジェクトと"
     (STRONG "test") "で同一であるとき、" "そのオブジェクトは" (STRONG "hash-table") "内に存在すると言われます。" EOL2
     (STRONG "size") "は" (STRONG "hash-table") "の初期スペースをどのようにして確保するかについて、" "実装にヒントを与えます。"
     "この情報は" (STRONG "rehash-threshold") "と一緒に使用され、" "テーブルが拡張される前にどれくらいの数のエントリーが"
     "挿入可能であるかの近似を制御します。" "実際のサイズは、" (STRONG "size") "から次の「良好な」サイズへと切り上げます。"
     "例えば、ある実装では次の素数に切り上げを行います。" EOL2 (STRONG "rehash-size") "は、" (STRONG "hash-table")
     "がいっぱいになり再ハッシュを必要とするときに、" "サイズを増やす最小量を指定します。" "下記の" (STRONG "rehash-threshold")
     "をご確認ください。" "もし" (STRONG "rehash-size") "が整数のときは、" "テーブルの拡張されるレートが加算的に行われることが期待され、"
     "その整数はエントリーの数に加算されます。" "もし" (STRONG "rehash-size") "が浮動小数のときは、"
     "テーブルの拡張されるレートが乗算で行われることが期待され、" "その浮動小数の値は古いサイズに対する新しいサイズの比率になります。" (STRONG "size")
     "同様に、実際の増加分は切り上げられるかもしれません。" EOL2 (STRONG "rehash-threshold") "は、"
     (STRONG "hash-table") "がどの程度まで一杯になったら" "拡張しなければならないかを指定します。"
     "これはハッシュテーブルの最大占有率を指定します。" EOL2 (STRONG "rehash-size") "と"
     (STRONG "rehash-threshold") "の値は、" (STRONG "hash-table") "のサイズをいつどのように拡張するべきかについて、"
     "実装に何らかの特定な方法を使うような制約をすることはありません。" "そのような決定は実装依存であり、"
     "それらの値はただ実装プログラミングする人へのヒントであり、" "実装はそれらを無視することも許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 46142754>"
      "(setf (gethash \"one\" table) 1) =>  1" "(gethash \"one\" table) =>  NIL, false"
      "(setq table (make-hash-table :test 'equal)) =>  #<HASH-TABLE EQUAL 0/139 46145547>"
      "(setf (gethash \"one\" table) 1) =>  1" "(gethash \"one\" table) =>  1, T"
      "(make-hash-table :rehash-size 1.5 :rehash-threshold 0.7) "
      "=>  #<HASH-TABLE EQL 0/120 46156620>"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "gethash") "," (CODE1 "hash-table"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAKE-HASH-TABLE" . "FUNCTION") *table*) (gethash "MAKE-HASH-TABLE" *table*))
(setf (gethash "MAKE-INSTANCE" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "MAKE-INSTANCE"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-instance") " " (STRONG "class") " &rest "
     (STRONG "initargs") " &key &allow-other-keys => " (STRONG "instance"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "make-instance") " (" (STRONG "class") " "
     (CODE1 "standard-class") ") &rest " (STRONG "initargs") EOL1 (CODE1 "make-instance")
     " (" (STRONG "class") " " (CODE1 "symbol") ") &rest " (STRONG "initargs"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "class") " - クラスか、クラス名のシンボル" EOL1
     (STRONG "initargs") " - 初期化引数リスト" EOL1 (STRONG "instance") " - 新しい" (STRONG "class")
     "クラスのインスタンス")
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "make-instance") "は、" "クラス" (STRONG "class")
     "の新しいインスタンスを作成して返却します。" EOL2 "もし上記メソッド定義の2番目が選ばれたとき、" "そのメソッドは、第一引数を"
     (CODE1 "(find-class class)") "、" "そのあとの引数を" (STRONG "initargs") "として"
     (CODE1 "make-instance") "を実行します。" EOL2 "初期化引数は、" (CODE1 "make-instance")
     "内でチェックされます。" EOL2 "ジェネリック関数" (CODE1 "make-instance") "は、"
     "7.1. オブジェクトの作成と初期化に記載されているように使われます。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし初期化引数が有効として定義されていない場合は、" "型" (CODE1 "error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "defclass") "," (CODE1 "class-of") ","
     (CODE1 "allocate-instance") "," (CODE1 "initialize-instance") ","
     "7.1. オブジェクトの作成と初期化")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAKE-INSTANCE" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "MAKE-INSTANCE" *table*))
(setf (gethash "MAKE-INSTANCES-OBSOLETE" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "MAKE-INSTANCES-OBSOLETE"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-instances-obsolete") " " (STRONG "class") " => "
     (STRONG "class"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "make-instances-obsolete") " (" (STRONG "class") " "
     (CODE1 "standard-class") ")" EOL1 (CODE1 "make-instances-obsolete") " ("
     (STRONG "class") " " (CODE1 "symbol") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "class") " - クラス指定子")
    (CHAPTER ("## 定義") 2 "関数" (CODE1 "make-instances-obsolete") "は、" "クラス"
     (STRONG "class") "のインスタンスの更新処理を開始する効果があります。" "更新中に、ジェネリック関数"
     (CODE1 "update-instance-for-redefined-class") "が" "実行されます。" EOL2 (CODE1 "defclass")
     "が既存の標準クラスの再定義を行ったあとで" "インスタンスのアクセス可能な局所スロットが変更されたか、" "あるいはストレージ内のスロットの順序が変更されたときに、"
     "ジェネリック関数" (CODE1 "make-instances-obsolete") "が" "システムによって自動的に実行されます。"
     "これは明示的にユーザーが実行することもできます。" EOL2 "もし上記メソッド定義の2番目が選ばれたとき、" "そのメソッドは、引数を"
     (CODE1 "(find-class class)") "として" (CODE1 "make-instances-obsolete") "を実行します。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "update-instance-for-redefined-class")
     ", 4.3.6. クラスの再定義")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAKE-INSTANCES-OBSOLETE" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "MAKE-INSTANCES-OBSOLETE" *table*))
(setf (gethash "MAKE-LIST" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-LIST"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-list") " " (STRONG "size") " &key "
     (STRONG "initial-element") " => " (STRONG "list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "size") " - 非負の整数" EOL1 (STRONG "initial-element")
     " - オブジェクト。デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "list") " - リスト")
    (CHAPTER ("## 定義") 2 "各要素が" (STRONG "initial-element") "であり、長さが" (STRONG "size")
     "のリストを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(make-list 5) =>  (NIL NIL NIL NIL NIL)"
      "(make-list 3 :initial-element 'rah) =>  (RAH RAH RAH)"
      "(make-list 2 :initial-element '(1 2 3)) =>  ((1 2 3) (1 2 3))"
      "(make-list 0) =>  NIL ;i.e.,  ()"
      "(make-list 0 :initial-element 'new-element) =>  NIL "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "size") "が非負の整数ではなかったとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "cons") "," (CODE1 "list")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAKE-LIST" . "FUNCTION") *table*) (gethash "MAKE-LIST" *table*))
(setf (gethash "MAKE-LOAD-FORM" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "MAKE-LOAD-FORM"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-load-form") " " (STRONG "object") " &optional "
     (STRONG "environment") "=> " (STRONG "creation-form") "[, "
     (STRONG "initialization-form") "]")
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "make-load-form") " (" (STRONG "object") " "
     (CODE1 "standard-object") ") &optional " (STRONG "environment") EOL1
     (CODE1 "make-load-form") " (" (STRONG "object") " " (CODE1 "structure-object")
     ") &optional " (STRONG "environment") EOL1 (CODE1 "make-load-form") " ("
     (STRONG "object") " " (CODE1 "condition") ") &optional " (STRONG "environment") EOL1
     (CODE1 "make-load-form") " (" (STRONG "object") " " (CODE1 "class") ") &optional "
     (STRONG "environment"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "environment")
     " - 環境オブジェクト" EOL1 (STRONG "creation-form") " - フォーム" EOL1
     (STRONG "initialization-form") " - フォーム")
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "make-load-form") "は、" "ひとつか2つのフォームを返却します。"
     "それぞれ" (STRONG "creation-form") "と" (STRONG "initialization-form") "であり、"
     (CODE1 "load") "時に" (STRONG "object") "と等価なオブジェクトを構築することができます。"
     (STRONG "environment") "は、フォームが処理されるときの" "レキシカルな環境に対応する環境オブジェクトです。" EOL2
     "ファイルコンパイラは、特定のクラスのリテラルオブジェクトを処理するため、" (CODE1 "make-load-form") "を呼び出します。"
     "3.2.4.4. 外部オブジェクトの制約の追記を参照。" EOL2 "仕様に適合したプログラムは、" (STRONG "object") "が"
     (CODE1 "standard-object") "," (CODE1 "structure-object") ", " (CODE1 "condition")
     "からなる一般的なインスタンスであれば、" (CODE1 "make-load-form") "を直接呼び出します。" EOL2
     (STRONG "creation-form") "は" (CODE1 "load") "時に評価されるフォームであり、" (STRONG "object")
     "と等価なオブジェクトを返却しなければなりません。" "等価の正確な意味は" (STRONG "object") "の型によって異なるので、"
     (CODE1 "make-load-form") "のメソッドを定義するプログラマーに任されています。"
     "3.2.4. ファイルコンパイル時のリテラルオブジェクトを参照。" EOL2 "もし" (STRONG "object") "が"
     (STRONG "initialization-form") "に定数として現れたときは、" "ロード時にそれは、" (STRONG "creation-form")
     "によって生成されたオブジェクトと" "同一なものとして置き換えられます。" "これは、さらなる初期化処理でオブジェクトにアクセスする方法です。" EOL2
     (STRONG "creation-form") "と" (STRONG "initialization-form") "の両方で、"
     "外部オブジェクトの参照が含まれる場合があります。" "しかし、" (STRONG "creation-forms") "では循環的な依存関係はがあってはなりません。"
     "循環的な依存関係とは、例えば" "オブジェクト" (CODE1 "X") "の" (STRONG "creation-form") "にオブジェクト"
     (CODE1 "Y") "が含まれており、" "オブジェクト" (CODE1 "Y") "の" (STRONG "creation-form") "にオブジェクト"
     (CODE1 "X") "が" "含まれているような場合です。" (STRONG "initialization-form")
     "には循環的な依存関係のような制約はありません。" "これが" (STRONG "initialization-form") "フォームが存在する理由です。"
     "循環的なデータ構造の例は下記を参照してください。" EOL2 (STRONG "object") "の" (STRONG "creation-form")
     "は、常に" (STRONG "initialization-form") "より前に実行されます。" (STRONG "creation-form") "または"
     (STRONG "initialization-form") "のいずれかが、" "コンパイル中のファイル内で"
     "以前に参照されていない他のオブジェクトを参照する場合、" "コンパイラは、その参照しているフォームを評価する前に、"
     "すべての参照されているオブジェクトが作成されたことを確認します。" "参照されるオブジェクトが、ファイルコンパイラによって"
     (CODE1 "make-load-form") "を実行するタイプの場合は、" "そのオブジェクトのために、" "評価された"
     (STRONG "creation-form") "の返却値を実行します。" "（これが、" (STRONG "creation-form")
     "で循環参照を禁止している理由です。）" EOL2 "各" (STRONG "initialization-form") "は、データフローに従って、" "その"
     (STRONG "creation-form") "実行の後、できるだけ早く評価されます。" "もしファイル内で、" (STRONG "object") "の"
     (STRONG "initialization-form") "が、" "まだ参照されていない他のどんなオブジェクトも参照していないときに"
     "そのファイルコンパイラが" (CODE1 "make-load-form") "を実行した場合は、" (STRONG "initialization-form")
     "は" (STRONG "creation-form") "処理直後に実行されます。" EOL2 "もし" (STRONG "creation-form") "か"
     (STRONG "initialization-form") "のフォームを" (CODE1 "F") "としたとき、" (CODE1 "F")
     "がそのようなオブジェクトを参照を含む場合は、" "それらのオブジェクトは" (STRONG "creation-form") "は" (CODE1 "F")
     "の前に実行され、" "また、それらが" (CODE1 "F") "によって生成と初期化が行われるオブジェクトに依存しない限り、" "それらのオブジェクトの"
     (STRONG "initialization-form") "も" (CODE1 "F") "の前に実行されます。"
     "これらの規則によって、作成と初期化の2フォーム間で" "評価する順序が一意に決定されない個所については、" "その評価順序は決められていません。" EOL2
     "これらの作成と初期化のフォームが評価されている間の" "オブジェクトはおそらく初期化されていない状態であり、" "例えるなら、"
     (CODE1 "allocate-instance") "で作成され、" (CODE1 "initialize-instance") "で完全に初期化処理されるまでの"
     "オブジェクトの状態と似ています。" (CODE1 "make-load-form") "のメソッドを作成するプログラマーは、"
     "まだ初期化されていないスロットに依存しないよう、" "注意深くオブジェクトを操作しなければなりません。" EOL2 (CODE1 "load") "がフォームを"
     (CODE1 "eval") "で処理するか、" "あるいは同等の効果を持つ他のオペレーションを行うかは、" "処理系に依存します。"
     "例をあげると、フォームを別の違った同等の形式に変換して評価する、" "それらをコンパイルした結果の関数を" (CODE1 "load") "から呼ぶ、" "それらが"
     (CODE1 "eval") "とは違う特殊な目的の関数によって実行される、" "などがあります。" "フォームを評価するということと同等の効果があればよいのです。"
     EOL2 "型" (CODE1 "class") "に特化したメソッドは、" "もしクラスがちゃんとした名前を持っているときは、" "クラス名を使った"
     (STRONG "creation-form") "が返却されます。" "もしクラスが名前を持っていない場合は、" "型" (CODE1 "error")
     "のエラーが発せられます。" (STRONG "creation-form") "の評価は、" (CODE1 "find-class") "を呼び出すように、"
     "その名前を使用してクラスを検索します。" "もしその名前のクラスが定義されていないときは、" "クラスは実装で定義した方法で処理されます。" "もし"
     (STRONG "creation-form") "を評価した結果、" "クラスを返却できなかった場合は、" "型" (CODE1 "error")
     "のエラーが発生します。" EOL2 "仕様に適合した実装と仕様に適合したプログラムの両方が" (CODE1 "make-load-form")
     "をさらに特別化することができます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defclass obj ()" "   ((x :initarg :x :reader obj-x)"
      "    (y :initarg :y :reader obj-y)" "    (dist :accessor obj-dist)))"
      "=>  #<STANDARD-CLASS OBJ 250020030>"
      "(defmethod shared-initialize :after ((self obj) slot-names &rest keys)"
      "  (declare (ignore slot-names keys))" "  (unless (slot-boundp self 'dist)"
      "    (setf (obj-dist self)"
      "          (sqrt (+ (expt (obj-x self) 2) (expt (obj-y self) 2))))))"
      "=>  #<STANDARD-METHOD SHARED-INITIALIZE (:AFTER) (OBJ T) 26266714>"
      "(defmethod make-load-form ((self obj) &optional environment)"
      "  (declare (ignore environment))" "  ;; この定義は、XとYがオブジェクト自身を参照する情報を"
      "  ;; 含んでいない場合にのみ有効であることに注意してください。" "  ;; この問題に対するより一般的な解決策については、"
      "  ;; 以下の改訂例を参照してください。" "  `(make-instance ',(class-of self)"
      "                  :x ',(obj-x self) :y ',(obj-y self)))"
      "=>  #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 26267532>"
      "(setq obj1 (make-instance 'obj :x 3.0 :y 4.0)) =>  #<OBJ 26274136>"
      "(obj-dist obj1) =>  5.0"
      "(make-load-form obj1) =>  (MAKE-INSTANCE 'OBJ :X '3.0 :Y '4.0)")
     EOL2 "上記の例では、" (CODE1 "obj") "の等価なインスタンスは、" "そのスロットのうちの2つの値を使用して再構築されます。"
     "3番目のスロットの値は、これら2つの値から導かれます。" EOL2 (CODE1 "make-load-form") "メソッドの別の書き方の例は、"
     (CODE1 "make-load-form-saving-slots") "を使うことです。" "このメソッドが生成するコードは、" "上に示した"
     (CODE1 "make-load-form") "メソッドとは" "少し異なる結果をもたらすかもしれませんが、" "操作上の効果は同じです。" "例を示します。"
     (CODE3 "```lisp" "```" ";; 上記で定義したメソッドを再定義する"
      "(defmethod make-load-form ((self obj) &optional environment)"
      "   (make-load-form-saving-slots self"
      "                                :slot-names '(x y)"
      "                                :environment environment))"
      "=>  #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 42755655>" NIL
      ";; 上記で作成したオブジェクトにMAKE-LOAD-FORMを実行" "(make-load-form obj1)"
      "=>  (ALLOCATE-INSTANCE '#<STANDARD-CLASS OBJ 250020030>)," "   (PROGN"
      "     (SETF (SLOT-VALUE '#<OBJ 26274136> 'X) '3.0)"
      "     (SETF (SLOT-VALUE '#<OBJ 26274136> 'Y) '4.0)"
      "     (INITIALIZE-INSTANCE '#<OBJ 26274136>))")
     EOL2 "次の例は、" (CODE1 "my-frob") "のインスタンスが、" "何らかの方法で" (STRONG "") "intern"
     (STRONG "") "されています。" "スロット" (CODE1 "name") "の値をキーとして既存のオブジェクトを検索し、"
     "同等のインスタンスを再構築しています。" "この例では、プログラマーはオブジェクトが存在しなかったとき、" "新しいをオブジェクトを生成することを選んでいますが、"
     "他にはエラーを発生させるという場合もあります。"
     (CODE3 "```lisp" "```" "(defclass my-frob ()"
      "   ((name :initarg :name :reader my-name)))"
      "(defmethod make-load-form ((self my-frob) &optional environment)"
      "  (declare (ignore environment))"
      "  `(find-my-frob ',(my-name self) :if-does-not-exist :create))")
     EOL2 "次の例では、各親がその子のリストを持ち、" "各子がその親に戻る参照を持っているので、" "データ構造は循環しています。"
     "このような構造のひとつのオブジェクトに" (CODE1 "make-load-form") "が呼ばれると、" (STRONG "creation-form")
     "は同等のオブジェクトを作成し、" (CODE1 "children") "スロットを埋め、" "その子や孫などすべてのオブジェクトに対して"
     "同等のオブジェクトを強制的に作成します。" "この時点では、" (CODE1 "parent") "スロットはひとつも埋まっていません。"
     (STRONG "initialization-form") "フォームでは、" (CODE1 "parent") "スロットが埋められ、"
     "親に相当するオブジェクトがまだ作成されていない場合は、" "強制的に作成されます。" "したがって、ロード時にツリー全体が再作成されます。" "コンパイル時では、"
     (CODE1 "make-load-form") "はツリー内の各オブジェクトに対して" "一度だけ呼び出されます。" "すべての"
     (STRONG "creation-form") "が処理系に依存した順序で評価され、" "次にすべての" (STRONG "initialization-form")
     "が、" "同じく処理系に依存した順序で評価されます。"
     (CODE3 "```lisp" "```"
      "(defclass tree-with-parent () ((parent :accessor tree-parent)"
      "                               (children :initarg :children)))"
      "(defmethod make-load-form ((x tree-with-parent) &optional environment)"
      "  (declare (ignore environment))" "  (values" "    ;; creation form"
      "    `(make-instance ',(class-of x) :children ',(slot-value x 'children))"
      "    ;; initialization form"
      "    `(setf (tree-parent ',x) ',(slot-value x 'parent))))")
     EOL2 "次のの例では、データ構造に特別な特性はなく出力され、" "単純にスロットの内容を再構築するだけで" "同等の構造体を再構築することができます。"
     (CODE3 "```lisp" "```" "(defstruct my-struct a b c)"
      "(defmethod make-load-form ((s my-struct) &optional environment)"
      "   (make-load-form-saving-slots s :environment environment))"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (CODE1 "standard-object") ", " (CODE1 "structure-object") ", "
     (CODE1 "condition") "の特定メソッドは、型" (CODE1 "error") "のエラーが発生します。" EOL2
     "システムクラスの一般化されたインスタンスに対して" (CODE1 "make-load-form") "を呼び出すと、"
     "エラーが発生するか、作成・初期化フォームが返されるかは、処理系に依存します。")
    (CHAPTER ("## 参考") 2 (CODE1 "compile-file") "," (CODE1 "make-load-form-saving-slots")
     "," "3.2.4.4. 外部オブジェクトの制約の追記," "3.1. 評価," "3.2. コンパイル")
    (CHAPTER ("## 備考") 2 "ファイルコンパイラは、特定の状況下で" (CODE1 "make-load-form") "を呼び出します。"
     "3.2.4.4. 外部オブジェクトの制約の追記を参照。" EOL2 "実装によっては、システムクラスとして指定されたクラスの新しいサブクラスを"
     "定義する機能を提供する場合があります。" "（考えられる候補としては、" (CODE1 "generic-function") "、"
     (CODE1 "method") "、" (CODE1 "stream") "があります。）"
     "そのような実装では、ファイルコンパイラがそのようなクラスのインスタンスを" "リテラルオブジェクトとして遭遇したときにどのように処理するかを文書化し、"
     (CODE1 "make-load-form") "に関連するメソッドを文書化しなければなりません。")))
(setf (gethash '("MAKE-LOAD-FORM" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "MAKE-LOAD-FORM" *table*))
(setf (gethash "MAKE-LOAD-FORM-SAVING-SLOTS" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-LOAD-FORM-SAVING-SLOTS"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-load-form-saving-slots") " " (STRONG "object")
     " &key " (STRONG "slot-names") " " (STRONG "environment") " => "
     (STRONG "creation-form") ", " (STRONG "initialization-form"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "slot-names")
     " - リスト" EOL1 (STRONG "environment") " - 環境オブジェクト" EOL1 (STRONG "creation-form")
     " - フォーム" EOL1 (STRONG "initialization-form") " - フォーム")
    (CHAPTER ("## 定義") 2 "返却値のフォームが評価されたとき、" (STRONG "initialization-form") "の実行なしに、"
     (STRONG "object") "と同等のオブジェクトが構築されます。" "新しいオブジェクトのスロットの初期化は、" (STRONG "object")
     "の初期化されているスロットに対してはその値を用いて行われます。" (STRONG "object") "の初期化されていないスロットについては、"
     "新しいオブジェクトでは初期化されません。" (CODE1 "make-load-form-saving-slots") "は、"
     (CODE1 "standard-object") "か" (CODE1 "structure-object") "の" "インスタンスであれば動作します。" EOL2
     (STRONG "slot-names") "は保存するスロットの名前のリストです。" (STRONG "slot-names")
     "が与えられない場合、その値はすべての局所スロットになります。" EOL2 (CODE1 "make-load-form-saving-slots")
     "は2つの値を返却するので、" "循環構造を扱うことができます。" "この結果がアプリケーションで有用かどうかは、" "オブジェクトの型とスロットの内容が、"
     "アプリケーションの考えるオブジェクトの状態を" "完全に捉えているかどうかに依存します。" EOL2 (STRONG "environment")
     "はフォームを処理する環境です。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-load-form") "," (CODE1 "make-instance") ","
     (CODE1 "setf") "," (CODE1 "slot-value") "," (CODE1 "slot-makunbound"))
    (CHAPTER ("## 備考") 2 (CODE1 "make-load-form-saving-slots") "は、" "ユーザーが"
     (CODE1 "make-load-form") "メソッドを作成する際に便利です。" EOL2 "もし" (STRONG "object") "が"
     (CODE1 "standard-object") "のインスタンスならば、" (CODE1 "make-load-form-saving-slots") "は"
     (STRONG "creation-form") "に" (CODE1 "allocate-instance") "を呼ぶフォームを、"
     (STRONG "initialization-form") "には" (CODE1 "slot-value") "の" (CODE1 "setf") "と、"
     (CODE1 "slot-makunbound") "を含むフォームが返却されます。" "しかし、実際には同様の効果を持つ他の関数が使用されるかもしれません。")))
(setf (gethash '("MAKE-LOAD-FORM-SAVING-SLOTS" . "FUNCTION") *table*) (gethash "MAKE-LOAD-FORM-SAVING-SLOTS" *table*))
(setf (gethash "MAKE-METHOD" *table*)
  '((CHAPTER NIL 0 "Local Macro " (CODE1 "CALL-METHOD") ", " (CODE1 "MAKE-METHOD"))
    (CHAPTER ("## 構文") 2 (CODE1 "call-method") " " (STRONG "method") " &optional "
     (STRONG "next-method-list") " => " (STRONG "result\\*") EOL1 (CODE1 "make-method")
     " " (STRONG "form") " => " (STRONG "method-object"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "method") " - メソッドオブジェクトか、リスト（下記参照）。評価はされません。" EOL1
     (STRONG "method-object") " - メソッドオブジェクト" EOL1 (STRONG "next-method-list")
     " - メソッドオブジェクトのリスト。評価はされません。" EOL1 (STRONG "results") " - メソッドの実行による返却値")
    (CHAPTER ("## 定義") 2 "マクロ" (CODE1 "call-method") "は、method-combination内で使用されます。"
     "メソッドがどのように呼ばれるかという詳細を" "実装依存で隠蔽することができます。" "マクロ" (CODE1 "call-method")
     "はレキシカルスコープを持っており、" "有効なメソッドフォーム内でのみ使用することができます。" EOL2 "グローバル環境下で、"
     (CODE1 "call-method") "が" (CODE1 "fbound") "かどうかは実装依存です。" "しかし、再定義と"
     (CODE1 "call-method") "のシャドウについての制限は、" (CODE1 "COMMON-LISP") "パッケージにある、"
     "グローバル環境下において" (CODE1 "fbound") "であるシンボルと同じです。" (CODE1 "call-method")
     "を有効なメソッド定義フォームの外で" "使おうとしたときの結果は未定義です。" EOL2 "マクロ" (CODE1 "call-method")
     "は、指定されたメソッド実行し、" "その際に引数と" (CODE1 "call-next-method") "、" (CODE1 "next-method-p")
     "の定義を与えます。" "もし" (CODE1 "call-method") "の実行が文脈的に" (CODE1 "make-method") "の内側であったとき、"
     "引数はメソッドに指定されたものになります。" "そうでなければ、引数はジェネリック関数に指定されたものです。" (CODE1 "call-next-method")
     "、" (CODE1 "next-method-p") "の定義は、" "指定された" (STRONG "next-method-list") "に依存します。"
     EOL2 "もし" (STRONG "method") "がリストの場合、" "リストの最初の要素はシンボル" (CODE1 "make-method") "、"
     "2番目の要素はフォームでなければなりません。" "このようなリストは、与えられたフォームが" "メソッド関数のボディ部であるようなメソッドオブジェクトを意味します。"
     EOL2 (STRONG "next-method-list") "は、メソッドオブジェクトか、" "あるいは最初の要素はシンボル"
     (CODE1 "make-method") "であり" "2番目の要素がフォームであるようなリストを含むことができます。" EOL2
     (CODE1 "make-method") "が使えるのは、この2か所だけです。" (CODE1 "make-method") "を使用したフォームは、"
     (CODE1 "null") "のレキシカルな環境から" "加えてローカルマクロ" (CODE1 "call-method") "の定義と、"
     (CODE1 "COMMON-LISP-USER") "パッケージからアクセスできないシンボル名の束縛で" "拡張された環境下で評価されます。" EOL2
     "メソッドで使用できる" (CODE1 "call-next-method") "関数は、" (STRONG "next-method-list")
     "の最初のメソッドを呼び出します。" "そのメソッドで使用できる" (CODE1 "call-next-method") "関数は、" "次に"
     (STRONG "next-method-list") "の2番目のメソッドを呼び出し、" "次のメソッドのリストを使い果たすまでこれを繰り返します。" EOL2
     (STRONG "next-method-list") "が与えられないときは、" "メソッドで使用できる" (CODE1 "call-next-method")
     "関数は" "型" (CODE1 "control-error") "のエラーを通知し、" "メソッドで使用できる" (CODE1 "next-method-p")
     "関数は" (CODE1 "nil") "を返します。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "call-next-method") ","
     (CODE1 "define-method-combination") "," (CODE1 "next-method-p"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAKE-METHOD" . "LOCAL-MACRO") *table*) (gethash "MAKE-METHOD" *table*))
(setf (gethash "MAKE-PACKAGE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-PACKAGE"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-package") " " (STRONG "package-name") " "
     (CODE1 "&key") " " (STRONG "nicknames") " " (STRONG "use") " => "
     (STRONG "package"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "package-name") " - 文字列指定子" EOL1
     (STRONG "nicknames") " - 文字列指定子のリスト。デフォルトは空のリスト。" EOL1 (STRONG "use")
     " - パッケージ指定子のリスト。デフォルトは実装依存。" EOL1 (STRONG "package") " - パッケージ")
    (CHAPTER ("## 定義") 2 (STRONG "packagen-name") "という名前の新しいパッケージを作成します。" EOL2
     (STRONG "nicknames") "は新しいパッケージを参照するときに使われる" "追加の名前です。" EOL2 (STRONG "use")
     "によって指定されたゼロか複数のパッケージの外部シンボルは" "新しいパッケージによって継承されます。" (CODE1 "use-package")
     "関数をご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(make-package 'temporary :nicknames '(\"TEMP\" \"temp\")) =>  #<PACKAGE \"TEMPORARY\">"
      "(make-package \"OWNER\" :use '(\"temp\")) =>  #<PACKAGE \"OWNER\">"
      "(package-used-by-list 'temp) =>  (#<PACKAGE \"OWNER\">)"
      "(package-use-list 'owner) =>  (#<PACKAGE \"TEMPORARY\">)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "システムにある他の既存のパッケージ")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "package") "が" (STRONG "use")
     "で存在しないものを示していたときの結果は指定されていません。" EOL2 (STRONG "package-name") "か"
     (STRONG "nicknames") "のどれかが" "すでに既存のパッケージの名前かニックネームであったときは、" "修正可能なエラーが通知されます。")
    (CHAPTER ("## 参考") 2 (CODE1 "defpackage") "," (CODE1 "use-package"))
    (CHAPTER ("## 備考") 2 "複数のパッケージが" (CODE1 "use") "されるような状況で" "衝突が発生するシンボルを含んでいるとき、"
     "最初に" (CODE1 ":use '()") "でパッケージを作成し、" "それから" (CODE1 "shadow") "か"
     (CODE1 "shadowing-import") "で" "衝突した場所に対して使用し、" "そのあと衝突が発生したものに対して"
     (CODE1 "use-package") "を" "使う必要があります。" EOL2 "パッケージをプログラムによって動的に作成するのではなく、"
     "プログラムの静的な宣言の部分として作成したいときは、" "一般的に考えて" (CODE1 "make-package") "ではなく"
     (CODE1 "defpackage") "を" "使うことがより文法的に適しています。")))
(setf (gethash '("MAKE-PACKAGE" . "FUNCTION") *table*) (gethash "MAKE-PACKAGE" *table*))
(setf (gethash "MAKE-PATHNAME" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-PATHNAME"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-pathname") " " (CODE1 "&key") " " (STRONG "host")
     " " (STRONG "device") " " (STRONG "directory") " " (STRONG "name") " "
     (STRONG "type") " " (STRONG "version") " " (STRONG "defaults") " " (STRONG "case")
     " => " (STRONG "pathname"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "host") " - 有効な物理パス名のホスト。" "標準の動作が複雑なので説明をご確認ください。"
     EOL1 (STRONG "device") " - 有効なパス名のデバイス。" "標準の動作が複雑なので説明をご確認ください。" EOL1
     (STRONG "directory") " - 有効なパス名のディレクトリ。" "標準の動作が複雑なので説明をご確認ください。" EOL1
     (STRONG "name") " - 有効なパス名の名前。" "標準の動作が複雑なので説明をご確認ください。" EOL1 (STRONG "type")
     " - 有効なパス名の型。" "標準の動作が複雑なので説明をご確認ください。" EOL1 (STRONG "version") " - 有効なパス名のバージョン。"
     "標準の動作が複雑なので説明をご確認ください。" EOL1 (STRONG "defaults") " - パス名指定子。" "デフォルトは、ホストの要素が"
     (CODE1 "*default-pathname-defaults*") "の値の" "ホストの要素と同じであり、" "その他の要素は全て"
     (CODE1 "nil") "であるパス名。" EOL1 (STRONG "case") " - " (CODE1 ":common") "か"
     (CODE1 ":local") "のうちのひとつ。デフォルトは" (CODE1 ":local") "です。" EOL1 (STRONG "pathname")
     " - パス名")
    (CHAPTER ("## 定義") 2 "指定されたキーワード引数からパス名を構築して返却します。" EOL2 "明示的に" (STRONG "host") ", "
     (STRONG "device") ", " (STRONG "directory") ", " (STRONG "name") ", "
     (STRONG "type") ", " (STRONG "version") "が" "指定された要素が記入されたあとは、"
     (CODE1 "merge-pathnames") "を使用したかのようなマージの規則に従い、" "指定されなかった要素に対して" (STRONG "default")
     "によって指定された標準の要素を埋めていきます。" EOL2 "パス名は適用可能であれば要素に対して正規化されて構築されます。"
     "各要素に対して指定された各引数の説明は19.2.1. パス名の説明をご確認ください。" EOL2 "もし" (STRONG "case") "が指定されたとき、"
     "それは19.2.2.1.2. パス名の要素の大文字小文字の説明のように扱われます。" EOL2 "もしホストの要素が論理ホストか、"
     "論理ホストとして定義された名前の文字列のときは、" "結果の" (STRONG "pathname") "は論理パス名です。" EOL2 "もし"
     (STRONG "directory") "が文字列のとき、" "それはトップレベルのディレクトリ名でなくてはならず、" "どんなくぐり文字も含まれてはなりません。"
     "つまり、文字列" (STRONG "str") "が指定されたときは、" "リストの" (CODE1 "(:absolute str)")
     "が指定されたのと同等です。" "シンボル" (CODE1 ":wild") "が指定されたときは、" "リストの"
     (CODE1 "(:absolute :wild-inferiors)") "か" "システムが" (CODE1 ":wild-inferiors")
     "をサポートしていないときは" (CODE1 "(:absolute :wild)") "が指定されたのと同等です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; 実装A - この実装はひとつのUnixファイルシステムにアクセスします。"
      ";;  この実装はhostの情報を名前文字列に決して表示しないので、" ";;  hostはただひとつになります。"
      "(make-pathname :directory '(:absolute \"public\" \"games\")"
      "               :name \"chess\" :type \"db\")" "=>  #P\"/public/games/chess.db\" "
      NIL ";; 実装B - この実装はひとつか複数のVMSファイルシステムにアクセスします。" ";;  この実装はhostの情報がローカルホストではないときのみ"
      ";;  名前文字列に出力します。それはホスト名とローカルファイル名を" ";;  区切るのにダブルコロンが使われます。"
      "(make-pathname :directory '(:absolute \"PUBLIC\" \"GAMES\")"
      "               :name \"CHESS\" :type \"DB\")"
      "=>  #P\"SYS$DISK:[PUBLIC.GAMES]CHESS.DB\" " "(make-pathname :host \"BOBBY\""
      "               :directory '(:absolute \"PUBLIC\" \"GAMES\")"
      "               :name \"CHESS\" :type \"DB\")"
      "=>  #P\"BOBBY::SYS$DISK:[PUBLIC.GAMES]CHESS.DB\" " NIL
      ";; 実装C - この実装は同じLispイメージから多重のファイルシステムに" ";;  同時にアクセスします。この実装は、パス名の名前文字列にある"
      ";;  最初のコロンに先行したテキストがホスト名である慣習があります。" "(dolist (case '(:common :local))"
      "  (dolist (host '(\"MY-LISPM\" \"MY-VAX\" \"MY-UNIX\"))"
      "    (print (make-pathname :host host :case case"
      "                          :directory '(:absolute \"PUBLIC\" \"GAMES\")"
      "                          :name \"CHESS\" :type \"DB\"))))"
      ">>  #P\"MY-LISPM:>public>games>chess.db\""
      ">>  #P\"MY-VAX:SYS$DISK:[PUBLIC.GAMES]CHESS.DB\""
      ">>  #P\"MY-UNIX:/public/games/chess.db\""
      ">>  #P\"MY-LISPM:>public>games>chess.db\" "
      ">>  #P\"MY-VAX:SYS$DISK:[PUBLIC.GAMES]CHESS.DB\" "
      ">>  #P\"MY-UNIX:/PUBLIC/GAMES/CHESS.DB\" " "=>  NIL"))
    (CHAPTER ("## 影響") 2 "ファイルシステム。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "merge-pathnames") "," (CODE1 "pathname") ","
     (CODE1 "logical-pathname") "," "20.1. ファイルシステムの説明," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "移植可能なプログラムは各要素に" (CODE1 ":unspecific") "を指定するべきではありません。"
     "19.2.2.2.3. " (CODE1 ":UNSPECIFIC") "という要素の値をご確認ください。")))
(setf (gethash '("MAKE-PATHNAME" . "FUNCTION") *table*) (gethash "MAKE-PATHNAME" *table*))
(setf (gethash "MAKE-SEQUENCE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-SEQUENCE"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-sequence") " " (STRONG "result-type") " "
     (STRONG "size") " &key " (STRONG "initial-element") " => " (STRONG "sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "result-type") " - " (CODE1 "sequence") "の型指定子" EOL1
     (STRONG "size") " - 非負の整数" EOL1 (STRONG "initial-element") " - オブジェクト。デフォルトは実装依存。"
     EOL1 (STRONG "sequence") " - 正常なシーケンス")
    (CHAPTER ("## 定義") 2 "型が" (STRONG "result-type") "、長さが" (STRONG "size") "、各要素が"
     (STRONG "initial-element") "で初期化された、" "シーケンスが返却されます。" EOL2 "もし"
     (STRONG "result-type") "が" (CODE1 "list") "のサブタイプの場合、" "リストが返却されます。" EOL2 "もし"
     (STRONG "result-type") "が" (CODE1 "vector") "のサブタイプの場合、" "実装が"
     (STRONG "result-type") "を要素の型として決めることができるのであれば、"
     "その要素の型をアップグレードした結果が返却値の配列の要素の型になります。" "しかし実装が要素の型を決定できないか、あるいは" (CODE1 "*") "のときは、"
     "返却値の配列の要素の型は" (CODE1 "t") "になります。" "その他の場合はエラーが発生します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(make-sequence 'list 0) =>  ()"
      "(make-sequence 'string 26 :initial-element #\\.) "
      "=>  \"..........................\"" "(make-sequence '(vector double-float) 2"
      "               :initial-element 1d0)" "=>  #(1.0d0 1.0d0)"
      "(make-sequence '(vector * 2) 3) should signal an error"
      "(make-sequence '(vector * 4) 3) should signal an error"))
    (CHAPTER ("## 影響") 2 "実装。")
    (CHAPTER ("## 例外") 2 (STRONG "initial-element") "が、" "返却値の" (STRONG "sequence")
     "に格納できないオブジェクトであったときの結果は不明です。" EOL2 (STRONG "result-type") "が、" (CODE1 "list")
     "のサブタイプでも、" (CODE1 "vector") "のサブタイプでもないとき、" "型" (CODE1 "type-error") "のエラーが発します。"
     EOL2 (STRONG "result-type") "で指定した要素数と" (STRONG "size") "の値が違う場合は、" "型"
     (CODE1 "type-error") "のエラーが発します。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-array") "," (CODE1 "make-list"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(make-sequence 'string 5) == (make-string 5)"))))
(setf (gethash '("MAKE-SEQUENCE" . "FUNCTION") *table*) (gethash "MAKE-SEQUENCE" *table*))
(setf (gethash "MAKE-STRING" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-STRING"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-string") " " (STRONG "size") " &key "
     (STRONG "initial-element") " " (STRONG "element-type") " => " (STRONG "string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "size") " - 有効な配列の大きさ" EOL1
     (STRONG "initial-element") " - 文字。標準値は処理系依存。" EOL1 (STRONG "element-type")
     " - 型指定子。標準値は" (CODE1 "character") "。" EOL1 (STRONG "string") " - simple-string")
    (CHAPTER ("## 定義") 2 (CODE1 "make-string") "は、長さが" (STRONG "size")
     "のsimple-stringを返却します。" "各要素は" (STRONG "initial-element") "で初期化されます。" EOL2
     (STRONG "element-type") "は、" (STRONG "string") "の各要素の型を指定します。" (STRONG "string")
     "は、指定された型を収容できる特化型で構築されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(make-string 10 :initial-element #\\5) =>  \"5555555555\""
      "(length (make-string 10)) =>  10"))
    (CHAPTER ("## 影響") 2 "処理系。") (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAKE-STRING" . "FUNCTION") *table*) (gethash "MAKE-STRING" *table*))
(setf (gethash "MAKE-STRING-INPUT-STREAM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-STRING-INPUT-STREAM"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-string-input-stream") " " (STRONG "string") " "
     (CODE1 "&optional") " " (STRONG "start") " " (STRONG "end") " => "
     (STRONG "string-stream"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string") " - 文字列" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "string") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1
     (STRONG "string-stream") " - 入力文字列ストリーム")
    (CHAPTER ("## 定義") 2 "入力の文字列ストリームを返却します。" "このストリームは" (STRONG "string") "を"
     (STRONG "start") "と" (STRONG "end") "で囲った部分文字列にある" "文字を順番に提供します。" "最後の文字が提供されたあとは、"
     "文字列ストリームはファイルの終わりになります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(let ((string-stream (make-string-input-stream \"1 one \")))"
      "  (list (read string-stream nil nil)" "        (read string-stream nil nil)"
      "        (read string-stream nil nil)))" "=>  (1 ONE NIL)" NIL
      "(read (make-string-input-stream \"prefixtargetsuffix\" 6 12)) =>  TARGET"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "with-input-from-string")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAKE-STRING-INPUT-STREAM" . "FUNCTION") *table*) (gethash "MAKE-STRING-INPUT-STREAM" *table*))
(setf (gethash "MAKE-STRING-OUTPUT-STREAM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-STRING-OUTPUT-STREAM"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-string-output-stream") " " (CODE1 "&key") " "
     (STRONG "element-type") " => " (STRONG "string-stream"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "element-type") " - 型指定子。デフォルトは" (CODE1 "character")
     "。" EOL1 (STRONG "string-stream") " - 出力文字列ストリーム")
    (CHAPTER ("## 定義") 2 "文字列を受け付ける出力の文字列ストリームを返却します。" "これは実際に出力された文字を含む文字列を" "（"
     (CODE1 "get-output-stream-string") "によって）作成することができます。" EOL2 (STRONG "element-type")
     "は文字列の要素の型を示す名前です。" "文字列は" (STRONG "element-type") "の要素を収容できるような"
     "特定化された型によって構築されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(let ((s (make-string-output-stream)))"
      "  (write-string \"testing... \" s)" "  (prin1 1234 s)"
      "  (get-output-stream-string s))" "=>  \"testing... 1234\""))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "get-output-stream-string") ","
     (CODE1 "with-output-to-string"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAKE-STRING-OUTPUT-STREAM" . "FUNCTION") *table*) (gethash "MAKE-STRING-OUTPUT-STREAM" *table*))
(setf (gethash "MAKE-SYMBOL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-SYMBOL"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-symbol") " " (STRONG "name") " => "
     (STRONG "new-symbol"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - 文字列" EOL1 (STRONG "new-symbol")
     " - 新しい、" (CODE1 "unintern") "シンボル")
    (CHAPTER ("## 定義") 2 (CODE1 "make-symbol") "は、新しく" (CODE1 "unintern") "であり、" "名前が"
     (STRONG "name") "のシンボルを作成して返却します。" (STRONG "new-symbol") "は、" (CODE1 "bound") "でも"
     (CODE1 "fbound") "でもありません。" "そして、" (CODE1 "null") "のプロパティリストを持っています。" EOL2
     (STRONG "new-symbol") "の名前の文字列が、引数" (STRONG "name") "なのか、" "あるいはそのコピーなのかは実装依存です。"
     "いったん文字列が" (CODE1 "make-symbol") "の引数" (STRONG "name") "として与えられたら、"
     "その文字を変更しようとした結果は未定義です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq temp-string \"temp\") =>  \"temp\""
      "(setq temp-symbol (make-symbol temp-string)) =>  #:|temp|"
      "(symbol-name temp-symbol) =>  \"temp\""
      "(eq (symbol-name temp-symbol) temp-string) =>  implementation-dependent"
      "(find-symbol \"temp\") =>  NIL, NIL"
      "(eq (make-symbol temp-string) (make-symbol temp-string)) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "name") "が文字列ではないとき、" "型" (CODE1 "error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "copy-symbol"))
    (CHAPTER ("## 備考") 2 (CODE1 "make-symbol") "は、名前のケースを大文字に変更しようとはしません。"
     "シンボルの大文字小文字の変換は、ただLispのリーダーが実行するだけです。" "シンボルを生成するプログラムのインターフェイスは大文字小文字を保持し、"
     "そしてシンボルの" (CODE1 "intern") "を行うプログラムインターフェイスは" "大文字小文字を区別します。")))
(setf (gethash '("MAKE-SYMBOL" . "FUNCTION") *table*) (gethash "MAKE-SYMBOL" *table*))
(setf (gethash "MAKE-SYNONYM-STREAM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-SYNONYM-STREAM"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-synonym-stream") " " (STRONG "symbol") " => "
     (STRONG "synonym-stream"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - 動的変数の名前のシンボル" EOL1
     (STRONG "synonym-stream") " - " (CODE1 "synonym") "ストリーム")
    (CHAPTER ("## 定義") 2 (CODE1 "synonym") "ストリームのシンボルが" (STRONG "symbol") "である、"
     (CODE1 "synonym") "ストリームを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq a-stream (make-string-input-stream \"a-stream\")"
      "       b-stream (make-string-input-stream \"b-stream\"))"
      "=>  #<String Input Stream> " "(setq s-stream (make-synonym-stream 'c-stream))"
      "=>  #<SYNONYM-STREAM for C-STREAM> " "(setq c-stream a-stream)"
      "=>  #<String Input Stream> " "(read s-stream) =>  A-STREAM"
      "(setq c-stream b-stream)" "=>  #<String Input Stream> "
      "(read s-stream) =>  B-STREAM"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "引数がシンボルではないとき、" "型" (CODE1 "type-error") "のエラーを通知しなければなりません。")
    (CHAPTER ("## 参考") 2 "21.1. ストリームの説明") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAKE-SYNONYM-STREAM" . "FUNCTION") *table*) (gethash "MAKE-SYNONYM-STREAM" *table*))
(setf (gethash "MAKE-TWO-WAY-STREAM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKE-TWO-WAY-STREAM"))
    (CHAPTER ("## 構文") 2 (CODE1 "make-two-way-stream") " " (STRONG "input-stream") " "
     (STRONG "output-stream") " => " (STRONG "two-way-stream"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "input-stream") " - ストリーム" EOL1
     (STRONG "output-stream") " - ストリーム" EOL1 (STRONG "two-way-stream") " - "
     (CODE1 "two-way") "ストリーム")
    (CHAPTER ("## 定義") 2 "取得は" (STRONG "input-stream") "からの入力で、" "送信は"
     (STRONG "output-stream") "からの出力で構成される" (CODE1 "two-way") "ストリームを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-output-to-string (out)"
      "   (with-input-from-string (in \"input...\")"
      "     (let ((two (make-two-way-stream in out)))"
      "       (format two \"output...\")"
      "       (setq what-is-read (read two))))) =>  \"output...\""
      "what-is-read =>  INPUT... "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "input-stream") "が入力ストリームではないとき、" "型"
     (CODE1 "type-error") "のエラーを通知しなければなりません。" (STRONG "output-stream") "出力ストリームではないとき、"
     "型" (CODE1 "type-error") "のエラーを通知しなければなりません。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAKE-TWO-WAY-STREAM" . "FUNCTION") *table*) (gethash "MAKE-TWO-WAY-STREAM" *table*))
(setf (gethash "MAKUNBOUND" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAKUNBOUND"))
    (CHAPTER ("## 構文") 2 (CODE1 "makunbound") " " (STRONG "symbol") " => "
     (STRONG "symbol"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - シンボル")
    (CHAPTER ("## 定義") 2 "以前" (CODE1 "bound") "であったかどうかにかかわらず、" (STRONG "symbol") "を"
     (CODE1 "unbound") "にします。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setf (symbol-value 'a) 1)" "(boundp 'a) =>  true" "a =>  1"
      "(makunbound 'a) =>  A" "(boundp 'a) =>  false"))
    (CHAPTER ("## 副作用") 2 (STRONG "symbol") "の値のセルが修正されます。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "symbol") "がシンボルではないとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "boundp") "," (CODE1 "fmakunbound"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAKUNBOUND" . "FUNCTION") *table*) (gethash "MAKUNBOUND" *table*))
(setf (gethash "MAP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAP"))
    (CHAPTER ("## 構文") 2 (CODE1 "map") " " (STRONG "result-type") " " (STRONG "function")
     " &rest " (STRONG "sequences+") " => " (STRONG "result"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "result-type") " - " (CODE1 "sequence") "の型指定子か、"
     (CODE1 "nil") EOL1 (STRONG "function") " - " (STRONG "sequences")
     "にある複数の引数を取る関数の指定子" EOL1 (STRONG "sequences") " - 正常なシーケンス" EOL1 (STRONG "result")
     " - もし" (STRONG "result-type") "が" (CODE1 "nil") "ではない型指定子のときは、" "その型のシーケンスです。"
     "その他の場合は（あるいは" (STRONG "result-type") "が" (CODE1 "nil") "のとき）" (CODE1 "nil") "です。")
    (CHAPTER ("## 定義") 2 "各シーケンスから得られる引数の連続した集合に対して" (STRONG "function") "を適用します。"
     (STRONG "function") "は最初、すべてのインデックス" (CODE1 "0") "の要素に対して呼び出され、" "それから、すべてのインデックス"
     (CODE1 "1") "の要素に対して呼び出され、" "それをくり返します。" (STRONG "result-type")
     "は、返却値のシーケンスの型を示します。" EOL2 (CODE1 "map") "は、" (STRONG "result-type") "が"
     (CODE1 "nil") "のときは、" (CODE1 "nil") "を返却します。" "それ以外のときは、" (CODE1 "map") "は、" "シーケンス"
     (CODE1 "j") "番目の要素が各" (STRONG "sequences") "のそれぞれの'j'番目の要素に" (STRONG "function")
     "を適用したものであるようなシーケンスを返却します。" "返却値のシーケンスは、" (STRONG "sequences") "の中の最も短いものと同じ長さです。"
     "もし" (STRONG "sequences") "の一連の要素を" (STRONG "function") "に適用した結果が、"
     (STRONG "result-type") "で示された型のシーケンスに" "含めることができなかったときの結果は未定義です。" EOL2 "もし"
     (STRONG "result-type") "が" (CODE1 "list") "のサブタイプの場合、" "リストが返却されます。" EOL2 "もし"
     (STRONG "result-type") "が" (CODE1 "vector") "のサブタイプの場合、" "実装が"
     (STRONG "result-type") "を要素の型として決めることができるのであれば、"
     "その要素の型をアップグレードした結果が返却値の配列の要素の型になります。" "しかし実装が要素の型を決定できないか、あるいは" (CODE1 "*") "のときは、"
     "返却値の配列の要素の型は" (CODE1 "t") "になります。" "その他の場合はエラーが発生します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(map 'string #'(lambda (x y)"
      "                 (char \"01234567890ABCDEF\" (mod (+ x y) 16)))"
      "      '(1 2 3 4)" "      '(10 9 8 7)) =>  \"AAAA\""
      "(setq seq '(\"lower\" \"UPPER\" \"\" \"123\")) =>  (\"lower\" \"UPPER\" \"\" \"123\")"
      "(map nil #'nstring-upcase seq) =>  NIL"
      "seq =>  (\"LOWER\" \"UPPER\" \"\" \"123\")"
      "(map 'list #'- '(1 2 3 4)) =>  (-1 -2 -3 -4)" "(map 'string"
      "     #'(lambda (x) (if (oddp x) #\\1 #\\0))" "     '(1 2 3 4)) =>  \"1010\""
      "(map '(vector * 4) #'cons \"abc\" \"de\") should signal an error"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "result-type") "が、" (CODE1 "list") "のサブタイプでも、"
     (CODE1 "vector") "のサブタイプでもないとき、" "型" (CODE1 "type-error") "のエラーが発します。" EOL2
     (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。" EOL2 (STRONG "result-type") "で指定した要素数と、"
     (STRONG "sequences") "の最小の長さが違う場合は、" "型" (CODE1 "type-error") "のエラーが発します。")
    (CHAPTER ("## 参考") 2 "3.6. 横断の規則と副作用") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAP" . "FUNCTION") *table*) (gethash "MAP" *table*))
(setf (gethash "MAP-INTO" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAP-INTO"))
    (CHAPTER ("## 構文") 2 (CODE1 "map-into") " " (STRONG "result-sequence") " "
     (STRONG "function") " &rest " (STRONG "sequences") " => "
     (STRONG "result-sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "result-sequence") " - 正常なシーケンス" EOL1
     (STRONG "function") " - " (STRONG "sequences") "にある複数の引数を取る関数の指定子" EOL1
     (STRONG "sequences") " - 正常なシーケンス")
    (CHAPTER ("## 定義") 2 "引数" (STRONG "sequences") "の各要素を" (STRONG "function") "に適用した結果を"
     (STRONG "result-sequence") "に含めるよう、破壊的に修正します。" EOL2 (STRONG "result-sequence") "と"
     (STRONG "sequences") "の各要素は、" "それぞれリストか" (CODE1 "vector") "のどちらかになります。" "もし"
     (STRONG "result-sequence") "と" (STRONG "sequences") "の各要素が、"
     "全てかあるいはいくつかが同じ長さではないとき、" "繰り返しはもっとも短いシーケンス" "（" (STRONG "sequences") "のどれかか、あるいは"
     (STRONG "result-sequence") "）が" "使い終わったときに終わります。" "もし" (STRONG "result-sequence")
     "がfill-pointerを持った" (CODE1 "vector") "のとき、"
     "そのfill-pointerは、何度繰り返しを行うかを決めるときには無視され、" "その後、fill-pointerに関数が適用された回数が設定されます。" "もし"
     (STRONG "result-sequence") "が、" (STRONG "sequences") "の最も短いものより長いときは、"
     (STRONG "result-sequence") "の末尾の余分な要素は変更されずに残されます。" "もし" (STRONG "result-sequence")
     "が" (CODE1 "nil") "のときは、" (CODE1 "nil") "は長さ" (CODE1 "0") "のシーケンスなので、" "即座に"
     (CODE1 "nil") "が返却されます。" EOL2 "もし" (STRONG "function") "に副作用があるなら、" "最初にインデックス"
     (CODE1 "0") "の全ての要素で呼ばれ、" "次にインデックス" (CODE1 "1") "の全ての要素で呼ばれ、" "といったように数えることができます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq a (list 1 2 3 4) b (list 10 10 10 10)) =>  (10 10 10 10)"
      "(map-into a #'+ a b) =>  (11 12 13 14)" "a =>  (11 12 13 14)"
      "b =>  (10 10 10 10)" "(setq k '(one two three)) =>  (ONE TWO THREE)"
      "(map-into a #'cons k a) =>  ((ONE . 11) (TWO . 12) (THREE . 13) 14)"
      "(map-into a #'gensym) =>  (#:G9090 #:G9091 #:G9092 #:G9093)"
      "a =>  (#:G9090 #:G9091 #:G9092 #:G9093)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "result-sequence") "が正常なシーケンスでないとき、" "型"
     (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。" (STRONG "sequences")
     "の各要素が正常なシーケンスでないとき、" "型" (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 (CODE1 "map-into") "と" (CODE1 "map") "の違うところは、"
     "シーケンスを作成するのではなく" "既存のシーケンスを変更するところです。" "加えて、" (CODE1 "map-into")
     "は2つの引数のみで呼び出すことができますが、" "それに対して" (CODE1 "map") "は最低でも3つの引数が必要です。" EOL2
     (CODE1 "map-into") "は下記のように定義できます。"
     (CODE3 "```lisp" "```" "(defun map-into (result-sequence function &rest sequences)"
      "  (loop for index below (apply #'min "
      "                               (length result-sequence)"
      "                               (mapcar #'length sequences))"
      "        do (setf (elt result-sequence index)" "                 (apply function"
      "                        (mapcar #'(lambda (seq) (elt seq index))"
      "                                sequences))))" "  result-sequence)"))))
(setf (gethash '("MAP-INTO" . "FUNCTION") *table*) (gethash "MAP-INTO" *table*))
(setf (gethash "MAPC" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAPC") ", " (CODE1 "MAPCAR") ", " (CODE1 "MAPCAN")
     ", " (CODE1 "MAPL") ", " (CODE1 "MAPLIST") ", " (CODE1 "MAPCON"))
    (CHAPTER ("## 構文") 2 (CODE1 "mapc") " " (STRONG "function") " &rest "
     (STRONG "lists+") " => " (STRONG "list-1") EOL1 (CODE1 "mapcar") " "
     (STRONG "function") " &rest " (STRONG "lists+") " => " (STRONG "result-list") EOL1
     (CODE1 "mapcan") " " (STRONG "function") " &rest " (STRONG "lists+") " => "
     (STRONG "concatenated-results") EOL1 (CODE1 "mapl") " " (STRONG "function")
     " &rest " (STRONG "lists+") " => " (STRONG "list-1") EOL1 (CODE1 "maplist") " "
     (STRONG "function") " &rest " (STRONG "lists+") " => " (STRONG "result-list") EOL1
     (CODE1 "mapcon") " " (STRONG "function") " &rest " (STRONG "lists+") " => "
     (STRONG "concatenated-results"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function") " - " (STRONG "lists") "と同じ数の引数を取る関数指定子"
     EOL1 (STRONG "lists") " - 通常のリスト" EOL1 (STRONG "list-1") " - 最初の" (STRONG "lists")
     "（通常のリストである必要があります）" EOL1 (STRONG "result-list") " - リスト" EOL1
     (STRONG "concatenated-results") " - リスト")
    (CHAPTER ("## 定義") 2 "マッピング操作は、" "引数の各列からひとつ得たものの集合を、" "連続で関数に適用した結果を返却します。"
     (CODE1 "mapc") "と" (CODE1 "mapl") "以外は、関数の返却値で構成された結果を返却します。" (CODE1 "mapc") "と"
     (CODE1 "mapl") "の場合は、返却値は" (STRONG "lists") "の列です。" EOL2 (STRONG "function")
     "は、最初はインデックス0番目の全ての要素で呼び出され、" "そのあとインデックス1番目の全ての要素で呼ばれ、" "以下同様に実行します。" "もし"
     (STRONG "function") "がシンボルのときは、" "それは" (CODE1 "symbol-function") "が実行されたかのように" "関数へ"
     (CODE1 "coerce") "されます。" EOL2 (CODE1 "mapcar") "は、" (STRONG "lists")
     "の連続した要素に対して操作します。" (STRONG "function") "は、各" (STRONG "lists") "の最初の要素で適用し、" "そのあと各"
     (STRONG "lists") "の二番目の要素で適用し、" "それを繰り返します。" "繰り返しは最短の" (STRONG "lists")
     "がなくなったときに終了し、" "他の" (STRONG "lists") "の余分な要素は無視されます。" (CODE1 "mapcar") "の返却値は、"
     (STRONG "function") "が連続して呼び出された結果のリストです。" EOL2 (CODE1 "mapc") "は" (CODE1 "mapcar")
     "と似ていますが、" "適用された" (STRONG "function") "の結果を蓄積しない所が違っています。" (STRONG "lists")
     "引数が返却されます。" EOL2 (CODE1 "maplist") "は" (CODE1 "mapcar") "と似ていますが、"
     (STRONG "function") "は、" (STRONG "lists") "のサブリストを連続して適用するところが違っています。"
     (STRONG "function") "は、最初は" (STRONG "lists") "そのものに適用され、" "そのあと各" (STRONG "lists")
     "の" (CODE1 "cdr") "によって適用され、" "さらに各" (STRONG "lists") "の" (CODE1 "cdr") "の"
     (CODE1 "cdr") "によって適用され、" "それをくり返します。" EOL2 (CODE1 "mapl") "は" (CODE1 "maplist")
     "と似ていますが、" "適用された" (STRONG "function") "の結果を蓄積しない所が違っています。" (STRONG "list-1")
     "が返却されます。" EOL2 (CODE1 "mapcan") "と" (CODE1 "mapcon") "は、" "それぞれ" (CODE1 "mapcar")
     "と" (CODE1 "maplist") "に似ていますが、" "適用した" (STRONG "function") "の結果を、" (CODE1 "list")
     "ではなく" (CODE1 "nconc") "によって" "リストに結合するところが違っています。" EOL2 "これは次のような関係であり、"
     (CODE3 "```lisp" "```" "(mapcon f x1 ... xn)"
      "  ==  (apply #'nconc (maplist f x1 ... xn))")
     EOL2 (CODE1 "mapcan") "と" (CODE1 "mapcar") "の関係に似ています。")
    (CHAPTER ("## Examples:") 2
     (CODE3 "```lisp" "```" "(mapcar #'car '((1 a) (2 b) (3 c))) =>  (1 2 3) "
      "(mapcar #'abs '(3 -4 2 -5 -6)) =>  (3 4 2 5 6)"
      "(mapcar #'cons '(a b c) '(1 2 3)) =>  ((A . 1) (B . 2) (C . 3))" NIL
      "(maplist #'append '(1 2 3 4) '(1 2) '(1 2 3)) "
      "=>  ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3)) "
      "(maplist #'(lambda (x) (cons 'foo x)) '(a b c d))"
      "=>  ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))"
      "(maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1)) '(a b a c d b c))"
      "=>  (0 0 1 0 1 1 1)" ";もし入力のリストに対応する要素が" ";そのリスト内で最後の要素の場合は1" NIL
      "(setq dummy nil) =>  NIL "
      "(mapc #'(lambda (&rest x) (setq dummy (append dummy x)))" "       '(1 2 3 4)"
      "       '(a b c d e)" "       '(x y z)) =>  (1 2 3 4) "
      "dummy =>  (1 A X 2 B Y 3 C Z)                   " NIL "(setq dummy nil) =>  NIL "
      "(mapl #'(lambda (x) (push x dummy)) '(1 2 3 4)) =>  (1 2 3 4) "
      "dummy =>  ((4) (3 4) (2 3 4) (1 2 3 4)) " NIL
      "(mapcan #'(lambda (x y) (if (null x) nil (list x y)))"
      "         '(nil nil nil d e)" "         '(1 2 3 4 5 6)) =>  (D 4 E 5) "
      "(mapcan #'(lambda (x) (and (numberp x) (list x)))" "         '(a 1 b c 3 4 d 5))"
      "=>  (1 3 4 5)")
     EOL2 "この場合は、関数はフィルタの役割を果たします。" "これは標準のLispの語句の" (CODE1 "mapcan") "です。"
     (CODE3 "```lisp" "```"
      "(mapcon #'list '(1 2 3 4)) =>  ((1 2 3 4) (2 3 4) (3 4) (4)) "))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "lists") "が通常のリストではないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "dolist") "," (CODE1 "map") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAPC" . "FUNCTION") *table*) (gethash "MAPC" *table*))
(setf (gethash "MAPCAN" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAPC") ", " (CODE1 "MAPCAR") ", " (CODE1 "MAPCAN")
     ", " (CODE1 "MAPL") ", " (CODE1 "MAPLIST") ", " (CODE1 "MAPCON"))
    (CHAPTER ("## 構文") 2 (CODE1 "mapc") " " (STRONG "function") " &rest "
     (STRONG "lists+") " => " (STRONG "list-1") EOL1 (CODE1 "mapcar") " "
     (STRONG "function") " &rest " (STRONG "lists+") " => " (STRONG "result-list") EOL1
     (CODE1 "mapcan") " " (STRONG "function") " &rest " (STRONG "lists+") " => "
     (STRONG "concatenated-results") EOL1 (CODE1 "mapl") " " (STRONG "function")
     " &rest " (STRONG "lists+") " => " (STRONG "list-1") EOL1 (CODE1 "maplist") " "
     (STRONG "function") " &rest " (STRONG "lists+") " => " (STRONG "result-list") EOL1
     (CODE1 "mapcon") " " (STRONG "function") " &rest " (STRONG "lists+") " => "
     (STRONG "concatenated-results"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function") " - " (STRONG "lists") "と同じ数の引数を取る関数指定子"
     EOL1 (STRONG "lists") " - 通常のリスト" EOL1 (STRONG "list-1") " - 最初の" (STRONG "lists")
     "（通常のリストである必要があります）" EOL1 (STRONG "result-list") " - リスト" EOL1
     (STRONG "concatenated-results") " - リスト")
    (CHAPTER ("## 定義") 2 "マッピング操作は、" "引数の各列からひとつ得たものの集合を、" "連続で関数に適用した結果を返却します。"
     (CODE1 "mapc") "と" (CODE1 "mapl") "以外は、関数の返却値で構成された結果を返却します。" (CODE1 "mapc") "と"
     (CODE1 "mapl") "の場合は、返却値は" (STRONG "lists") "の列です。" EOL2 (STRONG "function")
     "は、最初はインデックス0番目の全ての要素で呼び出され、" "そのあとインデックス1番目の全ての要素で呼ばれ、" "以下同様に実行します。" "もし"
     (STRONG "function") "がシンボルのときは、" "それは" (CODE1 "symbol-function") "が実行されたかのように" "関数へ"
     (CODE1 "coerce") "されます。" EOL2 (CODE1 "mapcar") "は、" (STRONG "lists")
     "の連続した要素に対して操作します。" (STRONG "function") "は、各" (STRONG "lists") "の最初の要素で適用し、" "そのあと各"
     (STRONG "lists") "の二番目の要素で適用し、" "それを繰り返します。" "繰り返しは最短の" (STRONG "lists")
     "がなくなったときに終了し、" "他の" (STRONG "lists") "の余分な要素は無視されます。" (CODE1 "mapcar") "の返却値は、"
     (STRONG "function") "が連続して呼び出された結果のリストです。" EOL2 (CODE1 "mapc") "は" (CODE1 "mapcar")
     "と似ていますが、" "適用された" (STRONG "function") "の結果を蓄積しない所が違っています。" (STRONG "lists")
     "引数が返却されます。" EOL2 (CODE1 "maplist") "は" (CODE1 "mapcar") "と似ていますが、"
     (STRONG "function") "は、" (STRONG "lists") "のサブリストを連続して適用するところが違っています。"
     (STRONG "function") "は、最初は" (STRONG "lists") "そのものに適用され、" "そのあと各" (STRONG "lists")
     "の" (CODE1 "cdr") "によって適用され、" "さらに各" (STRONG "lists") "の" (CODE1 "cdr") "の"
     (CODE1 "cdr") "によって適用され、" "それをくり返します。" EOL2 (CODE1 "mapl") "は" (CODE1 "maplist")
     "と似ていますが、" "適用された" (STRONG "function") "の結果を蓄積しない所が違っています。" (STRONG "list-1")
     "が返却されます。" EOL2 (CODE1 "mapcan") "と" (CODE1 "mapcon") "は、" "それぞれ" (CODE1 "mapcar")
     "と" (CODE1 "maplist") "に似ていますが、" "適用した" (STRONG "function") "の結果を、" (CODE1 "list")
     "ではなく" (CODE1 "nconc") "によって" "リストに結合するところが違っています。" EOL2 "これは次のような関係であり、"
     (CODE3 "```lisp" "```" "(mapcon f x1 ... xn)"
      "  ==  (apply #'nconc (maplist f x1 ... xn))")
     EOL2 (CODE1 "mapcan") "と" (CODE1 "mapcar") "の関係に似ています。")
    (CHAPTER ("## Examples:") 2
     (CODE3 "```lisp" "```" "(mapcar #'car '((1 a) (2 b) (3 c))) =>  (1 2 3) "
      "(mapcar #'abs '(3 -4 2 -5 -6)) =>  (3 4 2 5 6)"
      "(mapcar #'cons '(a b c) '(1 2 3)) =>  ((A . 1) (B . 2) (C . 3))" NIL
      "(maplist #'append '(1 2 3 4) '(1 2) '(1 2 3)) "
      "=>  ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3)) "
      "(maplist #'(lambda (x) (cons 'foo x)) '(a b c d))"
      "=>  ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))"
      "(maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1)) '(a b a c d b c))"
      "=>  (0 0 1 0 1 1 1)" ";もし入力のリストに対応する要素が" ";そのリスト内で最後の要素の場合は1" NIL
      "(setq dummy nil) =>  NIL "
      "(mapc #'(lambda (&rest x) (setq dummy (append dummy x)))" "       '(1 2 3 4)"
      "       '(a b c d e)" "       '(x y z)) =>  (1 2 3 4) "
      "dummy =>  (1 A X 2 B Y 3 C Z)                   " NIL "(setq dummy nil) =>  NIL "
      "(mapl #'(lambda (x) (push x dummy)) '(1 2 3 4)) =>  (1 2 3 4) "
      "dummy =>  ((4) (3 4) (2 3 4) (1 2 3 4)) " NIL
      "(mapcan #'(lambda (x y) (if (null x) nil (list x y)))"
      "         '(nil nil nil d e)" "         '(1 2 3 4 5 6)) =>  (D 4 E 5) "
      "(mapcan #'(lambda (x) (and (numberp x) (list x)))" "         '(a 1 b c 3 4 d 5))"
      "=>  (1 3 4 5)")
     EOL2 "この場合は、関数はフィルタの役割を果たします。" "これは標準のLispの語句の" (CODE1 "mapcan") "です。"
     (CODE3 "```lisp" "```"
      "(mapcon #'list '(1 2 3 4)) =>  ((1 2 3 4) (2 3 4) (3 4) (4)) "))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "lists") "が通常のリストではないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "dolist") "," (CODE1 "map") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAPCAN" . "FUNCTION") *table*) (gethash "MAPCAN" *table*))
(setf (gethash "MAPCAR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAPC") ", " (CODE1 "MAPCAR") ", " (CODE1 "MAPCAN")
     ", " (CODE1 "MAPL") ", " (CODE1 "MAPLIST") ", " (CODE1 "MAPCON"))
    (CHAPTER ("## 構文") 2 (CODE1 "mapc") " " (STRONG "function") " &rest "
     (STRONG "lists+") " => " (STRONG "list-1") EOL1 (CODE1 "mapcar") " "
     (STRONG "function") " &rest " (STRONG "lists+") " => " (STRONG "result-list") EOL1
     (CODE1 "mapcan") " " (STRONG "function") " &rest " (STRONG "lists+") " => "
     (STRONG "concatenated-results") EOL1 (CODE1 "mapl") " " (STRONG "function")
     " &rest " (STRONG "lists+") " => " (STRONG "list-1") EOL1 (CODE1 "maplist") " "
     (STRONG "function") " &rest " (STRONG "lists+") " => " (STRONG "result-list") EOL1
     (CODE1 "mapcon") " " (STRONG "function") " &rest " (STRONG "lists+") " => "
     (STRONG "concatenated-results"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function") " - " (STRONG "lists") "と同じ数の引数を取る関数指定子"
     EOL1 (STRONG "lists") " - 通常のリスト" EOL1 (STRONG "list-1") " - 最初の" (STRONG "lists")
     "（通常のリストである必要があります）" EOL1 (STRONG "result-list") " - リスト" EOL1
     (STRONG "concatenated-results") " - リスト")
    (CHAPTER ("## 定義") 2 "マッピング操作は、" "引数の各列からひとつ得たものの集合を、" "連続で関数に適用した結果を返却します。"
     (CODE1 "mapc") "と" (CODE1 "mapl") "以外は、関数の返却値で構成された結果を返却します。" (CODE1 "mapc") "と"
     (CODE1 "mapl") "の場合は、返却値は" (STRONG "lists") "の列です。" EOL2 (STRONG "function")
     "は、最初はインデックス0番目の全ての要素で呼び出され、" "そのあとインデックス1番目の全ての要素で呼ばれ、" "以下同様に実行します。" "もし"
     (STRONG "function") "がシンボルのときは、" "それは" (CODE1 "symbol-function") "が実行されたかのように" "関数へ"
     (CODE1 "coerce") "されます。" EOL2 (CODE1 "mapcar") "は、" (STRONG "lists")
     "の連続した要素に対して操作します。" (STRONG "function") "は、各" (STRONG "lists") "の最初の要素で適用し、" "そのあと各"
     (STRONG "lists") "の二番目の要素で適用し、" "それを繰り返します。" "繰り返しは最短の" (STRONG "lists")
     "がなくなったときに終了し、" "他の" (STRONG "lists") "の余分な要素は無視されます。" (CODE1 "mapcar") "の返却値は、"
     (STRONG "function") "が連続して呼び出された結果のリストです。" EOL2 (CODE1 "mapc") "は" (CODE1 "mapcar")
     "と似ていますが、" "適用された" (STRONG "function") "の結果を蓄積しない所が違っています。" (STRONG "lists")
     "引数が返却されます。" EOL2 (CODE1 "maplist") "は" (CODE1 "mapcar") "と似ていますが、"
     (STRONG "function") "は、" (STRONG "lists") "のサブリストを連続して適用するところが違っています。"
     (STRONG "function") "は、最初は" (STRONG "lists") "そのものに適用され、" "そのあと各" (STRONG "lists")
     "の" (CODE1 "cdr") "によって適用され、" "さらに各" (STRONG "lists") "の" (CODE1 "cdr") "の"
     (CODE1 "cdr") "によって適用され、" "それをくり返します。" EOL2 (CODE1 "mapl") "は" (CODE1 "maplist")
     "と似ていますが、" "適用された" (STRONG "function") "の結果を蓄積しない所が違っています。" (STRONG "list-1")
     "が返却されます。" EOL2 (CODE1 "mapcan") "と" (CODE1 "mapcon") "は、" "それぞれ" (CODE1 "mapcar")
     "と" (CODE1 "maplist") "に似ていますが、" "適用した" (STRONG "function") "の結果を、" (CODE1 "list")
     "ではなく" (CODE1 "nconc") "によって" "リストに結合するところが違っています。" EOL2 "これは次のような関係であり、"
     (CODE3 "```lisp" "```" "(mapcon f x1 ... xn)"
      "  ==  (apply #'nconc (maplist f x1 ... xn))")
     EOL2 (CODE1 "mapcan") "と" (CODE1 "mapcar") "の関係に似ています。")
    (CHAPTER ("## Examples:") 2
     (CODE3 "```lisp" "```" "(mapcar #'car '((1 a) (2 b) (3 c))) =>  (1 2 3) "
      "(mapcar #'abs '(3 -4 2 -5 -6)) =>  (3 4 2 5 6)"
      "(mapcar #'cons '(a b c) '(1 2 3)) =>  ((A . 1) (B . 2) (C . 3))" NIL
      "(maplist #'append '(1 2 3 4) '(1 2) '(1 2 3)) "
      "=>  ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3)) "
      "(maplist #'(lambda (x) (cons 'foo x)) '(a b c d))"
      "=>  ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))"
      "(maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1)) '(a b a c d b c))"
      "=>  (0 0 1 0 1 1 1)" ";もし入力のリストに対応する要素が" ";そのリスト内で最後の要素の場合は1" NIL
      "(setq dummy nil) =>  NIL "
      "(mapc #'(lambda (&rest x) (setq dummy (append dummy x)))" "       '(1 2 3 4)"
      "       '(a b c d e)" "       '(x y z)) =>  (1 2 3 4) "
      "dummy =>  (1 A X 2 B Y 3 C Z)                   " NIL "(setq dummy nil) =>  NIL "
      "(mapl #'(lambda (x) (push x dummy)) '(1 2 3 4)) =>  (1 2 3 4) "
      "dummy =>  ((4) (3 4) (2 3 4) (1 2 3 4)) " NIL
      "(mapcan #'(lambda (x y) (if (null x) nil (list x y)))"
      "         '(nil nil nil d e)" "         '(1 2 3 4 5 6)) =>  (D 4 E 5) "
      "(mapcan #'(lambda (x) (and (numberp x) (list x)))" "         '(a 1 b c 3 4 d 5))"
      "=>  (1 3 4 5)")
     EOL2 "この場合は、関数はフィルタの役割を果たします。" "これは標準のLispの語句の" (CODE1 "mapcan") "です。"
     (CODE3 "```lisp" "```"
      "(mapcon #'list '(1 2 3 4)) =>  ((1 2 3 4) (2 3 4) (3 4) (4)) "))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "lists") "が通常のリストではないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "dolist") "," (CODE1 "map") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAPCAR" . "FUNCTION") *table*) (gethash "MAPCAR" *table*))
(setf (gethash "MAPCON" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAPC") ", " (CODE1 "MAPCAR") ", " (CODE1 "MAPCAN")
     ", " (CODE1 "MAPL") ", " (CODE1 "MAPLIST") ", " (CODE1 "MAPCON"))
    (CHAPTER ("## 構文") 2 (CODE1 "mapc") " " (STRONG "function") " &rest "
     (STRONG "lists+") " => " (STRONG "list-1") EOL1 (CODE1 "mapcar") " "
     (STRONG "function") " &rest " (STRONG "lists+") " => " (STRONG "result-list") EOL1
     (CODE1 "mapcan") " " (STRONG "function") " &rest " (STRONG "lists+") " => "
     (STRONG "concatenated-results") EOL1 (CODE1 "mapl") " " (STRONG "function")
     " &rest " (STRONG "lists+") " => " (STRONG "list-1") EOL1 (CODE1 "maplist") " "
     (STRONG "function") " &rest " (STRONG "lists+") " => " (STRONG "result-list") EOL1
     (CODE1 "mapcon") " " (STRONG "function") " &rest " (STRONG "lists+") " => "
     (STRONG "concatenated-results"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function") " - " (STRONG "lists") "と同じ数の引数を取る関数指定子"
     EOL1 (STRONG "lists") " - 通常のリスト" EOL1 (STRONG "list-1") " - 最初の" (STRONG "lists")
     "（通常のリストである必要があります）" EOL1 (STRONG "result-list") " - リスト" EOL1
     (STRONG "concatenated-results") " - リスト")
    (CHAPTER ("## 定義") 2 "マッピング操作は、" "引数の各列からひとつ得たものの集合を、" "連続で関数に適用した結果を返却します。"
     (CODE1 "mapc") "と" (CODE1 "mapl") "以外は、関数の返却値で構成された結果を返却します。" (CODE1 "mapc") "と"
     (CODE1 "mapl") "の場合は、返却値は" (STRONG "lists") "の列です。" EOL2 (STRONG "function")
     "は、最初はインデックス0番目の全ての要素で呼び出され、" "そのあとインデックス1番目の全ての要素で呼ばれ、" "以下同様に実行します。" "もし"
     (STRONG "function") "がシンボルのときは、" "それは" (CODE1 "symbol-function") "が実行されたかのように" "関数へ"
     (CODE1 "coerce") "されます。" EOL2 (CODE1 "mapcar") "は、" (STRONG "lists")
     "の連続した要素に対して操作します。" (STRONG "function") "は、各" (STRONG "lists") "の最初の要素で適用し、" "そのあと各"
     (STRONG "lists") "の二番目の要素で適用し、" "それを繰り返します。" "繰り返しは最短の" (STRONG "lists")
     "がなくなったときに終了し、" "他の" (STRONG "lists") "の余分な要素は無視されます。" (CODE1 "mapcar") "の返却値は、"
     (STRONG "function") "が連続して呼び出された結果のリストです。" EOL2 (CODE1 "mapc") "は" (CODE1 "mapcar")
     "と似ていますが、" "適用された" (STRONG "function") "の結果を蓄積しない所が違っています。" (STRONG "lists")
     "引数が返却されます。" EOL2 (CODE1 "maplist") "は" (CODE1 "mapcar") "と似ていますが、"
     (STRONG "function") "は、" (STRONG "lists") "のサブリストを連続して適用するところが違っています。"
     (STRONG "function") "は、最初は" (STRONG "lists") "そのものに適用され、" "そのあと各" (STRONG "lists")
     "の" (CODE1 "cdr") "によって適用され、" "さらに各" (STRONG "lists") "の" (CODE1 "cdr") "の"
     (CODE1 "cdr") "によって適用され、" "それをくり返します。" EOL2 (CODE1 "mapl") "は" (CODE1 "maplist")
     "と似ていますが、" "適用された" (STRONG "function") "の結果を蓄積しない所が違っています。" (STRONG "list-1")
     "が返却されます。" EOL2 (CODE1 "mapcan") "と" (CODE1 "mapcon") "は、" "それぞれ" (CODE1 "mapcar")
     "と" (CODE1 "maplist") "に似ていますが、" "適用した" (STRONG "function") "の結果を、" (CODE1 "list")
     "ではなく" (CODE1 "nconc") "によって" "リストに結合するところが違っています。" EOL2 "これは次のような関係であり、"
     (CODE3 "```lisp" "```" "(mapcon f x1 ... xn)"
      "  ==  (apply #'nconc (maplist f x1 ... xn))")
     EOL2 (CODE1 "mapcan") "と" (CODE1 "mapcar") "の関係に似ています。")
    (CHAPTER ("## Examples:") 2
     (CODE3 "```lisp" "```" "(mapcar #'car '((1 a) (2 b) (3 c))) =>  (1 2 3) "
      "(mapcar #'abs '(3 -4 2 -5 -6)) =>  (3 4 2 5 6)"
      "(mapcar #'cons '(a b c) '(1 2 3)) =>  ((A . 1) (B . 2) (C . 3))" NIL
      "(maplist #'append '(1 2 3 4) '(1 2) '(1 2 3)) "
      "=>  ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3)) "
      "(maplist #'(lambda (x) (cons 'foo x)) '(a b c d))"
      "=>  ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))"
      "(maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1)) '(a b a c d b c))"
      "=>  (0 0 1 0 1 1 1)" ";もし入力のリストに対応する要素が" ";そのリスト内で最後の要素の場合は1" NIL
      "(setq dummy nil) =>  NIL "
      "(mapc #'(lambda (&rest x) (setq dummy (append dummy x)))" "       '(1 2 3 4)"
      "       '(a b c d e)" "       '(x y z)) =>  (1 2 3 4) "
      "dummy =>  (1 A X 2 B Y 3 C Z)                   " NIL "(setq dummy nil) =>  NIL "
      "(mapl #'(lambda (x) (push x dummy)) '(1 2 3 4)) =>  (1 2 3 4) "
      "dummy =>  ((4) (3 4) (2 3 4) (1 2 3 4)) " NIL
      "(mapcan #'(lambda (x y) (if (null x) nil (list x y)))"
      "         '(nil nil nil d e)" "         '(1 2 3 4 5 6)) =>  (D 4 E 5) "
      "(mapcan #'(lambda (x) (and (numberp x) (list x)))" "         '(a 1 b c 3 4 d 5))"
      "=>  (1 3 4 5)")
     EOL2 "この場合は、関数はフィルタの役割を果たします。" "これは標準のLispの語句の" (CODE1 "mapcan") "です。"
     (CODE3 "```lisp" "```"
      "(mapcon #'list '(1 2 3 4)) =>  ((1 2 3 4) (2 3 4) (3 4) (4)) "))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "lists") "が通常のリストではないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "dolist") "," (CODE1 "map") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAPCON" . "FUNCTION") *table*) (gethash "MAPCON" *table*))
(setf (gethash "MAPHASH" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAPHASH"))
    (CHAPTER ("## 構文") 2 (CODE1 "maphash") " " (STRONG "function") " "
     (STRONG "hash-table") " => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function") " - 2つの引数にキーと値を受け取る関数の指定子" EOL1
     (STRONG "hash-table") " - ハッシュテーブル")
    (CHAPTER ("## 定義") 2 (STRONG "hash-table") "内のすべてのエントリーに対して繰り返しを行います。" "各エントリ―は"
     (STRONG "function") "を2つの引数に" "エントリーのキーと値を指定して呼び出します。" EOL2 "もし" (CODE1 "maphash")
     "処理中に" (STRONG "hash-table") "からエントリーが" "追加されるか削除されるかを実行しようとしたときの結果は未定義ですが、"
     "次に示す2つの例外があります。" (STRONG "function") "は現在処理中のエントリーの値の部分は" (CODE1 "setf") "の"
     (CODE1 "gethash") "を使用することができます。" "または、そのエントリーを削除するために" (CODE1 "remhash")
     "を使用することができます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32304110>"
      "(dotimes (i 10) (setf (gethash i table) i)) =>  NIL" "(let ((sum-of-squares 0))"
      "   (maphash #'(lambda (key val) " "                (let ((square (* val val)))"
      "                  (incf sum-of-squares square)"
      "                  (setf (gethash key table) square)))" "            table)"
      "   sum-of-squares) =>  285" "(hash-table-count table) =>  10"
      "(maphash #'(lambda (key val)"
      "              (when (oddp val) (remhash key table)))" "          table) =>  NIL"
      "(hash-table-count table) =>  5"
      "(maphash #'(lambda (k v) (print (list k v))) table)" "(0 0) " "(8 64) " "(2 4) "
      "(6 36) " "(4 16) " "=>  NIL"))
    (CHAPTER ("## 副作用") 2 (STRONG "function") "によって実行されるかもしれないもの以外にはありません。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "loop") "," (CODE1 "with-hash-table-iterator") ","
     "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAPHASH" . "FUNCTION") *table*) (gethash "MAPHASH" *table*))
(setf (gethash "MAPL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAPC") ", " (CODE1 "MAPCAR") ", " (CODE1 "MAPCAN")
     ", " (CODE1 "MAPL") ", " (CODE1 "MAPLIST") ", " (CODE1 "MAPCON"))
    (CHAPTER ("## 構文") 2 (CODE1 "mapc") " " (STRONG "function") " &rest "
     (STRONG "lists+") " => " (STRONG "list-1") EOL1 (CODE1 "mapcar") " "
     (STRONG "function") " &rest " (STRONG "lists+") " => " (STRONG "result-list") EOL1
     (CODE1 "mapcan") " " (STRONG "function") " &rest " (STRONG "lists+") " => "
     (STRONG "concatenated-results") EOL1 (CODE1 "mapl") " " (STRONG "function")
     " &rest " (STRONG "lists+") " => " (STRONG "list-1") EOL1 (CODE1 "maplist") " "
     (STRONG "function") " &rest " (STRONG "lists+") " => " (STRONG "result-list") EOL1
     (CODE1 "mapcon") " " (STRONG "function") " &rest " (STRONG "lists+") " => "
     (STRONG "concatenated-results"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function") " - " (STRONG "lists") "と同じ数の引数を取る関数指定子"
     EOL1 (STRONG "lists") " - 通常のリスト" EOL1 (STRONG "list-1") " - 最初の" (STRONG "lists")
     "（通常のリストである必要があります）" EOL1 (STRONG "result-list") " - リスト" EOL1
     (STRONG "concatenated-results") " - リスト")
    (CHAPTER ("## 定義") 2 "マッピング操作は、" "引数の各列からひとつ得たものの集合を、" "連続で関数に適用した結果を返却します。"
     (CODE1 "mapc") "と" (CODE1 "mapl") "以外は、関数の返却値で構成された結果を返却します。" (CODE1 "mapc") "と"
     (CODE1 "mapl") "の場合は、返却値は" (STRONG "lists") "の列です。" EOL2 (STRONG "function")
     "は、最初はインデックス0番目の全ての要素で呼び出され、" "そのあとインデックス1番目の全ての要素で呼ばれ、" "以下同様に実行します。" "もし"
     (STRONG "function") "がシンボルのときは、" "それは" (CODE1 "symbol-function") "が実行されたかのように" "関数へ"
     (CODE1 "coerce") "されます。" EOL2 (CODE1 "mapcar") "は、" (STRONG "lists")
     "の連続した要素に対して操作します。" (STRONG "function") "は、各" (STRONG "lists") "の最初の要素で適用し、" "そのあと各"
     (STRONG "lists") "の二番目の要素で適用し、" "それを繰り返します。" "繰り返しは最短の" (STRONG "lists")
     "がなくなったときに終了し、" "他の" (STRONG "lists") "の余分な要素は無視されます。" (CODE1 "mapcar") "の返却値は、"
     (STRONG "function") "が連続して呼び出された結果のリストです。" EOL2 (CODE1 "mapc") "は" (CODE1 "mapcar")
     "と似ていますが、" "適用された" (STRONG "function") "の結果を蓄積しない所が違っています。" (STRONG "lists")
     "引数が返却されます。" EOL2 (CODE1 "maplist") "は" (CODE1 "mapcar") "と似ていますが、"
     (STRONG "function") "は、" (STRONG "lists") "のサブリストを連続して適用するところが違っています。"
     (STRONG "function") "は、最初は" (STRONG "lists") "そのものに適用され、" "そのあと各" (STRONG "lists")
     "の" (CODE1 "cdr") "によって適用され、" "さらに各" (STRONG "lists") "の" (CODE1 "cdr") "の"
     (CODE1 "cdr") "によって適用され、" "それをくり返します。" EOL2 (CODE1 "mapl") "は" (CODE1 "maplist")
     "と似ていますが、" "適用された" (STRONG "function") "の結果を蓄積しない所が違っています。" (STRONG "list-1")
     "が返却されます。" EOL2 (CODE1 "mapcan") "と" (CODE1 "mapcon") "は、" "それぞれ" (CODE1 "mapcar")
     "と" (CODE1 "maplist") "に似ていますが、" "適用した" (STRONG "function") "の結果を、" (CODE1 "list")
     "ではなく" (CODE1 "nconc") "によって" "リストに結合するところが違っています。" EOL2 "これは次のような関係であり、"
     (CODE3 "```lisp" "```" "(mapcon f x1 ... xn)"
      "  ==  (apply #'nconc (maplist f x1 ... xn))")
     EOL2 (CODE1 "mapcan") "と" (CODE1 "mapcar") "の関係に似ています。")
    (CHAPTER ("## Examples:") 2
     (CODE3 "```lisp" "```" "(mapcar #'car '((1 a) (2 b) (3 c))) =>  (1 2 3) "
      "(mapcar #'abs '(3 -4 2 -5 -6)) =>  (3 4 2 5 6)"
      "(mapcar #'cons '(a b c) '(1 2 3)) =>  ((A . 1) (B . 2) (C . 3))" NIL
      "(maplist #'append '(1 2 3 4) '(1 2) '(1 2 3)) "
      "=>  ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3)) "
      "(maplist #'(lambda (x) (cons 'foo x)) '(a b c d))"
      "=>  ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))"
      "(maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1)) '(a b a c d b c))"
      "=>  (0 0 1 0 1 1 1)" ";もし入力のリストに対応する要素が" ";そのリスト内で最後の要素の場合は1" NIL
      "(setq dummy nil) =>  NIL "
      "(mapc #'(lambda (&rest x) (setq dummy (append dummy x)))" "       '(1 2 3 4)"
      "       '(a b c d e)" "       '(x y z)) =>  (1 2 3 4) "
      "dummy =>  (1 A X 2 B Y 3 C Z)                   " NIL "(setq dummy nil) =>  NIL "
      "(mapl #'(lambda (x) (push x dummy)) '(1 2 3 4)) =>  (1 2 3 4) "
      "dummy =>  ((4) (3 4) (2 3 4) (1 2 3 4)) " NIL
      "(mapcan #'(lambda (x y) (if (null x) nil (list x y)))"
      "         '(nil nil nil d e)" "         '(1 2 3 4 5 6)) =>  (D 4 E 5) "
      "(mapcan #'(lambda (x) (and (numberp x) (list x)))" "         '(a 1 b c 3 4 d 5))"
      "=>  (1 3 4 5)")
     EOL2 "この場合は、関数はフィルタの役割を果たします。" "これは標準のLispの語句の" (CODE1 "mapcan") "です。"
     (CODE3 "```lisp" "```"
      "(mapcon #'list '(1 2 3 4)) =>  ((1 2 3 4) (2 3 4) (3 4) (4)) "))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "lists") "が通常のリストではないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "dolist") "," (CODE1 "map") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAPL" . "FUNCTION") *table*) (gethash "MAPL" *table*))
(setf (gethash "MAPLIST" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MAPC") ", " (CODE1 "MAPCAR") ", " (CODE1 "MAPCAN")
     ", " (CODE1 "MAPL") ", " (CODE1 "MAPLIST") ", " (CODE1 "MAPCON"))
    (CHAPTER ("## 構文") 2 (CODE1 "mapc") " " (STRONG "function") " &rest "
     (STRONG "lists+") " => " (STRONG "list-1") EOL1 (CODE1 "mapcar") " "
     (STRONG "function") " &rest " (STRONG "lists+") " => " (STRONG "result-list") EOL1
     (CODE1 "mapcan") " " (STRONG "function") " &rest " (STRONG "lists+") " => "
     (STRONG "concatenated-results") EOL1 (CODE1 "mapl") " " (STRONG "function")
     " &rest " (STRONG "lists+") " => " (STRONG "list-1") EOL1 (CODE1 "maplist") " "
     (STRONG "function") " &rest " (STRONG "lists+") " => " (STRONG "result-list") EOL1
     (CODE1 "mapcon") " " (STRONG "function") " &rest " (STRONG "lists+") " => "
     (STRONG "concatenated-results"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function") " - " (STRONG "lists") "と同じ数の引数を取る関数指定子"
     EOL1 (STRONG "lists") " - 通常のリスト" EOL1 (STRONG "list-1") " - 最初の" (STRONG "lists")
     "（通常のリストである必要があります）" EOL1 (STRONG "result-list") " - リスト" EOL1
     (STRONG "concatenated-results") " - リスト")
    (CHAPTER ("## 定義") 2 "マッピング操作は、" "引数の各列からひとつ得たものの集合を、" "連続で関数に適用した結果を返却します。"
     (CODE1 "mapc") "と" (CODE1 "mapl") "以外は、関数の返却値で構成された結果を返却します。" (CODE1 "mapc") "と"
     (CODE1 "mapl") "の場合は、返却値は" (STRONG "lists") "の列です。" EOL2 (STRONG "function")
     "は、最初はインデックス0番目の全ての要素で呼び出され、" "そのあとインデックス1番目の全ての要素で呼ばれ、" "以下同様に実行します。" "もし"
     (STRONG "function") "がシンボルのときは、" "それは" (CODE1 "symbol-function") "が実行されたかのように" "関数へ"
     (CODE1 "coerce") "されます。" EOL2 (CODE1 "mapcar") "は、" (STRONG "lists")
     "の連続した要素に対して操作します。" (STRONG "function") "は、各" (STRONG "lists") "の最初の要素で適用し、" "そのあと各"
     (STRONG "lists") "の二番目の要素で適用し、" "それを繰り返します。" "繰り返しは最短の" (STRONG "lists")
     "がなくなったときに終了し、" "他の" (STRONG "lists") "の余分な要素は無視されます。" (CODE1 "mapcar") "の返却値は、"
     (STRONG "function") "が連続して呼び出された結果のリストです。" EOL2 (CODE1 "mapc") "は" (CODE1 "mapcar")
     "と似ていますが、" "適用された" (STRONG "function") "の結果を蓄積しない所が違っています。" (STRONG "lists")
     "引数が返却されます。" EOL2 (CODE1 "maplist") "は" (CODE1 "mapcar") "と似ていますが、"
     (STRONG "function") "は、" (STRONG "lists") "のサブリストを連続して適用するところが違っています。"
     (STRONG "function") "は、最初は" (STRONG "lists") "そのものに適用され、" "そのあと各" (STRONG "lists")
     "の" (CODE1 "cdr") "によって適用され、" "さらに各" (STRONG "lists") "の" (CODE1 "cdr") "の"
     (CODE1 "cdr") "によって適用され、" "それをくり返します。" EOL2 (CODE1 "mapl") "は" (CODE1 "maplist")
     "と似ていますが、" "適用された" (STRONG "function") "の結果を蓄積しない所が違っています。" (STRONG "list-1")
     "が返却されます。" EOL2 (CODE1 "mapcan") "と" (CODE1 "mapcon") "は、" "それぞれ" (CODE1 "mapcar")
     "と" (CODE1 "maplist") "に似ていますが、" "適用した" (STRONG "function") "の結果を、" (CODE1 "list")
     "ではなく" (CODE1 "nconc") "によって" "リストに結合するところが違っています。" EOL2 "これは次のような関係であり、"
     (CODE3 "```lisp" "```" "(mapcon f x1 ... xn)"
      "  ==  (apply #'nconc (maplist f x1 ... xn))")
     EOL2 (CODE1 "mapcan") "と" (CODE1 "mapcar") "の関係に似ています。")
    (CHAPTER ("## Examples:") 2
     (CODE3 "```lisp" "```" "(mapcar #'car '((1 a) (2 b) (3 c))) =>  (1 2 3) "
      "(mapcar #'abs '(3 -4 2 -5 -6)) =>  (3 4 2 5 6)"
      "(mapcar #'cons '(a b c) '(1 2 3)) =>  ((A . 1) (B . 2) (C . 3))" NIL
      "(maplist #'append '(1 2 3 4) '(1 2) '(1 2 3)) "
      "=>  ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3)) "
      "(maplist #'(lambda (x) (cons 'foo x)) '(a b c d))"
      "=>  ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))"
      "(maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1)) '(a b a c d b c))"
      "=>  (0 0 1 0 1 1 1)" ";もし入力のリストに対応する要素が" ";そのリスト内で最後の要素の場合は1" NIL
      "(setq dummy nil) =>  NIL "
      "(mapc #'(lambda (&rest x) (setq dummy (append dummy x)))" "       '(1 2 3 4)"
      "       '(a b c d e)" "       '(x y z)) =>  (1 2 3 4) "
      "dummy =>  (1 A X 2 B Y 3 C Z)                   " NIL "(setq dummy nil) =>  NIL "
      "(mapl #'(lambda (x) (push x dummy)) '(1 2 3 4)) =>  (1 2 3 4) "
      "dummy =>  ((4) (3 4) (2 3 4) (1 2 3 4)) " NIL
      "(mapcan #'(lambda (x y) (if (null x) nil (list x y)))"
      "         '(nil nil nil d e)" "         '(1 2 3 4 5 6)) =>  (D 4 E 5) "
      "(mapcan #'(lambda (x) (and (numberp x) (list x)))" "         '(a 1 b c 3 4 d 5))"
      "=>  (1 3 4 5)")
     EOL2 "この場合は、関数はフィルタの役割を果たします。" "これは標準のLispの語句の" (CODE1 "mapcan") "です。"
     (CODE3 "```lisp" "```"
      "(mapcon #'list '(1 2 3 4)) =>  ((1 2 3 4) (2 3 4) (3 4) (4)) "))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "lists") "が通常のリストではないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "dolist") "," (CODE1 "map") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MAPLIST" . "FUNCTION") *table*) (gethash "MAPLIST" *table*))
(setf (gethash "MEMBER" *table*)
  '("MEMBER FUNCTION" EOL1 "MEMBER TYPE-SPECIFIER" EOL1))
(setf (gethash '("MEMBER" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MEMBER") ", " (CODE1 "MEMBER-IF") ", "
     (CODE1 "MEMBER-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "member") " " (STRONG "item") " " (STRONG "list")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "tail") EOL1 (CODE1 "member-if") " " (STRONG "predicate") " "
     (STRONG "list") " &key " (STRONG "key") " => " (STRONG "tail") EOL1
     (CODE1 "member-if-not") " " (STRONG "predicate") " " (STRONG "list") " &key "
     (STRONG "key") " => " (STRONG "tail"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "list") " - 通常のリスト"
     EOL1 (STRONG "predicate") " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "tail") " - リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "member") ", " (CODE1 "member-if") ", "
     (CODE1 "member-if-not") "は" "それぞれ" (STRONG "list") "から" (STRONG "item") "を探すか、"
     "あるいは" (STRONG "test") "をみなすトップレベルの要素を探します。" (STRONG "predicate") "関数の引数は、"
     (STRONG "list") "の要素です。" EOL2 "もしある要素が" (STRONG "test") "を満たすときは、"
     "その要素で始まるリストの末尾を返します。" "それ以外は" (CODE1 "nil") "を返却します。" EOL2 (STRONG "list")
     "はトップレベルのみで検索されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(member 2 '(1 2 3)) =>  (2 3)                                 "
      "(member 2 '((1 . 2) (3 . 4)) :test-not #'= :key #'cdr) =>  ((3 . 4))"
      "(member 'e '(a b c d)) =>  NIL" "(member-if #'listp '(a b nil c d)) =>  (NIL C D)"
      "(member-if #'numberp '(a #\\Space 5/3 foo)) =>  (5/3 FOO)"
      "(member-if-not #'zerop " "                '(3 6 9 11 . 12)"
      "                :key #'(lambda (x) (mod x 3))) =>  (11 . 12)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list") "が通常のリストではないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をする必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "find") "," (CODE1 "position") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "member-if-not") "は非推奨です。" EOL2 "下記の例を考えます。"
     (CODE3 "```lisp" "```" "(member 'a '(g (a y) c a d e a f)) =>  (A D E A F)") EOL2
     (CODE1 "member") "によって返却された値は、" (CODE1 "a") "から始まるリストの位置と同一です。" "したがって、"
     (CODE1 "member") "の結果を" (CODE1 "rplaca") "することで、" (CODE1 "a")
     "が発見された場所のリストの部分を変更することができます。" "（" (CODE1 "member") "が" (CODE1 "nil") "を返却していないという"
     "チェックがされていると仮定しています。）")))
(setf (gethash '("MEMBER" . "TYPE-SPECIFIER") *table*)
  '((CHAPTER NIL 0 "Type Specifier " (CODE1 "MEMBER")) (CHAPTER ("## 型指定子の種類") 2 "結合")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "member") " " (STRONG "object\\*"))
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "object") " - オブジェクト")
    (CHAPTER ("## 型指定子の定義") 2 (STRONG "object") "で示されるものを含む集合を示します。" (STRONG "object")
     "は、" "指定された" (STRONG "object") "と" (CODE1 "eql") "で等しいときにのみ" "この型になります。" EOL2 "型指定子"
     (CODE1 "(member)") "は、" (CODE1 "nil") "と同等です。" (STRONG "object") "にシンボル" (CODE1 "*")
     "を指定できますが、" "しかしそれは自分自身（つまりシンボル" (CODE1 "*") "）を示しているのであって、" "未指定の値を表現しているのではありません。"
     "シンボルとしての" (CODE1 "member") "は、有効な型指定子ではありませんし、" "とくに" (CODE1 "(member)") "や"
     (CODE1 "(member *)") "の省略形ではありません。")
    (CHAPTER ("## 参考") 2 (CODE1 "eql") "（型として）")))
(setf (gethash "MEMBER-IF" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MEMBER") ", " (CODE1 "MEMBER-IF") ", "
     (CODE1 "MEMBER-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "member") " " (STRONG "item") " " (STRONG "list")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "tail") EOL1 (CODE1 "member-if") " " (STRONG "predicate") " "
     (STRONG "list") " &key " (STRONG "key") " => " (STRONG "tail") EOL1
     (CODE1 "member-if-not") " " (STRONG "predicate") " " (STRONG "list") " &key "
     (STRONG "key") " => " (STRONG "tail"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "list") " - 通常のリスト"
     EOL1 (STRONG "predicate") " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "tail") " - リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "member") ", " (CODE1 "member-if") ", "
     (CODE1 "member-if-not") "は" "それぞれ" (STRONG "list") "から" (STRONG "item") "を探すか、"
     "あるいは" (STRONG "test") "をみなすトップレベルの要素を探します。" (STRONG "predicate") "関数の引数は、"
     (STRONG "list") "の要素です。" EOL2 "もしある要素が" (STRONG "test") "を満たすときは、"
     "その要素で始まるリストの末尾を返します。" "それ以外は" (CODE1 "nil") "を返却します。" EOL2 (STRONG "list")
     "はトップレベルのみで検索されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(member 2 '(1 2 3)) =>  (2 3)                                 "
      "(member 2 '((1 . 2) (3 . 4)) :test-not #'= :key #'cdr) =>  ((3 . 4))"
      "(member 'e '(a b c d)) =>  NIL" "(member-if #'listp '(a b nil c d)) =>  (NIL C D)"
      "(member-if #'numberp '(a #\\Space 5/3 foo)) =>  (5/3 FOO)"
      "(member-if-not #'zerop " "                '(3 6 9 11 . 12)"
      "                :key #'(lambda (x) (mod x 3))) =>  (11 . 12)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list") "が通常のリストではないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をする必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "find") "," (CODE1 "position") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "member-if-not") "は非推奨です。" EOL2 "下記の例を考えます。"
     (CODE3 "```lisp" "```" "(member 'a '(g (a y) c a d e a f)) =>  (A D E A F)") EOL2
     (CODE1 "member") "によって返却された値は、" (CODE1 "a") "から始まるリストの位置と同一です。" "したがって、"
     (CODE1 "member") "の結果を" (CODE1 "rplaca") "することで、" (CODE1 "a")
     "が発見された場所のリストの部分を変更することができます。" "（" (CODE1 "member") "が" (CODE1 "nil") "を返却していないという"
     "チェックがされていると仮定しています。）")))
(setf (gethash '("MEMBER-IF" . "FUNCTION") *table*) (gethash "MEMBER-IF" *table*))
(setf (gethash "MEMBER-IF-NOT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MEMBER") ", " (CODE1 "MEMBER-IF") ", "
     (CODE1 "MEMBER-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "member") " " (STRONG "item") " " (STRONG "list")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "tail") EOL1 (CODE1 "member-if") " " (STRONG "predicate") " "
     (STRONG "list") " &key " (STRONG "key") " => " (STRONG "tail") EOL1
     (CODE1 "member-if-not") " " (STRONG "predicate") " " (STRONG "list") " &key "
     (STRONG "key") " => " (STRONG "tail"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "list") " - 通常のリスト"
     EOL1 (STRONG "predicate") " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "tail") " - リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "member") ", " (CODE1 "member-if") ", "
     (CODE1 "member-if-not") "は" "それぞれ" (STRONG "list") "から" (STRONG "item") "を探すか、"
     "あるいは" (STRONG "test") "をみなすトップレベルの要素を探します。" (STRONG "predicate") "関数の引数は、"
     (STRONG "list") "の要素です。" EOL2 "もしある要素が" (STRONG "test") "を満たすときは、"
     "その要素で始まるリストの末尾を返します。" "それ以外は" (CODE1 "nil") "を返却します。" EOL2 (STRONG "list")
     "はトップレベルのみで検索されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(member 2 '(1 2 3)) =>  (2 3)                                 "
      "(member 2 '((1 . 2) (3 . 4)) :test-not #'= :key #'cdr) =>  ((3 . 4))"
      "(member 'e '(a b c d)) =>  NIL" "(member-if #'listp '(a b nil c d)) =>  (NIL C D)"
      "(member-if #'numberp '(a #\\Space 5/3 foo)) =>  (5/3 FOO)"
      "(member-if-not #'zerop " "                '(3 6 9 11 . 12)"
      "                :key #'(lambda (x) (mod x 3))) =>  (11 . 12)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list") "が通常のリストではないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をする必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "find") "," (CODE1 "position") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "member-if-not") "は非推奨です。" EOL2 "下記の例を考えます。"
     (CODE3 "```lisp" "```" "(member 'a '(g (a y) c a d e a f)) =>  (A D E A F)") EOL2
     (CODE1 "member") "によって返却された値は、" (CODE1 "a") "から始まるリストの位置と同一です。" "したがって、"
     (CODE1 "member") "の結果を" (CODE1 "rplaca") "することで、" (CODE1 "a")
     "が発見された場所のリストの部分を変更することができます。" "（" (CODE1 "member") "が" (CODE1 "nil") "を返却していないという"
     "チェックがされていると仮定しています。）")))
(setf (gethash '("MEMBER-IF-NOT" . "FUNCTION") *table*) (gethash "MEMBER-IF-NOT" *table*))
(setf (gethash "MERGE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MERGE"))
    (CHAPTER ("## 構文") 2 (CODE1 "merge") " " (STRONG "result-type") " "
     (STRONG "sequence-1") " " (STRONG "sequence-2") " " (STRONG "predicate") " &key "
     (STRONG "key") " => " (STRONG "result-sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "result-type") " - " (CODE1 "sequence") "の型指定子" EOL1
     (STRONG "sequences-1") " - シーケンス" EOL1 (STRONG "sequences-2") " - シーケンス" EOL1
     (STRONG "predicate") " - 2つの引数をとりgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "result-sequence") " - 型"
     (STRONG "result-type") "の正常なシーケンス")
    (CHAPTER ("## 定義") 2 (STRONG "sequence-1") "と" (STRONG "sequence-2") "を"
     (STRONG "predicate") "が決める順にしたがって" "破壊的にマージします。" (CODE1 "merge") "は、" (STRONG "key")
     "による要素の展開と" (STRONG "predicate") "の実行によって、" "2つの要素間の関係を決定します。" EOL2
     (STRONG "predicate") "関数の最初の引数は、" (STRONG "key") "関数によって展開された（もし" (STRONG "key")
     "が指定されたのなら）、" (STRONG "sequence-1") "の要素の部分であり、" "二番目の引数は、" (STRONG "key")
     "関数によって展開された（もし" (STRONG "key") "が指定されたのなら）、" (STRONG "sequence-2") "の要素の部分です。"
     (STRONG "predicate") "は、第一引数が第二引数より（何らかの適切な意味で）、" "厳密に小さい場合にのみ" (STRONG "true")
     "を返すべきです。" "もし最初の引数が二番目の引数が（何らかの適切な意味で）、" "以上であるときは、" (STRONG "predicate") "は"
     (STRONG "false") "を返却するべきです。" (CODE1 "merge") "は、2つの要素" (CODE1 "x") "と" (CODE1 "y")
     (CODE1 "(funcall predicate x y)") "と" (CODE1 "(funcall predicate y x)") "が" "両方とも"
     (STRONG "false") "であるときに、等しいとみなすと仮定しています。" EOL2 (STRONG "key") "関数の引数は、"
     (STRONG "sequence") "の要素です。" "通常、" (STRONG "key") "関数の返却値は、" (STRONG "predicate")
     "の引数になります。" "もし" (STRONG "key") "が与えられないか、あるいは" (CODE1 "nil") "が指定されたとき、"
     (STRONG "sequence") "の要素そのものが使用されます。" (STRONG "key") "は、各シーケンスの要素に対して、"
     "複数化呼び出される可能性があるので、" "副作用は任意の順番で呼び出されるかもしれません。" EOL2 "もし" (STRONG "key") "と"
     (STRONG "predicate") "が返却すれば、マージ操作も終了します。" "2つのシーケンス" (CODE1 "x") "と" (CODE1 "y")
     "のマージした結果を、" (STRONG "result-type") "の新しいシーケンス" (CODE1 "z") "としたとき、" (CODE1 "z")
     "の長さは、" (CODE1 "x") "と" (CODE1 "y") "の長さの合計であり、" (CODE1 "z") "には" (CODE1 "x") "と"
     (CODE1 "y") "の全ての要素が含まれます。" "もし" (CODE1 "x1") "と" (CODE1 "x2") "が" (CODE1 "x")
     "の2つの要素であり、" (CODE1 "x") "内で" (CODE1 "x1") "の方が" (CODE1 "x2") "より先行しているとき、"
     (CODE1 "z") "内でも" (CODE1 "x1") "の方が" (CODE1 "x2") "より先行しており、" (CODE1 "y")
     "の要素も同様です。" "要するに、" (CODE1 "z") "は" (CODE1 "x") "と" (CODE1 "y") "のインターリーブです。" EOL2
     "もし" (CODE1 "x") "と" (CODE1 "y") "が" (STRONG "predicate") "に従って正しくソートされれているならば、"
     (CODE1 "z") "もまた正しくソートされています。" (CODE1 "x") "と" (CODE1 "y") "がソートされていないのであれば、"
     (CODE1 "z") "はソートされていませんが、" "それでも" (CODE1 "x") "と" (CODE1 "y") "のインターリーブとなります。" EOL2
     "マージ操作は安定性が保証されます。" "もし2つかそれ以上の要素が" (STRONG "predicate") "によって等しい場合、" "返却値は、"
     (STRONG "sequence-1") "のそれらの要素の方が、" (STRONG "sequence-2") "のそれらの要素よりも優先されます。" EOL2
     (STRONG "sequence-1") "と" (STRONG "sequence-2") "は 破壊されるかもしれません。" EOL2 "もし"
     (STRONG "result-type") "が" (CODE1 "list") "のサブタイプの場合、" "リストが返却されます。" EOL2 "もし"
     (STRONG "result-type") "が" (CODE1 "vector") "のサブタイプの場合、" "実装が"
     (STRONG "result-type") "を要素の型として決めることができるのであれば、"
     "その要素の型をアップグレードした結果が返却値の配列の要素の型になります。" "しかし実装が要素の型を決定できないか、あるいは" (CODE1 "*") "のときは、"
     "返却値の配列の要素の型は" (CODE1 "t") "になります。" "その他の場合はエラーが発生します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq test1 (list 1 3 4 6 7))" "(setq test2 (list 2 5 8))"
      "(merge 'list test1 test2 #'<) =>  (1 2 3 4 5 6 7 8)"
      "(setq test1 (copy-seq \"BOY\"))" "(setq test2 (copy-seq :nosy\"))"
      "(merge 'string test1 test2 #'char-lessp) =>  \"BnOosYy\""
      "(setq test1 (vector ((red . 1) (blue . 4))))"
      "(setq test2 (vector ((yellow . 2) (green . 7))))"
      "(merge 'vector test1 test2 #'< :key #'cdr) "
      "=>  #((RED . 1) (YELLOW . 2) (BLUE . 4) (GREEN . 7)) "
      "(merge '(vector * 4) '(1 5) '(2 4 6) #'<) should signal an error"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "result-type") "が、" (CODE1 "list") "のサブタイプでも、"
     (CODE1 "vector") "のサブタイプでもないとき、" "型" (CODE1 "type-error") "のエラーが発します。" EOL2
     (STRONG "result-type") "で指定した要素数と、" (STRONG "sequence-1") "と" (STRONG "sequence-2")
     "の合計の長さが違う場合は、" "型" (CODE1 "type-error") "のエラーが発します。")
    (CHAPTER ("## 参考") 2 (CODE1 "sort") "," (CODE1 "stable-sort") "," "3.2.1. コンパイラーの用語,"
     "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MERGE" . "FUNCTION") *table*) (gethash "MERGE" *table*))
(setf (gethash "MERGE-PATHNAMES" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MERGE-PATHNAMES"))
    (CHAPTER ("## 構文") 2 (CODE1 "merge-pathnames") " " (STRONG "pathname") " "
     (CODE1 "&optional") " " (STRONG "default-pathname") " " (STRONG "default-version")
     EOL1 "=> " (STRONG "merged-pathname"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathname") " - パス名指定子" EOL1
     (STRONG "default-pathname") " - パス名指定子。" "デフォルトは"
     (CODE1 "*default-pathname-defaults*") "の値。" EOL1 (STRONG "default-version")
     " - 有効なパス名のバージョン。" "デフォルトは" (CODE1 ":newest") "。" EOL1 (STRONG "merged-pathname")
     " - パス名")
    (CHAPTER ("## 定義") 2 (STRONG "pathname") "の指定されていない要素について" "対応する"
     (STRONG "default-pathname") "と" (STRONG "default-version") "から"
     "情報を埋めることでパス名を生成します。" EOL2 "パス名の要素のデフォルトは、" "他のパス名から取得された要素を埋めることによって行われます。"
     "これは特に、入力ファイルと出力ファイルがある" "プログラムのような場合において便利です。" "出力パス名の指定されていない要素は入力パス名から指定されますが、"
     "例外としてタイプだけは入力パス名のタイプを" "デフォルトとして使用するのではなく、" "そのプログラムの出力にあったタイプをデフォルトとして使用するべきです。"
     "例えば、" (CODE1 "compile-file-pathname") "をご確認ください。" EOL2 "もしバージョンが指定されていない場合は、"
     (STRONG "default-version") "が使用されます。" "もし" (STRONG "default-version") "が"
     (CODE1 "nil") "のときは、" "そのバージョンの要素は変更されません。" EOL2 "もし" (STRONG "pathname")
     "が明にホストを指定しており、" "かつデバイスを指定していないとき、" "さらに" (STRONG "default-pathname") "のホストの要素が"
     (STRONG "pathname") "のホストの要素と一致しているときは、" (STRONG "default-pathname") "からデバイスを取得します。"
     "その他の場合は、デバイスはそのホストの" "デフォルトのファイルデバイスが使用されます。" "もし" (STRONG "pathname")
     "が、ホスト、デバイス、ディレクトリ、" "名前、タイプを指定しなかったとき、" "それぞれの要素は" (STRONG "default-pathname")
     "からコピーされます。" "もし" (STRONG "pathname") "が名前を指定せず、バージョンが指定されなかったとき、"
     "そのバージョンはちょうど他の要素と同じように、" (STRONG "default-pathname") "から指定されます。" "もし"
     (STRONG "pathname") "が名前を指定していたときは、" "バージョンは" (STRONG "default-pathname")
     "による影響はありません。" "もしこの処理でバージョンが欠落したときは、" (STRONG "default-version") "が使用されます。"
     "もしホストのファイル名の構文が、" "名前かタイプなしにバージョンの入力方法があったとき、" (STRONG "default-pathname")
     "に違ったバージョンが提供されたとしても" "ユーザーは名前とタイプをデフォルトのものに指定できます。" EOL2 "もし" (STRONG "pathname")
     "がストリームのとき、" (STRONG "pathname") "は効率よく" (CODE1 "(pathname pathname)") "の値が使用されます。"
     (CODE1 "merge-pathnames") "はストリームが" "開いているか閉じているかのどちらでも使用することができます。" EOL2 "もし"
     (STRONG "pathname") "が開いているファイルで使われている名前で表現されているとき、"
     "それはおそらく、しかし必須ではありませんが、実際のファイルの名前です。" EOL2 (STRONG "default-pathname") "が論理パス名のときか、"
     "あるいは名前文字列が定義された論理ホスト名と" "続けてコロンで始まっているとき、" (CODE1 "merge-pathnames")
     "は論理パス名の名前文字列として識別します。" "これらの二例のうち最初の方では、" "論理パス名の名前文字列のホストの位置と" "それに続くコロンはオプションです。"
     EOL2 "もし最初の引数が論理パス名であるか、" "最初の引数が明確にホストが指定された論理パス名の名前文字列であるか、"
     "あるいは最初の引数ではホストが指定されていないものの" (STRONG "default-pathname") "が論理パス名であるときのみ、"
     (CODE1 "merge-pathnames") "は論理パス名を返却します。" EOL2 (STRONG "pathname")
     "のマージは、相対ディレクトリを特別に扱います。" "もし" (CODE1 "(pathname-directory pathname)") "の返却が、"
     (CODE1 "car") "部" (CODE1 ":relative") "のリストであり、" "かつ"
     (CODE1 "(pathname-directory default-pathname)") "がリストであるときは、"
     "マージされたディレクトリは次の値で示されます。"
     (CODE3 "```lisp" "```" "(append (pathname-directory default-pathname)"
      "        (cdr  ;最初の要素から:relativeを取り除く" "          (pathname-directory pathname)))")
     EOL2 "ただし例外があり、" "もし結果のリストの中に対して、" "文字列か" (CODE1 ":wild") "のどちらかが存在している" "すぐあとに"
     (CODE1 ":back") "が続いているときは、" "その両方が削除されます。" (CODE1 ":back") "キーワードが複数あるときは、"
     "可能な限り何度でも繰り返して削除されます。" "もし" (CODE1 "(pathname-directory default-pathname)")
     "がリストではないか、" "あるいは" (CODE1 "(pathname-directory pathname)") "が" (CODE1 "car") "部"
     (CODE1 ":relative") "のリストではないときは、" "マージされたディレクトリは"
     (CODE1 "(or (pathname-directory pathname) (pathname-directory default-pathname))")
     "になります。" EOL2 (CODE1 "merge-pathnames") "は" (STRONG "pathname") "の慣習的な大文字小文字の表現を、"
     "出力するパス名の慣習的な大文字小文字の表現に対応させます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(merge-pathnames \"CMUC::FORMAT\""
      "                 \"CMUC::PS:<LISPIO>.FASL\")"
      "=>  #P\"CMUC::PS:<LISPIO>FORMAT.FASL.0\""))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "*default-pathname-defaults*") "," (CODE1 "pathname") ","
     (CODE1 "logical-pathname") "," "20.1. ファイルシステムの説明," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "この正味の効果は、" "もしちょうど名前だけが与えられたとき、" "ホスト、デバイス、ディレクトリ、そしてタイプは"
     (STRONG "default-pathname") "のものが使用されますが、" "バージョンは" (STRONG "default-version")
     "が使用されるというものです。" "もしそれが無く、ただディレクトリだけが与えられたとき、" "名前、タイプ、そしてバージョンは"
     (STRONG "default-pathname") "のものが一緒に使用されます。")))
(setf (gethash '("MERGE-PATHNAMES" . "FUNCTION") *table*) (gethash "MERGE-PATHNAMES" *table*))
(setf (gethash "METHOD" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "METHOD"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "method") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "メソッド" (CODE1 "method") "は、ジェネリック関数の振る舞いの"
     "基本的なモジュール単位を表すオブジェクトです。" EOL2 "メソッドは、" "メソッドのふるまいを実装したコード、"
     "そのメソッドが適用可能かどうかを指定する特定パラメーターの列、" "そしてメソッド間を区別するための" (CODE1 "method-combination")
     "の機能で使用される" "修飾子の列を含みます。" "各メソッドのそれぞれの要求パラメーターは、" "関連付けられた特定パラメーターを持っており、"
     "そのメソッドは引数が自身の特定パラメーターを" "満たすときのみ実行されます。" EOL2 (CODE1 "method-combination")
     "の機能は実行されたときに" "メソッドの選択を制御することができ、" "その返却値はジェネリック関数によって返却されます。" "オブジェクトシステムは標準の"
     (CODE1 "method-combination") "の型を提供しており、" "また" (CODE1 "method-combination")
     "の新しい型を定義する機能も提供しています。")
    (CHAPTER ("## 参考") 2 "7.6. ジェネリック関数とメソッド")))
(setf (gethash '("METHOD" . "SYSTEM-CLASS") *table*) (gethash "METHOD" *table*))
(setf (gethash "METHOD-COMBINATION" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "METHOD-COMBINATION"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "method-combination") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "全ての" (CODE1 "method-combination") "オブジェクトは、"
     (CODE1 "method-combination") "クラスの間接的なインスタンスです。" (CODE1 "method-combination")
     "オブジェクトは" "ジェネリック関数によって使用される" (CODE1 "method-combination") "についての情報を表現します。"
     (CODE1 "method-combination") "オブジェクトは、" (CODE1 "method-combination") "の型と、"
     "その型で使用できる引数の、" "両方についての情報を含みます。")))
(setf (gethash '("METHOD-COMBINATION" . "SYSTEM-CLASS") *table*) (gethash "METHOD-COMBINATION" *table*))
(setf (gethash "METHOD-COMBINATION-ERROR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "METHOD-COMBINATION-ERROR"))
    (CHAPTER ("## 構文") 2 (CODE1 "method-combination-error") " " (STRONG "format-control")
     " &rest " (STRONG "args") " => 実装依存")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "format-control") " - format-control" EOL1
     (STRONG "args") " - " (STRONG "format-control") "に対応する" (CODE1 "format") "の引数")
    (CHAPTER ("## 定義") 2 (CODE1 "method-combination-error") "関数は、"
     (CODE1 "method-combination") "内でエラーを通知する際に使われます。" EOL2 "エラーメッセージは、"
     (STRONG "format-control") "と" (STRONG "args") "を" (CODE1 "format") "に使って構築します。"
     "実装はエラーメッセージに追加で文脈的な情報を" "追加する必要があるかもしれないので、" (CODE1 "method-combination-error") "は"
     (CODE1 "method-combination") "関数の" "動的エクステント内でのみ呼び出すことができます。" EOL2
     (CODE1 "method-combination-error") "が呼び出し元へ戻るのか、" "あるいは" (CODE1 "throw")
     "を経由して退出するかどうかは、" "実装依存です。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "デバッガーに入るかもしれません。")
    (CHAPTER ("## 影響") 2 (CODE1 "*break-on-signals*")) (CHAPTER ("## 例外j") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "define-method-combination")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("METHOD-COMBINATION-ERROR" . "FUNCTION") *table*) (gethash "METHOD-COMBINATION-ERROR" *table*))
(setf (gethash "METHOD-QUALIFIERS" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "METHOD-QUALIFIERS"))
    (CHAPTER ("## 構文") 2 (CODE1 "method-qualifiers") " " (STRONG "method") " => "
     (STRONG "qualifiers"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "method-qualifiers") " (" (STRONG "method") " "
     (CODE1 "standard-method") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "method") " - メソッド" EOL1 (STRONG "qualifiers")
     " - 通常のリスト")
    (CHAPTER ("## 定義") 2 "メソッドの修飾子をリストで返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defmethod some-gf :before ((a integer)) a)"
      "=>  #<STANDARD-METHOD SOME-GF (:BEFORE) (INTEGER) 42736540>"
      "(method-qualifiers *) =>  (:BEFORE)"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "define-method-combination")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("METHOD-QUALIFIERS" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "METHOD-QUALIFIERS" *table*))
(setf (gethash "MISMATCH" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "MISMATCH"))
    (CHAPTER ("## 構文") 2 (CODE1 "mismatch") " " (STRONG "sequence-1") " "
     (STRONG "sequence-2") " &key " (STRONG "from-end") " " (STRONG "test") " "
     (STRONG "test-not") " " (STRONG "key") " " (STRONG "start1") " " (STRONG "start2")
     " " (STRONG "end1") " " (STRONG "end2") EOL1 "=> " (STRONG "position"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "sequence-1") " - 正常なシーケンス" EOL1
     (STRONG "sequence-2") " - 正常なシーケンス" EOL1 (STRONG "from-end")
     " - generalized-boolean、デフォルトは" (STRONG "false") EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "start1") ", " (STRONG "end1")
     " - " (STRONG "sequence-1") "の境界インデックス指定子。" "デフォルトは" (STRONG "start1") ", "
     (STRONG "end1") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "start2") ", "
     (STRONG "end2") " - " (STRONG "sequence-2") "の境界インデックス指定子。" "デフォルトは"
     (STRONG "start2") ", " (STRONG "end2") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1
     (STRONG "position") " - " (STRONG "sequence-2") "の境界インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "指定された" (STRONG "sequence-1") "と" (STRONG "sequence-2")
     "のサブシーケンスを" "要素ごとに比較します。" EOL2 (STRONG "key") "の引数は、" (STRONG "sequence-1") "と"
     (STRONG "sequence-2") "の両方が使われます。" EOL2 "もし" (STRONG "sequence-1") "と"
     (STRONG "sequence-2") "の長さが等しく、" "全ての要素も等しいときは、" (STRONG "false") "が返却されます。"
     "それ以外の場合は、返却値は非負の整数であり、" "2つのサブシーケンスがマッチしなかった、" "もっとも右側か左側（" (STRONG "from-end")
     "の値による）の、" (STRONG "sequence-1") "内でのインデックスを表します。" "どちらかのサブシーケンスが他方より短く、"
     "前の方で一致する部分がある場合、" "返却値は、最後にテストをした位置より先の、" (STRONG "sequence-1")
     "に対する相対的なインデックスになります。" EOL2 "もし" (STRONG "from-end") "が" (STRONG "true") "のときは、"
     "2つのシーケンスの異なった位置の右端のインデックスに" (CODE1 "1") "を加えた場所が返却されます。" "実際の比較は、サブシーケンスは右端で揃えられ、"
     "まず最後の要素が比較され、つぎに最後から2番目が比較され、" "それが繰り返されます。" "返却される値は、" (STRONG "sequence-1")
     "からの相対的なインデックスです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(mismatch \"abcd\" \"ABCDE\" :test #'char-equal) =>  4"
      "(mismatch '(3 2 1 1 2 3) '(1 2 3) :from-end t) =>  3"
      "(mismatch '(1 2 3) '(2 3 4) :test-not #'eq :key #'oddp) =>  NIL"
      "(mismatch '(1 2 3 4 5 6) '(3 4 5 6 7) :start1 2 :end2 4) =>  NIL "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。")))
(setf (gethash '("MISMATCH" . "FUNCTION") *table*) (gethash "MISMATCH" *table*))
(setf (gethash "MUFFLE-WARNING" *table*)
  '("MUFFLE-WARNING FUNCTION" EOL1 "MUFFLE-WARNING RESTART" EOL1))
(setf (gethash '("MUFFLE-WARNING" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ABORT") ", " (CODE1 "CONTINUE") ", "
     (CODE1 "MUFFLE-WARNING") ", " (CODE1 "STORE-VALUE") ", " (CODE1 "USE-VALUE"))
    (CHAPTER ("## 構文") 2 (CODE1 "abort") " " (CODE1 "&optional") " " (STRONG "condition")
     " => " (CODE1 "|") EOL1 (CODE1 "continue") " " (CODE1 "&optional") " "
     (STRONG "condition") " => " (CODE1 "nil") EOL1 (CODE1 "muffle-warning") " "
     (CODE1 "&optional") " " (STRONG "condition") " => " (CODE1 "|") EOL1
     (CODE1 "store-value") " " (STRONG "value") " " (CODE1 "&optional") " "
     (STRONG "condition") " => " (CODE1 "nil") EOL1 (CODE1 "use-value") " "
     (STRONG "value") " " (CODE1 "&optional") " " (STRONG "condition") " => "
     (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "value") " - オブジェクト" EOL1 (STRONG "condition")
     " - コンディションオブジェクトか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "もっとも最近確立された適用可能な" (CODE1 "restart") "のうち、"
     "関数と同じ名前を持つものへ制御が遷移されます。" "つまり、" (CODE1 "abort") "関数は" "適用可能な" (CODE1 "abort") " "
     (CODE1 "restart") "を探し、" (CODE1 "continue") "関数は" "適用可能な" (CODE1 "continue") " "
     (CODE1 "restart") "を探し、" "他も同様です。" EOL2 "もしそのような" (CODE1 "restart") "が存在しないときは、"
     (CODE1 "continue") ", " (CODE1 "store-value") "," (CODE1 "use-value") "は"
     (CODE1 "nil") "を返却し、" (CODE1 "abort") "と" (CODE1 "muffle-warning") "は" "型"
     (CODE1 "control-error") "のエラーを発生します。" EOL2 "もし" (STRONG "condition") "が"
     (CODE1 "nil") "ではないときは、" "それらの" (CODE1 "restart") "は、明に" (STRONG "condition")
     "と関連付けられているものか、" "あるいはどのコンディションにも関連付けられてないものかの" "どちらかのみが集められます。" "これは、排他された"
     (CODE1 "restart") "というのは、" "関連付けられたコンディションの集合が空ではなく、" "その要素に指定した"
     (STRONG "condition") "が含まれていないということです。" "もし" (STRONG "condition") "が" (CODE1 "nil")
     "のときは、" "全ての" (CODE1 "restart") "が集められます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";;; ABORT restartの例" NIL
      "(defmacro abort-on-error (&body forms)" "  `(handler-bind ((error #'abort))"
      "     ,@forms)) =>  ABORT-ON-ERROR" "(abort-on-error (+ 3 5)) =>  8"
      "(abort-on-error (error \"You lose.\"))" ">>  Returned to Lisp Top Level." NIL
      ";;; CONTINUE restartの例" NIL "(defun real-sqrt (n)" "  (when (minusp n)"
      "    (setq n (- n))"
      "    (cerror \"Return sqrt(~D) instead.\" \"Tried to take sqrt(-~D).\" n))"
      "  (sqrt n))" NIL "(real-sqrt 4) =>  2" "(real-sqrt -9)"
      ">>  Error: Tried to take sqrt(-9)."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Return sqrt(9) instead." ">>   2: Return to Lisp Toplevel."
      ">>  Debug> (continue)" ">>  Return sqrt(9) instead." "=>  3" " "
      " (handler-bind ((error #'(lambda (c) (continue))))" "   (real-sqrt -9)) =>  3" NIL
      ";;; MUFFLE-WARNING restartの例" NIL "(defun count-down (x)"
      "  (do ((counter x (1- counter)))" "      ((= counter 0) 'done)"
      "    (when (= counter 1)" "      (warn \"Almost done\"))"
      "    (format t \"~&~D~%\" counter)))" "=>  COUNT-DOWN" "(count-down 3)" ">>  3"
      ">>  2" ">>  Warning: Almost done" ">>  1" "=>  DONE"
      "(defun ignore-warnings-while-counting (x)"
      "  (handler-bind ((warning #'ignore-warning))" "    (count-down x)))"
      "=>  IGNORE-WARNINGS-WHILE-COUNTING" "(defun ignore-warning (condition)"
      "  (declare (ignore condition))" "  (muffle-warning))" "=>  IGNORE-WARNING"
      " (ignore-warnings-while-counting 3)" ">>  3" ">>  2" ">>  1" "=>  DONE" NIL
      ";;; STORE-VALUE restartとUSE-VALUE restartの例" NIL
      "(defun careful-symbol-value (symbol)" "  (check-type symbol symbol)"
      "  (restart-case (if (boundp symbol)"
      "                    (return-from careful-symbol-value "
      "                                 (symbol-value symbol))"
      "                    (error 'unbound-variable"
      "                           :name symbol))" "    (use-value (value)"
      "      :report \"Specify a value to use this time.\"" "      value)"
      "    (store-value (value)"
      "      :report \"Specify a value to store and use in the future.\""
      "      (setf (symbol-value symbol) value))))" "(setq a 1234) =>  1234"
      "(careful-symbol-value 'a) =>  1234" "(makunbound 'a) =>  A"
      "(careful-symbol-value 'a)" ">>  Error: A is not bound."
      ">>  To continue, type :CONTINUE followed by an option number."
      ">>   1: Specify a value to use this time."
      ">>   2: Specify a value to store and use in the future."
      ">>   3: Return to Lisp Toplevel." ">>  Debug> (use-value 12)" "=>  12"
      "(careful-symbol-value 'a)" ">>  Error: A is not bound."
      ">>  To continue, type :CONTINUE followed by an option number."
      ">>    1: Specify a value to use this time."
      ">>    2: Specify a value to store and use in the future."
      ">>    3: Return to Lisp Toplevel." ">>  Debug> (store-value 24)" "=>  24"
      " (careful-symbol-value 'a)" "=>  24" NIL ";;; USE-VALUE restartの例" NIL
      "(defun add-symbols-with-default (default &rest symbols)"
      "  (handler-bind ((sys:unbound-symbol" "                   #'(lambda (c)"
      "                       (declare (ignore c)) "
      "                       (use-value default))))"
      "    (apply #'+ (mapcar #'careful-symbol-value symbols))))"
      "=>  ADD-SYMBOLS-WITH-DEFAULT" "(setq x 1 y 2) =>  2"
      "(add-symbols-with-default 3 'x 'y 'z) =>  6"))
    (CHAPTER ("## 副作用") 2 "適用可能な" (CODE1 "restart") "が使用可能なときに" "制御の遷移が起こるかもしれませんし、"
     "あるいは（" (CODE1 "abort") "関数か" (CODE1 "muffle-warning") "関数の場合は）" "実行が停止するかもしれません。")
    (CHAPTER ("## 影響") 2 "もし適用可能な" (CODE1 "abort") " " (CODE1 "restart") "が" "利用不可の状態で"
     (CODE1 "abort") "関数が実行されれたときか、" "適用可能な" (CODE1 "muffle-warning") " "
     (CODE1 "restart") "が" "利用不可の状態で" (CODE1 "muffle-warning") "関数が実行されれたときは、" "型"
     (CODE1 "control-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "invoke-restart") "," "9.1.4.2. " (CODE1 "restart") ","
     "9.1.4.2.2. " (CODE1 "restart") "のインターフェイス," (CODE1 "assert") "," (CODE1 "ccase")
     "," (CODE1 "cerror") "," (CODE1 "check-type") "," (CODE1 "ctypecase") ","
     (CODE1 "use-value") "," (CODE1 "warn"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(abort condition) ==  (invoke-restart 'abort)"
      "(muffle-warning)  ==  (invoke-restart 'muffle-warning)"
      "(continue)        ==  (let ((r (find-restart 'continue))) (if r (invoke-restart r)))"
      "(use-value x) ==  (let ((r (find-restart 'use-value))) (if r (invoke-restart r x)))"
      "(store-value x) ==  (let ((r (find-restart 'store-value))) (if r (invoke-restart r x)))")
     EOL2 "この仕様書で" (CODE1 "use-value") " " (CODE1 "restart") "の提供に" "要求される関数定義はありません。")))
(setf (gethash '("MUFFLE-WARNING" . "RESTART") *table*)
  '((CHAPTER NIL 0 "Restart " (CODE1 "MUFFLE-WARNING"))
    (CHAPTER ("## 要求される引数のデータ") 2 "なし。")
    (CHAPTER ("## 定義") 2 "この" (CODE1 "restart") "は" (CODE1 "warn") "によって確立され、"
     (CODE1 "warning") "コンディションのハンドラーは" (CODE1 "warn") "に対して警告はすでに実行されており"
     "それ以上のアクションが必要ないということを伝える方法を持っています。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defvar *all-quiet* nil) =>  *ALL-QUIET*"
      "(defvar *saved-warnings* '()) =>  *SAVED-WARNINGS*"
      "(defun quiet-warning-handler (c)" "  (when *all-quiet*"
      "    (let ((r (find-restart 'muffle-warning c)))" "      (when r "
      "        (push c *saved-warnings*)" "        (invoke-restart r)))))"
      "=>  CUSTOM-WARNING-HANDLER" "(defmacro with-quiet-warnings (&body forms)"
      "  `(let ((*all-quiet* t)" "         (*saved-warnings* '()))"
      "     (handler-bind ((warning #'quiet-warning-handler))" "       ,@forms"
      "       *saved-warnings*)))" "=>  WITH-QUIET-WARNINGS" "(setq saved"
      "  (with-quiet-warnings" "    (warn \"Situation #1.\")"
      "    (let ((*all-quiet* nil))" "      (warn \"Situation #2.\"))"
      "    (warn \"Situation #3.\")))" ">>  Warning: Situation #2."
      "=>  (#<SIMPLE-WARNING 42744421> #<SIMPLE-WARNING 42744365>)"
      "(dolist (s saved) (format t \"~&~A~%\" s))" ">>  Situation #3."
      ">>  Situation #1." "=>  NIL"))
    (CHAPTER ("## 参考") 2 "9.1.4.2. " (CODE1 "restart") "," "9.1.4.2.2. "
     (CODE1 "restart") "のインターフェイス," (CODE1 "invoke-restart") "," (CODE1 "muffle-warning")
     "（関数）," (CODE1 "warn") ",")))
(setf (gethash "MULTIPLE-VALUE-BIND" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "MULTIPLE-VALUE-BIND"))
    (CHAPTER ("## 構文") 2 (CODE1 "multiple-value-bind") " (" (STRONG "var\\*") ") "
     (STRONG "values-form") " " (STRONG "declaration\\*") " " (STRONG "form\\*") EOL1
     "=> " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - 変数名のシンボル。評価されません。" EOL1
     (STRONG "values-form") " - フォーム。評価されます。" EOL1 (STRONG "declaration")
     " - 宣言式。評価されません。" EOL1 (STRONG "form") " - 暗黙のprogn" EOL1 (STRONG "result") " - "
     (STRONG "form") "から返却される多値")
    (CHAPTER ("## 定義") 2 (STRONG "var") "への新しい変数束縛を作成し、" "それらの束縛を使った一連の" (STRONG "form")
     "を実行します。" EOL2 "変数の束縛は、" (CODE1 "special") "宣言がされていないのであれば、" "レキシカルに行われます。" EOL2
     (STRONG "values-form") "は評価され、" "フォームによって返却されたそれぞれの値を各" (STRONG "var") "に束縛します。"
     "もし" (STRONG "var") "の方が多値より多い場合は、" "残りの" (STRONG "var") "には追加で" (CODE1 "nil")
     "が与えられます。" "もし多値の方が" (STRONG "var") "より多い場合は、" "超過した多値は切り捨てられます。" (STRONG "var")
     "は多値は、暗黙のprognとして" (STRONG "form") "が実行されているときに束縛されます。" "もし" (STRONG "var")
     "の型宣言が指定されていたものの、" "値が" (STRONG "var") "の型宣言に合った束縛ではなかった場合の結果は未定義です。" EOL2
     "名前の束縛と宣言のスコープは、" (STRONG "values-form") "は含まれていません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(multiple-value-bind (f r)" "    (floor 130 11)"
      "  (list f r)) =>  (11 9)"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "let") "," (CODE1 "multiple-value-call"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(multiple-value-bind (var*) values-form form*)"
      "==  (multiple-value-call #'(lambda (&optional var* &rest #1=#:ignore)"
      "                            (declare (ignore #1#))"
      "                            form*)" "                        values-form)"))))
(setf (gethash '("MULTIPLE-VALUE-BIND" . "MACRO") *table*) (gethash "MULTIPLE-VALUE-BIND" *table*))
(setf (gethash "MULTIPLE-VALUE-CALL" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "MULTIPLE-VALUE-CALL"))
    (CHAPTER ("## 構文") 2 (CODE1 "multiple-value-call") " " (STRONG "function-form") " "
     (STRONG "form\\*") " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function-form") " - フォーム。評価され" (STRONG "function")
     "が得られます。" EOL1 (STRONG "function") " - 関数指定子。" (STRONG "function-form")
     "の評価によって得られます。" EOL1 (STRONG "form") " - フォーム" EOL1 (STRONG "result") " - "
     (STRONG "function") "の返却値")
    (CHAPTER ("## 定義") 2 (STRONG "function") "を、多値のグループを収集したオブジェクトをまとめた" "リストと共に実行します。"
     EOL2 (CODE1 "multiple-value-call") "は最初に" (STRONG "function-form") "を評価して"
     (STRONG "function") "を取得し、そのあと各" (STRONG "form") "を実行します。" "各" (STRONG "form")
     "の全ての多値を一緒にまとめて（それぞれちょうどひとつずつではなく）、" (STRONG "function") "の引数として与えます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(multiple-value-call #'list 1 '/ (values 2 3) '/ (values) '/ (floor 2.5))"
      "=>  (1 / 2 3 / / 2 0.5)" "(+ (floor 5 3) (floor 19 4)) ==  (+ 1 4)" "=>  5"
      "(multiple-value-call #'+ (floor 5 3) (floor 19 4)) ==  (+ 1 2 4 3)" "=>  10"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "multiple-value-list") "," (CODE1 "multiple-value-bind"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MULTIPLE-VALUE-CALL" . "SPECIAL-OPERATOR") *table*) (gethash "MULTIPLE-VALUE-CALL" *table*))
(setf (gethash "MULTIPLE-VALUE-LIST" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "MULTIPLE-VALUE-LIST"))
    (CHAPTER ("## 構文") 2 (CODE1 "multiple-value-list") " " (STRONG "form") " => "
     (STRONG "list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "form") " - フォーム。下記に示す通り評価されます。" EOL1
     (STRONG "list") " - " (STRONG "form") "の返却値のリスト")
    (CHAPTER ("## 定義") 2 (CODE1 "multiple-value-list") "は" (STRONG "form") "を評価し、"
     "その返却値の多値のリストを作成します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(multiple-value-list (floor -3 4)) =>  (-1 1)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "values-list") "," (CODE1 "multiple-value-call"))
    (CHAPTER ("## 備考") 2 (CODE1 "multiple-value-list") "と" (CODE1 "values-list") "は、"
     "お互いに逆の関係にあります。"
     (CODE3 "```lisp" "```"
      "(multiple-value-list form) == (multiple-value-call #'list form)"))))
(setf (gethash '("MULTIPLE-VALUE-LIST" . "MACRO") *table*) (gethash "MULTIPLE-VALUE-LIST" *table*))
(setf (gethash "MULTIPLE-VALUE-PROG1" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "MULTIPLE-VALUE-PROG1"))
    (CHAPTER ("## 構文") 2 (CODE1 "multiple-value-prog1") " " (STRONG "first-form") " "
     (STRONG "form\\*") " => " (STRONG "first-form-results"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "first-form") " - フォーム。下記に示す通り評価されます。" EOL1
     (STRONG "form") " - フォーム。下記に示す通り評価されます。" EOL1 (STRONG "first-form-results") " - "
     (STRONG "first-form") "の評価の返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "multiple-value-prog1") "は" (STRONG "first-form") "を評価し、"
     "そのフォームによって生成された全ての多値を保存します。" "そのあと各" (STRONG "form") "を左から右へ評価し、それらの返却値を廃棄します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq temp '(1 2 3)) =>  (1 2 3)" "(multiple-value-prog1"
      "   (values-list temp)" "   (setq temp nil)" "   (values-list temp)) =>  1, 2, 3"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "prog1")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MULTIPLE-VALUE-PROG1" . "SPECIAL-OPERATOR") *table*) (gethash "MULTIPLE-VALUE-PROG1" *table*))
(setf (gethash "MULTIPLE-VALUE-SETQ" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "MULTIPLE-VALUE-SETQ"))
    (CHAPTER ("## 構文") 2 (CODE1 "multiple-value-setq") " " (STRONG "vars") " "
     (STRONG "form") " => " (STRONG "result"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "vars") " - 変数名かシンボルマクロ名どちらかのシンボルのリスト" EOL1
     (STRONG "form") " - フォーム" EOL1 (STRONG "result") " - " (STRONG "form") "の第一返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "multiple-value-setq") "は、" (STRONG "vars") "に値を代入します。"
     EOL2 (STRONG "form") "は評価され、" "フォームによって返却されたそれぞれの値を各" (STRONG "var") "に代入します。" "もし"
     (STRONG "var") "の方が多値より多い場合は、" "残りの" (STRONG "var") "には" (CODE1 "nil") "が代入されます。"
     "もし多値の方が" (STRONG "var") "より多い場合は、" "超過した多値は切り捨てられます。" EOL2 "もし" (STRONG "var")
     "がシンボルマクロの名前であったときは、" (CODE1 "setf") "として代入されます。" "とくに下記のような場合、"
     (CODE3 "```lisp" "```"
      "(multiple-value-setq (symbol1 ... symboln) value-producing-form)")
     EOL2 "常に下記のような動作と同じであると定義されます。"
     (CODE3 "```lisp" "```"
      "(values (setf (values symbol1 ... symboln) value-producing-form))")
     EOL2 "これらの評価と副作用の順序の規則は" (CODE1 "setf") "を使用したものと同じです。" "5.1.2.3. " (CODE1 "place")
     "としてのVALUESフォームをご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(multiple-value-setq (quotient remainder) (truncate 3.2 2)) =>  1"
      "quotient =>  1" "remainder =>  1.2"
      "(multiple-value-setq (a b c) (values 1 2)) =>  1" "a =>  1" "b =>  2" "c =>  NIL"
      "(multiple-value-setq (a b) (values 4 5 6)) =>  4" "a =>  4" "b =>  5"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "setq") "," (CODE1 "symbol-macrolet"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("MULTIPLE-VALUE-SETQ" . "MACRO") *table*) (gethash "MULTIPLE-VALUE-SETQ" *table*))
(setf (gethash "MULTIPLE-VALUES-LIMIT" *table*)
  '((CHAPTER NIL 0 "Constant Variable " (CODE1 "MULTIPLE-VALUES-LIMIT"))
    (CHAPTER ("## 定数値") 2 "20より小さくはない整数であり、" "正確な値は実装依存です。")
    (CHAPTER ("## 定義") 2 "の排他的上限値であり、" EOL2 "関数が返却できる多値の数、" "また"
     (CODE1 "multiple-value-bind") "か" (CODE1 "multiple-value-setq") "によって" "束縛か代入ができる数、"
     (CODE1 "nth-value") "の最初の引数として受け取れる数の、" "排他的上限値です。"
     "それぞれの個別の制限値が違っている場合は 最小の値が使われます。")
    (CHAPTER ("## 例文") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "lambda-parameters-limit") ","
     (CODE1 "call-arguments-limit"))
    (CHAPTER ("## 備考") 2 "実装者にはこれらの制限値を可能な限り大きくすることを勧めます。")))
(setf (gethash '("MULTIPLE-VALUES-LIMIT" . "CONSTANT-VARIABLE") *table*) (gethash "MULTIPLE-VALUES-LIMIT" *table*))
(setf (gethash "NAME-CHAR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "NAME-CHAR"))
    (CHAPTER ("## 構文") 2 (CODE1 "name-char") " " (STRONG "name") " => "
     (STRONG "char-p"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - string-designator" EOL1 (STRONG "name")
     " - 文字か" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "名前が" (STRONG "name") "である文字オブジェクトを返却します。" "名前の検索には"
     (CODE1 "string-equal") "が使われるので、" "大文字小文字の区別はありません。" "もしそのような文字が存在しない場合は"
     (CODE1 "nil") "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(name-char 'space) =>  #\\Space"
      "(name-char \"space\") =>  #\\Space" "(name-char \"Space\") =>  #\\Space"
      "(let ((x (char-name #\\a)))" "  (or (not x) (eql (name-char x) #\\a))) =>  true"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "character") "が文字ではなかったら、型" (CODE1 "type-error")
     "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 (CODE1 "char-name")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("NAME-CHAR" . "FUNCTION") *table*) (gethash "NAME-CHAR" *table*))
(setf (gethash "NAMESTRING" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "NAMESTRING") ", " (CODE1 "FILE-NAMESTRING") ", "
     (CODE1 "DIRECTORY-NAMESTRING") "," (CODE1 "HOST-NAMESTRING") ", "
     (CODE1 "ENOUGH-NAMESTRING"))
    (CHAPTER ("## 構文") 2 (CODE1 "namestring") " " (STRONG "pathname") " => "
     (STRONG "namestring") EOL1 (CODE1 "file-namestring") " " (STRONG "pathname") " => "
     (STRONG "namestring") EOL1 (CODE1 "directory-namestring") " " (STRONG "pathname")
     " => " (STRONG "namestring") EOL1 (CODE1 "host-namestring") " " (STRONG "pathname")
     " => " (STRONG "namestring") EOL1 (CODE1 "enough-namestring") " "
     (STRONG "pathname") " " (CODE1 "&optional") " " (STRONG "defaults") " => "
     (STRONG "namestring"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathname") " - パス名指定子" EOL1 (STRONG "defaults")
     " - パス名指定子。" "デフォルトは" (CODE1 "*default-pathname-defaults*") "の値です。" EOL1
     (STRONG "namestring") " - 文字列か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "pathname") "を名前文字列に変換します。"
     (STRONG "pathname") "によって表現される名前は、" "実装依存の基準のフォームに従った" "名前文字列として返却されます。" EOL2
     (CODE1 "namestring") "は、" (STRONG "pathname") "の完全なフォームを返却します。" EOL2
     (CODE1 "file-namestring") "は、" (STRONG "pathname") "の名前とタイプとバージョンの要素だけを返却します。" EOL2
     (CODE1 "directory-namestring") "は、" (STRONG "pathname") "のディレクトリの名前の部分を返却します。" EOL2
     (CODE1 "host-namestring") "は、ホスト名を返却します。" EOL2 (CODE1 "enough-namestring") "は、"
     (STRONG "pathname") "が" (STRONG "defaults") "から相対的に考慮されたものによって、"
     "同一と見なせるのに十分なファイル名である" "省略された名前文字列を返却します。" "これは、全ての場合において次のような関係を要求します。"
     (CODE3 "```lisp" "```"
      "(merge-pathnames (enough-namestring pathname defaults) defaults)"
      "==  (merge-pathnames (parse-namestring pathname nil defaults) defaults)")
     EOL2 (CODE1 "enough-namestring") "の結果は、" "このような基準を満たした最も短い適切な文字列です。" EOL2
     "この3つの短い名前文字列をある順にて結合することによって" "有効な名前文字列を生成することは必ずしも可能ではありません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(namestring \"getty\")            " "=>  \"getty\""
      "(setq q (make-pathname :host \"kathy\" " "                        :directory "
      "                          (pathname-directory *default-pathname-defaults*)"
      "                        :name \"getty\")) "
      "=>  #S(PATHNAME :HOST \"kathy\" :DEVICE NIL :DIRECTORY directory-name "
      "      :NAME \"getty\" :TYPE NIL :VERSION NIL)" "(file-namestring q) =>  \"getty\""
      "(directory-namestring q) =>  directory-name" "(host-namestring q) =>  \"kathy\" "
      ";;; Unix構文の使用とこの例での特定のUnixバージョンによる" ";;; ワイルドカード表記の使用によって作成されたもの" "(namestring"
      "  (translate-pathname \"/usr/dmr/hacks/frob.l\""
      "                      \"/usr/d*/hacks/*.l\""
      "                      \"/usr/d*/backup/hacks/backup-*.*\"))"
      ">  \"/usr/dmr/backup/hacks/backup-frob.l\"" "(namestring"
      "  (translate-pathname \"/usr/dmr/hacks/frob.l\""
      "                      \"/usr/d*/hacks/fr*.l\""
      "                      \"/usr/d*/backup/hacks/backup-*.*\"))"
      "=>  \"/usr/dmr/backup/hacks/backup-ob.l\"" NIL
      ";;; これは上記の例に似ていますが2つの違ったホストを使用しています。" ";;; UがUnixであり、VがVMSです。ファイルタイプの変換と"
      ";;; アルファベットの大文字小文字の表記に注意してください。" "(namestring"
      "  (translate-pathname \"U:/usr/dmr/hacks/frob.l\""
      "                      \"U:/usr/d*/hacks/*.l\""
      "                      \"V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*\"))"
      "=>  \"V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-FROB.LSP\"" "(namestring"
      "  (translate-pathname \"U:/usr/dmr/hacks/frob.l\""
      "                      \"U:/usr/d*/hacks/fr*.l\""
      "                      \"V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*\"))"
      "=>  \"V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-OB.LSP\""))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "truename") "," (CODE1 "merge-pathnames") ","
     (CODE1 "pathname") "," (CODE1 "logical-pathname") "," "20.1. ファイルシステムの説明,"
     "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("NAMESTRING" . "FUNCTION") *table*) (gethash "NAMESTRING" *table*))
(setf (gethash "NBUTLAST" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "BUTLAST") ", " (CODE1 "NBUTLAST"))
    (CHAPTER ("## 構文") 2 (CODE1 "butlast") " " (STRONG "list") " &optional " (STRONG "n")
     " => " (STRONG "result-list") EOL1 (CODE1 "nbutlast") " " (STRONG "list")
     " &optional " (STRONG "n") " => " (STRONG "result-list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト。ドットリストは受け付けますが、循環リストは受け付けません。" EOL1
     (STRONG "n") " - 非負の整数" EOL1 (STRONG "result-list") " - リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "butlast") "は、最後の" (STRONG "n") "個のコンスを無視した"
     (STRONG "list") "のコピーを返却します。" (STRONG "n") "が省略されたときの値は" (CODE1 "1") "です。" "もし"
     (STRONG "list") "内に" (STRONG "n") "個もコンスがなかったときは、" (CODE1 "nil") "が返却され、"
     (CODE1 "nbutlast") "のときは" (STRONG "list") "は修正されません。" EOL2 (CODE1 "nbutlast") "は、"
     (CODE1 "butlast") "と似てますが、" (CODE1 "nbutlast") "は" (STRONG "list") "を修正するかもしれません。"
     "それは、" (STRONG "list") "の終わりから" (STRONG "n") "+1個のコンスの" (CODE1 "cdr") "を"
     (CODE1 "nil") "に修正します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst '(1 2 3 4 5 6 7 8 9)) =>  (1 2 3 4 5 6 7 8 9)"
      "(butlast lst) =>  (1 2 3 4 5 6 7 8)" "(butlast lst 5) =>  (1 2 3 4)"
      "(butlast lst (+ 5 5)) =>  NIL" "lst =>  (1 2 3 4 5 6 7 8 9)"
      "(nbutlast lst 3) =>  (1 2 3 4 5 6)" "lst =>  (1 2 3 4 5 6)"
      "(nbutlast lst 99) =>  NIL" "lst =>  (1 2 3 4 5 6)"
      "(butlast '(a b c d)) =>  (A B C)" "(butlast '((a b) (c d))) =>  ((A B))"
      "(butlast '(a)) =>  NIL" "(butlast nil) =>  NIL"
      "(setq foo (list 'a 'b 'c 'd)) =>  (A B C D)" "(nbutlast foo) =>  (A B C)"
      "foo =>  (A B C)" "(nbutlast (list 'a)) =>  NIL" "(nbutlast '()) =>  NIL"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list") "が通常のリストではないか、" "ドットリストではないとき、" "型"
     (CODE1 "type-error") "のエラーが生じます。" (STRONG "n") "が非負の整数ではないとき、" "型"
     (CODE1 "type-error") "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(butlast list n) == (ldiff list (last list n))"))))
(setf (gethash '("NBUTLAST" . "FUNCTION") *table*) (gethash "NBUTLAST" *table*))
(setf (gethash "NCONC" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "NCONC"))
    (CHAPTER ("## 構文") 2 (CODE1 "nconc") " &rest " (STRONG "lists") " => "
     (STRONG "concatenated-list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "lists") " - 最後以外はリストでなければなりません"
     "（ドットリストは許容されますが、循環リストは許容されません）。" "最後の" (STRONG "list") "はどんなオブジェクトでも可能です。" EOL1
     (STRONG "concatenated-list") " - リスト")
    (CHAPTER ("## 定義") 2 (STRONG "lists") "を連結したリストを返却します。" "もし" (STRONG "lists")
     "がないときは、" (CODE1 "(nconc)") "は" (CODE1 "nil") "を返却します。" (CODE1 "nconc")
     "は下記のような再帰的関係を用いて定義されます。"
     (CODE3 "```lisp" "```" "(nconc) =>  ()" "(nconc nil . lists) ==  (nconc . lists)"
      "(nconc list) =>  list"
      "(nconc list-1 list-2) ==  (progn (rplacd (last list-1) list-2) list-1)"
      "(nconc list-1 list-2 . lists) ==  (nconc (nconc list-1 list-2) . lists)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(nconc) =>  NIL" "(setq x '(a b c)) =>  (A B C)"
      "(setq y '(d e f)) =>  (D E F)" "(nconc x y) =>  (A B C D E F)"
      "x =>  (A B C D E F)")
     EOL2 "この例では、" (STRONG "x") "の最後のコンスが" (CODE1 "rplacd") "により値" (STRONG "y")
     "に変更されたので、" "最終的な" (STRONG "x") "の値が変更されています。" "もし" (CODE1 "(nconc x y)")
     "が再び評価されると、" "循環リストが生成されるので、" "それは" (CODE1 "(A B C D E F D E F D E F ...)")
     "のように印字され、" "永遠に繰り返されます。" "もし" (CODE1 "*print-circle*") "を" (CODE1 "nil")
     "以外の値にすることで、" (CODE1 "(A B C . #1=(D E F . #1#))") "と印刷されるでしょう。"
     (CODE3 "```lisp" "```" "(setq foo (list 'a 'b 'c 'd 'e)"
      "      bar (list 'f 'g 'h 'i 'j)" "      baz (list 'k 'l 'm)) =>  (K L M)"
      "(setq foo (nconc foo bar baz)) =>  (A B C D E F G H I J K L M)"
      "foo =>  (A B C D E F G H I J K L M)" "bar =>  (F G H I J K L M)" "baz =>  (K L M)"
      NIL "(setq foo (list 'a 'b 'c 'd 'e)" "      bar (list 'f 'g 'h 'i 'j)"
      "      baz (list 'k 'l 'm)) =>  (K L M)"
      "(setq foo (nconc nil foo bar nil baz)) =>  (A B C D E F G H I J K L M) "
      "foo =>  (A B C D E F G H I J K L M)" "bar =>  (F G H I J K L M)"
      "baz =>  (K L M)"))
    (CHAPTER ("## 副作用") 2 (STRONG "list") "はコピーされずに修正されます。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "append") "," (CODE1 "concatenate"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("NCONC" . "FUNCTION") *table*) (gethash "NCONC" *table*))
(setf (gethash "NEXT-METHOD-P" *table*)
  '((CHAPTER NIL 0 "Local Function " (CODE1 "NEXT-METHOD-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "next-method-p") " " (CODE1 "<no arguments>") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "ローカルに定義された関数" (CODE1 "next-method-p") "は、" "メソッド定義フォームで定義された"
     "ボディフォーム内（ただしラムダリストは除く）で、" "次のメソッドがあるかどうかを判断するために使用することができます。" EOL2 "関数"
     (CODE1 "next-method-p") "は、" "レキシカルスコープと不定範囲を持っています。" EOL2 "グローバル環境下で、"
     (CODE1 "next-method-p") "が" (CODE1 "fbound") "かどうかは実装依存です。" "しかし、再定義と"
     (CODE1 "next-method-p") "のシャドウについての制限は、" (CODE1 "COMMON-LISP") "パッケージにある、"
     "グローバル環境下において" (CODE1 "fbound") "であるシンボルと同じです。" (CODE1 "next-method-p")
     "をメソッド定義フォームの外で" "使おうとしたときの結果は未定義です。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "call-next-method") "," (CODE1 "defmethod") ","
     (CODE1 "call-method"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("NEXT-METHOD-P" . "LOCAL-FUNCTION") *table*) (gethash "NEXT-METHOD-P" *table*))
(setf (gethash "NIL" *table*)
  '("NIL CONSTANT-VARIABLE" EOL1 "NIL TYPE" EOL1))
(setf (gethash '("NIL" . "CONSTANT-VARIABLE") *table*)
  '((CHAPTER NIL 0 "Constant Variable " (CODE1 "NIL"))
    (CHAPTER ("## 定数値") 2 (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "nil") "は、ブール値（そしてgeneralized-boolean）の" (STRONG "false")
     "と" "空のリストの両方を表しています。")
    (CHAPTER ("## 例文") 2 (CODE3 "```lisp" "```" "nil =>  NIL "))
    (CHAPTER ("## 参考") 2 (CODE1 "t")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("NIL" . "TYPE") *table*)
  '((CHAPTER NIL 0 "Type " (CODE1 "NIL")) (CHAPTER ("## スーパータイプ") 2 "全ての型。")
    (CHAPTER ("## 定義") 2 "型" (CODE1 "nil") "は何のオブジェクトも含まず、空の型とも呼ばれます。" "型" (CODE1 "nil")
     "は全ての型のサブタイプです。" "型" (CODE1 "nil") "のオブジェクトはありません。")
    (CHAPTER ("## 備考") 2 "オブジェクト" (CODE1 "nil") "を含む型は" "型" (CODE1 "null") "ですが、" "型"
     (CODE1 "nil") "には含まれません。")))
(setf (gethash "NINTERSECTION" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "INTERSECTION") ", " (CODE1 "NINTERSECTION"))
    (CHAPTER ("## 構文") 2 (CODE1 "intersection") " " (STRONG "list-1") " "
     (STRONG "list-2") " &key " (STRONG "key") " " (STRONG "test") " "
     (STRONG "test-not") " => " (STRONG "result-list") EOL1 (CODE1 "nintersection") " "
     (STRONG "list-1") " " (STRONG "list-2") " &key " (STRONG "key") " " (STRONG "test")
     " " (STRONG "test-not") " => " (STRONG "result-list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list-1") " - 通常のリスト" EOL1 (STRONG "list-2")
     " - 通常のリスト" EOL1 (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test-not") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "result-list") " - リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "intersection") "と" (CODE1 "nintersection") "は、"
     (STRONG "list-1") "と" (STRONG "list-2") "の両方に含まれるすべての要素を含むリストを返却します。" EOL2
     (CODE1 "nintersection") "は、" (CODE1 "intersection") "の破壊的バージョンです。" "それは同じ操作を行いますが、"
     (STRONG "list-1") "はそのセルを使って結果を構築するときに、" "破壊するかもしれません。" (STRONG "list-2")
     "は破壊されません。" EOL2 (CODE1 "intersection") "の操作は、次のように定義されます。" (STRONG "list-1")
     "のひとつの要素と、" (STRONG "list-2") "のひとつの要素からなる、" "全ての順序付けされたペアに対して、" (CODE1 ":test") "か"
     (CODE1 ":test-not") "を使ってテストが満たされるかどうかを決定します。" (CODE1 ":test") "か"
     (CODE1 ":test-not") "の関数の最初の要素は" (STRONG "list-1") "の要素であり、" "二番目の引数は"
     (STRONG "list-2") "の要素です。" "もし" (CODE1 ":test") "と" (CODE1 ":test-not")
     "が指定されなかったときは、" (CODE1 "eql") "を使用します。" "もし同じ関数呼び出し内において、" (CODE1 ":test") "と"
     (CODE1 ":test-not") "の両方が指定された場合はエラーです。" EOL2 "もし" (CODE1 ":key") "に" (CODE1 "nil")
     "ではない値で与えられたときは、" "リストの要素をテストする部分を引き出すときに使われます。" (CODE1 ":key") "関数の引数は、"
     (STRONG "list-1") "か" (STRONG "list-2") "の要素であり、" (CODE1 ":key")
     "関数は通常与えられた要素の部分を返却します。" "もし" (CODE1 ":key") "が与えられないか、あるいは" (CODE1 "nil")
     "が指定されたとき、" (STRONG "list-1") "と" (STRONG "list-2") "の要素が使われます。" EOL2
     "テストが満たされたすべてのペアは、" "そのペアの2つの要素のうち正確にひとつが結果に格納されます。" "どちらかのリストのある要素と、"
     "他方のリストとのテストが満たされなかったときは、" "その要素は結果のリストに現れません。" "もしリストのいずれかに重複する要素がある場合、"
     "結果には重複が生じるかもしれません。" EOL2 "どんな方法で引数の順番を変えたとしても、" "結果の要素の順番に反映できる保証はありません。"
     "結果のリストは、適切であれば、" (STRONG "list-1") "か" (STRONG "list-2") "のどちらかとセルを共有するか、" "あるいは"
     (CODE1 "eq") "になる可能性があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq list1 (list 1 1 2 3 4 a b c \"A\" \"B\" \"C\" \"d\")"
      "      list2 (list 1 4 5 b c d \"a\" \"B\" \"c\" \"D\")) "
      " =>  (1 4 5 B C D \"a\" \"B\" \"c\" \"D\")"
      "(intersection list1 list2) =>  (C B 4 1 1)"
      "(intersection list1 list2 :test 'equal) =>  (\"B\" C B 4 1 1)"
      "(intersection list1 list2 :test #'equalp) =>  (\"d\" \"C\" \"B\" \"A\" C B 4 1 1) "
      "(nintersection list1 list2) =>  (1 1 4 B C)"
      "list1 =>  implementation-dependent ;e.g.,  (1 1 4 B C)"
      "list2 =>  implementation-dependent ;e.g.,  (1 4 5 B C D \"a\" \"B\" \"c\" \"D\")"
      "(setq list1 (copy-list '((1 . 2) (2 . 3) (3 . 4) (4 . 5))))"
      "=>  ((1 . 2) (2 . 3) (3 . 4) (4 . 5)) "
      "(setq list2 (copy-list '((1 . 3) (2 . 4) (3 . 6) (4 . 8))))"
      "=>  ((1 . 3) (2 . 4) (3 . 6) (4 . 8)) "
      "(nintersection list1 list2 :key #'cdr) =>  ((2 . 3) (3 . 4)) "
      "list1 =>  implementation-dependent ;e.g.,  ((1 . 2) (2 . 3) (3 . 4)) "
      "list2 =>  implementation-dependent ;e.g.,  ((1 . 3) (2 . 4) (3 . 6) (4 . 8)) "))
    (CHAPTER ("## 副作用") 2 (CODE1 "nintersection") "は" (STRONG "list-1") "を変更できますが、"
     (STRONG "list-2") "はそうではありません。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list-1") "と" (STRONG "list-2") "が通常のリストではないとき、" "型"
     (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "union") "," "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 (CODE1 "nintersection")
     "の副作用は必要ないため、" "移植可能なコードにおいては副作用のみを期待した姿勢で使うべきではありません。")))
(setf (gethash '("NINTERSECTION" . "FUNCTION") *table*) (gethash "NINTERSECTION" *table*))
(setf (gethash "NINTH" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "FIRST") ", " (CODE1 "SECOND") ", " (CODE1 "THIRD")
     ", " (CODE1 "FOURTH") ", " (CODE1 "FIFTH") "," (CODE1 "SIXTH") ", "
     (CODE1 "SEVENTH") ", " (CODE1 "EIGHTH") ", " (CODE1 "NINTH") ", " (CODE1 "TENTH"))
    (CHAPTER ("## 構文") 2 (CODE1 "first") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "second") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "third") " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fourth")
     " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fifth") " "
     (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "sixth") " " (STRONG "list")
     " => " (STRONG "object") EOL1 (CODE1 "seventh") " " (STRONG "list") " => "
     (STRONG "object") EOL1 (CODE1 "eighth") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "ninth") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "tenth") " " (STRONG "list") " => " (STRONG "object") EOL1 "(" (CODE1 "setf")
     " (" (CODE1 "first") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "second") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "third") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "fourth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "fifth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "sixth") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "seventh") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "eighth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "ninth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "tenth") " " (STRONG "list") ") " (STRONG "new-object")
     ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト、ドットリストと循環リストも受け付けます。" EOL1
     (STRONG "object") ", " (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "関数" (CODE1 "first") ", " (CODE1 "second") ", " (CODE1 "third")
     ", " (CODE1 "fourth") ", " (CODE1 "fifth") "," (CODE1 "sixth") ", "
     (CODE1 "seventh") ", " (CODE1 "eighth") ", " (CODE1 "ninth") ", " (CODE1 "tenth")
     "は、" "それぞれリストの1番目、2番目、3番目、4番目、5番目、" "6番目、7番目、8番目、9番目、10番目の要素にアクセスします。"
     "具体的には次のようになります。"
     (CODE3 "```lisp" "```" "(first list)    ==   (car list)"
      "(second list)   ==   (car (cdr list))" "(third list)    ==   (car (cddr list))"
      "(fourth list)   ==   (car (cdddr list))"
      "(fifth list)    ==   (car (cddddr list))"
      "(sixth list)    ==   (car (cdr (cddddr list)))"
      "(seventh list)  ==   (car (cddr (cddddr list)))"
      "(eighth list)   ==   (car (cdddr (cddddr list)))"
      "(ninth list)    ==   (car (cddddr (cddddr list)))"
      "(tenth list)    ==   (car (cdr (cddddr (cddddr list))))")
     EOL2 (CODE1 "setf") "は、これらの関数を使うことによって" "既存の構成要素を変更することもできます。"
     "上記の等価な関係を用いて同じように適用できます。" "例えば次のようになります。"
     (CODE3 "```lisp" "```"
      "(setf (fifth list) new-object) == (setf (car (cddddr list)) new-object)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst '(1 2 3 (4 5 6) ((V)) vi 7 8 9 10)) "
      "=>  (1 2 3 (4 5 6) ((V)) VI 7 8 9 10)" "(first lst) =>  1" "(tenth lst) =>  10"
      "(fifth lst) =>  ((V))" "(second (fourth lst)) =>  5" "(sixth '(1 2 3)) =>  NIL"
      "(setf (fourth lst) \"four\") =>  \"four\""
      "lst =>  (1 2 3 \"four\" ((V)) VI 7 8 9 10)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "car") "," (CODE1 "nth"))
    (CHAPTER ("## 備考") 2 (CODE1 "first") "は機能的には" (CODE1 "car") "と同じです。" (CODE1 "second")
     "は機能的には" (CODE1 "cadr") "と同じです。" (CODE1 "third") "は機能的には" (CODE1 "caddr") "と同じです。"
     (CODE1 "fourth") "は機能的には" (CODE1 "cadddr") "と同じです。" EOL2 "通常の番号付けは1から開始しますが、"
     (CODE1 "nth") "によって使われる採番は0開始であり、" "次の関係が成り立ちます。"
     (CODE3 "```lisp" "```" "(fifth x) == (nth 4 x)"))))
(setf (gethash '("NINTH" . "ACCESSOR") *table*) (gethash "NINTH" *table*))
(setf (gethash "NO-APPLICABLE-METHOD" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "NO-APPLICABLE-METHOD"))
    (CHAPTER ("## 構文") 2 (CODE1 "no-applicable-method") " " (STRONG "generic-function")
     " &rest " (STRONG "function-arguments") " => " (STRONG "result\\*"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "no-applicable-method") " ("
     (STRONG "generic-function") " " (CODE1 "t") ")" "&rest "
     (STRONG "function-arguments"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "generic-function") " - 該当するメソッドが見つからなかったジェネリック関数"
     EOL1 (STRONG "function-arguments") " - ジェネリック関数の引数" EOL1 (STRONG "result")
     " - オブジェクト")
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "no-applicable-method") "は、"
     "あるジェネリック関数が呼ばれたときに" "適用するメソッドが見つからなかったときに呼び出されます。" "デフォルトのメソッドは、エラーが発生します。" EOL2
     "ジェネリック関数" (CODE1 "slot-unbound") "は、" "プログラマーによって呼び出されることを想定していません。"
     "プログラマーはメソッドを書くことができます。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "デフォルトのメソッドは、エラーが発生します。") (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("NO-APPLICABLE-METHOD" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "NO-APPLICABLE-METHOD" *table*))
(setf (gethash "NO-NEXT-METHOD" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "NO-NEXT-METHOD"))
    (CHAPTER ("## 構文") 2 (CODE1 "no-next-method") " " (STRONG "generic-function") " "
     (STRONG "method") " &rest " (STRONG "args") " => " (STRONG "result\\*"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "no-next-method") " (" (STRONG "generic-function")
     " " (CODE1 "standard-generic-function") ")" " (" (STRONG "method") " "
     (CODE1 "standard-method") ") &rest " (STRONG "args"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "generic-function") " - " (STRONG "method")
     "が属しているジェネリック関数" EOL1 (STRONG "method") " - 次のメソッドがないときに" (CODE1 "call-next-method")
     "を呼び出したメソッド" EOL1 (STRONG "args") " - " (CODE1 "call-next-method") "の引数" EOL1
     (STRONG "result") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "no-next-method") "は、" "次のメソッドが存在しないときに"
     (CODE1 "call-next-method") "によって呼び出されます。" EOL2 "ジェネリック関数" (CODE1 "slot-unbound")
     "は、" "プログラマーによって呼び出されることを想定していません。" "プログラマーはメソッドを書くことができます。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "システムが提供する" (CODE1 "no-next-method") "のメソッドは、" "型"
     (CODE1 "error") "のエラーを発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "call-next-method")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("NO-NEXT-METHOD" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "NO-NEXT-METHOD" *table*))
(setf (gethash "NOT" *table*)
  '("NOT FUNCTION" EOL1 "NOT TYPE-SPECIFIER" EOL1))
(setf (gethash '("NOT" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "not") " " (STRONG "x") " => " (STRONG "boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - generalized-boolean（例えばどんなオブジェクトでも）" EOL1
     (STRONG "boolean") " - ブール値")
    (CHAPTER ("## 定義") 2 (STRONG "x") "が" (STRONG "false") "なら" (CODE1 "t") "を、" "それ以外なら"
     (CODE1 "nil") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(not nil) =>  T" "(not '()) =>  T"
      "(not (integerp 'sss)) =>  T" "(not (integerp 1)) =>  NIL" "(not 3.7) =>  NIL"
      "(not 'apple) =>  NIL"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "null"))
    (CHAPTER ("## 備考") 2 (CODE1 "not") "はブール値（あるいはgeneralized-boolean）を" "反転させるときに使用され、"
     "一方、" (CODE1 "null") "は、空のリストかどうかテストするときに" "使うことを意図しています。" "操作上では、" (CODE1 "not")
     "と" (CODE1 "null") "は同じ結果を計算するので、" "どちらを使うかはスタイルの問題です。")))
(setf (gethash '("NOT" . "TYPE-SPECIFIER") *table*)
  '((CHAPTER NIL 0 "Type Specifier " (CODE1 "NOT")) (CHAPTER ("## 型指定子の種類") 2 "結合")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "not") " " (STRONG "typespec"))
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "typespec") " - 型指定子")
    (CHAPTER ("## 型指定子の定義") 2 "型" (STRONG "typespec") "ではない全てのオブジェクトの集合を示します。" EOL2
     "引数は要求されますが、シンボル" (CODE1 "*") "は指定できません。" EOL2 "シンボルとしての" (CODE1 "not")
     "は、有効な型指定子ではありません。")))
(setf (gethash "NOTANY" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "EVERY") ", " (CODE1 "SOME") ", "
     (CODE1 "NOTEVERY") ", " (CODE1 "NOTANY"))
    (CHAPTER ("## 構文") 2 (CODE1 "every") " " (STRONG "predicate") " &rest "
     (STRONG "sequence") "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "some") " "
     (STRONG "predicate") " &rest " (STRONG "sequence") "+ => " (STRONG "result") EOL1
     (CODE1 "notevery") " " (STRONG "predicate") " &rest " (STRONG "sequence") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "notany") " " (STRONG "predicate")
     " &rest " (STRONG "sequence") "+ => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "predicate") " - " (STRONG "sequence")
     "の数だけ引数を受け取る関数指定子" EOL1 (STRONG "sequence") "s - シーケンス" EOL1 (STRONG "result")
     " - オブジェクト" EOL1 (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "every") "、" (CODE1 "some") "、" (CODE1 "notevery") "、"
     (CODE1 "notany") "は、" "引数" (STRONG "predicate") "が" (STRONG "sequence")
     "の要素を満たすかどうかをテストします。" (STRONG "predicate") "の最初の引数は最初の" (STRONG "sequence")
     "の要素であり、" "後続の引数は後続のシーケンスの要素です。" EOL2 (STRONG "predicate") "は、最初は各"
     (STRONG "sequence") "のインデックス0番目の要素で呼び出され、" "そのあと可能であればインデックス1番目の要素で呼ばれ、"
     "以下同様に実行し、終了の基準が満たされるか、" "もっとも短い" (STRONG "sequence") "の終わりに到達するときまで続けられます。" EOL2
     (CODE1 "every") "は、" (STRONG "predicate") "のどれかが" (STRONG "false") "を返却したら、" "すぐに"
     (STRONG "false") "を返却します。" "もし" (STRONG "sequence") "の終わりに到達したら、" (CODE1 "every")
     "は" (STRONG "true") "を返却します。" "したがって" (CODE1 "every") "は、すべての" (STRONG "predicate")
     "が" (STRONG "true") "を返却したときのみ、" (STRONG "true") "を返却します。" EOL2 (CODE1 "some") "は、"
     (STRONG "predicate") "の実行によって返却された" "最初の非" (CODE1 "nil") "を値を返却します。" "もし"
     (STRONG "predicate") "の実行が" (STRONG "true") "を返却することなく" (STRONG "sequence")
     "の終わりに到達したら、" (CODE1 "some") "は" (STRONG "false") "を返却します。" "したがって" (CODE1 "some")
     "は、" "もしどれかの" (STRONG "predicate") "の実行が" (STRONG "true") "を返却したら、" (STRONG "true")
     "を返却します。" EOL2 (CODE1 "notany") "は、" (STRONG "predicate") "のどれかが" (STRONG "true")
     "を返却したら、" "すぐに" (STRONG "false") "を返却します。" "もし" (STRONG "sequence") "の終わりに到達したら、"
     (CODE1 "notany") "は" (STRONG "true") "を返却します。" "したがって" (CODE1 "notany") "は、どの"
     (STRONG "predicate") "も" (STRONG "true") "を返却しない場合にのみ、" (STRONG "true") "を返却します。"
     EOL2 (CODE1 "notevery") "は、" (STRONG "predicate") "のどれかが" (STRONG "false") "を返却したら、"
     "すぐに" (STRONG "true") "を返却します。" "もし" (STRONG "sequence") "の終わりに到達したら、"
     (CODE1 "notevery") "は" (STRONG "false") "を返却します。" "したがって" (CODE1 "notevery")
     "は、すべての" (STRONG "predicate") "が" (STRONG "true") "を返却しない場合にのみ、" (STRONG "true")
     "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(every #'characterp \"abc\") =>  true"
      "(some #'= '(1 2 3 4 5) '(5 4 3 2 1)) =>  true"
      "(notevery #'< '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) =>  false"
      "(notany #'> '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) =>  true "))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "最初の引数がシンボルでも関数でもないときか、" "続く引数のどれかが正常なシーケンスではなかったときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" EOL2 "他の例外が発生する可能性があり、それは" (STRONG "predicate")
     "の性質に依存します。")
    (CHAPTER ("## 参考") 2 (CODE1 "and") "," (CODE1 "or") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```"
      "(notany predicate sequence*) == (not (some predicate sequence*))"
      "(notevery predicate sequence*) == (not (every predicate sequence*))"))))
(setf (gethash '("NOTANY" . "FUNCTION") *table*) (gethash "NOTANY" *table*))
(setf (gethash "NOTEVERY" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "EVERY") ", " (CODE1 "SOME") ", "
     (CODE1 "NOTEVERY") ", " (CODE1 "NOTANY"))
    (CHAPTER ("## 構文") 2 (CODE1 "every") " " (STRONG "predicate") " &rest "
     (STRONG "sequence") "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "some") " "
     (STRONG "predicate") " &rest " (STRONG "sequence") "+ => " (STRONG "result") EOL1
     (CODE1 "notevery") " " (STRONG "predicate") " &rest " (STRONG "sequence") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "notany") " " (STRONG "predicate")
     " &rest " (STRONG "sequence") "+ => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "predicate") " - " (STRONG "sequence")
     "の数だけ引数を受け取る関数指定子" EOL1 (STRONG "sequence") "s - シーケンス" EOL1 (STRONG "result")
     " - オブジェクト" EOL1 (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "every") "、" (CODE1 "some") "、" (CODE1 "notevery") "、"
     (CODE1 "notany") "は、" "引数" (STRONG "predicate") "が" (STRONG "sequence")
     "の要素を満たすかどうかをテストします。" (STRONG "predicate") "の最初の引数は最初の" (STRONG "sequence")
     "の要素であり、" "後続の引数は後続のシーケンスの要素です。" EOL2 (STRONG "predicate") "は、最初は各"
     (STRONG "sequence") "のインデックス0番目の要素で呼び出され、" "そのあと可能であればインデックス1番目の要素で呼ばれ、"
     "以下同様に実行し、終了の基準が満たされるか、" "もっとも短い" (STRONG "sequence") "の終わりに到達するときまで続けられます。" EOL2
     (CODE1 "every") "は、" (STRONG "predicate") "のどれかが" (STRONG "false") "を返却したら、" "すぐに"
     (STRONG "false") "を返却します。" "もし" (STRONG "sequence") "の終わりに到達したら、" (CODE1 "every")
     "は" (STRONG "true") "を返却します。" "したがって" (CODE1 "every") "は、すべての" (STRONG "predicate")
     "が" (STRONG "true") "を返却したときのみ、" (STRONG "true") "を返却します。" EOL2 (CODE1 "some") "は、"
     (STRONG "predicate") "の実行によって返却された" "最初の非" (CODE1 "nil") "を値を返却します。" "もし"
     (STRONG "predicate") "の実行が" (STRONG "true") "を返却することなく" (STRONG "sequence")
     "の終わりに到達したら、" (CODE1 "some") "は" (STRONG "false") "を返却します。" "したがって" (CODE1 "some")
     "は、" "もしどれかの" (STRONG "predicate") "の実行が" (STRONG "true") "を返却したら、" (STRONG "true")
     "を返却します。" EOL2 (CODE1 "notany") "は、" (STRONG "predicate") "のどれかが" (STRONG "true")
     "を返却したら、" "すぐに" (STRONG "false") "を返却します。" "もし" (STRONG "sequence") "の終わりに到達したら、"
     (CODE1 "notany") "は" (STRONG "true") "を返却します。" "したがって" (CODE1 "notany") "は、どの"
     (STRONG "predicate") "も" (STRONG "true") "を返却しない場合にのみ、" (STRONG "true") "を返却します。"
     EOL2 (CODE1 "notevery") "は、" (STRONG "predicate") "のどれかが" (STRONG "false") "を返却したら、"
     "すぐに" (STRONG "true") "を返却します。" "もし" (STRONG "sequence") "の終わりに到達したら、"
     (CODE1 "notevery") "は" (STRONG "false") "を返却します。" "したがって" (CODE1 "notevery")
     "は、すべての" (STRONG "predicate") "が" (STRONG "true") "を返却しない場合にのみ、" (STRONG "true")
     "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(every #'characterp \"abc\") =>  true"
      "(some #'= '(1 2 3 4 5) '(5 4 3 2 1)) =>  true"
      "(notevery #'< '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) =>  false"
      "(notany #'> '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) =>  true "))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "最初の引数がシンボルでも関数でもないときか、" "続く引数のどれかが正常なシーケンスではなかったときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" EOL2 "他の例外が発生する可能性があり、それは" (STRONG "predicate")
     "の性質に依存します。")
    (CHAPTER ("## 参考") 2 (CODE1 "and") "," (CODE1 "or") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```"
      "(notany predicate sequence*) == (not (some predicate sequence*))"
      "(notevery predicate sequence*) == (not (every predicate sequence*))"))))
(setf (gethash '("NOTEVERY" . "FUNCTION") *table*) (gethash "NOTEVERY" *table*))
(setf (gethash "NOTINLINE" *table*)
  '((CHAPTER NIL 0 "Declaration " (CODE1 "INLINE") ", " (CODE1 "NOTINLINE"))
    (CHAPTER ("## 構文") 2 "(" (CODE1 "inline") " " (STRONG "function-name\\*") ")" EOL1
     "(" (CODE1 "notinline") " " (STRONG "function-name\\*") ")")
    (CHAPTER ("## 引数") 2 (STRONG "function-name") " - 関数名")
    (CHAPTER ("## 有効な文脈") 2 (CODE1 "declare") "か" (CODE1 "proclaim"))
    (CHAPTER ("## 影響する束縛の型") 2 "関数")
    (CHAPTER ("## 定義") 2 (CODE1 "inline") "は、" (STRONG "function-name") "という名前の関数に対して、"
     "コンパイラーがインラインで呼び出すようなコードを" "生成するのが望ましいと指定します。" "つまり、" (STRONG "function-name")
     "で指定されたコードは、" "呼び出す処理を「行中」に現れるように、" "その場所に呼出処理を統合する必要があります。"
     "コンパイラーがこの宣言を無視するのは自由です。" (CODE1 "inline") "宣言は決して変数束縛を行いません。" EOL2
     "もしあるひとつの関数が宣言されており、" "その関数がレキシカルにローカル定義を持っているとき" "（" (CODE1 "flet") "か"
     (CODE1 "labels") "によって作成されたもの）、" "その宣言はグローバル関数定義ではなく、" "ローカルの関数定義の方に適用されます。" EOL2
     "もし仕様に適合した実装において、" "ユーザー定義関数のインラインの展開が要求されていないとき、" "これらの実装は下記の規範のように認識しようとします。" EOL2
     "定義された関数" (CODE1 "f") "は、標準では" (CODE1 "inline") "ではありません。" "しかし"
     (CODE1 "(declare (inline f))") "宣言内では" (CODE1 "F") "がローカルで" (CODE1 "inline")
     "になります。" "前のものも含めて定義の列が次のような場合を考えます。"
     (CODE3 "```lisp" "```" "(declaim (inline f))" "(defun f ...)"
      "(declaim (notinline f))")
     EOL2 (CODE1 "defun") "フォームの前にある" (CODE1 "inline") "の" (CODE1 "proclamation") "は、"
     "コンパイラーに、インライン展開が必要な時のための" "情報を保存する機会を保証します。" "そして" (CODE1 "defun") "フォームの後にある"
     (CODE1 "notinline") "の" (CODE1 "proclamation") "は、" (CODE1 "f")
     "がどこでもインライン展開しないよう抑制します。" EOL2 (CODE1 "notinline") "は、" (STRONG "function-name")
     "という名前の関数に対して、" "インラインコンパイルが望ましくないと指定します。" "コンパイラーはこの宣言を無視してはいけません。"
     "この指定の関数の呼び出しは、" "ラインの外のサブルーチンを呼び出すように実装しなければなりません。" EOL2 "もしあるひとつの関数が宣言されており、"
     "その関数がレキシカルにローカル定義を持っているとき" "（" (CODE1 "flet") "か" (CODE1 "labels") "によって作成されたもの）、"
     "その宣言はグローバル関数定義ではなく、ローカルの関数定義に適用されます。" EOL2 (STRONG "function-name")
     "コンパイラーマクロが現れたとき、" (CODE1 "notinline") "宣言はコンパイラーマクロの使用を禁止します。" (CODE1 "inline")
     "宣言はコンパイラーマクロの使用を勧めるようにします。" (CODE1 "inline") "と" (CODE1 "notinline") "宣言は、"
     "レキシカルに見える" (STRONG "function-name") "の定義が" "マクロ定義であったときは効果がありません。" EOL2
     (CODE1 "inline") "と" (CODE1 "notinline") "宣言は、自由宣言と境界宣言のどちらも使えます。" (CODE1 "flet")
     "か" (CODE1 "labels") "フォーム本体の前に現れた" "関数の" (CODE1 "inline") "と" (CODE1 "notinline")
     "宣言は、" "関数の境界宣言として定義されます。" "その他の文脈の宣言は自由宣言です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; グローバルに宣言された関数DISPATCHはオープンコードであり、"
      ";; もし実装がinlineをサポートしているのであれば、" ";; NOTINLINEの宣言をこの効果で上書きします。"
      "(declaim (inline dispatch))"
      "(defun dispatch (x) (funcall (get (car x) 'dispatch) x))" ";; これはinlineを推奨する例です。"
      "(defun top-level-1 () (dispatch (read-command)))" ";; これはinlineを禁止する例です。"
      "(defun top-level-2 ()" "  (declare (notinline dispatch))"
      "  (dispatch (read-command)))" ";; これはinlineを禁止する例です。"
      "(declaim (notinline dispatch))" "(defun top-level-3 () (dispatch (read-command)))"
      ";; これはinlineを推奨する例です。" "(defun top-level-4 () " "  (declare (inline dispatch))"
      "  (dispatch (read-command)))"))
    (CHAPTER ("## 参考") 2 (CODE1 "declare") "," (CODE1 "declaim") "," (CODE1 "proclaim"))))
(setf (gethash '("NOTINLINE" . "DECLARATION") *table*) (gethash "NOTINLINE" *table*))
(setf (gethash "NRECONC" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "REVAPPEND") ", " (CODE1 "NRECONC"))
    (CHAPTER ("## 構文") 2 (CODE1 "revappend") " " (STRONG "list") " " (STRONG "tail")
     " => " (STRONG "result-list") EOL1 (CODE1 "nreconc") " " (STRONG "list") " "
     (STRONG "tail") " => " (STRONG "result-list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - 通常のリスト" EOL1 (STRONG "tail") " - オブジェクト"
     EOL1 (STRONG "result-list") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "revappend") "は、" (STRONG "list") "の各要素を逆順でコピーします。"
     "そして、逆順のリストに" (STRONG "tail") "を（" (CODE1 "nconc") "のように）追加し、" "その結果を返却します。" EOL2
     (CODE1 "nreconc") "は、" (STRONG "list") "の要素を（" (CODE1 "nreverse") "のように）反転させます。"
     "そして、逆順のリストに" (STRONG "tail") "を（" (CODE1 "nconc") "のように）追加し、" "その結果を返却します。" EOL2
     "結果のリストは、" (STRONG "tail") "とリスト構造を共有します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(let ((list-1 (list 1 2 3))"
      "      (list-2 (list 'a 'b 'c)))" "  (print (revappend list-1 list-2))"
      "  (print (equal list-1 '(1 2 3)))" "  (print (equal list-2 '(a b c))))"
      ">>  (3 2 1 A B C) " ">>  T" ">>  T" "=>  T" NIL
      "(revappend '(1 2 3) '()) =>  (3 2 1)"
      "(revappend '(1 2 3) '(a . b)) =>  (3 2 1 A . B)"
      "(revappend '() '(a b c)) =>  (A B C)" "(revappend '(1 2 3) 'a) =>  (3 2 1 . A)"
      "(revappend '() 'a) =>  A   ;degenerate case" NIL "(let ((list-1 '(1 2 3))"
      "      (list-2 '(a b c)))" "  (print (nreconc list-1 list-2))"
      "  (print (equal list-1 '(1 2 3)))" "  (print (equal list-2 '(a b c))))"
      ">>  (3 2 1 A B C) " ">>  NIL" ">>  T" "=>  T"))
    (CHAPTER ("## 副作用") 2 (CODE1 "revappend") "は、どんな引数も修正しません。" (CODE1 "nreconc") "は、"
     (STRONG "list") "の修正を許可しますが、" (STRONG "tail") "はそうではありません。" EOL2 "違った実装になるかもしれませんが、"
     (CODE1 "nreconc") "は、下記の動作と同等の副作用を持つように制限されています。"
     (CODE3 "```lisp" "```" " (nconc (nreverse list) tail)"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "reverse") "," (CODE1 "nreverse") "," (CODE1 "nconc"))
    (CHAPTER ("## 備考") 2 "下記の機能の等号式は真ですが、" "良い実装は、通常同じ効果が得られるより速いアルゴリズムを使用しているでしょう。"
     (CODE3 "```lisp" "```" "(revappend list tail) ==  (nconc (reverse list) tail)"
      "(nreconc list tail) ==  (nconc (nreverse list) tail)"))))
(setf (gethash '("NRECONC" . "FUNCTION") *table*) (gethash "NRECONC" *table*))
(setf (gethash "NREVERSE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "REVERSE") ", " (CODE1 "NREVERSE"))
    (CHAPTER ("## 構文") 2 (CODE1 "reverse") " " (STRONG "sequence") " => "
     (STRONG "reversed-sequence") (CODE1 "nreverse") " " (STRONG "sequence") " => "
     (STRONG "reversed-sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "sequence") " - 正常なシーケンス" EOL1
     (STRONG "reversed-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "reverse") "と" (CODE1 "nreverse") "は、"
     (STRONG "sequence") "と同じ種類の、同じ要素が逆順に配置された、" "新しいシーケンスを返却します。" EOL2 (CODE1 "reverse")
     "と" (CODE1 "nreverse") "の違いは、" (CODE1 "reverse") "は常に新しいシーケンスを作成して返却するのに対して、"
     (CODE1 "nreverse") "はおそらく引数の" (STRONG "sequence") "を修正して返却します。" EOL2
     (CODE1 "reverse") "は、もし" (STRONG "sequence") "が" (CODE1 "vector") "のとき、"
     "返却値は新しい一次元のsimple-arrayであり、" (STRONG "sequence") "と同じ実際の配列の要素の型を持ちます。" "もし"
     (STRONG "sequence") "がリストなら、返却値は新しいリストです。" EOL2 (CODE1 "nreverse") "は、もし"
     (STRONG "sequence") "が" (CODE1 "vector") "のとき、" "返却値は一次元のsimple-arrayであり、"
     (STRONG "sequence") "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence")
     "がリストなら、返却値はリストです。" EOL2 (CODE1 "nreverse") "は、" (STRONG "sequence") "を破壊して再利用して、"
     "返却値を生成するかもしれません。" "返却値は" (STRONG "sequence") "と同一かもしれませんし、そうでないかもしれません。" "特に、"
     (STRONG "sequence") "がリストのとき、" (CODE1 "nreverse") "は、" (STRONG "sequence")
     "のリスト構造の部分にあるどのコンスの" (CODE1 "car") ", " (CODE1 "cdr") "部分でも、" (CODE1 "setf")
     "を実行することが許されます。" (STRONG "sequence") "が" (CODE1 "vector") "のとき、" (CODE1 "nreverse")
     "は、返却値の" (CODE1 "vector") "を求めるために、" (STRONG "sequence") "の要素の順番を変更することが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq str \"abc\") =>  \"abc\"" "(reverse str) =>  \"cba\""
      "str =>  \"abc\"" "(setq str (copy-seq str)) =>  \"abc\""
      "(nreverse str) =>  \"cba\"" "str =>  implementation-dependent"
      "(setq l (list 1 2 3)) =>  (1 2 3)" "(nreverse l) =>  (3 2 1)"
      "l =>  implementation-dependent"))
    (CHAPTER ("## 副作用") 2 (CODE1 "nreverse") "は、新しいシーケンスを作成するか、" (STRONG "sequence")
     "の引数を変更するか、" "あるいはその両方をするかもしれません。" "（" (CODE1 "reverse") "は" (STRONG "seqeunce")
     "の修正を行いません）")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("NREVERSE" . "FUNCTION") *table*) (gethash "NREVERSE" *table*))
(setf (gethash "NSET-DIFFERENCE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SET-DIFFERENCE") ", " (CODE1 "NSET-DIFFERENCE"))
    (CHAPTER ("## 構文") 2 (CODE1 "set-difference") " " (STRONG "list-1") " "
     (STRONG "list-2") " &key " (STRONG "key") " " (STRONG "test") " "
     (STRONG "test-not") " => " (STRONG "result-list") EOL1 (CODE1 "nset-difference") " "
     (STRONG "list-1") " " (STRONG "list-2") " &key " (STRONG "key") " " (STRONG "test")
     " " (STRONG "test-not") " => " (STRONG "result-list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list-1") " - 通常のリスト" EOL1 (STRONG "list-2")
     " - 通常のリスト" EOL1 (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test-not") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "result-list") " - リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "set-difference") "は、" (STRONG "list-2") "には現れない、"
     (STRONG "list-1") "の要素のリストを返却します。" EOL2 (CODE1 "nset-difference") "は、"
     (CODE1 "set-difference") "の破壊的バージョンです。" (STRONG "list-1") "はおそらく破壊されます。" EOL2
     (STRONG "list-1") "のひとつの要素と、" (STRONG "list-2") "のひとつの要素からなる、" "全ての順序付けされたペアに対して、"
     (CODE1 ":test") "か" (CODE1 ":test-not") "を使ってテストが満たされるかどうかを決定します。" (CODE1 ":test")
     "か" (CODE1 ":test-not") "の関数の最初の要素は" (STRONG "list-1") "の要素であり、" (CODE1 ":key")
     "関数によって返却されたものです（もし" (CODE1 ":key") "が指定されたなら）。" "二番目の引数は" (STRONG "list-2")
     "の要素であり、" (CODE1 ":key") "関数によって返却されたものです（もし" (CODE1 ":key") "が指定されたなら）。" EOL2 "もし"
     (CODE1 ":key") "が与えられたなら、" "その引数は、" (STRONG "list-1") "か" (STRONG "list-2") "の要素です。"
     (CODE1 ":key") "関数は通常与えられた要素の部分を返却します。" "もし" (CODE1 ":key") "が与えられないか、あるいは"
     (CODE1 "nil") "が指定されたとき、" (STRONG "list-1") "と" (STRONG "list-2") "の要素が使われます。" EOL2
     (STRONG "list-1") "の要素は、" (STRONG "list-2") "のどの要素にもマッチしないときのみ、" "結果に現れます。" EOL2
     "どんな方法で引数の順番を変えたとしても、" "結果の要素の順番に反映できる保証はありません。" "結果のリストは、適切であれば、" (STRONG "list-1")
     "か" (STRONG "list-2") "のどちらかとセルを共有するか、" "あるいは" (CODE1 "eq") "になる可能性があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst1 (list \"A\" \"b\" \"C\" \"d\")"
      "      lst2 (list \"a\" \"B\" \"C\" \"d\")) =>  (\"a\" \"B\" \"C\" \"d\")"
      "(set-difference lst1 lst2) =>  (\"d\" \"C\" \"b\" \"A\")"
      "(set-difference lst1 lst2 :test 'equal) =>  (\"b\" \"A\")"
      "(set-difference lst1 lst2 :test #'equalp) =>  NIL "
      "(nset-difference lst1 lst2 :test #'string=) =>  (\"A\" \"b\")"
      "(setq lst1 '((\"a\" . \"b\") (\"c\" . \"d\") (\"e\" . \"f\")))"
      "=>  ((\"a\" . \"b\") (\"c\" . \"d\") (\"e\" . \"f\")) "
      "(setq lst2 '((\"c\" . \"a\") (\"e\" . \"b\") (\"d\" . \"a\")))"
      "=>  ((\"c\" . \"a\") (\"e\" . \"b\") (\"d\" . \"a\")) "
      "(nset-difference lst1 lst2 :test #'string= :key #'cdr)"
      "=>  ((\"c\" . \"d\") (\"e\" . \"f\")) "
      "lst1 =>  ((\"a\" . \"b\") (\"c\" . \"d\") (\"e\" . \"f\")) "
      "lst2 =>  ((\"c\" . \"a\") (\"e\" . \"b\") (\"d\" . \"a\")) "
      ";; 名前に\"c\"か\"w\"を含む全ての食べ物は削除される"
      "(set-difference '(\"strawberry\" \"chocolate\" \"banana\""
      "                 \"lemon\" \"pistachio\" \"rhubarb\")" "         '(#\\c #\\w)"
      "         :test #'(lambda (s c) (find c s)))"
      "=>  (\"banana\" \"rhubarb\" \"lemon\")    ;One possible ordering."))
    (CHAPTER ("## 副作用") 2 (CODE1 "nset-difference") "は" (STRONG "list-1") "を破壊するでしょう。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list-1") "と" (STRONG "list-2") "が通常のリストではないとき、" "型"
     (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。")))
(setf (gethash '("NSET-DIFFERENCE" . "FUNCTION") *table*) (gethash "NSET-DIFFERENCE" *table*))
(setf (gethash "NSET-EXCLUSIVE-OR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SET-EXCLUSIVE-OR") ", "
     (CODE1 "NSET-EXCLUSIVE-OR"))
    (CHAPTER ("## 構文") 2 (CODE1 "set-exclusive-or") " " (STRONG "list-1") " "
     (STRONG "list-2") " &key " (STRONG "key") " " (STRONG "test") " "
     (STRONG "test-not") " => " (STRONG "result-list") EOL1 (CODE1 "nset-exclusive-or")
     " " (STRONG "list-1") " " (STRONG "list-2") " &key " (STRONG "key") " "
     (STRONG "test") " " (STRONG "test-not") " => " (STRONG "result-list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list-1") " - 通常のリスト" EOL1 (STRONG "list-2")
     " - 通常のリスト" EOL1 (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test-not") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "result-list") " - リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "set-difference") "は、" (STRONG "list-1") "と"
     (STRONG "list-2") "に" "正確に一度現れている要素をリストで返却します。" EOL2 (CODE1 "nset-exclusive-or")
     "は、" (CODE1 "set-exclusive-or") "の破壊的バージョンです。" EOL2 (STRONG "list-1") "のひとつの要素と、"
     (STRONG "list-2") "のひとつの要素からなる、" "全ての順序付けされたペアに対して、" (CODE1 ":test") "か"
     (CODE1 ":test-not") "を使ってテストが満たされるかどうかを決定します。" EOL2 "もし" (CODE1 ":key") "が与えられたなら、"
     (STRONG "list-1") "か" (STRONG "list-2") "の要素をテストする部分を引き出すときに使われます。" (CODE1 ":test")
     "か" (CODE1 ":test-not") "の関数の最初の要素は" (STRONG "list-1") "の要素であり、" (CODE1 ":key")
     "関数によって返却されたものです（もし" (CODE1 ":key") "が指定されたなら）。" "二番目の引数は" (STRONG "list-2")
     "の要素であり、" (CODE1 ":key") "関数によって返却されたものです（もし" (CODE1 ":key") "が指定されたなら）。" "もし"
     (CODE1 ":key") "が与えられないか、あるいは" (CODE1 "nil") "が指定されたとき、" (STRONG "list-1") "と"
     (STRONG "list-2") "の要素が使われます。" EOL2 "結果は、" (STRONG "list-1") "と" (STRONG "list-2")
     "の要素のうち、" "マッチするペアがないものを正確に含んでいます。" EOL2 (CODE1 "set-difference") "の結果のリストは、"
     (STRONG "list-1") "か" (STRONG "list-2") "のどちらかが" "ストレージ上で共有されているかもしれません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst1 (list 1 \"a\" \"b\")"
      "      lst2 (list 1 \"A\" \"b\")) =>  (1 \"A\" \"b\")"
      "(set-exclusive-or lst1 lst2) =>  (\"b\" \"A\" \"b\" \"a\")"
      "(set-exclusive-or lst1 lst2 :test #'equal) =>  (\"A\" \"a\")"
      "(set-exclusive-or lst1 lst2 :test 'equalp) =>  NIL "
      "(nset-exclusive-or lst1 lst2) =>  (\"a\" \"b\" \"A\" \"b\") "
      "(setq lst1 (list ((\"a\" . \"b\") (\"c\" . \"d\") (\"e\" . \"f\"))))"
      "=>  ((\"a\" . \"b\") (\"c\" . \"d\") (\"e\" . \"f\"))"
      "(setq lst2 (list ((\"c\" . \"a\") (\"e\" . \"b\") (\"d\" . \"a\"))))"
      "=>  ((\"c\" . \"a\") (\"e\" . \"b\") (\"d\" . \"a\")) "
      "(nset-exclusive-or lst1 lst2 :test #'string= :key #'cdr)"
      "=>  ((\"c\" . \"d\") (\"e\" . \"f\") (\"c\" . \"a\") (\"d\" . \"a\")) "
      "lst1 =>  ((\"a\" . \"b\") (\"c\" . \"d\") (\"e\" . \"f\"))"
      "lst2 =>  ((\"c\" . \"a\") (\"d\" . \"a\")) "))
    (CHAPTER ("## 副作用") 2 (CODE1 "nset-exclusive-or") "は、" (STRONG "list-1") "か"
     (STRONG "list-2") "のリスト構造の" (CODE1 "car") ", " (CODE1 "cdr") "の"
     "どの部分も修正することが許されています。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list-1") "と" (STRONG "list-2") "が通常のリストではないとき、" "型"
     (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "3.2.1. コンパイラーの用語")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2
     (CODE1 "nset-exclusive-or") "の副作用は必要ないため、" "移植可能なコードにおいては副作用のみを期待した姿勢で使うべきではありません。")))
(setf (gethash '("NSET-EXCLUSIVE-OR" . "FUNCTION") *table*) (gethash "NSET-EXCLUSIVE-OR" *table*))
(setf (gethash "NSTRING-CAPITALIZE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING-UPCASE") ", " (CODE1 "STRING-DOWNCASE")
     ", " (CODE1 "STRING-CAPITALIZE") "," (CODE1 "NSTRING-UPCASE") ", "
     (CODE1 "NSTRING-DOWNCASE") ", " (CODE1 "NSTRING-CAPITALIZE"))
    (CHAPTER ("## 構文") 2 (CODE1 "string-upcase") " " (STRONG "string") " &key "
     (STRONG "start") " " (STRONG "end") " => " (STRONG "cased-string") EOL1
     (CODE1 "string-downcase") " " (STRONG "string") " &key " (STRONG "start") " "
     (STRONG "end") " => " (STRONG "cased-string") EOL1 (CODE1 "string-capitalize") " "
     (STRONG "string") " &key " (STRONG "start") " " (STRONG "end") " => "
     (STRONG "cased-string") EOL1 (CODE1 "nstring-upcase") " " (STRONG "string") " &key "
     (STRONG "start") " " (STRONG "end") " => " (STRONG "string") EOL1
     (CODE1 "string-downcase") " " (STRONG "string") " &key " (STRONG "start") " "
     (STRONG "end") " => " (STRONG "string") EOL1 (CODE1 "string-capitalize") " "
     (STRONG "string") " &key " (STRONG "start") " " (STRONG "end") " => "
     (STRONG "string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string") " - string-designator。ただし、"
     (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") "の場合は、" "文字列出なければならない。" EOL1 (STRONG "start") ", "
     (STRONG "end") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end") "の標準値はそれぞれ"
     (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "cased-string") " - 文字列。")
    (CHAPTER ("## 定義") 2 (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "," (CODE1 "nstring-upcase") ", "
     (CODE1 "nstring-downcase") ", " (CODE1 "nstring-capitalize") "は、" "文字列の"
     (STRONG "start") ", " (STRONG "end") "の境界間の列のケース（大文字小文字）を次のように変更します。" EOL2 "- "
     (CODE1 "string-upcase") EOL1 (CODE1 "string-upcase") "は、" (STRONG "string")
     "の全ての小文字を、" "対応する大文字に全て置き換えた文字列を返却します。" "正確には、返却された文字列の各文字は、" (STRONG "string")
     "の各文字に対して関数" (CODE1 "char-upcase") "の実行によって生成されたものです。" EOL2 "- "
     (CODE1 "string-downcase") EOL1 (CODE1 "string-downcase") "は、"
     (CODE1 "string-upcase") "と似ていますが、" "全ての大文字を小文字に置き換えるところが違っています" "("
     (CODE1 "char-downcase") "を使用します）。" EOL2 "- " (CODE1 "string-capitalize") EOL1
     (CODE1 "string-capitalize") "は、すべての単語" (CODE1 "word") "について、" (CODE1 "word")
     "の最初の文字が大文字であり、" "その他の文字が小文字であるような文字列のコピーを作成します。" (CODE1 "string-capitalize") "では、"
     "英数字からなる連続した文字列の両端を、" "英数字以外の文字か、" "または文字列の終端で区切ったものを単語" (CODE1 "word") "と定義しています。"
     EOL2 "- " (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") EOL1 (CODE1 "nstring-upcase") ", "
     (CODE1 "nstring-downcase") ", " (CODE1 "nstring-capitalize") "は、" "それぞれ"
     (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "と" "同一ですが、" (STRONG "string") "を変更するところが違っています。" EOL2
     (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "は、" (STRONG "string") "を変更しません。" "しかし文字列に変更する文字がない場合は、"
     "処理系の判断により、返却値は" (STRONG "string") "かあるいはそのコピーのどちらかになります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string-upcase \"abcde\") =>  \"ABCDE\""
      "(string-upcase \"Dr. Livingston, I presume?\")"
      "=>  \"DR. LIVINGSTON, I PRESUME?\""
      "(string-upcase \"Dr. Livingston, I presume?\" :start 6 :end 10)"
      "=>  \"Dr. LiVINGston, I presume?\""
      "(string-downcase \"Dr. Livingston, I presume?\")"
      "=>  \"dr. livingston, i presume?\"" NIL
      "(string-capitalize \"elm 13c arthur;fig don't\") =>  \"Elm 13c Arthur;Fig Don'T\""
      "(string-capitalize \" hello \") =>  \" Hello \""
      "(string-capitalize \"occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION\")"
      "=>   \"Occluded Casements Forestall Inadvertent Defenestration\""
      "(string-capitalize 'kludgy-hash-search) =>  \"Kludgy-Hash-Search\""
      "(string-capitalize \"DON'T!\") =>  \"Don'T!\"    ;not \"Don't!\""
      "(string-capitalize \"pipe 13a, foo16c\") =>  \"Pipe 13a, Foo16c\"" NIL
      "(setq str (copy-seq \"0123ABCD890a\")) =>  \"0123ABCD890a\""
      "(nstring-downcase str :start 5 :end 7) =>  \"0123AbcD890a\""
      "str =>  \"0123AbcD890a\""))
    (CHAPTER ("## 副作用") 2 (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") "は、" "新しい文字列を構築するのではなく、" (STRONG "string") "を変更します。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char-upcase") ", " (CODE1 "char-downcase") ".")
    (CHAPTER ("## 備考") 2 "返却値は常に" (STRONG "string") "と同じ長さです。")))
(setf (gethash '("NSTRING-CAPITALIZE" . "FUNCTION") *table*) (gethash "NSTRING-CAPITALIZE" *table*))
(setf (gethash "NSTRING-DOWNCASE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING-UPCASE") ", " (CODE1 "STRING-DOWNCASE")
     ", " (CODE1 "STRING-CAPITALIZE") "," (CODE1 "NSTRING-UPCASE") ", "
     (CODE1 "NSTRING-DOWNCASE") ", " (CODE1 "NSTRING-CAPITALIZE"))
    (CHAPTER ("## 構文") 2 (CODE1 "string-upcase") " " (STRONG "string") " &key "
     (STRONG "start") " " (STRONG "end") " => " (STRONG "cased-string") EOL1
     (CODE1 "string-downcase") " " (STRONG "string") " &key " (STRONG "start") " "
     (STRONG "end") " => " (STRONG "cased-string") EOL1 (CODE1 "string-capitalize") " "
     (STRONG "string") " &key " (STRONG "start") " " (STRONG "end") " => "
     (STRONG "cased-string") EOL1 (CODE1 "nstring-upcase") " " (STRONG "string") " &key "
     (STRONG "start") " " (STRONG "end") " => " (STRONG "string") EOL1
     (CODE1 "string-downcase") " " (STRONG "string") " &key " (STRONG "start") " "
     (STRONG "end") " => " (STRONG "string") EOL1 (CODE1 "string-capitalize") " "
     (STRONG "string") " &key " (STRONG "start") " " (STRONG "end") " => "
     (STRONG "string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string") " - string-designator。ただし、"
     (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") "の場合は、" "文字列出なければならない。" EOL1 (STRONG "start") ", "
     (STRONG "end") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end") "の標準値はそれぞれ"
     (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "cased-string") " - 文字列。")
    (CHAPTER ("## 定義") 2 (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "," (CODE1 "nstring-upcase") ", "
     (CODE1 "nstring-downcase") ", " (CODE1 "nstring-capitalize") "は、" "文字列の"
     (STRONG "start") ", " (STRONG "end") "の境界間の列のケース（大文字小文字）を次のように変更します。" EOL2 "- "
     (CODE1 "string-upcase") EOL1 (CODE1 "string-upcase") "は、" (STRONG "string")
     "の全ての小文字を、" "対応する大文字に全て置き換えた文字列を返却します。" "正確には、返却された文字列の各文字は、" (STRONG "string")
     "の各文字に対して関数" (CODE1 "char-upcase") "の実行によって生成されたものです。" EOL2 "- "
     (CODE1 "string-downcase") EOL1 (CODE1 "string-downcase") "は、"
     (CODE1 "string-upcase") "と似ていますが、" "全ての大文字を小文字に置き換えるところが違っています" "("
     (CODE1 "char-downcase") "を使用します）。" EOL2 "- " (CODE1 "string-capitalize") EOL1
     (CODE1 "string-capitalize") "は、すべての単語" (CODE1 "word") "について、" (CODE1 "word")
     "の最初の文字が大文字であり、" "その他の文字が小文字であるような文字列のコピーを作成します。" (CODE1 "string-capitalize") "では、"
     "英数字からなる連続した文字列の両端を、" "英数字以外の文字か、" "または文字列の終端で区切ったものを単語" (CODE1 "word") "と定義しています。"
     EOL2 "- " (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") EOL1 (CODE1 "nstring-upcase") ", "
     (CODE1 "nstring-downcase") ", " (CODE1 "nstring-capitalize") "は、" "それぞれ"
     (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "と" "同一ですが、" (STRONG "string") "を変更するところが違っています。" EOL2
     (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "は、" (STRONG "string") "を変更しません。" "しかし文字列に変更する文字がない場合は、"
     "処理系の判断により、返却値は" (STRONG "string") "かあるいはそのコピーのどちらかになります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string-upcase \"abcde\") =>  \"ABCDE\""
      "(string-upcase \"Dr. Livingston, I presume?\")"
      "=>  \"DR. LIVINGSTON, I PRESUME?\""
      "(string-upcase \"Dr. Livingston, I presume?\" :start 6 :end 10)"
      "=>  \"Dr. LiVINGston, I presume?\""
      "(string-downcase \"Dr. Livingston, I presume?\")"
      "=>  \"dr. livingston, i presume?\"" NIL
      "(string-capitalize \"elm 13c arthur;fig don't\") =>  \"Elm 13c Arthur;Fig Don'T\""
      "(string-capitalize \" hello \") =>  \" Hello \""
      "(string-capitalize \"occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION\")"
      "=>   \"Occluded Casements Forestall Inadvertent Defenestration\""
      "(string-capitalize 'kludgy-hash-search) =>  \"Kludgy-Hash-Search\""
      "(string-capitalize \"DON'T!\") =>  \"Don'T!\"    ;not \"Don't!\""
      "(string-capitalize \"pipe 13a, foo16c\") =>  \"Pipe 13a, Foo16c\"" NIL
      "(setq str (copy-seq \"0123ABCD890a\")) =>  \"0123ABCD890a\""
      "(nstring-downcase str :start 5 :end 7) =>  \"0123AbcD890a\""
      "str =>  \"0123AbcD890a\""))
    (CHAPTER ("## 副作用") 2 (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") "は、" "新しい文字列を構築するのではなく、" (STRONG "string") "を変更します。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char-upcase") ", " (CODE1 "char-downcase") ".")
    (CHAPTER ("## 備考") 2 "返却値は常に" (STRONG "string") "と同じ長さです。")))
(setf (gethash '("NSTRING-DOWNCASE" . "FUNCTION") *table*) (gethash "NSTRING-DOWNCASE" *table*))
(setf (gethash "NSTRING-UPCASE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING-UPCASE") ", " (CODE1 "STRING-DOWNCASE")
     ", " (CODE1 "STRING-CAPITALIZE") "," (CODE1 "NSTRING-UPCASE") ", "
     (CODE1 "NSTRING-DOWNCASE") ", " (CODE1 "NSTRING-CAPITALIZE"))
    (CHAPTER ("## 構文") 2 (CODE1 "string-upcase") " " (STRONG "string") " &key "
     (STRONG "start") " " (STRONG "end") " => " (STRONG "cased-string") EOL1
     (CODE1 "string-downcase") " " (STRONG "string") " &key " (STRONG "start") " "
     (STRONG "end") " => " (STRONG "cased-string") EOL1 (CODE1 "string-capitalize") " "
     (STRONG "string") " &key " (STRONG "start") " " (STRONG "end") " => "
     (STRONG "cased-string") EOL1 (CODE1 "nstring-upcase") " " (STRONG "string") " &key "
     (STRONG "start") " " (STRONG "end") " => " (STRONG "string") EOL1
     (CODE1 "string-downcase") " " (STRONG "string") " &key " (STRONG "start") " "
     (STRONG "end") " => " (STRONG "string") EOL1 (CODE1 "string-capitalize") " "
     (STRONG "string") " &key " (STRONG "start") " " (STRONG "end") " => "
     (STRONG "string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string") " - string-designator。ただし、"
     (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") "の場合は、" "文字列出なければならない。" EOL1 (STRONG "start") ", "
     (STRONG "end") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end") "の標準値はそれぞれ"
     (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "cased-string") " - 文字列。")
    (CHAPTER ("## 定義") 2 (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "," (CODE1 "nstring-upcase") ", "
     (CODE1 "nstring-downcase") ", " (CODE1 "nstring-capitalize") "は、" "文字列の"
     (STRONG "start") ", " (STRONG "end") "の境界間の列のケース（大文字小文字）を次のように変更します。" EOL2 "- "
     (CODE1 "string-upcase") EOL1 (CODE1 "string-upcase") "は、" (STRONG "string")
     "の全ての小文字を、" "対応する大文字に全て置き換えた文字列を返却します。" "正確には、返却された文字列の各文字は、" (STRONG "string")
     "の各文字に対して関数" (CODE1 "char-upcase") "の実行によって生成されたものです。" EOL2 "- "
     (CODE1 "string-downcase") EOL1 (CODE1 "string-downcase") "は、"
     (CODE1 "string-upcase") "と似ていますが、" "全ての大文字を小文字に置き換えるところが違っています" "("
     (CODE1 "char-downcase") "を使用します）。" EOL2 "- " (CODE1 "string-capitalize") EOL1
     (CODE1 "string-capitalize") "は、すべての単語" (CODE1 "word") "について、" (CODE1 "word")
     "の最初の文字が大文字であり、" "その他の文字が小文字であるような文字列のコピーを作成します。" (CODE1 "string-capitalize") "では、"
     "英数字からなる連続した文字列の両端を、" "英数字以外の文字か、" "または文字列の終端で区切ったものを単語" (CODE1 "word") "と定義しています。"
     EOL2 "- " (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") EOL1 (CODE1 "nstring-upcase") ", "
     (CODE1 "nstring-downcase") ", " (CODE1 "nstring-capitalize") "は、" "それぞれ"
     (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "と" "同一ですが、" (STRONG "string") "を変更するところが違っています。" EOL2
     (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "は、" (STRONG "string") "を変更しません。" "しかし文字列に変更する文字がない場合は、"
     "処理系の判断により、返却値は" (STRONG "string") "かあるいはそのコピーのどちらかになります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string-upcase \"abcde\") =>  \"ABCDE\""
      "(string-upcase \"Dr. Livingston, I presume?\")"
      "=>  \"DR. LIVINGSTON, I PRESUME?\""
      "(string-upcase \"Dr. Livingston, I presume?\" :start 6 :end 10)"
      "=>  \"Dr. LiVINGston, I presume?\""
      "(string-downcase \"Dr. Livingston, I presume?\")"
      "=>  \"dr. livingston, i presume?\"" NIL
      "(string-capitalize \"elm 13c arthur;fig don't\") =>  \"Elm 13c Arthur;Fig Don'T\""
      "(string-capitalize \" hello \") =>  \" Hello \""
      "(string-capitalize \"occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION\")"
      "=>   \"Occluded Casements Forestall Inadvertent Defenestration\""
      "(string-capitalize 'kludgy-hash-search) =>  \"Kludgy-Hash-Search\""
      "(string-capitalize \"DON'T!\") =>  \"Don'T!\"    ;not \"Don't!\""
      "(string-capitalize \"pipe 13a, foo16c\") =>  \"Pipe 13a, Foo16c\"" NIL
      "(setq str (copy-seq \"0123ABCD890a\")) =>  \"0123ABCD890a\""
      "(nstring-downcase str :start 5 :end 7) =>  \"0123AbcD890a\""
      "str =>  \"0123AbcD890a\""))
    (CHAPTER ("## 副作用") 2 (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") "は、" "新しい文字列を構築するのではなく、" (STRONG "string") "を変更します。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char-upcase") ", " (CODE1 "char-downcase") ".")
    (CHAPTER ("## 備考") 2 "返却値は常に" (STRONG "string") "と同じ長さです。")))
(setf (gethash '("NSTRING-UPCASE" . "FUNCTION") *table*) (gethash "NSTRING-UPCASE" *table*))
(setf (gethash "NSUBLIS" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SUBLIS") ", " (CODE1 "NSUBLIS"))
    (CHAPTER ("## 構文") 2 (CODE1 "sublis") " " (STRONG "alist") " " (STRONG "tree")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "new-tree") EOL1 (CODE1 "nsublis") " " (STRONG "alist") " " (STRONG "tree")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "new-tree"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "alist") " - 連想リスト" EOL1 (STRONG "tree") " - ツリー"
     EOL1 (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test-not") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "new-tree") " - ツリー")
    (CHAPTER ("## 定義") 2 (CODE1 "sublis") "は、" (STRONG "tree") "（コンスの構造）をオブジェクトに置換します。"
     (CODE1 "nsublis") "は" (CODE1 "sublis") "と似ていますが、" (STRONG "tree")
     "の関連する部分を破壊的に修正します。" EOL2 (CODE1 "sublis") "は、" (STRONG "tree") "の部分ツリーと葉を全て見ます。"
     "もし部分ツリーか葉が" (STRONG "alist") "のキーとして現れたとき" "（つまりキーと、部分ツリーか葉が" (STRONG "test")
     "を満たすとき）、" "それはキーに連想されているオブジェクトに置き換えられます。" "この操作は非破壊的です。" "実際には、" (CODE1 "sublis")
     "は複数の" (CODE1 "subst") "の操作を同時に" "行うようなものです。" EOL2 (CODE1 "sublis") "が成功すると、"
     "指定された部分ツリーと葉が出現された各部分が、" "関連付けらているオブジェクトで置き換わった" "新しいツリーが返却されます。"
     "もし変更が生じなかったときは、もとの" (STRONG "tree") "が返却されます。" "元の" (STRONG "tree")
     "に変更は生じないとしても、返却値のツリーは" "元のツリーとセルを共有しているかもしれません。" EOL2 (CODE1 "nsublis") "は"
     (STRONG "tree") "の変更を許可されていますが、" "それ以外は" (CODE1 "sublis") "と同じ値を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(sublis '((x . 100) (z . zprime))"
      "        '(plus x (minus g z x p) 4 . x))"
      "=>  (PLUS 100 (MINUS G ZPRIME 100 P) 4 . 100)"
      "(sublis '(((+ x y) . (- x y)) ((- x y) . (+ x y)))"
      "        '(* (/ (+ x y) (+ x p)) (- x y))" "        :test #'equal)"
      "=>  (* (/ (- X Y) (+ X P)) (+ X Y))"
      "(setq tree1 '(1 (1 2) ((1 2 3)) (((1 2 3 4)))))"
      "=>  (1 (1 2) ((1 2 3)) (((1 2 3 4))))" "(sublis '((3 . \"three\")) tree1) "
      "=>  (1 (1 2) ((1 2 \"three\")) (((1 2 \"three\" 4))))"
      "(sublis '((t . \"string\"))" "         (sublis '((1 . \"\") (4 . 44)) tree1)"
      "         :key #'stringp)"
      "=>  (\"string\" (\"string\" 2) ((\"string\" 2 3)) (((\"string\" 2 3 44))))"
      "tree1 =>  (1 (1 2) ((1 2 3)) (((1 2 3 4))))"
      "(setq tree2 '(\"one\" (\"one\" \"two\") ((\"one\" \"Two\" \"three\"))))"
      "=>  (\"one\" (\"one\" \"two\") ((\"one\" \"Two\" \"three\"))) "
      "(sublis '((\"two\" . 2)) tree2) "
      "=>  (\"one\" (\"one\" \"two\") ((\"one\" \"Two\" \"three\"))) "
      "tree2 =>  (\"one\" (\"one\" \"two\") ((\"one\" \"Two\" \"three\"))) "
      "(sublis '((\"two\" . 2)) tree2 :test 'equal) "
      "=>  (\"one\" (\"one\" 2) ((\"one\" \"Two\" \"three\"))) " NIL
      "(nsublis '((t . 'temp))" "          tree1"
      "          :key #'(lambda (x) (or (atom x) (< (list-length x) 3))))"
      "=>  ((QUOTE TEMP) (QUOTE TEMP) QUOTE TEMP) "))
    (CHAPTER ("## 副作用") 2 (CODE1 "nsublis") "は" (STRONG "tree") "を修正します。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "subst") "," "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "副作用による変形（"
     (CODE1 "nsublis") "など）は、" "通過するパスを変更する可能性があるので、" "共有構造や循環構造が現れるものでは、"
     "副作用による修正がないものと比べると、" "驚くべき方法で変化する可能性があります。" "このような挙動を見るために、" "いくつかの実装では見られるかもしれない、"
     "次のような副作用の動作を考えてみましょう。"
     (CODE3 "```lisp" "```" "(defun test-it (fn)" "  (let* ((shared-piece (list 'a 'b))"
      "         (data (list shared-piece shared-piece)))"
      "    (funcall fn '((a . b) (b . a)) data)))" "(test-it #'sublis) =>  ((B A) (B A))"
      "(test-it #'nsublis) =>  ((A B) (A B))"))))
(setf (gethash '("NSUBLIS" . "FUNCTION") *table*) (gethash "NSUBLIS" *table*))
(setf (gethash "NSUBST" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SUBST") ", " (CODE1 "SUBST-IF") ", "
     (CODE1 "SUBST-IF-NOT") "," (CODE1 "NSUBST") ", " (CODE1 "NSUBST-IF") ", "
     (CODE1 "NSUBST-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "subst") " " (STRONG "new") " " (STRONG "old") " "
     (STRONG "tree") " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not")
     " => " (STRONG "new-tree") EOL1 (CODE1 "subst-if") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "subst-if-not") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "nsubst") " " (STRONG "new") " " (STRONG "old") " "
     (STRONG "tree") " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not")
     " => " (STRONG "new-tree") EOL1 (CODE1 "nsubst-if") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "nsubst-if-not") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "new") " - オブジェクト" EOL1 (STRONG "old") " - オブジェクト"
     EOL1 (STRONG "predicate") " - 関数名のシンボルか、" "1つの引数をとりgeneralized-booleanを返却する関数" EOL1
     (STRONG "tree") " - ツリー" EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "new-tree") " - ツリー")
    (CHAPTER ("## 定義") 2 (CODE1 "subst") ", " (CODE1 "subst-if") ", "
     (CODE1 "subst-if-not") "は、" (STRONG "tree") "の置換操作を行います。" "各関数は" (STRONG "tree")
     "に対して" (STRONG "test") "を満たすような特定の" (STRONG "old") "要素か、" "あるいは部分式を満たすものを検索します。"
     EOL2 (CODE1 "nsubst") ", " (CODE1 "nsubst-if") ", " (CODE1 "nsubst-if-not") "はそれぞれ"
     (CODE1 "subst") ", " (CODE1 "subst-if") ", " (CODE1 "subst-if-not") "と似ていますが、" "元の"
     (STRONG "tree") "を修正するところが違っています。" EOL2 (CODE1 "subst") "は" (STRONG "tree")
     "のコピーを作成し、" "全てのサブツリー、葉、親の" (CODE1 "car") "部、" (CODE1 "cdr") "部、すべてに対して"
     (STRONG "old") "と" (STRONG "test") "が満たされる部分を" (STRONG "new") "に置換します。" EOL2
     (CODE1 "nsubst") "は、" (CODE1 "subst") "の破壊的バージョンです。" (STRONG "tree") "のリスト構造は、それぞれの"
     (STRONG "tree") "の葉に対して、" (STRONG "old") "と" (STRONG "test") "が満たされる葉の部分を"
     (STRONG "new") "で破壊的に置換することによって変更されます" EOL2 (CODE1 "subst") ", " (CODE1 "subst-if")
     ", " (CODE1 "subst-if-not") "は、" "もし関数が成功すると、" "指定された要素のそれぞれの出現を" (STRONG "new")
     "要素で置き換えられたものか、" "あるいは部分式で置き換えられたものの新たなコピーが返却されます。" "もし変更が生じなかったときは、元の"
     (STRONG "tree") "が返却されるかもしれません。" "元の" (STRONG "tree") "が変更されないとしても、"
     "返却値のツリーは元のツリーと" "ストレージを共有しているかもしれません。" EOL2 (CODE1 "nsubst") ", "
     (CODE1 "nsubst-if") ", " (CODE1 "nsubst-if-not") "は、" "元の" (STRONG "tree")
     "を修正し返却します。" "しかし関数の結果は、" (STRONG "tree") "と" (CODE1 "eq") "で等しくないかもしれません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq tree1 '(1 (1 2) (1 2 3) (1 2 3 4))) =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(subst \"two\" 2 tree1) =>  (1 (1 \"two\") (1 \"two\" 3) (1 \"two\" 3 4))"
      "(subst \"five\" 5 tree1) =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(eq tree1 (subst \"five\" 5 tree1)) =>  implementation-dependent"
      "(subst 'tempest 'hurricane" "       '(shakespeare wrote (the hurricane)))"
      "=>  (SHAKESPEARE WROTE (THE TEMPEST))"
      "(subst 'foo 'nil '(shakespeare wrote (twelfth night)))"
      "=>  (SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO)"
      "(subst '(a . cons) '(old . pair)"
      "       '((old . spice) ((old . shoes) old . pair) (old . pair))"
      "       :test #'equal)" "=>  ((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS))"
      NIL "(subst-if 5 #'listp tree1) =>  5" "(subst-if-not '(x) #'consp tree1) "
      "=>  (1 X)" NIL "tree1 =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(nsubst 'x 3 tree1 :key #'(lambda (y) (and (listp y) (third y)))) "
      "=>  (1 (1 2) X X)" "tree1 =>  (1 (1 2) X X)"))
    (CHAPTER ("## 副作用") 2 (CODE1 "nsubst") ", " (CODE1 "nsubst-if") ", "
     (CODE1 "nsubst-if-not") "は、" (STRONG "tree") "のツリー構造を変更するかもしれません。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "substitute") "," (CODE1 "nsubstitute") ","
     "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "subst-if-not") "と" (CODE1 "nsubst-if-not") "は非推奨です。" EOL2 (CODE1 "subst")
     "は一例として次のように定義できます。"
     (CODE3 "```lisp" "```" "(defun subst (old new tree &rest x &key test test-not key)"
      "  (cond ((satisfies-the-test old tree :test test"
      "                             :test-not test-not :key key)" "         new)"
      "        ((atom tree) tree)"
      "        (t (let ((a (apply #'subst old new (car tree) x))"
      "                 (d (apply #'subst old new (cdr tree) x)))"
      "             (if (and (eql a (car tree))"
      "                      (eql d (cdr tree)))" "                 tree"
      "                 (cons a d))))))"))))
(setf (gethash '("NSUBST" . "FUNCTION") *table*) (gethash "NSUBST" *table*))
(setf (gethash "NSUBST-IF" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SUBST") ", " (CODE1 "SUBST-IF") ", "
     (CODE1 "SUBST-IF-NOT") "," (CODE1 "NSUBST") ", " (CODE1 "NSUBST-IF") ", "
     (CODE1 "NSUBST-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "subst") " " (STRONG "new") " " (STRONG "old") " "
     (STRONG "tree") " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not")
     " => " (STRONG "new-tree") EOL1 (CODE1 "subst-if") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "subst-if-not") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "nsubst") " " (STRONG "new") " " (STRONG "old") " "
     (STRONG "tree") " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not")
     " => " (STRONG "new-tree") EOL1 (CODE1 "nsubst-if") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "nsubst-if-not") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "new") " - オブジェクト" EOL1 (STRONG "old") " - オブジェクト"
     EOL1 (STRONG "predicate") " - 関数名のシンボルか、" "1つの引数をとりgeneralized-booleanを返却する関数" EOL1
     (STRONG "tree") " - ツリー" EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "new-tree") " - ツリー")
    (CHAPTER ("## 定義") 2 (CODE1 "subst") ", " (CODE1 "subst-if") ", "
     (CODE1 "subst-if-not") "は、" (STRONG "tree") "の置換操作を行います。" "各関数は" (STRONG "tree")
     "に対して" (STRONG "test") "を満たすような特定の" (STRONG "old") "要素か、" "あるいは部分式を満たすものを検索します。"
     EOL2 (CODE1 "nsubst") ", " (CODE1 "nsubst-if") ", " (CODE1 "nsubst-if-not") "はそれぞれ"
     (CODE1 "subst") ", " (CODE1 "subst-if") ", " (CODE1 "subst-if-not") "と似ていますが、" "元の"
     (STRONG "tree") "を修正するところが違っています。" EOL2 (CODE1 "subst") "は" (STRONG "tree")
     "のコピーを作成し、" "全てのサブツリー、葉、親の" (CODE1 "car") "部、" (CODE1 "cdr") "部、すべてに対して"
     (STRONG "old") "と" (STRONG "test") "が満たされる部分を" (STRONG "new") "に置換します。" EOL2
     (CODE1 "nsubst") "は、" (CODE1 "subst") "の破壊的バージョンです。" (STRONG "tree") "のリスト構造は、それぞれの"
     (STRONG "tree") "の葉に対して、" (STRONG "old") "と" (STRONG "test") "が満たされる葉の部分を"
     (STRONG "new") "で破壊的に置換することによって変更されます" EOL2 (CODE1 "subst") ", " (CODE1 "subst-if")
     ", " (CODE1 "subst-if-not") "は、" "もし関数が成功すると、" "指定された要素のそれぞれの出現を" (STRONG "new")
     "要素で置き換えられたものか、" "あるいは部分式で置き換えられたものの新たなコピーが返却されます。" "もし変更が生じなかったときは、元の"
     (STRONG "tree") "が返却されるかもしれません。" "元の" (STRONG "tree") "が変更されないとしても、"
     "返却値のツリーは元のツリーと" "ストレージを共有しているかもしれません。" EOL2 (CODE1 "nsubst") ", "
     (CODE1 "nsubst-if") ", " (CODE1 "nsubst-if-not") "は、" "元の" (STRONG "tree")
     "を修正し返却します。" "しかし関数の結果は、" (STRONG "tree") "と" (CODE1 "eq") "で等しくないかもしれません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq tree1 '(1 (1 2) (1 2 3) (1 2 3 4))) =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(subst \"two\" 2 tree1) =>  (1 (1 \"two\") (1 \"two\" 3) (1 \"two\" 3 4))"
      "(subst \"five\" 5 tree1) =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(eq tree1 (subst \"five\" 5 tree1)) =>  implementation-dependent"
      "(subst 'tempest 'hurricane" "       '(shakespeare wrote (the hurricane)))"
      "=>  (SHAKESPEARE WROTE (THE TEMPEST))"
      "(subst 'foo 'nil '(shakespeare wrote (twelfth night)))"
      "=>  (SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO)"
      "(subst '(a . cons) '(old . pair)"
      "       '((old . spice) ((old . shoes) old . pair) (old . pair))"
      "       :test #'equal)" "=>  ((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS))"
      NIL "(subst-if 5 #'listp tree1) =>  5" "(subst-if-not '(x) #'consp tree1) "
      "=>  (1 X)" NIL "tree1 =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(nsubst 'x 3 tree1 :key #'(lambda (y) (and (listp y) (third y)))) "
      "=>  (1 (1 2) X X)" "tree1 =>  (1 (1 2) X X)"))
    (CHAPTER ("## 副作用") 2 (CODE1 "nsubst") ", " (CODE1 "nsubst-if") ", "
     (CODE1 "nsubst-if-not") "は、" (STRONG "tree") "のツリー構造を変更するかもしれません。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "substitute") "," (CODE1 "nsubstitute") ","
     "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "subst-if-not") "と" (CODE1 "nsubst-if-not") "は非推奨です。" EOL2 (CODE1 "subst")
     "は一例として次のように定義できます。"
     (CODE3 "```lisp" "```" "(defun subst (old new tree &rest x &key test test-not key)"
      "  (cond ((satisfies-the-test old tree :test test"
      "                             :test-not test-not :key key)" "         new)"
      "        ((atom tree) tree)"
      "        (t (let ((a (apply #'subst old new (car tree) x))"
      "                 (d (apply #'subst old new (cdr tree) x)))"
      "             (if (and (eql a (car tree))"
      "                      (eql d (cdr tree)))" "                 tree"
      "                 (cons a d))))))"))))
(setf (gethash '("NSUBST-IF" . "FUNCTION") *table*) (gethash "NSUBST-IF" *table*))
(setf (gethash "NSUBST-IF-NOT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SUBST") ", " (CODE1 "SUBST-IF") ", "
     (CODE1 "SUBST-IF-NOT") "," (CODE1 "NSUBST") ", " (CODE1 "NSUBST-IF") ", "
     (CODE1 "NSUBST-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "subst") " " (STRONG "new") " " (STRONG "old") " "
     (STRONG "tree") " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not")
     " => " (STRONG "new-tree") EOL1 (CODE1 "subst-if") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "subst-if-not") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "nsubst") " " (STRONG "new") " " (STRONG "old") " "
     (STRONG "tree") " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not")
     " => " (STRONG "new-tree") EOL1 (CODE1 "nsubst-if") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "nsubst-if-not") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "new") " - オブジェクト" EOL1 (STRONG "old") " - オブジェクト"
     EOL1 (STRONG "predicate") " - 関数名のシンボルか、" "1つの引数をとりgeneralized-booleanを返却する関数" EOL1
     (STRONG "tree") " - ツリー" EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "new-tree") " - ツリー")
    (CHAPTER ("## 定義") 2 (CODE1 "subst") ", " (CODE1 "subst-if") ", "
     (CODE1 "subst-if-not") "は、" (STRONG "tree") "の置換操作を行います。" "各関数は" (STRONG "tree")
     "に対して" (STRONG "test") "を満たすような特定の" (STRONG "old") "要素か、" "あるいは部分式を満たすものを検索します。"
     EOL2 (CODE1 "nsubst") ", " (CODE1 "nsubst-if") ", " (CODE1 "nsubst-if-not") "はそれぞれ"
     (CODE1 "subst") ", " (CODE1 "subst-if") ", " (CODE1 "subst-if-not") "と似ていますが、" "元の"
     (STRONG "tree") "を修正するところが違っています。" EOL2 (CODE1 "subst") "は" (STRONG "tree")
     "のコピーを作成し、" "全てのサブツリー、葉、親の" (CODE1 "car") "部、" (CODE1 "cdr") "部、すべてに対して"
     (STRONG "old") "と" (STRONG "test") "が満たされる部分を" (STRONG "new") "に置換します。" EOL2
     (CODE1 "nsubst") "は、" (CODE1 "subst") "の破壊的バージョンです。" (STRONG "tree") "のリスト構造は、それぞれの"
     (STRONG "tree") "の葉に対して、" (STRONG "old") "と" (STRONG "test") "が満たされる葉の部分を"
     (STRONG "new") "で破壊的に置換することによって変更されます" EOL2 (CODE1 "subst") ", " (CODE1 "subst-if")
     ", " (CODE1 "subst-if-not") "は、" "もし関数が成功すると、" "指定された要素のそれぞれの出現を" (STRONG "new")
     "要素で置き換えられたものか、" "あるいは部分式で置き換えられたものの新たなコピーが返却されます。" "もし変更が生じなかったときは、元の"
     (STRONG "tree") "が返却されるかもしれません。" "元の" (STRONG "tree") "が変更されないとしても、"
     "返却値のツリーは元のツリーと" "ストレージを共有しているかもしれません。" EOL2 (CODE1 "nsubst") ", "
     (CODE1 "nsubst-if") ", " (CODE1 "nsubst-if-not") "は、" "元の" (STRONG "tree")
     "を修正し返却します。" "しかし関数の結果は、" (STRONG "tree") "と" (CODE1 "eq") "で等しくないかもしれません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq tree1 '(1 (1 2) (1 2 3) (1 2 3 4))) =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(subst \"two\" 2 tree1) =>  (1 (1 \"two\") (1 \"two\" 3) (1 \"two\" 3 4))"
      "(subst \"five\" 5 tree1) =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(eq tree1 (subst \"five\" 5 tree1)) =>  implementation-dependent"
      "(subst 'tempest 'hurricane" "       '(shakespeare wrote (the hurricane)))"
      "=>  (SHAKESPEARE WROTE (THE TEMPEST))"
      "(subst 'foo 'nil '(shakespeare wrote (twelfth night)))"
      "=>  (SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO)"
      "(subst '(a . cons) '(old . pair)"
      "       '((old . spice) ((old . shoes) old . pair) (old . pair))"
      "       :test #'equal)" "=>  ((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS))"
      NIL "(subst-if 5 #'listp tree1) =>  5" "(subst-if-not '(x) #'consp tree1) "
      "=>  (1 X)" NIL "tree1 =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(nsubst 'x 3 tree1 :key #'(lambda (y) (and (listp y) (third y)))) "
      "=>  (1 (1 2) X X)" "tree1 =>  (1 (1 2) X X)"))
    (CHAPTER ("## 副作用") 2 (CODE1 "nsubst") ", " (CODE1 "nsubst-if") ", "
     (CODE1 "nsubst-if-not") "は、" (STRONG "tree") "のツリー構造を変更するかもしれません。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "substitute") "," (CODE1 "nsubstitute") ","
     "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "subst-if-not") "と" (CODE1 "nsubst-if-not") "は非推奨です。" EOL2 (CODE1 "subst")
     "は一例として次のように定義できます。"
     (CODE3 "```lisp" "```" "(defun subst (old new tree &rest x &key test test-not key)"
      "  (cond ((satisfies-the-test old tree :test test"
      "                             :test-not test-not :key key)" "         new)"
      "        ((atom tree) tree)"
      "        (t (let ((a (apply #'subst old new (car tree) x))"
      "                 (d (apply #'subst old new (cdr tree) x)))"
      "             (if (and (eql a (car tree))"
      "                      (eql d (cdr tree)))" "                 tree"
      "                 (cons a d))))))"))))
(setf (gethash '("NSUBST-IF-NOT" . "FUNCTION") *table*) (gethash "NSUBST-IF-NOT" *table*))
(setf (gethash "NSUBSTITUTE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SUBSTITUTE") ", " (CODE1 "SUBSTITUTE-IF") ", "
     (CODE1 "SUBSTITUTE-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "substitute") " " (STRONG "newitem") " "
     (STRONG "olditem") " " (STRONG "sequence") " &key " (STRONG "from-end") " "
     (STRONG "test") " " (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " "
     (STRONG "count") " " (STRONG "key") EOL1 "=> " (STRONG "result-sequence") EOL2
     (CODE1 "substitute-if") " " (STRONG "newitem") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") EOL1 "=> result-sequence"
     EOL2 (CODE1 "substitute-if-not") " " (STRONG "newitem") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") EOL1 "=> result-sequence"
     EOL2 (CODE1 "nsubstitute") " " (STRONG "newitem") " " (STRONG "olditem") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "test") " "
     (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> " (STRONG "result-sequence") EOL2 (CODE1 "nsubstitute-if")
     " " (STRONG "newitem") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> result-sequence" EOL2 (CODE1 "nsubstitute-if-not") " "
     (STRONG "newitem") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> result-sequence")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "newitem") " - オブジェクト" EOL1 (STRONG "olditem")
     " - オブジェクト" EOL1 (STRONG "sequence") " - 正常なシーケンス" EOL1 (STRONG "predicate")
     " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "from-end")
     " - generalized-boolean、デフォルトは" (STRONG "false") EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "count")
     " - 整数か" (CODE1 "nil") "。デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "result-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "substitute") "、" (CODE1 "substitute-if") "、"
     (CODE1 "substitute-if-not") "は、" "テストを満たす各要素が" (STRONG "newitem") "に置き換えられた、"
     (STRONG "sequence") "のコピーを返却します。" EOL2 (CODE1 "nsubstitute") "、"
     (CODE1 "nsubstitute-if") "、" (CODE1 "nsubstitute-if-not") "は、" "それぞれ"
     (CODE1 "substitute") "、" (CODE1 "substitute-if") "、" (CODE1 "substitute-if-not")
     "と似ていますが、" "しかし" (STRONG "sequence") "を修正するでしょう。" EOL2 "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のとき、返却値は" (CODE1 "vector") "であり、" (STRONG "sequence")
     "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence") "がリストなら、返却値はリストです。" EOL2
     (STRONG "count") "が与えられたとき、変更する要素数を制限できます。" "もしテストを満たす要素が" (STRONG "count")
     "を越えていたときは、" "それらの要素は左端か右端（" (STRONG "from-end") "の値による）から、" "ただ" (STRONG "count")
     "で指定された数だけ置き換えられます。" "もし" (STRONG "count") "負の値が指定されたときは、" (CODE1 "0")
     "が指定されたかのようにふるまいます。" "もし" (STRONG "count") "が" (CODE1 "nil") "のときは、" (STRONG "item")
     "にマッチした全てに影響します。" EOL2 (STRONG "from-end") "が" (STRONG "true") "のときは、" "ただ"
     (STRONG "count") "が指定されたとき（" (CODE1 "nil") "以外）が" "重要になります。"
     "このような場合、右端から（左端ではなく）テストを満たす" (STRONG "count") "の要素だけが置き換えられます。" EOL2
     (STRONG "predicate") ", " (STRONG "test") ", " (STRONG "test-not") "は、"
     "各シーケンスの要素に対して一回以上呼び出されるかもしれず、" "それらの副作用はどんな順番でも生じます。" EOL2 "これらすべての関数の返却値は、"
     (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start") ", " (STRONG "end")
     "に囲まれたサブシーケンスのテストを満たし" (STRONG "newitem") "に置き換えが生じたもの以外は、" "同じ要素を持ちます。" EOL2
     (CODE1 "substitute") "、" (CODE1 "substitute-if") "、" (CODE1 "substitute-if-not")
     "は、" "もし要素に変更が生じなかったときは、" (STRONG "sequence") "と共有されたシーケンスか、" "あるいは入力の"
     (STRONG "sequence") "と同一のものが返却されます。" EOL2 (CODE1 "nsubstitute") "、"
     (CODE1 "nsubstitute-if") "、" (CODE1 "nsubstitute-if-not") "は、" "もし"
     (STRONG "sequence") "がリストのときは" (CODE1 "setf") "の" (CODE1 "car") "を、" "もし"
     (STRONG "sequence") "が" (CODE1 "vector") "のときは" (CODE1 "aref") "を"
     (STRONG "sequence") "に対して行い、" (STRONG "newitem") "に置き換えます。" "もし" (STRONG "sequence")
     "がリストのときは、" "トップレベルのリストのどの" (CODE1 "cdr") "も変更できません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(substitute #\\. #\\SPACE \"0 2 4 6\") =>  \"0.2.4.6\""
      "(substitute 9 4 '(1 2 4 1 3 4 5)) =>  (1 2 9 1 3 9 5)"
      "(substitute 9 4 '(1 2 4 1 3 4 5) :count 1) =>  (1 2 9 1 3 4 5)"
      "(substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t)" "=>  (1 2 4 1 3 9 5)"
      "(substitute 9 3 '(1 2 4 1 3 4 5) :test #'>) =>  (9 9 4 9 3 4 5)" NIL
      "(substitute-if 0 #'evenp '((1) (2) (3) (4)) :start 2 :key #'car)"
      "=>  ((1) (2) (3) 0)"
      "(substitute-if 9 #'oddp '(1 2 4 1 3 4 5)) =>  (9 2 4 9 9 4 9)"
      "(substitute-if 9 #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)"
      "=>  (1 2 4 1 3 9 5)" NIL
      "(setq some-things (list 'a 'car 'b 'cdr 'c)) =>  (A CAR B CDR C)"
      "(nsubstitute-if \"function was here\" #'fboundp some-things"
      "                :count 1 :from-end t) =>  (A CAR B \"function was here\" C)"
      "some-things =>  (A CAR B \"function was here\" C)"
      "(setq alpha-tester (copy-seq \"ab \")) =>  \"ab \""
      "(nsubstitute-if-not #\\z #'alpha-char-p alpha-tester) =>  \"abz\""
      "alpha-tester =>  \"abz\""))
    (CHAPTER ("## 副作用") 2 (CODE1 "nsubstitute") "、" (CODE1 "nsubstitute-if") "、"
     (CODE1 "nsubstitute-if-not") "は、" (STRONG "sequence") "を修正します。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "subst") "," (CODE1 "nsubst") "," "3.2.1. コンパイラーの用語,"
     "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "返却値は"
     (CODE1 "simple") "かもしれませんし、そうでないかもしれません。" "また、返却値は" (STRONG "sequence")
     "と同一かもしれませんし、" "そうでないかもしれません。" EOL2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "substitute-if-not") "と" (CODE1 "nsubstitute-if-not") "は非推奨です。" EOL2
     "副作用による変形（" (CODE1 "nsubstitute") "など）は、" "通過するパスを変更する可能性があるので、"
     "共有構造や循環構造が現れるものでは、" "副作用による修正がないものと比べると、" "驚くべき方法で変化する可能性があります。" "このような挙動を見るために、"
     "いくつかの実装では見られるかもしれない、" "次のような副作用の動作を考えてみましょう。"
     (CODE3 "```lisp" "```" "(defun test-it (fn)" "  (let ((x (cons 'b nil)))"
      "    (rplacd x x)" "    (funcall fn 'a 'b x :count 1)))"
      "(test-it #'substitute) =>  (A . #1=(B . #1#))"
      "(test-it #'nsubstitute) =>  (A . #1#)"))))
(setf (gethash '("NSUBSTITUTE" . "FUNCTION") *table*) (gethash "NSUBSTITUTE" *table*))
(setf (gethash "NSUBSTITUTE-IF" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SUBSTITUTE") ", " (CODE1 "SUBSTITUTE-IF") ", "
     (CODE1 "SUBSTITUTE-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "substitute") " " (STRONG "newitem") " "
     (STRONG "olditem") " " (STRONG "sequence") " &key " (STRONG "from-end") " "
     (STRONG "test") " " (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " "
     (STRONG "count") " " (STRONG "key") EOL1 "=> " (STRONG "result-sequence") EOL2
     (CODE1 "substitute-if") " " (STRONG "newitem") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") EOL1 "=> result-sequence"
     EOL2 (CODE1 "substitute-if-not") " " (STRONG "newitem") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") EOL1 "=> result-sequence"
     EOL2 (CODE1 "nsubstitute") " " (STRONG "newitem") " " (STRONG "olditem") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "test") " "
     (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> " (STRONG "result-sequence") EOL2 (CODE1 "nsubstitute-if")
     " " (STRONG "newitem") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> result-sequence" EOL2 (CODE1 "nsubstitute-if-not") " "
     (STRONG "newitem") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> result-sequence")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "newitem") " - オブジェクト" EOL1 (STRONG "olditem")
     " - オブジェクト" EOL1 (STRONG "sequence") " - 正常なシーケンス" EOL1 (STRONG "predicate")
     " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "from-end")
     " - generalized-boolean、デフォルトは" (STRONG "false") EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "count")
     " - 整数か" (CODE1 "nil") "。デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "result-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "substitute") "、" (CODE1 "substitute-if") "、"
     (CODE1 "substitute-if-not") "は、" "テストを満たす各要素が" (STRONG "newitem") "に置き換えられた、"
     (STRONG "sequence") "のコピーを返却します。" EOL2 (CODE1 "nsubstitute") "、"
     (CODE1 "nsubstitute-if") "、" (CODE1 "nsubstitute-if-not") "は、" "それぞれ"
     (CODE1 "substitute") "、" (CODE1 "substitute-if") "、" (CODE1 "substitute-if-not")
     "と似ていますが、" "しかし" (STRONG "sequence") "を修正するでしょう。" EOL2 "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のとき、返却値は" (CODE1 "vector") "であり、" (STRONG "sequence")
     "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence") "がリストなら、返却値はリストです。" EOL2
     (STRONG "count") "が与えられたとき、変更する要素数を制限できます。" "もしテストを満たす要素が" (STRONG "count")
     "を越えていたときは、" "それらの要素は左端か右端（" (STRONG "from-end") "の値による）から、" "ただ" (STRONG "count")
     "で指定された数だけ置き換えられます。" "もし" (STRONG "count") "負の値が指定されたときは、" (CODE1 "0")
     "が指定されたかのようにふるまいます。" "もし" (STRONG "count") "が" (CODE1 "nil") "のときは、" (STRONG "item")
     "にマッチした全てに影響します。" EOL2 (STRONG "from-end") "が" (STRONG "true") "のときは、" "ただ"
     (STRONG "count") "が指定されたとき（" (CODE1 "nil") "以外）が" "重要になります。"
     "このような場合、右端から（左端ではなく）テストを満たす" (STRONG "count") "の要素だけが置き換えられます。" EOL2
     (STRONG "predicate") ", " (STRONG "test") ", " (STRONG "test-not") "は、"
     "各シーケンスの要素に対して一回以上呼び出されるかもしれず、" "それらの副作用はどんな順番でも生じます。" EOL2 "これらすべての関数の返却値は、"
     (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start") ", " (STRONG "end")
     "に囲まれたサブシーケンスのテストを満たし" (STRONG "newitem") "に置き換えが生じたもの以外は、" "同じ要素を持ちます。" EOL2
     (CODE1 "substitute") "、" (CODE1 "substitute-if") "、" (CODE1 "substitute-if-not")
     "は、" "もし要素に変更が生じなかったときは、" (STRONG "sequence") "と共有されたシーケンスか、" "あるいは入力の"
     (STRONG "sequence") "と同一のものが返却されます。" EOL2 (CODE1 "nsubstitute") "、"
     (CODE1 "nsubstitute-if") "、" (CODE1 "nsubstitute-if-not") "は、" "もし"
     (STRONG "sequence") "がリストのときは" (CODE1 "setf") "の" (CODE1 "car") "を、" "もし"
     (STRONG "sequence") "が" (CODE1 "vector") "のときは" (CODE1 "aref") "を"
     (STRONG "sequence") "に対して行い、" (STRONG "newitem") "に置き換えます。" "もし" (STRONG "sequence")
     "がリストのときは、" "トップレベルのリストのどの" (CODE1 "cdr") "も変更できません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(substitute #\\. #\\SPACE \"0 2 4 6\") =>  \"0.2.4.6\""
      "(substitute 9 4 '(1 2 4 1 3 4 5)) =>  (1 2 9 1 3 9 5)"
      "(substitute 9 4 '(1 2 4 1 3 4 5) :count 1) =>  (1 2 9 1 3 4 5)"
      "(substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t)" "=>  (1 2 4 1 3 9 5)"
      "(substitute 9 3 '(1 2 4 1 3 4 5) :test #'>) =>  (9 9 4 9 3 4 5)" NIL
      "(substitute-if 0 #'evenp '((1) (2) (3) (4)) :start 2 :key #'car)"
      "=>  ((1) (2) (3) 0)"
      "(substitute-if 9 #'oddp '(1 2 4 1 3 4 5)) =>  (9 2 4 9 9 4 9)"
      "(substitute-if 9 #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)"
      "=>  (1 2 4 1 3 9 5)" NIL
      "(setq some-things (list 'a 'car 'b 'cdr 'c)) =>  (A CAR B CDR C)"
      "(nsubstitute-if \"function was here\" #'fboundp some-things"
      "                :count 1 :from-end t) =>  (A CAR B \"function was here\" C)"
      "some-things =>  (A CAR B \"function was here\" C)"
      "(setq alpha-tester (copy-seq \"ab \")) =>  \"ab \""
      "(nsubstitute-if-not #\\z #'alpha-char-p alpha-tester) =>  \"abz\""
      "alpha-tester =>  \"abz\""))
    (CHAPTER ("## 副作用") 2 (CODE1 "nsubstitute") "、" (CODE1 "nsubstitute-if") "、"
     (CODE1 "nsubstitute-if-not") "は、" (STRONG "sequence") "を修正します。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "subst") "," (CODE1 "nsubst") "," "3.2.1. コンパイラーの用語,"
     "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "返却値は"
     (CODE1 "simple") "かもしれませんし、そうでないかもしれません。" "また、返却値は" (STRONG "sequence")
     "と同一かもしれませんし、" "そうでないかもしれません。" EOL2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "substitute-if-not") "と" (CODE1 "nsubstitute-if-not") "は非推奨です。" EOL2
     "副作用による変形（" (CODE1 "nsubstitute") "など）は、" "通過するパスを変更する可能性があるので、"
     "共有構造や循環構造が現れるものでは、" "副作用による修正がないものと比べると、" "驚くべき方法で変化する可能性があります。" "このような挙動を見るために、"
     "いくつかの実装では見られるかもしれない、" "次のような副作用の動作を考えてみましょう。"
     (CODE3 "```lisp" "```" "(defun test-it (fn)" "  (let ((x (cons 'b nil)))"
      "    (rplacd x x)" "    (funcall fn 'a 'b x :count 1)))"
      "(test-it #'substitute) =>  (A . #1=(B . #1#))"
      "(test-it #'nsubstitute) =>  (A . #1#)"))))
(setf (gethash '("NSUBSTITUTE-IF" . "FUNCTION") *table*) (gethash "NSUBSTITUTE-IF" *table*))
(setf (gethash "NSUBSTITUTE-IF-NOT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SUBSTITUTE") ", " (CODE1 "SUBSTITUTE-IF") ", "
     (CODE1 "SUBSTITUTE-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "substitute") " " (STRONG "newitem") " "
     (STRONG "olditem") " " (STRONG "sequence") " &key " (STRONG "from-end") " "
     (STRONG "test") " " (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " "
     (STRONG "count") " " (STRONG "key") EOL1 "=> " (STRONG "result-sequence") EOL2
     (CODE1 "substitute-if") " " (STRONG "newitem") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") EOL1 "=> result-sequence"
     EOL2 (CODE1 "substitute-if-not") " " (STRONG "newitem") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") EOL1 "=> result-sequence"
     EOL2 (CODE1 "nsubstitute") " " (STRONG "newitem") " " (STRONG "olditem") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "test") " "
     (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> " (STRONG "result-sequence") EOL2 (CODE1 "nsubstitute-if")
     " " (STRONG "newitem") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> result-sequence" EOL2 (CODE1 "nsubstitute-if-not") " "
     (STRONG "newitem") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> result-sequence")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "newitem") " - オブジェクト" EOL1 (STRONG "olditem")
     " - オブジェクト" EOL1 (STRONG "sequence") " - 正常なシーケンス" EOL1 (STRONG "predicate")
     " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "from-end")
     " - generalized-boolean、デフォルトは" (STRONG "false") EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "count")
     " - 整数か" (CODE1 "nil") "。デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "result-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "substitute") "、" (CODE1 "substitute-if") "、"
     (CODE1 "substitute-if-not") "は、" "テストを満たす各要素が" (STRONG "newitem") "に置き換えられた、"
     (STRONG "sequence") "のコピーを返却します。" EOL2 (CODE1 "nsubstitute") "、"
     (CODE1 "nsubstitute-if") "、" (CODE1 "nsubstitute-if-not") "は、" "それぞれ"
     (CODE1 "substitute") "、" (CODE1 "substitute-if") "、" (CODE1 "substitute-if-not")
     "と似ていますが、" "しかし" (STRONG "sequence") "を修正するでしょう。" EOL2 "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のとき、返却値は" (CODE1 "vector") "であり、" (STRONG "sequence")
     "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence") "がリストなら、返却値はリストです。" EOL2
     (STRONG "count") "が与えられたとき、変更する要素数を制限できます。" "もしテストを満たす要素が" (STRONG "count")
     "を越えていたときは、" "それらの要素は左端か右端（" (STRONG "from-end") "の値による）から、" "ただ" (STRONG "count")
     "で指定された数だけ置き換えられます。" "もし" (STRONG "count") "負の値が指定されたときは、" (CODE1 "0")
     "が指定されたかのようにふるまいます。" "もし" (STRONG "count") "が" (CODE1 "nil") "のときは、" (STRONG "item")
     "にマッチした全てに影響します。" EOL2 (STRONG "from-end") "が" (STRONG "true") "のときは、" "ただ"
     (STRONG "count") "が指定されたとき（" (CODE1 "nil") "以外）が" "重要になります。"
     "このような場合、右端から（左端ではなく）テストを満たす" (STRONG "count") "の要素だけが置き換えられます。" EOL2
     (STRONG "predicate") ", " (STRONG "test") ", " (STRONG "test-not") "は、"
     "各シーケンスの要素に対して一回以上呼び出されるかもしれず、" "それらの副作用はどんな順番でも生じます。" EOL2 "これらすべての関数の返却値は、"
     (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start") ", " (STRONG "end")
     "に囲まれたサブシーケンスのテストを満たし" (STRONG "newitem") "に置き換えが生じたもの以外は、" "同じ要素を持ちます。" EOL2
     (CODE1 "substitute") "、" (CODE1 "substitute-if") "、" (CODE1 "substitute-if-not")
     "は、" "もし要素に変更が生じなかったときは、" (STRONG "sequence") "と共有されたシーケンスか、" "あるいは入力の"
     (STRONG "sequence") "と同一のものが返却されます。" EOL2 (CODE1 "nsubstitute") "、"
     (CODE1 "nsubstitute-if") "、" (CODE1 "nsubstitute-if-not") "は、" "もし"
     (STRONG "sequence") "がリストのときは" (CODE1 "setf") "の" (CODE1 "car") "を、" "もし"
     (STRONG "sequence") "が" (CODE1 "vector") "のときは" (CODE1 "aref") "を"
     (STRONG "sequence") "に対して行い、" (STRONG "newitem") "に置き換えます。" "もし" (STRONG "sequence")
     "がリストのときは、" "トップレベルのリストのどの" (CODE1 "cdr") "も変更できません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(substitute #\\. #\\SPACE \"0 2 4 6\") =>  \"0.2.4.6\""
      "(substitute 9 4 '(1 2 4 1 3 4 5)) =>  (1 2 9 1 3 9 5)"
      "(substitute 9 4 '(1 2 4 1 3 4 5) :count 1) =>  (1 2 9 1 3 4 5)"
      "(substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t)" "=>  (1 2 4 1 3 9 5)"
      "(substitute 9 3 '(1 2 4 1 3 4 5) :test #'>) =>  (9 9 4 9 3 4 5)" NIL
      "(substitute-if 0 #'evenp '((1) (2) (3) (4)) :start 2 :key #'car)"
      "=>  ((1) (2) (3) 0)"
      "(substitute-if 9 #'oddp '(1 2 4 1 3 4 5)) =>  (9 2 4 9 9 4 9)"
      "(substitute-if 9 #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)"
      "=>  (1 2 4 1 3 9 5)" NIL
      "(setq some-things (list 'a 'car 'b 'cdr 'c)) =>  (A CAR B CDR C)"
      "(nsubstitute-if \"function was here\" #'fboundp some-things"
      "                :count 1 :from-end t) =>  (A CAR B \"function was here\" C)"
      "some-things =>  (A CAR B \"function was here\" C)"
      "(setq alpha-tester (copy-seq \"ab \")) =>  \"ab \""
      "(nsubstitute-if-not #\\z #'alpha-char-p alpha-tester) =>  \"abz\""
      "alpha-tester =>  \"abz\""))
    (CHAPTER ("## 副作用") 2 (CODE1 "nsubstitute") "、" (CODE1 "nsubstitute-if") "、"
     (CODE1 "nsubstitute-if-not") "は、" (STRONG "sequence") "を修正します。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "subst") "," (CODE1 "nsubst") "," "3.2.1. コンパイラーの用語,"
     "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "返却値は"
     (CODE1 "simple") "かもしれませんし、そうでないかもしれません。" "また、返却値は" (STRONG "sequence")
     "と同一かもしれませんし、" "そうでないかもしれません。" EOL2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "substitute-if-not") "と" (CODE1 "nsubstitute-if-not") "は非推奨です。" EOL2
     "副作用による変形（" (CODE1 "nsubstitute") "など）は、" "通過するパスを変更する可能性があるので、"
     "共有構造や循環構造が現れるものでは、" "副作用による修正がないものと比べると、" "驚くべき方法で変化する可能性があります。" "このような挙動を見るために、"
     "いくつかの実装では見られるかもしれない、" "次のような副作用の動作を考えてみましょう。"
     (CODE3 "```lisp" "```" "(defun test-it (fn)" "  (let ((x (cons 'b nil)))"
      "    (rplacd x x)" "    (funcall fn 'a 'b x :count 1)))"
      "(test-it #'substitute) =>  (A . #1=(B . #1#))"
      "(test-it #'nsubstitute) =>  (A . #1#)"))))
(setf (gethash '("NSUBSTITUTE-IF-NOT" . "FUNCTION") *table*) (gethash "NSUBSTITUTE-IF-NOT" *table*))
(setf (gethash "NTH" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "NTH"))
    (CHAPTER ("## 構文") 2 (CODE1 "nth") " " (STRONG "n") " " (STRONG "list") " => "
     (STRONG "object") EOL1 "(" (CODE1 "setf") " (" (CODE1 "nth") " " (STRONG "n") " "
     (STRONG "list") ") " (STRONG "new-object") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "n") " - 非負の整数" EOL1 (STRONG "list")
     " - リスト、ドットリストと循環リストも受け付けます。" EOL1 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "nth") "は、" (STRONG "list") "の" (CODE1 "car")
     "部を「0番目」の要素したときの、" (STRONG "list") "の" (STRONG "n") "番目の要素を示します。" "具体的には次のようになります。"
     (CODE3 "```lisp" "```" "(nth n list) ==  (car (nthcdr n list))") EOL2 (CODE1 "nth")
     "は、" (CODE1 "setf") "の" (CODE1 "place") "として指定できます。" "具体的には次のようになります。"
     (CODE3 "```lisp" "```"
      "(setf (nth n list) new-object) ==  (setf (car (nthcdr n list)) new-object)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(nth 0 '(foo bar baz)) =>  FOO"
      "(nth 1 '(foo bar baz)) =>  BAR" "(nth 3 '(foo bar baz)) =>  NIL"
      "(setq 0-to-3 (list 0 1 2 3)) =>  (0 1 2 3)"
      "(setf (nth 2 0-to-3) \"two\") =>  \"two\"" "0-to-3 =>  (0 1 \"two\" 3)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "elt") "," (CODE1 "first") "," (CODE1 "nthcdr"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("NTH" . "ACCESSOR") *table*) (gethash "NTH" *table*))
(setf (gethash "NTH-VALUE" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "NTH-VALUE"))
    (CHAPTER ("## 構文") 2 (CODE1 "nth-value") " " (STRONG "n") " " (STRONG "form") " => "
     (STRONG "object"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "n") " - 非負の整数。評価されます。" EOL1 (STRONG "form")
     " - フォーム。下記の説明に従って評価されます。" EOL1 (STRONG "object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "n") "が評価され、そのつぎに" (STRONG "form") "が評価され、"
     (STRONG "form") "によって返却された" (STRONG "n") "番目の値のみを返却します。" "もし" (STRONG "n") "が"
     (STRONG "form") "の返却数以上の場合は" (CODE1 "nil") "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(nth-value 0 (values 'a 'b)) =>  A"
      "(nth-value 1 (values 'a 'b)) =>  B" "(nth-value 2 (values 'a 'b)) =>  NIL"
      "(let* ((x 83927472397238947423879243432432432)" "       (y 32423489732)"
      "       (a (nth-value 1 (floor x y)))" "       (b (mod x y)))"
      "  (values a b (= a b)))" "=>  3332987528, 3332987528, true"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "multiple-value-list") "," (CODE1 "nth"))
    (CHAPTER ("## 備考") 2 "操作において、下記の関数は等しいと言えますが、" (CODE1 "nth-value")
     "は実装によってはより効率と言えます。" "なぜなら、例えばコンス化することを回避できるからです。"
     (CODE3 "```lisp" "```" "(nth-value n form) == (nth n (multiple-value-list form))"))))
(setf (gethash '("NTH-VALUE" . "MACRO") *table*) (gethash "NTH-VALUE" *table*))
(setf (gethash "NTHCDR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "NTHCDR"))
    (CHAPTER ("## 構文") 2 (CODE1 "nthcdr") " " (STRONG "n") " " (STRONG "list") " => "
     (STRONG "tail"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "n") " - 非負の整数" EOL1 (STRONG "list")
     " - リスト。ドットリストと循環リストを受け付けます。" EOL1 (STRONG "tail") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "list") "に対して" (CODE1 "cdr") "を" (STRONG "n")
     "回連続で呼び出して得られる" "末尾を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(nthcdr 0 '()) =>  NIL" "(nthcdr 3 '()) =>  NIL"
      "(nthcdr 0 '(a b c)) =>  (A B C)" "(nthcdr 2 '(a b c)) =>  (C)"
      "(nthcdr 4 '(a b c)) =>  ()" "(nthcdr 1 '(0 . 1)) =>  1" NIL
      "(locally (declare (optimize (safety 3)))" "  (nthcdr 3 '(0 . 1)))"
      "Error: 1のCDRを取得しようとしました。"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "n") "が非負の整数ではないとき、型" (CODE1 "type-error") "が発生します。"
     EOL2 (STRONG "n") "が1より大きい整数のとき、" (CODE1 "(nthcdr n list)") "によって行われるエラーチェックは、"
     (CODE1 "(nthcdr (- n 1) (cdr list))") "によるものと同じです。" "関数" (CODE1 "cdr") "をご確認ください。")
    (CHAPTER ("## 参考") 2 (CODE1 "cdr") "," (CODE1 "nth") "," (CODE1 "rest"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("NTHCDR" . "FUNCTION") *table*) (gethash "NTHCDR" *table*))
(setf (gethash "NULL" *table*)
  '("NULL FUNCTION" EOL1 "NULL SYSTEM-CLASS" EOL1))
(setf (gethash '("NULL" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "NULL"))
    (CHAPTER ("## 構文") 2 (CODE1 "null") " " (STRONG "object") " => " (STRONG "boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "boolean")
     " - ブール値")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が空のリストなら" (CODE1 "t") "を、" "それ以外は"
     (CODE1 "nil") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(null '()) =>  T" "(null nil) =>  T" "(null t) =>  NIL"
      "(null 1) =>  NIL"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "not"))
    (CHAPTER ("## 備考") 2 (CODE1 "null") "は、空のリストかどうかテストするときに使用され、" "一方、" (CODE1 "not")
     "はブール値（あるいはgeneralized-boolean）を" "反転させるときに使うことを意図しています。" "操作上では、" (CODE1 "null")
     "と" (CODE1 "not") "は同じ結果を計算するので、" "どちらを使うかはスタイルの問題です。"
     (CODE3 "```lisp" "```" "(null object) == (typep object 'null) == (eq object '())"))))
(setf (gethash '("NULL" . "SYSTEM-CLASS") *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "NULL"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "null") "," (CODE1 "symbol") "," (CODE1 "list")
     "," (CODE1 "sequence") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "null") "の唯一のオブジェクトは、" (CODE1 "nil") "です。"
     "このオブジェクトは、空のリストの表現であり、" (CODE1 "()") "と記載することもできます。")
    (CHAPTER ("## 参考") 2 "2.3.4. トークンとしてのシンボル," "2.4.1. 左括弧," "22.1.3.3. シンボルの印字")))
(setf (gethash "NUNION" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "UNION") ", " (CODE1 "NUNION"))
    (CHAPTER ("## 構文") 2 (CODE1 "union") " " (STRONG "list-1") " " (STRONG "list-2")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "result-list") EOL1 (CODE1 "nunion") " " (STRONG "list-1") " "
     (STRONG "list-2") " &key " (STRONG "key") " " (STRONG "test") " "
     (STRONG "test-not") " => " (STRONG "result-list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list-1") " - 通常のリスト" EOL1 (STRONG "list-2")
     " - 通常のリスト" EOL1 (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test-not") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "result-list") " - リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "union") "と" (CODE1 "nunion") "は、" (STRONG "list-1") "か"
     (STRONG "list-2") "のどちらかに生じたすべての要素を含むリストを返却します。" EOL2 (STRONG "list-1") "のひとつの要素と、"
     (STRONG "list-2") "のひとつの要素からなる、" "全ての順序付けされたペアに対して、" (CODE1 ":test") "か"
     (CODE1 ":test-not") "を使ってテストが満たされるかどうかを決定します。" (CODE1 ":test") "か"
     (CODE1 ":test-not") "の関数の最初の要素は" (STRONG "list-1") "の要素であり、" (CODE1 ":key")
     "関数によって返却されたものです（もし" (CODE1 ":key") "が指定されたなら）。" "二番目の引数は" (STRONG "list-2")
     "の要素であり、" (CODE1 ":key") "関数によって返却されたものです（もし" (CODE1 ":key") "が指定されたなら）。" EOL2
     (CODE1 ":key") "関数の引数は、" (STRONG "list-1") "か" (STRONG "list-2") "の要素です。"
     "返却値は、引数で与えられたリスト要素からなる、" "判定に使われる要素の部分です。" "もし" (CODE1 ":key") "が与えられないか、あるいは"
     (CODE1 "nil") "が指定されたとき、" (STRONG "list-1") "と" (STRONG "list-2") "の要素自身がが使われ、"
     (CODE1 ":test") "か" (CODE1 ":test-not") "関数に供給されます。" EOL2 "全てのマッチしたペアに対して、"
     "そのペアの2つの要素のうちのひとつが結果に含まれます。" (STRONG "list-1") "か" (STRONG "list-2") "のどちらかの要素が、"
     "もう一方の要素にマッチしないものがあれば、それが結果に含まれます。" EOL2 (STRONG "list-1") "と" (STRONG "list-2")
     "に重複があるとき、" "重複している要素のうちひとつだけが結果に含まれます。" (STRONG "list-1") "か" (STRONG "list-2")
     "のどちらかの中に重複するものがあるときは、" "その冗長な要素は結果に現れるかもしれませんし、" "現れないかもしれません。" EOL2 "結果の要素の順番は、"
     (STRONG "list-1") "と" (STRONG "list-2") "の順番を反映する必要はありません。" "適切に評価されたのであれば、"
     (STRONG "list-1") "と" (STRONG "list-2") "は、" "結果のリストに対して" (CODE1 "eq")
     "で一致するかもしれません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(union '(a b c) '(f a d))" "=>  (A B C F D)"
      "OR=>  (B C F A D)" "OR=>  (D F A B C)"
      "(union '((x 5) (y 6)) '((z 2) (x 4)) :key #'car)" "=>  ((X 5) (Y 6) (Z 2))"
      "OR=>  ((X 4) (Y 6) (Z 2))" NIL "(setq lst1 (list 1 2 '(1 2) \"a\" \"b\")"
      "      lst2 (list 2 3 '(2 3) \"B\" \"C\"))" "=>  (2 3 (2 3) \"B\" \"C\")"
      "(nunion lst1 lst2)" "=>  (1 (1 2) \"a\" \"b\" 2 3 (2 3) \"B\" \"C\") "
      "OR=>  (1 2 (1 2) \"a\" \"b\" \"C\" \"B\" (2 3) 3)"))
    (CHAPTER ("## 副作用") 2 (CODE1 "nunion") "は、" (STRONG "list-1") "か" (STRONG "list-2")
     "のリスト構造の" (CODE1 "car") ", " (CODE1 "cdr") "の" "どの部分も修正することが許されています。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list-1") "と" (STRONG "list-2") "が通常のリストではないとき、" "型"
     (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "intersection") "," "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 (CODE1 "nunion")
     "の副作用は必要ないため、" "移植可能なコードにおいては副作用のみを期待した姿勢で使うべきではありません。")))
(setf (gethash '("NUNION" . "FUNCTION") *table*) (gethash "NUNION" *table*))
(setf (gethash "OPEN" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "OPEN"))
    (CHAPTER ("## 構文") 2 (CODE1 "open") " " (STRONG "filespec") " " (CODE1 "&key") " "
     (STRONG "direction") " " (STRONG "element-type") " " (STRONG "if-exists") " "
     (STRONG "if-does-not-exist") " " (STRONG "external-format") EOL1 " => "
     (STRONG "stream"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "filespec") " - パス名指定子" EOL1 (STRONG "direction")
     " - " (CODE1 ":input") ", " (CODE1 ":output") ", " (CODE1 ":io") ", "
     (CODE1 ":probe") "のどれか。" "デフォルトは" (CODE1 ":input") "。" EOL1 (STRONG "element-type")
     " -" (CODE1 "character") "として認識可能なサブタイプの型指定子か、" "整数の有限値として認識可能なサブタイプの型指定子か、"
     "シンボルである" (CODE1 "signed-byte") ", " (CODE1 "unsigned-byte") "のうちのひとつか、" "あるいは"
     (CODE1 ":default") "。" "デフォルトは" (CODE1 "character") "。" EOL1 (STRONG "if-exists")
     " - " (CODE1 ":error") ", " (CODE1 ":new-version") ", " (CODE1 ":rename") ", "
     (CODE1 ":rename-and-delete") "," (CODE1 ":overwrite") ", " (CODE1 ":append") ", "
     (CODE1 ":supersede") ", " (CODE1 "nil") "のどれか。" "デフォルトは、" (STRONG "filespec")
     "のバージョンの要素が" (CODE1 ":newest") "のときは" (CODE1 ":new-version") "、" "それ以外のときは"
     (CODE1 ":error") "。" EOL1 (STRONG "if-does-not-exist") " - " (CODE1 ":error") ", "
     (CODE1 ":create") ", " (CODE1 "nil") "のどれか。" "デフォルトは、もし" (STRONG "direction") "が"
     (CODE1 ":input") "であるか" (STRONG "if-exists") "が" (CODE1 ":overwrite") "か"
     (CODE1 ":append") "のときは" (CODE1 ":error") "。" (STRONG "direction") "が"
     (CODE1 ":output") "か" (CODE1 ":io") "でありかつ" (STRONG "if-exists") "が"
     (CODE1 ":overwrite") "でも" (CODE1 ":append") "でもないときは" (CODE1 ":create") "。"
     (STRONG "direction") "が" (CODE1 ":probe") "のときは" (CODE1 "nil") "。" EOL1
     (STRONG "external-format") " - 外部ファイルフォーマット指定子。デフォルトは" (CODE1 ":default") "。" EOL1
     (STRONG "stream") " - ファイルストリームか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "open") "は、" (STRONG "filespec") "によって指定されたファイルと接続した"
     "ファイルストリームを作成し、開き、返却します。" (STRONG "filespec") "は開かれるファイルの名前です。" "もし"
     (STRONG "filespec") "指定子がストリームのとき、" "そのストリームは最初に閉じられたり、" "あるいはその他の影響を受けることはありません。"
     EOL2 (CODE1 "open") "のキーワード引数は、" "返却されるファイルストリームの特性と、" "どのようにエラーを扱うかを指定します。" EOL2
     (STRONG "direction") "が" (CODE1 ":input") "か" (CODE1 ":probe") "のときか、" "あるいは"
     (STRONG "if-exists") "が" (CODE1 ":new-version") "ではなく" "同時に" (STRONG "filespec")
     "のバージョン要素が" (CODE1 ":newest") "のときは、" "開かれたファイルはすでにファイルシステム内に存在しているので、"
     "そのバージョンはファイルシステム内の、" "他のパス名の要素が" (STRONG "filespec") "と同じである"
     "他のどんなファイルのものより大きなバージョンになります。" EOL2 "実装は" (CODE1 "open") "の全てのキーワードオプションを識別し、"
     "ホストオペレーティングシステムの構造上で" "適切な処理を行うよう要求されます。" "例えば、もしファイルシステムが" "ファイルのバージョンの区別をサポートせず、"
     "さらに削除と抹消（" (CODE1 "deleting") "と" (CODE1 "expunging") "）の表記を区別できないとき、"
     (CODE1 ":new-version") "は" (CODE1 ":rename") "か" (CODE1 ":supersede") "と同じように扱われ、"
     (CODE1 ":rename-and-delete") "は" (CODE1 ":supersede") "と同じように扱われることが考えられます。" EOL2
     "- " (CODE1 ":direction") EOL1 "  - " (STRONG "direction") "で使用可能な値を示します。"
     "    これは作成される" (STRONG "stream") "の性質に対してどのような影響があるかを指定します。" "  - " (CODE1 ":input")
     "    - 入力ファイルストリームの生成を行います。" "  - " (CODE1 ":output") "    - 出力ファイルストリームの生成を行います。"
     "  - " (CODE1 ":io") "    - 双方向ファイルストリームの生成を行います。" "  - 「非方向性」ファイルストリームの生成を行います。"
     "    この効果は、ファイルストリームが生成されてから、" "    " (CODE1 "open") "によって返却される前にクローズされます。" EOL2
     "- " (CODE1 ":element-type") "  - " (STRONG "element-type")
     "はファイルストリームのデータの単位を指定します。" "    もし" (CODE1 ":default") "が指定されたとき、"
     "    その単位はファイルシステムによって決まり、" "    可能であればファイルを元に決定されます。" EOL2 "- "
     (CODE1 ":if-exists") "  - " (STRONG "if-exists") "は、" (STRONG "direction") "が"
     (CODE1 ":output") "か" (CODE1 ":io") "であり、" "    " (STRONG "filespec")
     "の名前のファイルがすでに存在しているときに" "    実行する動作を指定します。" "    もし" (STRONG "direction") "が"
     (CODE1 ":input") "か、指定されなかったか、あるいは" (CODE1 ":probe") "のとき、" "    "
     (STRONG "if-exists") "は無視されます。" "    " (CODE1 "open") "の結果は" (STRONG "if-exists")
     "の次の値によって変更されます。" "  - " (CODE1 ":error") "    - 型" (CODE1 "file-error")
     "のエラーが通知されます。" "  - " (CODE1 ":new-version") "    - 新しいファイルがもっとも大きなバージョン値で生成されます。"
     "  - " (CODE1 ":rename") "    - 存在しているファイルを何か他の名前に変更してから" "      新しいファイルを作成します。"
     "  - " (CODE1 ":rename-and-delete") "    - 存在しているファイルを何か他の名前に変更し、" "      それを抹消"
     (CODE1 "expunging") "ではなく削除" (CODE1 "deleting") "し、" "      そして新しいファイルを生成します。"
     "  - " (CODE1 ":overwrite") "    - ストリームの出力操作において、存在するファイルを破壊的に修正します。" "      "
     (STRONG "direction") "が" (CODE1 ":io") "であり、ファイルが読み込みと書き込みの両方を許可する"
     "      双方向モードとして開かれたとき、" "      そのファイルポインターは初期状態ではファイルの最初に位置します。"
     "      しかしファイルが開かれたときに、" "      ファイルは長さ" (CODE1 "0") "として前方に切り捨てられることはありません。" "  - "
     (CODE1 ":append") "    - ストリームの出力操作において、存在するファイルを破壊的に修正します。"
     "      そのファイルポインターは初期状態ではファイルの最後に位置します。" EOL1 "      " (STRONG "direction") "が"
     (CODE1 ":io") "のとき、ファイルが読み込みと書き込みの両方を許可する" "      双方向モードとして開かれます。" "  - "
     (CODE1 ":supersede") " " "    - 存在しているファイルは別のものに変えられます。"
     "      つまり同じ名前の新しいファイルが古いファイルとして作成さえれます。" "      もし可能であれば、実装は新しいストリームを閉じるまで"
     "      古いファイルを破壊するべきではありません。" "  - " (CODE1 "nil") "    - ファイルもストリームも生成されません。"
     "      代わりに失敗を示す" (CODE1 "nil") "が返却されます。" EOL2 "- " (CODE1 ":if-does-not-exist")
     "  - " (STRONG "if-does-not-exists") "は、" "    " (STRONG "filespec")
     "の名前のファイルがまだ存在してないときに実行する動作を指定します。" "    " (CODE1 "open") "の結果は"
     (STRONG "if-does-not-exists") "の次の値によって変更されます。" "  - " (CODE1 ":error") "    - 型"
     (CODE1 "file-error") "のエラーが通知されます。" "  - " (CODE1 ":create") "    - 空のファイルが作成されます。"
     "      ファイルがすでに存在しているときは処理が継続されますが、" "      " (STRONG "if-exists")
     "の方向による操作によっては処理しません。" "  - " (CODE1 "nil") "    - ファイルもストリームも生成されません。"
     "      代わりに失敗を示す" (CODE1 "nil") "が返却されます。" EOL2 "- " (CODE1 ":external-format")
     "  - このオプションはファイルの外部ファイルフォーマットを選択します。" "    このオプションの標準の値はただひとつ" (CODE1 ":default")
     "ですが、" "    実装は追加の外部ファイルフォーマットを定義することが許されており、" "    "
     (CODE1 "stream-external-format") "によって返却される" "    実装依存の値を"
     "    仕様に適合したプログラムで使用することができます。" EOL1 "    <br>" "    " (STRONG "external-format")
     "は、" (CODE1 "character") "のサブタイプである要素の型の" "    ファイルストリームに対して意味があります。"
     "    このオプションは、これらの値に意味を持たない" "    ストリームに対しては無視されます。"
     "    しかし実装は意味を持つ他の要素の型を定義することができます。" "    もし指定した外部ファイルフォーマットによって表現できない"
     "    文字を書き込んだ時の結果は指定されていません。" EOL2 "ファイルが開かれたとき、" "ファイルストリームは"
     "Lisp環境においてファイルシステムに仕える代理人として構築され、" "ファイルストリームへの操作は"
     "対象のファイルシステム内の指定したファイル上の操作として反映されます。" EOL2 "ファイルは" (CODE1 "open")
     "によって、削除、名前の変更、破壊的な修正が行われます。" EOL2 (CODE1 "open")
     "とパス名の関係については、19.2.3. パス名のマージをご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(open filespec :direction :probe)  =>  #<Closed Probe File Stream...>"
      "(setq q (merge-pathnames (user-homedir-pathname) \"test\"))"
      "=>  #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY directory-name"
      "   :NAME \"test\" :TYPE NIL :VERSION :NEWEST>"
      "(open filespec :if-does-not-exist :create) =>  #<Input File Stream...>"
      "(setq s (open filespec :direction :probe)) =>  #<Closed Probe File Stream...>"
      "(truename s) =>  #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY"
      "   directory-name :NAME filespec :TYPE extension :VERSION 1>"
      "(open s :direction :output :if-exists nil) =>  NIL "))
    (CHAPTER ("## 影響") 2 "ホストコンピューターのファイルシステムの性質と状態")
    (CHAPTER ("## 例外") 2 (STRONG "if-exists") "が" (CODE1 ":error") "のとき" "（上記のリストにある"
     (STRONG "if-exists") "の意味の制約に従い）、" "型" (CODE1 "file-error") "のエラーが発生します。" EOL2
     (STRONG "if-does-not-exist") "が" (CODE1 ":error") "のとき" "（上記のリストにある"
     (STRONG "if-does-not-exist") "の意味の制約に従い）、" "型" (CODE1 "file-error") "のエラーが発生します。"
     EOL2 "ここで指定された何かの挙動において" "実装が何らかのオプションを処理できなかったときは、" "型" (CODE1 "error")
     "のエラーが通知されるかもしれません。" EOL2 (CODE1 "(wild-pathname-p filespec)") "が" (STRONG "true")
     "のとき、" "型" (CODE1 "file-error") "のエラーが発生します。" EOL2 "実装が" (STRONG "external-format")
     "を解釈できなかったときは、" "型" (CODE1 "error") "のエラーが発生します。" EOL2
     "現在存在する様々なファイルシステムは大きく異なった機能を持っており、" "あるファイルシステムの様相はここで定義された仕様の範囲を超えています。"
     "実装はこれらの全てのオプションについて" "規定された動作を正確にサポートできないかもしれません。" "実装はこれらの全てのキーワードオプションを認識し、"
     "ホストファイルシステムの環境上において" "「適切な」何らかの挙動を試行することが求められます。" "ファイルシステムに適合させるために必要であれば、"
     "実装はここで指定された意味からわずかに逸脱しても、" "仕様に適合した実装として失格とみなされることはありません。"
     "もし、あるオプションをここで指定されたものと同様の方法で処理することが" "実装上まったく不可能な場合は、単にエラーが通知されます。" EOL2
     (CODE1 ":element-type") "オプションに関して、" "ファイルシステムでサポートされていない型が指定されたとき、"
     "そのような型をアップグレードした型を代用することが許されます。" "最小の要求としては、" "あるファイルに対して指定した要素の型で出力ストリームを開き、"
     "後で同じファイルに対して同じ要素の型で入力ストリームを開いたときに" "矛盾なく動作することが求められます。")
    (CHAPTER ("## 参考") 2 (CODE1 "with-open-file") "," (CODE1 "close") ","
     (CODE1 "pathname") "," (CODE1 "logical-pathname") "," "19.2.3. パス名のマージ,"
     "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 (CODE1 "open") "は、異常な退出が生じたときに" "自動的にはファイルをクローズしません。" EOL2
     (STRONG "element-type") "が" (CODE1 "character") "のサブタイプのとき、" (CODE1 "read-char") "と"
     (CODE1 "write-char") "が結果のファイルストリームで使用できます。" EOL2 (STRONG "element-type")
     "が整数のサブタイプのとき、" (CODE1 "read-byte") "と" (CODE1 "write-byte") "が結果のファイルストリームで使用できます。"
     EOL2 (STRONG "element-type") "が" (CODE1 ":default") "のとき、" "その型は"
     (CODE1 "stream-element-type") "を使うことで決定することができます。")))
(setf (gethash '("OPEN" . "FUNCTION") *table*) (gethash "OPEN" *table*))
(setf (gethash "OPEN-STREAM-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "OPEN-STREAM-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "open-stream-p") " " (STRONG "stream") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream") " - ストリーム" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "stream") "が開いているストリームのときは" (STRONG "true") "を、"
     "それ以外のときは" (STRONG "false") "を返却します。" EOL2 "ストリームは、明示的に" (CODE1 "close")
     "により閉じられるまでか、" "あるいは" (CODE1 "with-output-to-string") "," (CODE1 "with-open-file")
     "," (CODE1 "with-input-from-string") "," (CODE1 "with-open-stream") "のフォームを退出して"
     "暗黙的に閉じられるまでは開いています。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(open-stream-p *standard-input*) =>  true"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 (CODE1 "close"))
    (CHAPTER ("## 例外") 2 (STRONG "stream") "がストリームではないときは、" "型" (CODE1 "type-error")
     "のエラーを発生させるべきです。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("OPEN-STREAM-P" . "FUNCTION") *table*) (gethash "OPEN-STREAM-P" *table*))
(setf (gethash "OPTIMIZE" *table*)
  '((CHAPTER NIL 0)
    (CHAPTER ("## 構文") 2 "(" (CODE1 "optimize") " " (CODE1 "{") (STRONG "quality") " "
     (CODE1 "|") " (" (STRONG "quality") " " (STRONG "value") ")" (CODE1 "}") "\\*)")
    (CHAPTER ("## 引数") 2 (STRONG "quality") " - 最適化の性質" EOL1 (STRONG "value")
     " - 次の整数のうちのひとつ、" (CODE1 "0") ", " (CODE1 "1") ", " (CODE1 "2") ", " (CODE1 "3"))
    (CHAPTER ("## 有効な文脈") 2 (CODE1 "declare") "か" (CODE1 "proclaim"))
    (CHAPTER ("## 影響する束縛の型") 2 "なし。")
    (CHAPTER ("## 定義") 2 "コンパイラーに対して、各" (STRONG "quality") "が対応する値" (STRONG "value")
     "で指定されたことの" "注意を促すように知らせます。" "各" (STRONG "quality") "は最適化の性質の名前のシンボルである必要があります。"
     "その名前である標準の最適化の性質を次の表に表します。" EOL2
     "|名前                     |意味                           |"
     "|-------------------------|-------------------------------|" "|"
     (CODE1 "compilation-speed") " |コンパイル処理の速度           |" "|" (CODE1 "debug")
     "             |デバッグのやりやすさ           |" "|" (CODE1 "safety")
     "            |実行自エラーチェック           |" "|" (CODE1 "space")
     "             |コードサイズと実行時空間の両方 |" "|" (CODE1 "speed")
     "             |コードの速度                   |" EOL2 "Figure 3-25. 最適化の性質" EOL2
     "他にも実装定義の最適化の性質が存在します。" EOL2 "値" (CODE1 "0") "は対応する" (STRONG "quality")
     "が全体的に重要ではないことを意味します。" "値" (CODE1 "3") "は" (STRONG "quality") "が非常に重要であることを意味します。"
     "値" (CODE1 "1") "と" (CODE1 "2") "はその中間の値であり、値" (CODE1 "1") "が標準の値です。"
     (CODE1 "(quality 3)") "は省略して" (CODE1 "quality") "と記載できます。" EOL2 "最適化"
     (CODE1 "(safety 3)") "かただ" (CODE1 "safety") "と指定したコードは、" "安全なコードと呼ばれます。" EOL2
     (STRONG "quality") "が複数違う値で現れたときの結果は指定されていません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun often-used-subroutine (x y)"
      "  (declare (optimize (safety 2)))" "  (error-check x y)" "  (hairy-setup x)"
      "  (do ((i 0 (+ i 1))" "       (z x (cdr z)))" "      ((null z))"
      "    ;; この内部ループは本当に燃やす必要があります。" "    ;; （高負荷という意味）"
      "    (declare (optimize speed))" "    (declare (fixnum i))" "    ))"))
    (CHAPTER ("## 参考") 2 (CODE1 "declare") "," (CODE1 "declaim") "," (CODE1 "proclaim")
     "," "3.3.4. 宣言のスコープ")
    (CHAPTER ("## 備考") 2 (CODE1 "optimize") "宣言は、決して変数束縛にも関数束縛にも適用しません。"
     (CODE1 "optimize") "宣言は自由宣言にのみ使用できます。" "詳細は3.3.4. 宣言のスコープをご確認ください。")))
(setf (gethash '("OPTIMIZE" . "DECLARATION") *table*) (gethash "OPTIMIZE" *table*))
(setf (gethash "OR" *table*)
  '("OR MACRO" EOL1 "OR TYPE-SPECIFIER" EOL1))
(setf (gethash '("OR" . "MACRO") *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "OR"))
    (CHAPTER ("## 構文") 2 (CODE1 "or") " " (STRONG "form\\*") " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "form") " - フォーム" EOL1 (STRONG "result")
     " - 多値か、最後の" (STRONG "form") "の実行した結果の第一返却値（下記参照）か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "or") "は、各" (STRONG "form") "を左から右へひとつずつ評価します。" "すべての"
     (STRONG "from") "の評価は、" (STRONG "form") "のどれかの評価が" (STRONG "true") "（それは"
     (CODE1 "nil") "以外のなにか）を返却したときに停止します。" EOL2 "もし最後以外の各" (STRONG "form") "の評価の第一返却値が"
     (STRONG "true") "のときは、" (CODE1 "or") "は残りの" (STRONG "form") "を評価することなく"
     "即座にその値（しかし多値は追加しません）を返却します。" "もし最後以外のすべての" (STRONG "form") "が第一返却値に"
     (STRONG "false") "を返却したとき、" (CODE1 "or") "は最後の" (STRONG "form") "の全ての多値を返却します。"
     (STRONG "form") "がないときは、" (CODE1 "nil") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(or) =>  NIL "
      "(setq temp0 nil temp1 10 temp2 20 temp3 30) =>  30"
      "(or temp0 temp1 (setq temp2 37)) =>  10" "temp2 =>  20"
      "(or (incf temp1) (incf temp2) (incf temp3)) =>  11" "temp1 =>  11" "temp2 =>  20"
      "temp3 =>  30" "(or (values) temp1) =>  11"
      "(or (values temp1 temp2) temp3) =>  11"
      "(or temp0 (values temp1 temp2)) =>  11, 20"
      "(or (values temp0 temp1) (values temp2 temp3)) =>  20, 30"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "and") "," (CODE1 "some") "," (CODE1 "unless"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("OR" . "TYPE-SPECIFIER") *table*)
  '((CHAPTER NIL 0 "Type Specifier " (CODE1 "OR")) (CHAPTER ("## 型指定子の種類") 2 "結合")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "or") " " (STRONG "typespec\\*"))
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "typespec") " - 型指定子")
    (CHAPTER ("## 型指定子の定義") 2 "型" (STRONG "typespec") "の結合によって決定される型の"
     "全てのオブジェクトの集合を示します。" "例えば、型" (CODE1 "list") "の定義は" (CODE1 "(or null cons)") "と同じです。"
     "また、" (CODE1 "position") "の返却値は" (CODE1 "(or null (integer 0 *))") "の型のオブジェクトです。"
     "これは" (CODE1 "nil") "か非負の整数を意味しています。" EOL2 "引数にシンボル" (CODE1 "*") "は許されません。" EOL2
     "型指定子" (CODE1 "(or)") "は" (CODE1 "nil") "と同等です。" "シンボルとしての" (CODE1 "or")
     "は、有効な型指定子ではありませんし、" "とくに" (CODE1 "(or)") "の省略形ではありません。")))
(setf (gethash "OUTPUT-STREAM-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "INPUT-STREAM-P") ", " (CODE1 "OUTPUT-STREAM-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "input-stream-p") " " (STRONG "stream") " => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "output-stream-p") " " (STRONG "stream")
     " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream") " - ストリーム" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "input-stream-p") "は、" (STRONG "stream") "が入力ストリームのときは"
     (STRONG "true") "を、" "それ以外のときは" (STRONG "false") "を返却します。" EOL2
     (CODE1 "output-stream-p") "は、" (STRONG "stream") "が出力ストリームのときは" (STRONG "true") "を、"
     "それ以外のときは" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(input-stream-p *standard-input*) =>  true"
      "(input-stream-p *terminal-io*) =>  true"
      "(input-stream-p (make-string-output-stream)) =>  false" NIL
      "(output-stream-p *standard-output*) =>  true"
      "(output-stream-p *terminal-io*) =>  true"
      "(output-stream-p (make-string-input-stream \"jr\")) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "stream") "がストリームではないときは、" "型" (CODE1 "type-error")
     "のエラーを発生させるべきです。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("OUTPUT-STREAM-P" . "FUNCTION") *table*) (gethash "OUTPUT-STREAM-P" *table*))
(setf (gethash "PACKAGE" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "PACKAGE"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "package") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "パッケージはシンボルの名前からシンボルをマップする名前空間です。" "11.1. パッケージの説明をご確認ください。")
    (CHAPTER ("## 参考") 2 "11.1. パッケージの説明," "22.1.3.13. 他のオブジェクトの印字,"
     "2.3.4. トークンとしてのシンボル")))
(setf (gethash '("PACKAGE" . "SYSTEM-CLASS") *table*) (gethash "PACKAGE" *table*))
(setf (gethash "PACKAGE-ERROR" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "EXPORT"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "package-error") "," (CODE1 "error") ","
     (CODE1 "serious-condition") "," (CODE1 "condition") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "package-error") "は、"
     "パッケージの操作に関連するエラーのコンディションを含みます。" "問題のあるパッケージ（あるいはパッケージの名前）は"
     (CODE1 "make-condition") "の初期化引数" (CODE1 ":package") "によって初期化され、" "それは"
     (CODE1 "package-error-package") "関数によってアクセスされます。")
    (CHAPTER ("## 参考") 2 (CODE1 "package-error-package") "," "9. コンディション")))
(setf (gethash '("PACKAGE-ERROR" . "CONDITION-TYPE") *table*) (gethash "PACKAGE-ERROR" *table*))
(setf (gethash "PACKAGE-ERROR-PACKAGE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PACKAGE-ERROR-PACKAGE"))
    (CHAPTER ("## 構文") 2 (CODE1 "package-error-package") " " (STRONG "condition") " => "
     (STRONG "package"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "condition") " - 型" (CODE1 "package-error")
     "のコンディション" EOL1 (STRONG "package") " - パッケージ指定子")
    (CHAPTER ("## 定義") 2 (STRONG "condition") "によって表された状況の" "問題のあるパッケージの指定子を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(package-error-package " "  (make-condition 'package-error"
      "    :package (find-package \"COMMON-LISP\")))" "=>  #<Package \"COMMON-LISP\">"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "package-error")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PACKAGE-ERROR-PACKAGE" . "FUNCTION") *table*) (gethash "PACKAGE-ERROR-PACKAGE" *table*))
(setf (gethash "PACKAGE-NAME" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PACKAGE-NAME"))
    (CHAPTER ("## 構文") 2 (CODE1 "package-name") " " (STRONG "package") " => "
     (STRONG "name"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "package") " - パッケージ指定子" EOL1 (STRONG "name")
     " - 文字列か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "package-name") "は" (STRONG "package")
     "に名付けられている文字列を返却するか、" "もし" (STRONG "package") "指定子が名前を持たないパッケージの場合は" (CODE1 "nil")
     "を返却します" "（" (CODE1 "delete-package") "関数をご確認ください）。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(in-package \"COMMON-LISP-USER\") =>  #<PACKAGE \"COMMON-LISP-USER\">"
      "(package-name *package*) =>  \"COMMON-LISP-USER\""
      "(package-name (symbol-package :test)) =>  \"KEYWORD\""
      "(package-name (find-package 'common-lisp)) =>  \"COMMON-LISP\""
      "(defvar *foo-package* (make-package \"FOO\"))" "(rename-package \"FOO\" \"FOO0\")"
      "(package-name *foo-package*) =>  \"FOO0\""))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "package") "がパッケージ指定子ではないときは、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PACKAGE-NAME" . "FUNCTION") *table*) (gethash "PACKAGE-NAME" *table*))
(setf (gethash "PACKAGE-NICKNAMES" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PACKAGE-NICKNAMES"))
    (CHAPTER ("## 構文") 2 (CODE1 "package-nicknames") " " (STRONG "package") " => "
     (STRONG "nicknames"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "package") " - パッケージ指定子" EOL1 (STRONG "nicknames")
     " - 文字列のリスト")
    (CHAPTER ("## 定義") 2 (STRONG "package") "のニックネームである文字列のリストを返却しますが、" "それに"
     (STRONG "package") "の名前は含まれません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(package-nicknames (make-package 'temporary"
      "                                  :nicknames '(\"TEMP\" \"temp\")))"
      "=>  (\"temp\" \"TEMP\") "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "package") "がパッケージ指定子ではないときは、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PACKAGE-NICKNAMES" . "FUNCTION") *table*) (gethash "PACKAGE-NICKNAMES" *table*))
(setf (gethash "PACKAGE-SHADOWING-SYMBOLS" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PACKAGE-SHADOWING-SYMBOLS"))
    (CHAPTER ("## 構文") 2 (CODE1 "package-shadowing-symbols") " " (STRONG "package")
     " => " (STRONG "symbols"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "package") " - パッケージ指定子" EOL1 (STRONG "symbols")
     " - シンボルのリスト")
    (CHAPTER ("## 定義") 2 (CODE1 "shadow") "か" (CODE1 "shadowing-import") "によって" "（または同等の"
     (CODE1 "defpackage") "オプションによって）" (STRONG "package") "に" (CODE1 "shadowing")
     "シンボルとして宣言された" "シンボルのリストを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(package-shadowing-symbols (make-package 'temp)) =>  ()"
      "(shadow 'cdr 'temp) =>  T" "(package-shadowing-symbols 'temp) =>  (TEMP::CDR)"
      "(intern \"PILL\" 'temp) =>  TEMP::PILL, NIL"
      "(shadowing-import 'pill 'temp) =>  T"
      "(package-shadowing-symbols 'temp) =>  (PILL TEMP::CDR)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "package") "がパッケージ指定子ではないときは、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "shadow") "," (CODE1 "shadowing-import"))
    (CHAPTER ("## 備考") 2 "シンボルのリストが新しいものかどうかは実装依存です。")))
(setf (gethash '("PACKAGE-SHADOWING-SYMBOLS" . "FUNCTION") *table*) (gethash "PACKAGE-SHADOWING-SYMBOLS" *table*))
(setf (gethash "PACKAGE-USE-LIST" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PACKAGE-USE-LIST"))
    (CHAPTER ("## 構文") 2 (CODE1 "package-use-list") " " (STRONG "package") " => "
     (STRONG "use-list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "package") " - パッケージ指定子" EOL1 (STRONG "use-list")
     " - パッケージオブジェクトのリスト")
    (CHAPTER ("## 定義") 2 (STRONG "package") "によって" (CODE1 "use")
     "されている他のパッケージのリストを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(package-use-list (make-package 'temp)) =>  (#<PACKAGE \"COMMON-LISP\">)"
      "(use-package 'common-lisp-user 'temp) =>  T"
      "(package-use-list 'temp) =>  (#<PACKAGE \"COMMON-LISP\"> #<PACKAGE \"COMMON-LISP-USER\">)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "package") "がパッケージ指定子ではないときは、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "use-package") "," (CODE1 "unuse-package"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PACKAGE-USE-LIST" . "FUNCTION") *table*) (gethash "PACKAGE-USE-LIST" *table*))
(setf (gethash "PACKAGE-USED-BY-LIST" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PACKAGE-USED-BY-LIST"))
    (CHAPTER ("## 構文") 2 (CODE1 "package-used-by-list") " " (STRONG "package") " => "
     (STRONG "used-by-list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "package") " - パッケージ指定子" EOL1
     (STRONG "used-by-list") " - パッケージオブジェクトのリスト")
    (CHAPTER ("## 定義") 2 (CODE1 "package-used-by-list") "は、" (STRONG "package") "を"
     (CODE1 "use") "している他のパッケージのリストを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(package-used-by-list (make-package 'temp)) =>  ()"
      "(make-package 'trash :use '(temp)) =>  #<PACKAGE \"TRASH\">"
      "(package-used-by-list 'temp) =>  (#<PACKAGE \"TRASH\">)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "package") "がパッケージ指定子ではないときは、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "use-package") "," (CODE1 "unuse-package"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PACKAGE-USED-BY-LIST" . "FUNCTION") *table*) (gethash "PACKAGE-USED-BY-LIST" *table*))
(setf (gethash "PACKAGEP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PACKAGEP"))
    (CHAPTER ("## 構文") 2 (CODE1 "packagep") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が型" (CODE1 "package") "のときは" (STRONG "true")
     "を、" "それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(packagep *package*) =>  true "
      "(packagep 'common-lisp) =>  false "
      "(packagep (find-package 'common-lisp)) =>  true "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(packagep object) == (typep object 'package)"))))
(setf (gethash '("PACKAGEP" . "FUNCTION") *table*) (gethash "PACKAGEP" *table*))
(setf (gethash "PAIRLIS" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PAIRLIS"))
    (CHAPTER ("## 構文") 2 (CODE1 "pairlis") " " (STRONG "keys") " " (STRONG "data")
     " &optional " (STRONG "alist") " => " (STRONG "new-alist"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "keys") " - 通常のリスト" EOL1 (STRONG "data") " - 通常のリスト"
     EOL1 (STRONG "alist") " - 連想リスト、デフォルトは空のリスト" EOL1 (STRONG "new-alist") " - 連想リスト")
    (CHAPTER ("## 定義") 2 (STRONG "keys") "の要素と、対応する" (STRONG "data")
     "の要素を関連付けた連想リストを返却します。" (STRONG "keys") "と" (STRONG "data") "が同じ長さではないときの結果は未定義です。"
     EOL2 (STRONG "alist") "が与えられたとき、" (CODE1 "pairlis") "は、" "新しいペアを先頭に追加するように"
     (STRONG "alist") "を修正します。" "新しいペアは、結果の連想リストに正順か逆順のどちらかで表すことができます。" "下記の結果は、"
     (CODE3 "```lisp" "```" " (pairlis '(one two) '(1 2) '((three . 3) (four . 19)))")
     EOL2 "次のようになるか、"
     (CODE3 "```lisp" "```" "((one . 1) (two . 2) (three . 3) (four . 19))") EOL2
     "あるいは次のようになります。"
     (CODE3 "```lisp" "```" "((two . 2) (one . 1) (three . 3) (four . 19))"))
    (CHAPTER ("## Examples:") 2
     (CODE3 "```lisp" "```" "(setq keys '(1 2 3)"
      "       data '(\"one\" \"two\" \"three\")"
      "       alist '((4 . \"four\"))) =>  ((4 . \"four\"))"
      "(pairlis keys data) =>  ((3 . \"three\") (2 . \"two\") (1 . \"one\"))"
      "(pairlis keys data alist)"
      "=>  ((3 . \"three\") (2 . \"two\") (1 . \"one\") (4 . \"four\"))"
      "alist =>  ((4 . \"four\"))"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "keys") "と" (STRONG "data") "が通常のリストではないとき、" "型"
     (CODE1 "type-error") "を通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "acons")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PAIRLIS" . "FUNCTION") *table*) (gethash "PAIRLIS" *table*))
(setf (gethash "PARSE-ERROR" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "PARSE-ERROR"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "parse-error") "," (CODE1 "error") ","
     (CODE1 "serious-condition") "," (CODE1 "condition") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "parse-error") "は、構文解析に関するエラーのコンディションを含みます。")
    (CHAPTER ("## 参考") 2 (CODE1 "parse-namestring") "," (CODE1 "reader-error"))))
(setf (gethash '("PARSE-ERROR" . "CONDITION-TYPE") *table*) (gethash "PARSE-ERROR" *table*))
(setf (gethash "PARSE-NAMESTRING" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PARSE-NAMESTRING"))
    (CHAPTER ("## 構文") 2 (CODE1 "parse-namestring") " " (STRONG "thing") " "
     (CODE1 "&optional") " " (STRONG "host") " " (STRONG "default-pathname") " "
     (CODE1 "&key") " " (STRONG "start") " " (STRONG "end") " " (STRONG "junk-allowed")
     EOL1 "=> " (STRONG "pathname") ", " (STRONG "position"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "thing") " - 文字列か、パス名か、ファイルストリーム" EOL1
     (STRONG "host") " - 有効なパス名のホストか、論理ホストか、" (CODE1 "nil") EOL1
     (STRONG "default-pathname") " - パス名指定子。" "デフォルトは"
     (CODE1 "*default-pathname-defaults*") "の値です。" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "thing") "の境界インデックス指定子。" "デフォルトは" (STRONG "start") "と"
     (STRONG "end") "がそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1
     (STRONG "junk-allowed") " - generalized-boolean。デフォルトは" (STRONG "false") "。" EOL1
     (STRONG "pathname") " - パス名か、" (CODE1 "nil") EOL1 (STRONG "position") " - "
     (STRONG "thing") "の境界インデックス指定子")
    (CHAPTER ("## 定義") 2 (STRONG "thing") "をパス名に変換します。" EOL2 (STRONG "host")
     "には構文解析の対象となるホスト名を指定します。" EOL2 "もし" (STRONG "thing") "がパス名のときは、" (STRONG "host") "と"
     (STRONG "thing") "のホストの要素が比較されます。" "もしそれらが合っているときは、二値の" (STRONG "thing") "と"
     (STRONG "start") "がすぐに返却されます。" "それ以外のときは（もしそれらが合っていないとき）、エラーが通知されます。" EOL2 "もし"
     (STRONG "thing") "が文字列のとき、" (CODE1 "parse-namestring") "は" (STRONG "start") "と"
     (STRONG "end") "の境界による" (STRONG "thing") "の部分文字列内を" "ファイル名として構文解析します。" EOL2 "もし"
     (STRONG "thing") "が文字列であるとき、" (STRONG "start") "と" (STRONG "end") "の境界による"
     (STRONG "thing") "の部分文字列は" "次のようにパス名を構文解析します。" EOL2 "- もし" (STRONG "host")
     "が論理ホストなら、" "  " (STRONG "thing") "は" (STRONG "host") "の論理パス名の名前文字列として構文解析されます。"
     EOL2 "- もし" (STRONG "host") "が" (CODE1 "nil") "であり、" "  " (STRONG "thing")
     "が暗にホストに含まれるような" "  論理パス名の名前文字列の有効な構文であったときは、" "  それは論理パス名の名前文字列として構文解析されます。" EOL2
     "- もし" (STRONG "host") "が" (CODE1 "nil") "であり、" "  " (STRONG "default-pathname")
     "が論理パス名で、" "  かつ" (STRONG "thing") "が暗にホストに含まれるような" "  論理パス名の名前文字列の有効な構文であったときは、"
     "  それはホストが" (STRONG "default-pathname") "のホスト要素であるような" "  論理パス名の名前文字列として構文解析されます。"
     EOL2 "- それ以外のときは、" (STRONG "thing") "の構文解析はは実装定義です。" EOL2
     "これらの最初の場合は、論理パス名の名前文字列にある" "ホストの位置と続くコロンはオプションです。" EOL2 "もし名前文字列のホストの位置と"
     (STRONG "host") "の両方が現れており、" "それらがマッチしなかったときはエラーが発生します。" EOL2 "もし"
     (STRONG "junk-allowed") "が" (STRONG "true") "のとき、" "主値は構文解析されたパス名か、"
     "あるいはもしパス名が構文として正しくないときは" (CODE1 "nil") "になります。" "もし" (STRONG "junk-allowed") "が"
     (STRONG "false") "のとき、" "部分文字列の全体が調査され、" "主値は構文解析されたパス名になります。" EOL2
     "どちらの場合でも、第二返却値は、" "構文解析が終了した" (STRONG "thing") "の区切りのインデックスか、"
     "あるいはもし部分文字列の終了位置まで構文解析が終わったときの" "その部分文字列を越えたインデックスになります" "（もし"
     (STRONG "junk-allowed") "が" (STRONG "false") "のときは常にこのケースです）。" EOL2
     "空の文字列の構文解析は常に成功であり、" "全ての要素（ホストを除く）が" (CODE1 "nil") "と等しい" "パス名が生成されます。" EOL2 "もし"
     (STRONG "thing") "に暗にホスト名が含まれており、" "そしてデバイス名が含まれてないときは、" (CODE1 "parse-namestring")
     "が" "そのホストの結果のパス名のデバイスの要素として" "標準のデバイスを供給するかどうかは実装定義です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq q (parse-namestring \"test\"))  "
      "=>  #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME \"test\" "
      "      :TYPE NIL :VERSION NIL)" "(pathnamep q) =>  true"
      "(parse-namestring \"test\") "
      "=>  #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME \"test\""
      "      :TYPE NIL :VERSION NIL), 4"
      "(setq s (open xxx)) =>  #<Input File Stream...>" "(parse-namestring s) "
      "=>  #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME xxx "
      "      :TYPE NIL :VERSION NIL), 0"
      "(parse-namestring \"test\" nil nil :start 2 :end 4 )" "=>  #S(PATHNAME ...), 15"
      "(parse-namestring \"foo.lisp\")" "=>  #P\"foo.lisp\""))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "junk-allowed") "が" (STRONG "false") "であり、"
     (STRONG "thing") "がパス名の全体の表現で構成されていないときは、" "型" (CODE1 "parse-error") "のエラーが通知されます。"
     "ただし実装の文化的習慣に合っているならば、" "両サイドが空白文字によって囲むことができるかもしれません。" EOL2 "もし" (STRONG "host")
     "が" (CODE1 "nil") "以外で指定されており、" (STRONG "thing") "に明にホスト名が含まれているとき、"
     "その両者のホストがあっていなかったときは" "型" (CODE1 "error") "のエラーが通知されます。" EOL2 "もし" (STRONG "thing")
     "が論理パス名の名前文字列であり、" "名前文字列のホストの位置のものと" (STRONG "host") "の両方が存在し、" "両者がマッチしなかったときは、"
     "型" (CODE1 "error") "のエラーが通知されます。")
    (CHAPTER ("## 参考") 2 (CODE1 "pathname") "," (CODE1 "logical-pathname") ","
     "20.1. ファイルシステムの説明," "19.2.2.2.3. " (CODE1 ":UNSPECIFIC") "という要素の値,"
     "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PARSE-NAMESTRING" . "FUNCTION") *table*) (gethash "PARSE-NAMESTRING" *table*))
(setf (gethash "PATHNAME" *table*)
  '("PATHNAME FUNCTION" EOL1 "PATHNAME SYSTEM-CLASS" EOL1))
(setf (gethash '("PATHNAME" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PATHNAME"))
    (CHAPTER ("## 構文") 2 (CODE1 "pathname") " " (STRONG "pathspec") " => "
     (STRONG "pathname"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathspec") " - パス名指定子" EOL1 (STRONG "pathname")
     " - パス名")
    (CHAPTER ("## 定義") 2 (STRONG "pathspec") "によって示されるパス名を返却します。" EOL2 "もし"
     (STRONG "pathspec") "指定子がストリームのとき、" "そのストリームは開いているか閉じているかのどちらでも指定でき、" "その両方の場合は"
     (CODE1 "pathname") "はファイルオープンに" "使用された対応するファイル名を返却します。" (CODE1 "pathname") "は、"
     "クローズされた後のファイルストリームについて" "開いていたときのものと同じパス名を返却します。" EOL2 "もし" (STRONG "pathspec")
     "指定子が論理パス名をオープンしたものによって" "作成されたファイルストリームのときは、" "論理パス名が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; ここでは大きなばらつきが許されます。 次のいくつかの例は、"
      ";; ちょうど多くの可能性のうちの数例を示したものです。" ";; 名前が特定の大文字小文字に正規化されるかどうかは"
      ";; ファイルシステムと実装によって依存しますし、2つの異なった実装が" ";; 同じファイルシステムを使用したとき多くの問題が起こり違いが"
      ";; 生じるかもしれません。また内部的にどのように情報を格納するか" ";; （場合によっては#S記法で表示する）も異なり、アクセス時に"
      ";; 大文字小文字を変換するためにPATHNAME-NAMEなどの「アクセサ」を" ";; 必要とする可能性があります。名前文字列の形式は、ファイルシステムと"
      ";; 実装の両方に依存します。例えば、ある実装では名前文字列にホスト名を" ";; 含めるかもしれませんし、別の実装では含めないかもしれないからです。"
      ";; #S表記は一般に、#Pで使用するための適切な名前文字列が作成できない" ";; 場合にのみ使用されます。"
      "(setq p1 (pathname \"test\"))" "=>  #P\"CHOCOLATE:TEST\" ; 大文字小文字の正規化あり(例えばVMS)"
      "OR=>  #P\"VANILLA:test\"   ; 大文字小文字の正規化なし(例えばUnix)" "OR=>  #P\"test\""
      "OR=>  #S(PATHNAME :HOST \"STRAWBERRY\" :NAME \"TEST\")"
      "OR=>  #S(PATHNAME :HOST \"BELGIAN-CHOCOLATE\" :NAME \"test\")"
      "(setq p2 (pathname \"test\"))" "=>  #P\"CHOCOLATE:TEST\""
      "OR=>  #P\"VANILLA:test\"" "OR=>  #P\"test\""
      "OR=>  #S(PATHNAME :HOST \"STRAWBERRY\" :NAME \"TEST\")"
      "OR=>  #S(PATHNAME :HOST \"BELGIAN-CHOCOLATE\" :NAME \"test\")"
      "(pathnamep p1) =>  true" "(eq p1 (pathname p1)) =>  true" "(eq p1 p2)" "=>  true"
      "OR=>  false" "(with-open-file (stream \"test\" :direction :output)"
      "  (pathname stream))" "=>  #P\"ORANGE-CHOCOLATE:>Gus>test.lisp.newest\""))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "pathname") "," (CODE1 "logical-pathname") ","
     "20.1. ファイルシステムの説明," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PATHNAME" . "SYSTEM-CLASS") *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "PATHNAME"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "pathname") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "パス名は、ファイル名を表現する構造化されたオブジェクトです。" EOL2
     "パス名は2種類存在し、物理パス名と論理パス名です。")))
(setf (gethash "PATHNAME-DEVICE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PATHNAME-HOST") " " (CODE1 "PATHNAME-DEVICE") ", "
     (CODE1 "PATHNAME-DIRECTORY") "," " " (CODE1 "PATHNAME-NAME") ", "
     (CODE1 "PATHNAME-TYPE") ", " (CODE1 "PATHNAME-VERSION"))
    (CHAPTER ("## 構文") 2 (CODE1 "pathname-host") " " (STRONG "pathname") " "
     (CODE1 "&key") " " (STRONG "case") " => " (STRONG "host") EOL1
     (CODE1 "pathname-device") " " (STRONG "pathname") " " (CODE1 "&key") " "
     (STRONG "case") " => " (STRONG "device") EOL1 (CODE1 "pathname-directory") " "
     (STRONG "pathname") " " (CODE1 "&key") " " (STRONG "case") " => "
     (STRONG "directory") EOL1 (CODE1 "pathname-name") " " (STRONG "pathname") " "
     (CODE1 "&key") " " (STRONG "case") " => " (STRONG "name") EOL1
     (CODE1 "pathname-type") " " (STRONG "pathname") " " (CODE1 "&key") " "
     (STRONG "case") " => " (STRONG "type") EOL1 (CODE1 "pathname-version") " "
     (STRONG "pathname") " => " (STRONG "version"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathname") " - パス名指定子" EOL1 (STRONG "case") " - "
     (CODE1 ":common") "か" (CODE1 ":local") "のうちのひとつ。デフォルトは" (CODE1 ":local") "です。" EOL1
     (STRONG "host") " - 有効なパス名のホスト。" EOL1 (STRONG "device") " - 有効なパス名のデバイス。" EOL1
     (STRONG "directory") " - 有効なパス名のディレクトリ。" EOL1 (STRONG "name") " - 有効なパス名の名前。" EOL1
     (STRONG "type") " - 有効なパス名の型。" EOL1 (STRONG "version") " - 有効なパス名のバージョン。")
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "pathname") "の要素を返却します。" EOL2 "もし"
     (STRONG "pathname") "指定子がパス名（おそらくストリームの誤字）のとき、"
     "それはオープンされているファイルによって使用されている名前が表現されます。" "これはおそらく、要求はされていませんが、" "実際のファイルの名前です。" EOL2
     "もし" (STRONG "case") "が指定されたとき、" "それは19.2.2.1.2. パス名の要素の大文字小文字の説明のように扱われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq q (make-pathname :host \"KATHY\""
      "                       :directory \"CHAPMAN\" "
      "                       :name \"LOGIN\" :type \"COM\"))"
      "=>  #P\"KATHY::[CHAPMAN]LOGIN.COM\"" "(pathname-host q) =>  \"KATHY\""
      "(pathname-name q) =>  \"LOGIN\"" "(pathname-type q) =>  \"COM\"" NIL
      ";; 名前文字列を使用するため、例で示した結果が唯一の可能な結果で" ";; あるとは限りません。名前文字列の表現からパス名表現へのマッピングは、"
      ";; 関係するファイルシステムと実装の両方に依存します（同じファイルシステムを" ";; 操作できる実装が複数存在し、それらの実装はすべての詳細について合意する"
      ";; 制約がないため）。名前文字列がどのように扱われるかについての" ";; 具体的な情報は、各実装のドキュメントを参照してください。" NIL ";; VMS"
      "(pathname-directory (parse-namestring \"[FOO.*.BAR]BAZ.LSP\"))"
      "=>  (:ABSOLUTE \"FOO\" \"BAR\")"
      "(pathname-directory (parse-namestring \"[FOO.*.BAR]BAZ.LSP\") :case :common)"
      ">  (:ABSOLUTE \"FOO\" \"BAR\")" NIL ";; Unix"
      "(pathname-directory \"foo.l\") =>  NIL"
      "(pathname-device \"foo.l\") =>  :UNSPECIFIC"
      "(pathname-name \"foo.l\") =>  \"foo\""
      "(pathname-name \"foo.l\" :case :local) =>  \"foo\""
      "(pathname-name \"foo.l\" :case :common) =>  \"FOO\""
      "(pathname-type \"foo.l\") =>  \"l\""
      "(pathname-type \"foo.l\" :case :local) =>  \"l\""
      "(pathname-type \"foo.l\" :case :common) =>  \"L\""
      "(pathname-type \"foo\") =>  :UNSPECIFIC"
      "(pathname-type \"foo\" :case :common) =>  :UNSPECIFIC"
      "(pathname-type \"foo.\") =>  \"\""
      "(pathname-type \"foo.\" :case :common) =>  \"\""
      "(pathname-directory (parse-namestring \"/foo/bar/baz.lisp\") :case :local)"
      "=>  (:ABSOLUTE \"foo\" \"bar\")"
      "(pathname-directory (parse-namestring \"/foo/bar/baz.lisp\") :case :local)"
      "=>  (:ABSOLUTE \"FOO\" \"BAR\")"
      "(pathname-directory (parse-namestring \"../baz.lisp\"))" "=>  (:RELATIVE :UP)"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/BAR/../Mum/baz\"))"
      "=>  (:ABSOLUTE \"foo\" \"BAR\" :UP \"Mum\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/BAR/../Mum/baz\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" \"bar\" :UP \"Mum\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/*/bar/baz.l\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD \"bar\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/*/bar/baz.l\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" :WILD \"BAR\")" NIL ";; Symbolics LMFS"
      "(pathname-directory (parse-namestring \">foo>**>bar>baz.lisp\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD-INFERIORS \"bar\")"
      "(pathname-directory (parse-namestring \">foo>*>bar>baz.lisp\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD \"bar\")"
      "(pathname-directory (parse-namestring \">foo>*>bar>baz.lisp\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" :WILD \"BAR\")"
      "(pathname-device (parse-namestring \">foo>baz.lisp\")) =>  :UNSPECIFIC"))
    (CHAPTER ("## 影響") 2 "実装とホストファイルシステム。")
    (CHAPTER ("## 例外") 2 "最初の引数がパス名でないときは" "型" (CODE1 "type-error") "のエラーを通知するべきです。")
    (CHAPTER ("## 参考") 2 (CODE1 "pathname") "," (CODE1 "logical-pathname") ","
     "20.1. ファイルシステムの説明," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PATHNAME-DEVICE" . "FUNCTION") *table*) (gethash "PATHNAME-DEVICE" *table*))
(setf (gethash "PATHNAME-DIRECTORY" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PATHNAME-HOST") " " (CODE1 "PATHNAME-DEVICE") ", "
     (CODE1 "PATHNAME-DIRECTORY") "," " " (CODE1 "PATHNAME-NAME") ", "
     (CODE1 "PATHNAME-TYPE") ", " (CODE1 "PATHNAME-VERSION"))
    (CHAPTER ("## 構文") 2 (CODE1 "pathname-host") " " (STRONG "pathname") " "
     (CODE1 "&key") " " (STRONG "case") " => " (STRONG "host") EOL1
     (CODE1 "pathname-device") " " (STRONG "pathname") " " (CODE1 "&key") " "
     (STRONG "case") " => " (STRONG "device") EOL1 (CODE1 "pathname-directory") " "
     (STRONG "pathname") " " (CODE1 "&key") " " (STRONG "case") " => "
     (STRONG "directory") EOL1 (CODE1 "pathname-name") " " (STRONG "pathname") " "
     (CODE1 "&key") " " (STRONG "case") " => " (STRONG "name") EOL1
     (CODE1 "pathname-type") " " (STRONG "pathname") " " (CODE1 "&key") " "
     (STRONG "case") " => " (STRONG "type") EOL1 (CODE1 "pathname-version") " "
     (STRONG "pathname") " => " (STRONG "version"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathname") " - パス名指定子" EOL1 (STRONG "case") " - "
     (CODE1 ":common") "か" (CODE1 ":local") "のうちのひとつ。デフォルトは" (CODE1 ":local") "です。" EOL1
     (STRONG "host") " - 有効なパス名のホスト。" EOL1 (STRONG "device") " - 有効なパス名のデバイス。" EOL1
     (STRONG "directory") " - 有効なパス名のディレクトリ。" EOL1 (STRONG "name") " - 有効なパス名の名前。" EOL1
     (STRONG "type") " - 有効なパス名の型。" EOL1 (STRONG "version") " - 有効なパス名のバージョン。")
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "pathname") "の要素を返却します。" EOL2 "もし"
     (STRONG "pathname") "指定子がパス名（おそらくストリームの誤字）のとき、"
     "それはオープンされているファイルによって使用されている名前が表現されます。" "これはおそらく、要求はされていませんが、" "実際のファイルの名前です。" EOL2
     "もし" (STRONG "case") "が指定されたとき、" "それは19.2.2.1.2. パス名の要素の大文字小文字の説明のように扱われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq q (make-pathname :host \"KATHY\""
      "                       :directory \"CHAPMAN\" "
      "                       :name \"LOGIN\" :type \"COM\"))"
      "=>  #P\"KATHY::[CHAPMAN]LOGIN.COM\"" "(pathname-host q) =>  \"KATHY\""
      "(pathname-name q) =>  \"LOGIN\"" "(pathname-type q) =>  \"COM\"" NIL
      ";; 名前文字列を使用するため、例で示した結果が唯一の可能な結果で" ";; あるとは限りません。名前文字列の表現からパス名表現へのマッピングは、"
      ";; 関係するファイルシステムと実装の両方に依存します（同じファイルシステムを" ";; 操作できる実装が複数存在し、それらの実装はすべての詳細について合意する"
      ";; 制約がないため）。名前文字列がどのように扱われるかについての" ";; 具体的な情報は、各実装のドキュメントを参照してください。" NIL ";; VMS"
      "(pathname-directory (parse-namestring \"[FOO.*.BAR]BAZ.LSP\"))"
      "=>  (:ABSOLUTE \"FOO\" \"BAR\")"
      "(pathname-directory (parse-namestring \"[FOO.*.BAR]BAZ.LSP\") :case :common)"
      ">  (:ABSOLUTE \"FOO\" \"BAR\")" NIL ";; Unix"
      "(pathname-directory \"foo.l\") =>  NIL"
      "(pathname-device \"foo.l\") =>  :UNSPECIFIC"
      "(pathname-name \"foo.l\") =>  \"foo\""
      "(pathname-name \"foo.l\" :case :local) =>  \"foo\""
      "(pathname-name \"foo.l\" :case :common) =>  \"FOO\""
      "(pathname-type \"foo.l\") =>  \"l\""
      "(pathname-type \"foo.l\" :case :local) =>  \"l\""
      "(pathname-type \"foo.l\" :case :common) =>  \"L\""
      "(pathname-type \"foo\") =>  :UNSPECIFIC"
      "(pathname-type \"foo\" :case :common) =>  :UNSPECIFIC"
      "(pathname-type \"foo.\") =>  \"\""
      "(pathname-type \"foo.\" :case :common) =>  \"\""
      "(pathname-directory (parse-namestring \"/foo/bar/baz.lisp\") :case :local)"
      "=>  (:ABSOLUTE \"foo\" \"bar\")"
      "(pathname-directory (parse-namestring \"/foo/bar/baz.lisp\") :case :local)"
      "=>  (:ABSOLUTE \"FOO\" \"BAR\")"
      "(pathname-directory (parse-namestring \"../baz.lisp\"))" "=>  (:RELATIVE :UP)"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/BAR/../Mum/baz\"))"
      "=>  (:ABSOLUTE \"foo\" \"BAR\" :UP \"Mum\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/BAR/../Mum/baz\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" \"bar\" :UP \"Mum\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/*/bar/baz.l\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD \"bar\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/*/bar/baz.l\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" :WILD \"BAR\")" NIL ";; Symbolics LMFS"
      "(pathname-directory (parse-namestring \">foo>**>bar>baz.lisp\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD-INFERIORS \"bar\")"
      "(pathname-directory (parse-namestring \">foo>*>bar>baz.lisp\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD \"bar\")"
      "(pathname-directory (parse-namestring \">foo>*>bar>baz.lisp\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" :WILD \"BAR\")"
      "(pathname-device (parse-namestring \">foo>baz.lisp\")) =>  :UNSPECIFIC"))
    (CHAPTER ("## 影響") 2 "実装とホストファイルシステム。")
    (CHAPTER ("## 例外") 2 "最初の引数がパス名でないときは" "型" (CODE1 "type-error") "のエラーを通知するべきです。")
    (CHAPTER ("## 参考") 2 (CODE1 "pathname") "," (CODE1 "logical-pathname") ","
     "20.1. ファイルシステムの説明," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PATHNAME-DIRECTORY" . "FUNCTION") *table*) (gethash "PATHNAME-DIRECTORY" *table*))
(setf (gethash "PATHNAME-HOST" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PATHNAME-HOST") " " (CODE1 "PATHNAME-DEVICE") ", "
     (CODE1 "PATHNAME-DIRECTORY") "," " " (CODE1 "PATHNAME-NAME") ", "
     (CODE1 "PATHNAME-TYPE") ", " (CODE1 "PATHNAME-VERSION"))
    (CHAPTER ("## 構文") 2 (CODE1 "pathname-host") " " (STRONG "pathname") " "
     (CODE1 "&key") " " (STRONG "case") " => " (STRONG "host") EOL1
     (CODE1 "pathname-device") " " (STRONG "pathname") " " (CODE1 "&key") " "
     (STRONG "case") " => " (STRONG "device") EOL1 (CODE1 "pathname-directory") " "
     (STRONG "pathname") " " (CODE1 "&key") " " (STRONG "case") " => "
     (STRONG "directory") EOL1 (CODE1 "pathname-name") " " (STRONG "pathname") " "
     (CODE1 "&key") " " (STRONG "case") " => " (STRONG "name") EOL1
     (CODE1 "pathname-type") " " (STRONG "pathname") " " (CODE1 "&key") " "
     (STRONG "case") " => " (STRONG "type") EOL1 (CODE1 "pathname-version") " "
     (STRONG "pathname") " => " (STRONG "version"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathname") " - パス名指定子" EOL1 (STRONG "case") " - "
     (CODE1 ":common") "か" (CODE1 ":local") "のうちのひとつ。デフォルトは" (CODE1 ":local") "です。" EOL1
     (STRONG "host") " - 有効なパス名のホスト。" EOL1 (STRONG "device") " - 有効なパス名のデバイス。" EOL1
     (STRONG "directory") " - 有効なパス名のディレクトリ。" EOL1 (STRONG "name") " - 有効なパス名の名前。" EOL1
     (STRONG "type") " - 有効なパス名の型。" EOL1 (STRONG "version") " - 有効なパス名のバージョン。")
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "pathname") "の要素を返却します。" EOL2 "もし"
     (STRONG "pathname") "指定子がパス名（おそらくストリームの誤字）のとき、"
     "それはオープンされているファイルによって使用されている名前が表現されます。" "これはおそらく、要求はされていませんが、" "実際のファイルの名前です。" EOL2
     "もし" (STRONG "case") "が指定されたとき、" "それは19.2.2.1.2. パス名の要素の大文字小文字の説明のように扱われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq q (make-pathname :host \"KATHY\""
      "                       :directory \"CHAPMAN\" "
      "                       :name \"LOGIN\" :type \"COM\"))"
      "=>  #P\"KATHY::[CHAPMAN]LOGIN.COM\"" "(pathname-host q) =>  \"KATHY\""
      "(pathname-name q) =>  \"LOGIN\"" "(pathname-type q) =>  \"COM\"" NIL
      ";; 名前文字列を使用するため、例で示した結果が唯一の可能な結果で" ";; あるとは限りません。名前文字列の表現からパス名表現へのマッピングは、"
      ";; 関係するファイルシステムと実装の両方に依存します（同じファイルシステムを" ";; 操作できる実装が複数存在し、それらの実装はすべての詳細について合意する"
      ";; 制約がないため）。名前文字列がどのように扱われるかについての" ";; 具体的な情報は、各実装のドキュメントを参照してください。" NIL ";; VMS"
      "(pathname-directory (parse-namestring \"[FOO.*.BAR]BAZ.LSP\"))"
      "=>  (:ABSOLUTE \"FOO\" \"BAR\")"
      "(pathname-directory (parse-namestring \"[FOO.*.BAR]BAZ.LSP\") :case :common)"
      ">  (:ABSOLUTE \"FOO\" \"BAR\")" NIL ";; Unix"
      "(pathname-directory \"foo.l\") =>  NIL"
      "(pathname-device \"foo.l\") =>  :UNSPECIFIC"
      "(pathname-name \"foo.l\") =>  \"foo\""
      "(pathname-name \"foo.l\" :case :local) =>  \"foo\""
      "(pathname-name \"foo.l\" :case :common) =>  \"FOO\""
      "(pathname-type \"foo.l\") =>  \"l\""
      "(pathname-type \"foo.l\" :case :local) =>  \"l\""
      "(pathname-type \"foo.l\" :case :common) =>  \"L\""
      "(pathname-type \"foo\") =>  :UNSPECIFIC"
      "(pathname-type \"foo\" :case :common) =>  :UNSPECIFIC"
      "(pathname-type \"foo.\") =>  \"\""
      "(pathname-type \"foo.\" :case :common) =>  \"\""
      "(pathname-directory (parse-namestring \"/foo/bar/baz.lisp\") :case :local)"
      "=>  (:ABSOLUTE \"foo\" \"bar\")"
      "(pathname-directory (parse-namestring \"/foo/bar/baz.lisp\") :case :local)"
      "=>  (:ABSOLUTE \"FOO\" \"BAR\")"
      "(pathname-directory (parse-namestring \"../baz.lisp\"))" "=>  (:RELATIVE :UP)"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/BAR/../Mum/baz\"))"
      "=>  (:ABSOLUTE \"foo\" \"BAR\" :UP \"Mum\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/BAR/../Mum/baz\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" \"bar\" :UP \"Mum\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/*/bar/baz.l\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD \"bar\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/*/bar/baz.l\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" :WILD \"BAR\")" NIL ";; Symbolics LMFS"
      "(pathname-directory (parse-namestring \">foo>**>bar>baz.lisp\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD-INFERIORS \"bar\")"
      "(pathname-directory (parse-namestring \">foo>*>bar>baz.lisp\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD \"bar\")"
      "(pathname-directory (parse-namestring \">foo>*>bar>baz.lisp\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" :WILD \"BAR\")"
      "(pathname-device (parse-namestring \">foo>baz.lisp\")) =>  :UNSPECIFIC"))
    (CHAPTER ("## 影響") 2 "実装とホストファイルシステム。")
    (CHAPTER ("## 例外") 2 "最初の引数がパス名でないときは" "型" (CODE1 "type-error") "のエラーを通知するべきです。")
    (CHAPTER ("## 参考") 2 (CODE1 "pathname") "," (CODE1 "logical-pathname") ","
     "20.1. ファイルシステムの説明," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PATHNAME-HOST" . "FUNCTION") *table*) (gethash "PATHNAME-HOST" *table*))
(setf (gethash "PATHNAME-MATCH-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PATHNAME-MATCH-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "pathname-match-p") " " (STRONG "pathname") " "
     (STRONG "wildcard") " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathname") " - パス名指定子" EOL1 (STRONG "wildcard")
     " - ワイルドカードパス名の指定子" EOL1 (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "pathname-match-p") "は、" (STRONG "pathname") "と"
     (STRONG "wildcard") "がマッチするときは" (STRONG "true") "を、" "そうでないときは" (CODE1 "nil")
     "を返却します。" "マッチの規則は実装定義ですが、" "それは" (CODE1 "directory") "と一貫していなければなりません。"
     (STRONG "wildcard") "の欠落した要素は標準で" (CODE1 ":wild") "になります。" EOL2 "もし"
     (STRONG "pathname") "が有効なワイルドカードのパス名のとき、" (STRONG "pathname") "のワイルドカードの要素は、"
     (STRONG "wildcard") "のその要素がワイルドカードのときのみマッチします" "（よって" (CODE1 "pathname-match-p")
     "は交換可能ではありません）。" (STRONG "wildcard") "がワイルドカードを含まないパス名のときでも有効です。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "pathname") "か" (STRONG "wildcard") "が、"
     "パス名、文字列、ファイルに関連づいたストリームの" "いずれかでもないときは、" "型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "directory") "," (CODE1 "pathname") ","
     (CODE1 "logical-pathname") "," "20.1. ファイルシステムの説明," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PATHNAME-MATCH-P" . "FUNCTION") *table*) (gethash "PATHNAME-MATCH-P" *table*))
(setf (gethash "PATHNAME-NAME" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PATHNAME-HOST") " " (CODE1 "PATHNAME-DEVICE") ", "
     (CODE1 "PATHNAME-DIRECTORY") "," " " (CODE1 "PATHNAME-NAME") ", "
     (CODE1 "PATHNAME-TYPE") ", " (CODE1 "PATHNAME-VERSION"))
    (CHAPTER ("## 構文") 2 (CODE1 "pathname-host") " " (STRONG "pathname") " "
     (CODE1 "&key") " " (STRONG "case") " => " (STRONG "host") EOL1
     (CODE1 "pathname-device") " " (STRONG "pathname") " " (CODE1 "&key") " "
     (STRONG "case") " => " (STRONG "device") EOL1 (CODE1 "pathname-directory") " "
     (STRONG "pathname") " " (CODE1 "&key") " " (STRONG "case") " => "
     (STRONG "directory") EOL1 (CODE1 "pathname-name") " " (STRONG "pathname") " "
     (CODE1 "&key") " " (STRONG "case") " => " (STRONG "name") EOL1
     (CODE1 "pathname-type") " " (STRONG "pathname") " " (CODE1 "&key") " "
     (STRONG "case") " => " (STRONG "type") EOL1 (CODE1 "pathname-version") " "
     (STRONG "pathname") " => " (STRONG "version"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathname") " - パス名指定子" EOL1 (STRONG "case") " - "
     (CODE1 ":common") "か" (CODE1 ":local") "のうちのひとつ。デフォルトは" (CODE1 ":local") "です。" EOL1
     (STRONG "host") " - 有効なパス名のホスト。" EOL1 (STRONG "device") " - 有効なパス名のデバイス。" EOL1
     (STRONG "directory") " - 有効なパス名のディレクトリ。" EOL1 (STRONG "name") " - 有効なパス名の名前。" EOL1
     (STRONG "type") " - 有効なパス名の型。" EOL1 (STRONG "version") " - 有効なパス名のバージョン。")
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "pathname") "の要素を返却します。" EOL2 "もし"
     (STRONG "pathname") "指定子がパス名（おそらくストリームの誤字）のとき、"
     "それはオープンされているファイルによって使用されている名前が表現されます。" "これはおそらく、要求はされていませんが、" "実際のファイルの名前です。" EOL2
     "もし" (STRONG "case") "が指定されたとき、" "それは19.2.2.1.2. パス名の要素の大文字小文字の説明のように扱われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq q (make-pathname :host \"KATHY\""
      "                       :directory \"CHAPMAN\" "
      "                       :name \"LOGIN\" :type \"COM\"))"
      "=>  #P\"KATHY::[CHAPMAN]LOGIN.COM\"" "(pathname-host q) =>  \"KATHY\""
      "(pathname-name q) =>  \"LOGIN\"" "(pathname-type q) =>  \"COM\"" NIL
      ";; 名前文字列を使用するため、例で示した結果が唯一の可能な結果で" ";; あるとは限りません。名前文字列の表現からパス名表現へのマッピングは、"
      ";; 関係するファイルシステムと実装の両方に依存します（同じファイルシステムを" ";; 操作できる実装が複数存在し、それらの実装はすべての詳細について合意する"
      ";; 制約がないため）。名前文字列がどのように扱われるかについての" ";; 具体的な情報は、各実装のドキュメントを参照してください。" NIL ";; VMS"
      "(pathname-directory (parse-namestring \"[FOO.*.BAR]BAZ.LSP\"))"
      "=>  (:ABSOLUTE \"FOO\" \"BAR\")"
      "(pathname-directory (parse-namestring \"[FOO.*.BAR]BAZ.LSP\") :case :common)"
      ">  (:ABSOLUTE \"FOO\" \"BAR\")" NIL ";; Unix"
      "(pathname-directory \"foo.l\") =>  NIL"
      "(pathname-device \"foo.l\") =>  :UNSPECIFIC"
      "(pathname-name \"foo.l\") =>  \"foo\""
      "(pathname-name \"foo.l\" :case :local) =>  \"foo\""
      "(pathname-name \"foo.l\" :case :common) =>  \"FOO\""
      "(pathname-type \"foo.l\") =>  \"l\""
      "(pathname-type \"foo.l\" :case :local) =>  \"l\""
      "(pathname-type \"foo.l\" :case :common) =>  \"L\""
      "(pathname-type \"foo\") =>  :UNSPECIFIC"
      "(pathname-type \"foo\" :case :common) =>  :UNSPECIFIC"
      "(pathname-type \"foo.\") =>  \"\""
      "(pathname-type \"foo.\" :case :common) =>  \"\""
      "(pathname-directory (parse-namestring \"/foo/bar/baz.lisp\") :case :local)"
      "=>  (:ABSOLUTE \"foo\" \"bar\")"
      "(pathname-directory (parse-namestring \"/foo/bar/baz.lisp\") :case :local)"
      "=>  (:ABSOLUTE \"FOO\" \"BAR\")"
      "(pathname-directory (parse-namestring \"../baz.lisp\"))" "=>  (:RELATIVE :UP)"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/BAR/../Mum/baz\"))"
      "=>  (:ABSOLUTE \"foo\" \"BAR\" :UP \"Mum\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/BAR/../Mum/baz\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" \"bar\" :UP \"Mum\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/*/bar/baz.l\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD \"bar\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/*/bar/baz.l\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" :WILD \"BAR\")" NIL ";; Symbolics LMFS"
      "(pathname-directory (parse-namestring \">foo>**>bar>baz.lisp\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD-INFERIORS \"bar\")"
      "(pathname-directory (parse-namestring \">foo>*>bar>baz.lisp\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD \"bar\")"
      "(pathname-directory (parse-namestring \">foo>*>bar>baz.lisp\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" :WILD \"BAR\")"
      "(pathname-device (parse-namestring \">foo>baz.lisp\")) =>  :UNSPECIFIC"))
    (CHAPTER ("## 影響") 2 "実装とホストファイルシステム。")
    (CHAPTER ("## 例外") 2 "最初の引数がパス名でないときは" "型" (CODE1 "type-error") "のエラーを通知するべきです。")
    (CHAPTER ("## 参考") 2 (CODE1 "pathname") "," (CODE1 "logical-pathname") ","
     "20.1. ファイルシステムの説明," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PATHNAME-NAME" . "FUNCTION") *table*) (gethash "PATHNAME-NAME" *table*))
(setf (gethash "PATHNAME-TYPE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PATHNAME-HOST") " " (CODE1 "PATHNAME-DEVICE") ", "
     (CODE1 "PATHNAME-DIRECTORY") "," " " (CODE1 "PATHNAME-NAME") ", "
     (CODE1 "PATHNAME-TYPE") ", " (CODE1 "PATHNAME-VERSION"))
    (CHAPTER ("## 構文") 2 (CODE1 "pathname-host") " " (STRONG "pathname") " "
     (CODE1 "&key") " " (STRONG "case") " => " (STRONG "host") EOL1
     (CODE1 "pathname-device") " " (STRONG "pathname") " " (CODE1 "&key") " "
     (STRONG "case") " => " (STRONG "device") EOL1 (CODE1 "pathname-directory") " "
     (STRONG "pathname") " " (CODE1 "&key") " " (STRONG "case") " => "
     (STRONG "directory") EOL1 (CODE1 "pathname-name") " " (STRONG "pathname") " "
     (CODE1 "&key") " " (STRONG "case") " => " (STRONG "name") EOL1
     (CODE1 "pathname-type") " " (STRONG "pathname") " " (CODE1 "&key") " "
     (STRONG "case") " => " (STRONG "type") EOL1 (CODE1 "pathname-version") " "
     (STRONG "pathname") " => " (STRONG "version"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathname") " - パス名指定子" EOL1 (STRONG "case") " - "
     (CODE1 ":common") "か" (CODE1 ":local") "のうちのひとつ。デフォルトは" (CODE1 ":local") "です。" EOL1
     (STRONG "host") " - 有効なパス名のホスト。" EOL1 (STRONG "device") " - 有効なパス名のデバイス。" EOL1
     (STRONG "directory") " - 有効なパス名のディレクトリ。" EOL1 (STRONG "name") " - 有効なパス名の名前。" EOL1
     (STRONG "type") " - 有効なパス名の型。" EOL1 (STRONG "version") " - 有効なパス名のバージョン。")
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "pathname") "の要素を返却します。" EOL2 "もし"
     (STRONG "pathname") "指定子がパス名（おそらくストリームの誤字）のとき、"
     "それはオープンされているファイルによって使用されている名前が表現されます。" "これはおそらく、要求はされていませんが、" "実際のファイルの名前です。" EOL2
     "もし" (STRONG "case") "が指定されたとき、" "それは19.2.2.1.2. パス名の要素の大文字小文字の説明のように扱われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq q (make-pathname :host \"KATHY\""
      "                       :directory \"CHAPMAN\" "
      "                       :name \"LOGIN\" :type \"COM\"))"
      "=>  #P\"KATHY::[CHAPMAN]LOGIN.COM\"" "(pathname-host q) =>  \"KATHY\""
      "(pathname-name q) =>  \"LOGIN\"" "(pathname-type q) =>  \"COM\"" NIL
      ";; 名前文字列を使用するため、例で示した結果が唯一の可能な結果で" ";; あるとは限りません。名前文字列の表現からパス名表現へのマッピングは、"
      ";; 関係するファイルシステムと実装の両方に依存します（同じファイルシステムを" ";; 操作できる実装が複数存在し、それらの実装はすべての詳細について合意する"
      ";; 制約がないため）。名前文字列がどのように扱われるかについての" ";; 具体的な情報は、各実装のドキュメントを参照してください。" NIL ";; VMS"
      "(pathname-directory (parse-namestring \"[FOO.*.BAR]BAZ.LSP\"))"
      "=>  (:ABSOLUTE \"FOO\" \"BAR\")"
      "(pathname-directory (parse-namestring \"[FOO.*.BAR]BAZ.LSP\") :case :common)"
      ">  (:ABSOLUTE \"FOO\" \"BAR\")" NIL ";; Unix"
      "(pathname-directory \"foo.l\") =>  NIL"
      "(pathname-device \"foo.l\") =>  :UNSPECIFIC"
      "(pathname-name \"foo.l\") =>  \"foo\""
      "(pathname-name \"foo.l\" :case :local) =>  \"foo\""
      "(pathname-name \"foo.l\" :case :common) =>  \"FOO\""
      "(pathname-type \"foo.l\") =>  \"l\""
      "(pathname-type \"foo.l\" :case :local) =>  \"l\""
      "(pathname-type \"foo.l\" :case :common) =>  \"L\""
      "(pathname-type \"foo\") =>  :UNSPECIFIC"
      "(pathname-type \"foo\" :case :common) =>  :UNSPECIFIC"
      "(pathname-type \"foo.\") =>  \"\""
      "(pathname-type \"foo.\" :case :common) =>  \"\""
      "(pathname-directory (parse-namestring \"/foo/bar/baz.lisp\") :case :local)"
      "=>  (:ABSOLUTE \"foo\" \"bar\")"
      "(pathname-directory (parse-namestring \"/foo/bar/baz.lisp\") :case :local)"
      "=>  (:ABSOLUTE \"FOO\" \"BAR\")"
      "(pathname-directory (parse-namestring \"../baz.lisp\"))" "=>  (:RELATIVE :UP)"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/BAR/../Mum/baz\"))"
      "=>  (:ABSOLUTE \"foo\" \"BAR\" :UP \"Mum\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/BAR/../Mum/baz\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" \"bar\" :UP \"Mum\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/*/bar/baz.l\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD \"bar\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/*/bar/baz.l\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" :WILD \"BAR\")" NIL ";; Symbolics LMFS"
      "(pathname-directory (parse-namestring \">foo>**>bar>baz.lisp\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD-INFERIORS \"bar\")"
      "(pathname-directory (parse-namestring \">foo>*>bar>baz.lisp\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD \"bar\")"
      "(pathname-directory (parse-namestring \">foo>*>bar>baz.lisp\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" :WILD \"BAR\")"
      "(pathname-device (parse-namestring \">foo>baz.lisp\")) =>  :UNSPECIFIC"))
    (CHAPTER ("## 影響") 2 "実装とホストファイルシステム。")
    (CHAPTER ("## 例外") 2 "最初の引数がパス名でないときは" "型" (CODE1 "type-error") "のエラーを通知するべきです。")
    (CHAPTER ("## 参考") 2 (CODE1 "pathname") "," (CODE1 "logical-pathname") ","
     "20.1. ファイルシステムの説明," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PATHNAME-TYPE" . "FUNCTION") *table*) (gethash "PATHNAME-TYPE" *table*))
(setf (gethash "PATHNAME-VERSION" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PATHNAME-HOST") " " (CODE1 "PATHNAME-DEVICE") ", "
     (CODE1 "PATHNAME-DIRECTORY") "," " " (CODE1 "PATHNAME-NAME") ", "
     (CODE1 "PATHNAME-TYPE") ", " (CODE1 "PATHNAME-VERSION"))
    (CHAPTER ("## 構文") 2 (CODE1 "pathname-host") " " (STRONG "pathname") " "
     (CODE1 "&key") " " (STRONG "case") " => " (STRONG "host") EOL1
     (CODE1 "pathname-device") " " (STRONG "pathname") " " (CODE1 "&key") " "
     (STRONG "case") " => " (STRONG "device") EOL1 (CODE1 "pathname-directory") " "
     (STRONG "pathname") " " (CODE1 "&key") " " (STRONG "case") " => "
     (STRONG "directory") EOL1 (CODE1 "pathname-name") " " (STRONG "pathname") " "
     (CODE1 "&key") " " (STRONG "case") " => " (STRONG "name") EOL1
     (CODE1 "pathname-type") " " (STRONG "pathname") " " (CODE1 "&key") " "
     (STRONG "case") " => " (STRONG "type") EOL1 (CODE1 "pathname-version") " "
     (STRONG "pathname") " => " (STRONG "version"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathname") " - パス名指定子" EOL1 (STRONG "case") " - "
     (CODE1 ":common") "か" (CODE1 ":local") "のうちのひとつ。デフォルトは" (CODE1 ":local") "です。" EOL1
     (STRONG "host") " - 有効なパス名のホスト。" EOL1 (STRONG "device") " - 有効なパス名のデバイス。" EOL1
     (STRONG "directory") " - 有効なパス名のディレクトリ。" EOL1 (STRONG "name") " - 有効なパス名の名前。" EOL1
     (STRONG "type") " - 有効なパス名の型。" EOL1 (STRONG "version") " - 有効なパス名のバージョン。")
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "pathname") "の要素を返却します。" EOL2 "もし"
     (STRONG "pathname") "指定子がパス名（おそらくストリームの誤字）のとき、"
     "それはオープンされているファイルによって使用されている名前が表現されます。" "これはおそらく、要求はされていませんが、" "実際のファイルの名前です。" EOL2
     "もし" (STRONG "case") "が指定されたとき、" "それは19.2.2.1.2. パス名の要素の大文字小文字の説明のように扱われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq q (make-pathname :host \"KATHY\""
      "                       :directory \"CHAPMAN\" "
      "                       :name \"LOGIN\" :type \"COM\"))"
      "=>  #P\"KATHY::[CHAPMAN]LOGIN.COM\"" "(pathname-host q) =>  \"KATHY\""
      "(pathname-name q) =>  \"LOGIN\"" "(pathname-type q) =>  \"COM\"" NIL
      ";; 名前文字列を使用するため、例で示した結果が唯一の可能な結果で" ";; あるとは限りません。名前文字列の表現からパス名表現へのマッピングは、"
      ";; 関係するファイルシステムと実装の両方に依存します（同じファイルシステムを" ";; 操作できる実装が複数存在し、それらの実装はすべての詳細について合意する"
      ";; 制約がないため）。名前文字列がどのように扱われるかについての" ";; 具体的な情報は、各実装のドキュメントを参照してください。" NIL ";; VMS"
      "(pathname-directory (parse-namestring \"[FOO.*.BAR]BAZ.LSP\"))"
      "=>  (:ABSOLUTE \"FOO\" \"BAR\")"
      "(pathname-directory (parse-namestring \"[FOO.*.BAR]BAZ.LSP\") :case :common)"
      ">  (:ABSOLUTE \"FOO\" \"BAR\")" NIL ";; Unix"
      "(pathname-directory \"foo.l\") =>  NIL"
      "(pathname-device \"foo.l\") =>  :UNSPECIFIC"
      "(pathname-name \"foo.l\") =>  \"foo\""
      "(pathname-name \"foo.l\" :case :local) =>  \"foo\""
      "(pathname-name \"foo.l\" :case :common) =>  \"FOO\""
      "(pathname-type \"foo.l\") =>  \"l\""
      "(pathname-type \"foo.l\" :case :local) =>  \"l\""
      "(pathname-type \"foo.l\" :case :common) =>  \"L\""
      "(pathname-type \"foo\") =>  :UNSPECIFIC"
      "(pathname-type \"foo\" :case :common) =>  :UNSPECIFIC"
      "(pathname-type \"foo.\") =>  \"\""
      "(pathname-type \"foo.\" :case :common) =>  \"\""
      "(pathname-directory (parse-namestring \"/foo/bar/baz.lisp\") :case :local)"
      "=>  (:ABSOLUTE \"foo\" \"bar\")"
      "(pathname-directory (parse-namestring \"/foo/bar/baz.lisp\") :case :local)"
      "=>  (:ABSOLUTE \"FOO\" \"BAR\")"
      "(pathname-directory (parse-namestring \"../baz.lisp\"))" "=>  (:RELATIVE :UP)"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/BAR/../Mum/baz\"))"
      "=>  (:ABSOLUTE \"foo\" \"BAR\" :UP \"Mum\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/BAR/../Mum/baz\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" \"bar\" :UP \"Mum\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/*/bar/baz.l\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD \"bar\")"
      "(PATHNAME-DIRECTORY (PARSE-NAMESTRING \"/foo/*/bar/baz.l\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" :WILD \"BAR\")" NIL ";; Symbolics LMFS"
      "(pathname-directory (parse-namestring \">foo>**>bar>baz.lisp\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD-INFERIORS \"bar\")"
      "(pathname-directory (parse-namestring \">foo>*>bar>baz.lisp\"))"
      "=>  (:ABSOLUTE \"foo\" :WILD \"bar\")"
      "(pathname-directory (parse-namestring \">foo>*>bar>baz.lisp\") :case :common)"
      "=>  (:ABSOLUTE \"FOO\" :WILD \"BAR\")"
      "(pathname-device (parse-namestring \">foo>baz.lisp\")) =>  :UNSPECIFIC"))
    (CHAPTER ("## 影響") 2 "実装とホストファイルシステム。")
    (CHAPTER ("## 例外") 2 "最初の引数がパス名でないときは" "型" (CODE1 "type-error") "のエラーを通知するべきです。")
    (CHAPTER ("## 参考") 2 (CODE1 "pathname") "," (CODE1 "logical-pathname") ","
     "20.1. ファイルシステムの説明," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PATHNAME-VERSION" . "FUNCTION") *table*) (gethash "PATHNAME-VERSION" *table*))
(setf (gethash "PATHNAMEP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PATHNAMEP"))
    (CHAPTER ("## 構文") 2 (CODE1 "pathnamep") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が型" (CODE1 "pathname") "のときは" (STRONG "true")
     "を、" "それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq q \"test\")  =>  \"test\"" "(pathnamep q) =>  false"
      "(setq q (pathname \"test\"))"
      "=>  #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME \"test\" :TYPE NIL"
      "      :VERSION NIL)" "(pathnamep q) =>  true "
      "(setq q (logical-pathname \"SYS:SITE;FOO.SYSTEM\"))"
      "=>  #P\"SYS:SITE;FOO.SYSTEM\"" "(pathnamep q) =>  true"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(pathnamep object) == (typep object 'pathname)"))))
(setf (gethash '("PATHNAMEP" . "FUNCTION") *table*) (gethash "PATHNAMEP" *table*))
(setf (gethash "PEEK-CHAR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PEEK-CHAR"))
    (CHAPTER ("## 構文") 2 (CODE1 "peek-char") " " (CODE1 "&optional") " "
     (STRONG "peek-type") " " (STRONG "input-stream") " " (STRONG "eof-error-p") " "
     (STRONG "eof-value") " " (STRONG "recursive-p") " => " (STRONG "char"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "peek-type") " - 文字か、" (CODE1 "t") "か、"
     (CODE1 "nil") EOL1 (STRONG "input-stream") " - 入力ストリーム指定子。デフォルトは標準入力。" EOL1
     (STRONG "eof-error-p") " - generalized-boolean。デフォルトは" (STRONG "true") "。" EOL1
     (STRONG "eof-value") " - オブジェクト。デフォルトは" (CODE1 "nil") "。" EOL1
     (STRONG "recursive-p") " - generalized-boolean。デフォルトは" (STRONG "false") "。" EOL1
     (STRONG "char") " - 文字か、" (STRONG "eof-value"))
    (CHAPTER ("## 定義") 2 (CODE1 "peek-char") "は、" (STRONG "input-stream") "から"
     "実際に読み込むことをせず次の文字を取得し、" "あとで読み込まれるように文字を残したままにします。" "また、特定の文字が見つかるまで"
     (STRONG "input-stream") "の文字をスキップし" "文字による介入を無視するときにも使用されます。" EOL2 "もし"
     (STRONG "peek-type") "が指定されなかったか、あるいは" (CODE1 "nil") "のとき、" (CODE1 "peek-char") "は"
     (STRONG "input-stream") "から文字を取り除くことをせずに" "次に読み込まれる文字を返却します。" "次回の入力は実行された"
     (STRONG "input-stream") "のものであり、" "その文字はまだそこに存在します。" "もし" (STRONG "peek-type") "が"
     (CODE1 "t") "のとき、" (CODE1 "peek-char") "は空白文字をスキップし、" "しかしコメントはスキップせずに、" "次の文字の"
     (CODE1 "peek-char") "処理を行います。" "最後に調査された文字は、" "その文字が開始のオブジェクトになるので、"
     (STRONG "input-stream") "から削除されません。" "もし" (STRONG "peek-char") "が文字のとき、"
     (CODE1 "peek-char") "は入力された文字に対して、" (CODE1 "char=") "と同じものが見つかるまでスキップし、" "その文字は"
     (STRONG "input-stream") "から削除されます。" EOL2 "もしファイルの終わりが発生し、" (STRONG "eof-error-p")
     "が" (STRONG "false") "であるときは、" (STRONG "eof-value") "が返却されます。" EOL2 "もし"
     (STRONG "recursive-p") "が" (STRONG "true") "のとき、" "この呼び出しはより上位レベルの" (CODE1 "read")
     "によるものか、" "Lispのリーダーによって使われる似たような関数から" "埋め込まれたものであると見なされます。" EOL2
     (STRONG "input-stream") "が" (CODE1 "echo") "ストリームであるとき、" "文字はのぞき見だけが行われ、エコーはされません。"
     "このような場合、" (STRONG "peek-type") "が" (CODE1 "nil") "ではないとき、" (CODE1 "peek-char")
     "によってのぞき見された文字は、" (CODE1 "read-char") "によるものと同じように扱われるので、" (CODE1 "unread-char")
     "で別段指定されない限りエコーされます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-input-from-string (input-stream \"    1 2 3 4 5\")"
      "   (format t \"~S ~S ~S\" " "           (peek-char t input-stream)"
      "           (peek-char #\\4 input-stream)"
      "           (peek-char nil input-stream)))" ">>  #\\1 #\\4 #\\4" "=>  NIL"))
    (CHAPTER ("## 影響") 2 (CODE1 "*readtable*") "," (CODE1 "*standard-input*") ","
     (CODE1 "*terminal-io*"))
    (CHAPTER ("## 例外") 2 (STRONG "eof-error-p") "が" (STRONG "true")
     "でありファイルの終わりに到達したときは、" "型" (CODE1 "end-of-file") "のエラーが通知されます。" EOL2
     (STRONG "peek-type") "が文字であり、ファイルの終わりに到達し、" (STRONG "eof-error-p") "が"
     (STRONG "true") "のときは、" "型" (CODE1 "end-of-file") "のエラーが通知されます。" EOL2
     (STRONG "recursive-p") "が" (STRONG "true") "であり、ファイルの終わりに到達したときは、" "型"
     (CODE1 "end-of-file") "のエラーが通知されます。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PEEK-CHAR" . "FUNCTION") *table*) (gethash "PEEK-CHAR" *table*))
(setf (gethash "POP" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "POP"))
    (CHAPTER ("## 構文") 2 (CODE1 "pop") " " (STRONG "place") " => " (STRONG "element"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "place") " - " (CODE1 "place") ","
     "リストである値（ドットリストか循環リストの可能性があります）" EOL1 (STRONG "element") " - オブジェクト（"
     (STRONG "place") "の内容の" (CODE1 "car") "部）")
    (CHAPTER ("## 定義") 2 (CODE1 "pop") "は" (STRONG "place") "から値を読み、" "取得されたリストの"
     (CODE1 "car") "を取得し、" (STRONG "place") "にリストの" (CODE1 "cdr") "を書き込み、"
     "そして最後にリストから取得した元の" (CODE1 "car") "部を返却します。" EOL2 (STRONG "place")
     "のサブフォームの評価については、" "5.1.1.1. " (CODE1 "place") "のサブフォームの評価をご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq stack '(a b c)) =>  (A B C)" "(pop stack) =>  A  "
      "stack =>  (B C)" "(setq llst '((1 2 3 4))) =>  ((1 2 3 4))"
      "(pop (car llst)) =>  1" "llst =>  ((2 3 4))"))
    (CHAPTER ("## 副作用") 2 (STRONG "place") "の内容は修正されます。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "push") "," (CODE1 "pushnew") "," "5.1. 一般化された参照")
    (CHAPTER ("## 備考") 2 (CODE1 "(pop place)") "の効果は、だいたい次と同等です。"
     (CODE3 "```lisp" "```" "(prog1 (car place) (setf place (cdr place)))") EOL2
     "ただし、これはサブフォームを3回評価するのに対して、" (CODE1 "pop") "はそれをたった一度しか評価しません。")))
(setf (gethash '("POP" . "MACRO") *table*) (gethash "POP" *table*))
(setf (gethash "POSITION" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "POSITION") ", " (CODE1 "POSITION-IF") ", "
     (CODE1 "POSITION-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "position") " " (STRONG "item") " " (STRONG "sequence")
     " &key " (STRONG "from-end") " " (STRONG "test") " " (STRONG "test-not") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "key") " => " (STRONG "position")
     EOL1 (CODE1 "position-if") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "key")
     " => " (STRONG "position") EOL1 (CODE1 "position-if-not") " " (STRONG "predicate")
     " " (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "key") " => " (STRONG "position"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "sequence")
     " - 正常なシーケンス" EOL1 (STRONG "predicate") " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子"
     EOL1 (STRONG "from-end") " - generalized-boolean、デフォルトは" (STRONG "false") EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "position") " - "
     (STRONG "sequence") "の境界インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "position") "、" (CODE1 "position-if") "、"
     (CODE1 "position-if-not") "は、" "それぞれテストを満たす要素を検索します。" EOL2 "返却値" (STRONG "position")
     "は、" (STRONG "sequence") "内でテストを満たす" "もっとも左の要素（" (STRONG "from-end") "が"
     (STRONG "false") "のとき）か、" "もっとも右の要素（" (STRONG "from-end") "が" (STRONG "true")
     "のとき）のインデックスです。" "もし見つからなかったときは、" (CODE1 "nil") "が返却されます。" "インデックスの返却値は、"
     (STRONG "start") ", " (STRONG "end") ", " (STRONG "from-end") "に関係なく、"
     (STRONG "seqeunce") "全体の左端から相対的なものです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(position #\\a \"baobab\" :from-end t) =>  4"
      "(position-if #'oddp '((1) (2) (3) (4)) :start 1 :key #'car) =>  2"
      "(position 595 '()) =>  NIL" "(position-if-not #'integerp '(1 2 3 4 5.0)) =>  4 "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "find") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "position-if-not") "は非推奨です。")))
(setf (gethash '("POSITION" . "FUNCTION") *table*) (gethash "POSITION" *table*))
(setf (gethash "POSITION-IF" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "POSITION") ", " (CODE1 "POSITION-IF") ", "
     (CODE1 "POSITION-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "position") " " (STRONG "item") " " (STRONG "sequence")
     " &key " (STRONG "from-end") " " (STRONG "test") " " (STRONG "test-not") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "key") " => " (STRONG "position")
     EOL1 (CODE1 "position-if") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "key")
     " => " (STRONG "position") EOL1 (CODE1 "position-if-not") " " (STRONG "predicate")
     " " (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "key") " => " (STRONG "position"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "sequence")
     " - 正常なシーケンス" EOL1 (STRONG "predicate") " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子"
     EOL1 (STRONG "from-end") " - generalized-boolean、デフォルトは" (STRONG "false") EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "position") " - "
     (STRONG "sequence") "の境界インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "position") "、" (CODE1 "position-if") "、"
     (CODE1 "position-if-not") "は、" "それぞれテストを満たす要素を検索します。" EOL2 "返却値" (STRONG "position")
     "は、" (STRONG "sequence") "内でテストを満たす" "もっとも左の要素（" (STRONG "from-end") "が"
     (STRONG "false") "のとき）か、" "もっとも右の要素（" (STRONG "from-end") "が" (STRONG "true")
     "のとき）のインデックスです。" "もし見つからなかったときは、" (CODE1 "nil") "が返却されます。" "インデックスの返却値は、"
     (STRONG "start") ", " (STRONG "end") ", " (STRONG "from-end") "に関係なく、"
     (STRONG "seqeunce") "全体の左端から相対的なものです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(position #\\a \"baobab\" :from-end t) =>  4"
      "(position-if #'oddp '((1) (2) (3) (4)) :start 1 :key #'car) =>  2"
      "(position 595 '()) =>  NIL" "(position-if-not #'integerp '(1 2 3 4 5.0)) =>  4 "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "find") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "position-if-not") "は非推奨です。")))
(setf (gethash '("POSITION-IF" . "FUNCTION") *table*) (gethash "POSITION-IF" *table*))
(setf (gethash "POSITION-IF-NOT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "POSITION") ", " (CODE1 "POSITION-IF") ", "
     (CODE1 "POSITION-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "position") " " (STRONG "item") " " (STRONG "sequence")
     " &key " (STRONG "from-end") " " (STRONG "test") " " (STRONG "test-not") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "key") " => " (STRONG "position")
     EOL1 (CODE1 "position-if") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "key")
     " => " (STRONG "position") EOL1 (CODE1 "position-if-not") " " (STRONG "predicate")
     " " (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "key") " => " (STRONG "position"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "sequence")
     " - 正常なシーケンス" EOL1 (STRONG "predicate") " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子"
     EOL1 (STRONG "from-end") " - generalized-boolean、デフォルトは" (STRONG "false") EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "position") " - "
     (STRONG "sequence") "の境界インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "position") "、" (CODE1 "position-if") "、"
     (CODE1 "position-if-not") "は、" "それぞれテストを満たす要素を検索します。" EOL2 "返却値" (STRONG "position")
     "は、" (STRONG "sequence") "内でテストを満たす" "もっとも左の要素（" (STRONG "from-end") "が"
     (STRONG "false") "のとき）か、" "もっとも右の要素（" (STRONG "from-end") "が" (STRONG "true")
     "のとき）のインデックスです。" "もし見つからなかったときは、" (CODE1 "nil") "が返却されます。" "インデックスの返却値は、"
     (STRONG "start") ", " (STRONG "end") ", " (STRONG "from-end") "に関係なく、"
     (STRONG "seqeunce") "全体の左端から相対的なものです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(position #\\a \"baobab\" :from-end t) =>  4"
      "(position-if #'oddp '((1) (2) (3) (4)) :start 1 :key #'car) =>  2"
      "(position 595 '()) =>  NIL" "(position-if-not #'integerp '(1 2 3 4 5.0)) =>  4 "))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "find") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "position-if-not") "は非推奨です。")))
(setf (gethash '("POSITION-IF-NOT" . "FUNCTION") *table*) (gethash "POSITION-IF-NOT" *table*))
(setf (gethash "PPRINT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "WRITE") ", " (CODE1 "PRIN1") ", " (CODE1 "PRINT")
     ", " (CODE1 "PPRINT") ", " (CODE1 "PRINC"))
    (CHAPTER ("## 構文") 2 (CODE1 "write") " " (STRONG "object") " " (CODE1 "&key") " "
     (STRONG "array") " " (STRONG "base") " " (STRONG "case") " " (STRONG "circle") " "
     (STRONG "escape") " " (STRONG "gensym") " " (STRONG "length") " " (STRONG "level")
     " " (STRONG "lines") " " (STRONG "miser-width") " " (STRONG "pprint-dispatch") " "
     (STRONG "pretty") " " (STRONG "radix") " " (STRONG "readably") " "
     (STRONG "right-margin") " " (STRONG "stream") " => " (STRONG "object") EOL1
     (CODE1 "prin1") " " (STRONG "object") " " (CODE1 "&optional") " "
     (STRONG "output-stream") " => " (STRONG "object") EOL1 (CODE1 "princ") " "
     (STRONG "object") " " (CODE1 "&optional") " " (STRONG "output-stream") " => "
     (STRONG "object") EOL1 (CODE1 "print") " " (STRONG "object") " " (CODE1 "&optional")
     " " (STRONG "output-stream") " => " (STRONG "object") EOL1 (CODE1 "pprint") " "
     (STRONG "object") " " (CODE1 "&optional") " " (STRONG "output-stream") " => "
     (CODE1 "<返却値なし>"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "output-stream")
     " - 出力ストリーム指定子。デフォルトは標準出力。" EOL1 (STRONG "array") " - generalized-boolean" EOL1
     (STRONG "base") " - 基数" EOL1 (STRONG "case") " - 型"
     (CODE1 "(member :upcase :downcase :capitalize)") "のシンボル" EOL1 (STRONG "circle")
     " - generalized-boolean" EOL1 (STRONG "escape") " - generalized-boolean" EOL1
     (STRONG "gensym") " - generalized-boolean" EOL1 (STRONG "length") " - 非負の整数か、"
     (CODE1 "nil") EOL1 (STRONG "level") " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "lines")
     " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "miser-width") " - 非負の整数か、" (CODE1 "nil")
     EOL1 (STRONG "pprint-dispatch") " - " (CODE1 "pprint") "ディスパッチテーブル" EOL1
     (STRONG "pretty") " - generalized-boolean" EOL1 (STRONG "radix")
     " - generalized-boolean" EOL1 (STRONG "readably") " - generalized-boolean" EOL1
     (STRONG "right-margin") " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "stream")
     " - 出力ストリーム指定子。デフォルトは標準出力。")
    (CHAPTER ("## 定義") 2 (CODE1 "write") ", " (CODE1 "prin1") ", " (CODE1 "princ") ", "
     (CODE1 "print") ", " (CODE1 "pprint") "は、" (STRONG "object") "の印刷表現を"
     (STRONG "output-stream") "に書き込みます。" EOL2 (CODE1 "write") "は、Lispプリンターの一般的な入り口です。"
     "次の表で示されるような名前のキーワードパラメーターが明に指定されたとき、" "印刷が実行されている間はそれらの値が対応する"
     "プリンター制御変数に動的に束縛されます。" "次の表で示されるような名前のキーワードパラメーターが明に指定されなかったとき、" "対応するプリンター制御変数の値は"
     (CODE1 "write") "が実行された時点でのものと同じになります。" "いちど適切な束縛が確立されたら、"
     "オブジェクトはLispプリンターによって出力されます。" EOL2 "|パラメーター     |対応する動的変数               |"
     "|:----------------|:------------------------------|" "|array            |"
     (CODE1 "*print-array*") "           |" "|base             |" (CODE1 "*print-base*")
     "            |" "|case             |" (CODE1 "*print-case*") "            |"
     "|circle           |" (CODE1 "*print-circle*") "          |" "|escape           |"
     (CODE1 "*print-escape*") "          |" "|gensym           |"
     (CODE1 "*print-gensym*") "          |" "|length           |"
     (CODE1 "*print-length*") "          |" "|level            |" (CODE1 "*print-level*")
     "           |" "|lines            |" (CODE1 "*print-lines*") "           |"
     "|miser-width      |" (CODE1 "*print-miser-width*") "     |" "|pprint-dispatch  |"
     (CODE1 "*print-pprint-dispatch*") " |" "|pretty           |"
     (CODE1 "*print-pretty*") "          |" "|radix            |" (CODE1 "*print-radix*")
     "           |" "|readably         |" (CODE1 "*print-readably*") "        |"
     "|right-margin     |" (CODE1 "*print-right-margin*") "    |" EOL2 "Figure 22-7. "
     (CODE1 "WRITE") "関数の引数の対応" EOL2 (CODE1 "prin1") ", " (CODE1 "princ") ", "
     (CODE1 "print") ", " (CODE1 "pprint") "は、" "特定の印刷パラメーターを特定の値に暗に束縛します。"
     "残りのパラメーターの値は、" (CODE1 "*print-array*") "," (CODE1 "*print-base*") ","
     (CODE1 "*print-case*") "," (CODE1 "*print-circle*") "," (CODE1 "*print-escape*") ","
     (CODE1 "*print-gensym*") "," (CODE1 "*print-length*") "," (CODE1 "*print-level*")
     "," (CODE1 "*print-lines*") "," (CODE1 "*print-miser-width*") ","
     (CODE1 "*print-pprint-dispatch*") "," (CODE1 "*print-pretty*") ","
     (CODE1 "*print-radix*") "," (CODE1 "*print-right-margin*") "から取得します。" EOL2
     (CODE1 "prin1") "は、" (CODE1 "read") "からの入力に適切な出力を生成します。" "それは"
     (CODE1 "*print-escape*") "を" (STRONG "true") "に束縛します。" EOL2 (CODE1 "princ") "は、ちょうど"
     (CODE1 "prin1") "と似ていますが、" "出力にエスケープ文字を含めない所が違っています。" (CODE1 "*print-escape*") "を"
     (STRONG "false") "に、" (CODE1 "*print-readably*") "を" (STRONG "false") "に束縛します。"
     "一般的なルールは、" (CODE1 "princ") "による出力は人に見やすいことを意図しており、" (CODE1 "prin1") "による出力は"
     (CODE1 "read") "に受け入れられることを意図しています。" EOL2 (CODE1 "print") "は、ちょうど" (CODE1 "prin1")
     "に似ていますが、" (STRONG "object") "の印刷表現の前に改行を、" "その後にスペースを入れるところが違っています。" EOL2
     (CODE1 "pprint") "は、ちょうど" (CODE1 "print") "に似ていますが、" "末尾の空白が省略され、かつ"
     (STRONG "object") "を印刷するときに" (CODE1 "*print-pretty*") "に" (CODE1 "nil") "以外の値を指定し、"
     "プリティプリントの出力を行うということが違っています。" EOL2 (STRONG "output-stream") "は出力を送信するストリームを指定します。")
    (CHAPTER ("## 影響") 2 (CODE1 "*standard-output*") "," (CODE1 "*terminal-io*") ","
     (CODE1 "*print-escape*") "," (CODE1 "*print-radix*") "," (CODE1 "*print-base*") ","
     (CODE1 "*print-circle*") "," (CODE1 "*print-pretty*") "," (CODE1 "*print-level*")
     "," (CODE1 "*print-length*") "," (CODE1 "*print-case*") "," (CODE1 "*print-gensym*")
     "," (CODE1 "*print-array*") "," (CODE1 "*read-default-float-format*"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "readtable-case") "," "22.3.4. " (CODE1 "FORMAT")
     "プリンター操作")
    (CHAPTER ("## 備考") 2 "関数の" (CODE1 "prin1") "と" (CODE1 "print") "は、"
     (CODE1 "*print-readably*") "を束縛しません。"
     (CODE3 "```lisp" "```" "(prin1 object output-stream)"
      "==  (write object :stream output-stream :escape t)" NIL
      "(princ object output-stream)"
      "==  (write object stream output-stream :escape nil :readably nil)" NIL
      "(print object output-stream)" "==  (progn (terpri output-stream)"
      "           (write object :stream output-stream"
      "                         :escape t)"
      "           (write-char #\\space output-stream))" NIL
      "(pprint object output-stream)"
      "==  (write object :stream output-stream :escape t :pretty t)"))))
(setf (gethash '("PPRINT" . "FUNCTION") *table*) (gethash "PPRINT" *table*))
(setf (gethash "PPRINT-DISPATCH" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PPRINT-DISPATCH"))
    (CHAPTER ("## 構文") 2 (CODE1 "pprint-dispatch object") " " (CODE1 "&optional") " "
     (STRONG "table") " => " (STRONG "function") ", " (STRONG "found-p"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "table") " - "
     (CODE1 "pprint") "ディスパッチテーブルか、" (CODE1 "nil") "。" "デフォルトは"
     (CODE1 "*print-pprint-dispatch*") "の値。" EOL1 (STRONG "function") " - 関数指定子" EOL1
     (STRONG "found-p") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "table") "の中から、" (STRONG "object") "にマッチする型指定子と関連づけられた"
     "優先度の高い関数を検索します。" "その関数は、" (STRONG "table") "の中の" (STRONG "object")
     "にマッチする全ての型指定子から検索され、" "それらの型指定子の中に関連づいた最も高い優先度の関数が選択されます。"
     "もし最も高い優先度の関数がひとつではなく複数あったとき、" "任意のものが選ばれます。" "もし型指定子が" (STRONG "object")
     "にマッチしなかったときは、" (STRONG "object") "が出力されるときに使われる" (CODE1 "print-object")
     "の関数が返却されます。" EOL2 "第二返却値の" (STRONG "found-p") "は、" "もし型指定子が" (STRONG "table")
     "にマッチされたときは" (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "もし"
     (STRONG "table") "が" (CODE1 "nil") "のとき、" (CODE1 "pprint")
     "ディスパッチテーブルの初期値から検索が行われます。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。")
    (CHAPTER ("## 影響") 2 (STRONG "table") "の状態")
    (CHAPTER ("## 例外") 2 (STRONG "table") "が" (CODE1 "pprint") "ディスパッチテーブルでも"
     (CODE1 "nil") "でもないときは、" "型" (CODE1 "type-error") "のエラーが通知されるべきです。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(let ((*print-pretty* t))" "  (write object :stream s))"
      "==  (funcall (pprint-dispatch object) s object)"))))
(setf (gethash '("PPRINT-DISPATCH" . "FUNCTION") *table*) (gethash "PPRINT-DISPATCH" *table*))
(setf (gethash "PPRINT-EXIT-IF-LIST-EXHAUSTED" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PPRINT-EXIT-IF-LIST-EXHAUSTED"))
    (CHAPTER ("## 構文") 2 (CODE1 "pprint-exit-if-list-exhausted") " " (CODE1 "<引数なし>")
     " => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 "なし。")
    (CHAPTER ("## 定義") 2 "レキシカル環境の現在の論理ブロックに渡された" (STRONG "list") "が使い果たされたかどうかをテストします。"
     "22.2.1.1. 出力の配置の動的制御をご確認ください。" "もしこの" (STRONG "list") "が" (CODE1 "nil")
     "にまで使われたとき、" (CODE1 "pprint-exit-if-list-exhausted") "は" "レキシカル環境の現在の論理ブロックの実行を、"
     "サフィックスの出力を行い終了します。" "それ以外の場合は、" (CODE1 "pprint-exit-if-list-exhausted") "は"
     (CODE1 "nil") "を返却します。" EOL2 "グローバル環境下で" (CODE1 "pprint-exit-if-list-exhausted") "が"
     (CODE1 "fbound") "かどうかは" "実装依存ですが、" "グローバル環境において" (CODE1 "COMMON-LISP") "パッケージ内の"
     (CODE1 "pprint-exit-if-list-exhausted") "という同じシンボルを" "シャドウするように再定義することは制限されます。"
     (CODE1 "pprint-logical-block") "の外側で" (CODE1 "pprint-exit-if-list-exhausted") "を"
     "使用しようとしたときの結果は未定義です。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (CODE1 "pprint-logical-block") "のレキシカル環境内で" "呼び出されたものではなく"
     "それ以外のどこかで" (CODE1 "pprint-exit-if-list-exhausted") "が呼ばれたときは、"
     "（マクロ展開時か実行時かで）エラーが発生します。" "また、レキシカル環境内に含まれる" (CODE1 "pprint-logical-block") "の"
     "動的エクステントの外側で" (CODE1 "pprint-exit-if-list-exhausted") "を" "実行したときの結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "pprint-logical-block") "," (CODE1 "pprint-pop"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PPRINT-EXIT-IF-LIST-EXHAUSTED" . "FUNCTION") *table*) (gethash "PPRINT-EXIT-IF-LIST-EXHAUSTED" *table*))
(setf (gethash "PPRINT-FILL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PPRINT-FILL") ", " (CODE1 "PPRINT-LINEAR") ", "
     (CODE1 "PPRINT-TABULAR"))
    (CHAPTER ("## 構文") 2 (CODE1 "pprint-fill") " " (STRONG "stream") " "
     (STRONG "object") " " (CODE1 "&optional") " " (STRONG "colon-p") " "
     (STRONG "at-sign-p") " => " (CODE1 "nil") EOL1 (CODE1 "pprint-linear") " "
     (STRONG "stream") " " (STRONG "object") " " (CODE1 "&optional") " "
     (STRONG "colon-p") " " (STRONG "at-sign-p") " => " (CODE1 "nil") EOL1
     (CODE1 "pprint-tabular") " " (STRONG "stream") " " (STRONG "object") " "
     (CODE1 "&optional") " " (STRONG "colon-p") " " (STRONG "at-sign-p") " "
     (STRONG "tabsize") " => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream") " - 出力ストリーム指定子" EOL1 (STRONG "object")
     " - オブジェクト" EOL1 (STRONG "colon-p") " - generalized-boolean。デフォルトは" (STRONG "true")
     "。" EOL1 (STRONG "at-sign-p") " - generalized-boolean。デフォルトは実装依存。" EOL1
     (STRONG "tabsize") " - 非負の整数。デフォルトは" (CODE1 "16") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "pprint-fill") ", " (CODE1 "pprint-linear") ", "
     (CODE1 "pprint-tabular") "の関数は、" (STRONG "stream") "に対してリストをどのように"
     "プリティプリントとして出力するか特定の方法を指定します。" (STRONG "colon-p") "が" (STRONG "true") "のときは、"
     "各関数は出力の周りを囲うようにカッコを出力します。" "各関数は、" (STRONG "at-sign-p") "の引数を無視します。"
     "（両方の引数が、ひとつの引数しか必要ないにもかかわらず含まれるのは、" (CODE1 "~/.../") "を経由して使用される関数や、"
     (CODE1 "set-pprint-dispatch") "関数によって直接使われるからです）" "各関数は省略形を扱い、循環構造を検出し、"
     "共有構造を正しく検出し、" "そしてリストではないものが指定されたときは" (CODE1 "write") "を使用して" (STRONG "object")
     "を印字します。" EOL2 (STRONG "object") "がリストであり、" (CODE1 "*print-pretty*") "の値が"
     (STRONG "false") "のときは、" "これらの関数は" (STRONG "object") "を出力する際に"
     "22.1.3.5. リストとコンスの印字の定義に従い最小の空白を使用します。" "それ以外のときは" "（" (STRONG "object") "がリストであり、"
     (CODE1 "*print-pretty*") "の値が" (STRONG "true") "のとき）、" "次のように出力します。" EOL2 "- 関数"
     (CODE1 "pprint-linear") "はリストを、" "ひとつの行に全てを出力するか、" "あるいは各要素を行で区切るかのどちらかです。" "- 関数"
     (CODE1 "pprint-fill") "はリストに対して、" "可能な限り一行に多くの要素を出力します。" "- 関数"
     (CODE1 "pprint-tabular") "は" (CODE1 "pprint-fill") "と同じですが、" "各要素が列をなして並ぶように印字します。"
     (STRONG "tabsize") "は列の間隔を" (CODE1 "ems") "で指定し、"
     "これはある列の前の開始位置から次の列の開始位置までの合計の間隔です。")
    (CHAPTER ("## 例文") 2 "一行の長さが" (CODE1 "25") "のときの" "下記が評価されたときの出力を示します。"
     (CODE3 "```lisp" "```" "(progn (princ \"Roads \") "
      "       (pprint-tabular *standard-output* '(elm main maple center) nil nil 8))"
      "Roads ELM     MAIN" "      MAPLE   CENTER"))
    (CHAPTER ("## 副作用") 2 "指定したストリームに出力されます。")
    (CHAPTER ("## 影響") 2 "もし決定できるならば、指定したストリームのカーソルの位置。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 "関数" (CODE1 "pprint-tabular") "は次のように定義できます。"
     (CODE3 "```lisp" "```"
      "(defun pprint-tabular (s list &optional (colon-p t) at-sign-p (tabsize nil))"
      "  (declare (ignore at-sign-p))" "  (when (null tabsize) (setq tabsize 16))"
      "  (pprint-logical-block (s list :prefix (if colon-p \"(\" \"\")"
      "                                :suffix (if colon-p \")\" \"\"))"
      "    (pprint-exit-if-list-exhausted)" "    (loop (write (pprint-pop) :stream s)"
      "          (pprint-exit-if-list-exhausted)" "          (write-char #\\Space s)"
      "          (pprint-tab :section-relative 0 tabsize s)"
      "          (pprint-newline :fill s))))")
     EOL2 "これは" (CODE1 "format") "を使用して" "この関数を定義するには不便であることに注意してください。"
     "なぜならリストの繰り返し内にある" (CODE1 "format") "の命令" (CODE1 "~:T") "に" (CODE1 "tabsize")
     "引数を渡す必要があるためです。")))
(setf (gethash '("PPRINT-FILL" . "FUNCTION") *table*) (gethash "PPRINT-FILL" *table*))
(setf (gethash "PPRINT-INDENT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PPRINT-INDENT"))
    (CHAPTER ("## 構文") 2 (CODE1 "pprint-indent") " " (STRONG "relative-to") " "
     (STRONG "n") " " (CODE1 "&optional") " " (STRONG "stream") " => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "relative-to") " - " (CODE1 ":block") "か"
     (CODE1 ":current") "のどちらか" EOL1 (STRONG "n") " - 実数" EOL1 (STRONG "stream")
     " - 出力ストリーム指定子。デフォルトは標準出力。")
    (CHAPTER ("## 定義") 2 (CODE1 "pprint-indent") "は、" (STRONG "stream")
     "上で使用される論理ブロックのインデントを指定します。" (STRONG "stream") "がプリティプリントのストリームであり、"
     (CODE1 "*print-pretty*") "が" (STRONG "true") "のとき、" (CODE1 "pprint-indent") "は"
     "もっとも内側の動的に閉じられた論理ブロック内の" "インデントを設定します。" "それ以外の場合は、" (CODE1 "pprint-indent")
     "は何もしません。" EOL2 (CODE1 "n") "はインデントを" (CODE1 "ems") "で指定します。" (STRONG "relative-to")
     "が" (CODE1 ":block") "のとき、" "動的な現在の論理ブロック内において最初の文字から" (CODE1 "n ems")
     "を加算した水平位置をインデントに設定します。" (STRONG "relative-to") "が" (CODE1 ":current") "のとき、"
     "現在の出力位置に" (CODE1 "n ems") "を加算したものをインデントに設定します" "（可変幅のフォントに対応するため、" "可能な限り"
     (CODE1 ":current") "において" (CODE1 "n") " が" (CODE1 "0") "を使用することが推奨されます）。" EOL2
     (CODE1 "n") "が負の数のとき、" "インデントの合計は行の始まりの左には移動できませんし、"
     "行ごとのプレフィックスの右の終端より左には移動できませんが、" "これらの制限を越えて移動しようとしたときは、" "その制限に移動したものと同じように扱われます。"
     (CODE1 "pprint-indent") "によってインデントを変更したときは、" "次の行の区切りの後までは効果が現れません。"
     "さらに、マイザーモードにおいては" (CODE1 "pprint-indent") "の全ての呼び出しは無視され、" "論理ブロック内の対応する行は、"
     "そのブロック内の最初の文字の元に揃えられます。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "relative-to") "が" (CODE1 ":block") "でも"
     (CODE1 ":current") "でもない" "別のオブジェクトのときはエラーが発生します。")
    (CHAPTER ("## 参考") 2 "22.3.5.3. チルダ" (CODE1 "I") ": インデント")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PPRINT-INDENT" . "FUNCTION") *table*) (gethash "PPRINT-INDENT" *table*))
(setf (gethash "PPRINT-LINEAR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PPRINT-FILL") ", " (CODE1 "PPRINT-LINEAR") ", "
     (CODE1 "PPRINT-TABULAR"))
    (CHAPTER ("## 構文") 2 (CODE1 "pprint-fill") " " (STRONG "stream") " "
     (STRONG "object") " " (CODE1 "&optional") " " (STRONG "colon-p") " "
     (STRONG "at-sign-p") " => " (CODE1 "nil") EOL1 (CODE1 "pprint-linear") " "
     (STRONG "stream") " " (STRONG "object") " " (CODE1 "&optional") " "
     (STRONG "colon-p") " " (STRONG "at-sign-p") " => " (CODE1 "nil") EOL1
     (CODE1 "pprint-tabular") " " (STRONG "stream") " " (STRONG "object") " "
     (CODE1 "&optional") " " (STRONG "colon-p") " " (STRONG "at-sign-p") " "
     (STRONG "tabsize") " => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream") " - 出力ストリーム指定子" EOL1 (STRONG "object")
     " - オブジェクト" EOL1 (STRONG "colon-p") " - generalized-boolean。デフォルトは" (STRONG "true")
     "。" EOL1 (STRONG "at-sign-p") " - generalized-boolean。デフォルトは実装依存。" EOL1
     (STRONG "tabsize") " - 非負の整数。デフォルトは" (CODE1 "16") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "pprint-fill") ", " (CODE1 "pprint-linear") ", "
     (CODE1 "pprint-tabular") "の関数は、" (STRONG "stream") "に対してリストをどのように"
     "プリティプリントとして出力するか特定の方法を指定します。" (STRONG "colon-p") "が" (STRONG "true") "のときは、"
     "各関数は出力の周りを囲うようにカッコを出力します。" "各関数は、" (STRONG "at-sign-p") "の引数を無視します。"
     "（両方の引数が、ひとつの引数しか必要ないにもかかわらず含まれるのは、" (CODE1 "~/.../") "を経由して使用される関数や、"
     (CODE1 "set-pprint-dispatch") "関数によって直接使われるからです）" "各関数は省略形を扱い、循環構造を検出し、"
     "共有構造を正しく検出し、" "そしてリストではないものが指定されたときは" (CODE1 "write") "を使用して" (STRONG "object")
     "を印字します。" EOL2 (STRONG "object") "がリストであり、" (CODE1 "*print-pretty*") "の値が"
     (STRONG "false") "のときは、" "これらの関数は" (STRONG "object") "を出力する際に"
     "22.1.3.5. リストとコンスの印字の定義に従い最小の空白を使用します。" "それ以外のときは" "（" (STRONG "object") "がリストであり、"
     (CODE1 "*print-pretty*") "の値が" (STRONG "true") "のとき）、" "次のように出力します。" EOL2 "- 関数"
     (CODE1 "pprint-linear") "はリストを、" "ひとつの行に全てを出力するか、" "あるいは各要素を行で区切るかのどちらかです。" "- 関数"
     (CODE1 "pprint-fill") "はリストに対して、" "可能な限り一行に多くの要素を出力します。" "- 関数"
     (CODE1 "pprint-tabular") "は" (CODE1 "pprint-fill") "と同じですが、" "各要素が列をなして並ぶように印字します。"
     (STRONG "tabsize") "は列の間隔を" (CODE1 "ems") "で指定し、"
     "これはある列の前の開始位置から次の列の開始位置までの合計の間隔です。")
    (CHAPTER ("## 例文") 2 "一行の長さが" (CODE1 "25") "のときの" "下記が評価されたときの出力を示します。"
     (CODE3 "```lisp" "```" "(progn (princ \"Roads \") "
      "       (pprint-tabular *standard-output* '(elm main maple center) nil nil 8))"
      "Roads ELM     MAIN" "      MAPLE   CENTER"))
    (CHAPTER ("## 副作用") 2 "指定したストリームに出力されます。")
    (CHAPTER ("## 影響") 2 "もし決定できるならば、指定したストリームのカーソルの位置。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 "関数" (CODE1 "pprint-tabular") "は次のように定義できます。"
     (CODE3 "```lisp" "```"
      "(defun pprint-tabular (s list &optional (colon-p t) at-sign-p (tabsize nil))"
      "  (declare (ignore at-sign-p))" "  (when (null tabsize) (setq tabsize 16))"
      "  (pprint-logical-block (s list :prefix (if colon-p \"(\" \"\")"
      "                                :suffix (if colon-p \")\" \"\"))"
      "    (pprint-exit-if-list-exhausted)" "    (loop (write (pprint-pop) :stream s)"
      "          (pprint-exit-if-list-exhausted)" "          (write-char #\\Space s)"
      "          (pprint-tab :section-relative 0 tabsize s)"
      "          (pprint-newline :fill s))))")
     EOL2 "これは" (CODE1 "format") "を使用して" "この関数を定義するには不便であることに注意してください。"
     "なぜならリストの繰り返し内にある" (CODE1 "format") "の命令" (CODE1 "~:T") "に" (CODE1 "tabsize")
     "引数を渡す必要があるためです。")))
(setf (gethash '("PPRINT-LINEAR" . "FUNCTION") *table*) (gethash "PPRINT-LINEAR" *table*))
(setf (gethash "PPRINT-LOGICAL-BLOCK" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "PPRINT-LOGICAL-BLOCK"))
    (CHAPTER ("## 構文") 2 (CODE1 "pprint-logical-block") " " (CODE1 "(")
     (STRONG "stream-symbol") " " (STRONG "object") " " (CODE1 "&key") " "
     (STRONG "prefix") " " (STRONG "per-line-prefix") " " (STRONG "suffix") (CODE1 ")")
     " " (STRONG "declaration\\*") " " (STRONG "form\\*") " => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream-symbol") " - ストリーム変数指定子" EOL1
     (STRONG "object") " - オブジェクト。評価されます。" EOL1 (STRONG "prefix")
     " - 文字列。評価されます。標準の動作は複雑なので説明を参照。" EOL1 (STRONG "per-line-prefix")
     " - 文字列。評価されます。標準の動作は複雑なので説明を参照。" EOL1 (STRONG "suffix") " - 文字列。評価されます。デフォルトは空文字。"
     EOL1 (STRONG "declaration") " - 宣言式。評価されません。" EOL1 (STRONG "form") " - 暗黙のprogn")
    (CHAPTER ("## 定義") 2 "プリントを行う際の論理ブロックのグルーピングを行います。" "論理ブロックは、ストリームに対して印刷を行い、"
     "そのストリームの値は" (STRONG "stream-symbol") "によって示された変数の値になります。" (STRONG "form")
     "を実行している間、" "その変数にはプリティプリントのストリームが束縛されており、" "そのストリームは出力の配置についての決定を行い、"
     "その結果を宛先の出力ストリームに送信します。" "標準の印刷関数の全て（例えば" (CODE1 "write") ", " (CODE1 "princ") ", "
     (CODE1 "terpri") "）は、" "プリティプリントのストリームへ印刷を出力するために使用できます。" "プリティプリントのストリームへの全ての出力は、"
     "ただ論理ブロック内にあるもののみ扱われます。" EOL2 (STRONG "prefix") "は、論理ブロックの開始の前に印刷されるプレフィックスを指定します。"
     (STRONG "per-line-prefix") "は、ブロックの前と" "ブロック内の新しい各行の始まりに印刷されるプレフィックスを指定します。"
     (CODE1 ":prefix") "と" (CODE1 ":per-line-prefix") "引数は、互いに排他的です。" "もし"
     (CODE1 ":prefix") "と" (CODE1 ":per-line-prefix") "がどちらも指定されなかったら、" (STRONG "prefix")
     "が空文字であると仮定されます。" EOL2 (STRONG "suffix") "は、ちょうど論理ブロックのあとに" "印刷されるサフィックスを指定します。"
     EOL2 (STRONG "object") "は普通はリストであり、" "ボディ部である" (STRONG "form") "において印刷のために使用されます。"
     "もし" (STRONG "object") "がリストではなかったとき、" "それは" (CODE1 "write") "によって印刷されます"
     "（これにより、不正な引数に直面しても" "堅牢な印刷関数を簡単に書くことができます）。" "もし" (CODE1 "*print-circle*") "が"
     (CODE1 "nil") "ではなく、" (STRONG "object") "がコンスへ循環（あるいは共有）した参照があったとき、" "適切な"
     (CODE1 "#n#") "という印が印刷されます" "（これにより、循環と共有の省略形を完全にサポートした" "印刷関数を簡単に書くことができます）。" "もし"
     (CODE1 "*print-level*") "が" (CODE1 "nil") "ではなく、" "論理ブロックが、複数の論理ブロック内において"
     "動的にネストされた深さが" (CODE1 "*print-level*") "より大きいとき、" (CODE1 "#") "が印刷されます。"
     "（これにより、深さの省略形を完全にサポートした" "印刷関数を簡単に書くことができます）。" EOL2 "もし上記の3つの状況のどれかが生じたとき、"
     "示された出力が" (STRONG "stream-symbol") "上に印刷され、" "ボディ部の" (STRONG "form") "は"
     (CODE1 ":prefix") "と" (CODE1 ":suffix") "の印刷とともにスキップされます" "（ボディ部の" (STRONG "form")
     "がリストの印刷を担当しないときは、" "引数" (STRONG "object") "に" (CODE1 "nil") "指定することで、"
     "上記の最初の2つのテストをオフにすることができます）。" EOL2 "さらに" (CODE1 "pprint-logical-block") "の引数"
     (STRONG "object") "は、" "標準印刷関数（" (CODE1 "write") ", " (CODE1 "print") ", "
     (CODE1 "princ") ", " (CODE1 "pprint") "や、" "標準の" (CODE1 "format") "指示子の"
     (CODE1 "~A") "と" (CODE1 "~S") "（そして" (CODE1 "~W") "も）の引数と同様に）"
     "（必要であれば）循環と要求のチェックが全てにおいて行われます。" "しかし、そのようなチェックは" (CODE1 "write-line") ", "
     (CODE1 "write-string") ", そして" (CODE1 "write-char") "の引数か、" (CODE1 "format")
     "によるリテラルテキストの出力については行われません。" "これらの結果から、" "もし何らかのリテラルテキストを出力する際に"
     "循環と共有のチェックをして欲しくないときは、" "後者の関数のうちのひとつを使用するべきです。" EOL2
     (CODE1 "pprint-logical-block") "のボディ部である" (STRONG "form") "は、"
     "周囲の環境上において何も副作用を実施するべきではありません。" "例えば、そのスコープ内において束縛されていない変数に代入してはいけません。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。")
    (CHAPTER ("## 影響") 2 (CODE1 "*print-circle*") "," (CODE1 "*print-level*"))
    (CHAPTER ("## 例外") 2 (CODE1 ":suffix") ", " (CODE1 ":prefix") ", "
     (CODE1 ":per-line-prefix") "のどれかが指定されたものの" "文字列に評価されなかったときは型" (CODE1 "type-error")
     "のエラーが発生します。" EOL2 (CODE1 ":prefix") "と" (CODE1 ":per-line-prefix")
     "の両方が使用されたときはエラーが発生します。" EOL2 (CODE1 "pprint-logical-block") "は動的エクステントを持っており、"
     "プリティプリントのストリームを生成します。" "もしそのエクステントの外側において" " 生成されたプリティプリントのストリームへ"
     "出力しようとしたときの結果は未定義です。" EOL2 "また、そのエクステントの内側において、"
     "元となる宛先のストリームに直接出力を送信したときの結果は指定されていません。")
    (CHAPTER ("## 参考") 2 (CODE1 "pprint-pop") "," (CODE1 "pprint-exit-if-list-exhausted")
     "," "22.3.5.2. チルダ" (CODE1 "<") ": 論理ブロック")
    (CHAPTER ("## 備考") 2 (CODE1 "*print-pretty*") "の値が" (CODE1 "nil") "のときに"
     (CODE1 "pprint-logical-block") "マクロを使用するひとつの理由は、" "ドットリストのチェックを行うということ、" "また同様に（"
     (CODE1 "pprint-pop") "によって）" (CODE1 "*print-level*") "か" (CODE1 "*print-length*")
     "を超過したかどうかの" "チェックを行うということです。" EOL2 "循環と共有の検出は、プリティプリンターによって"
     "要求された出力を二回行うことで実現します。" "最初の実行では循環と共有を検出し、実際の文字の出力は抑制されます。" "二回目の実行では、"
     (CODE1 "#n=") "と" (CODE1 "#n#") "のマークを適切な位置に挿入し、そして文字を出力します。"
     "これが、なぜ副作用を制限する必要があるかという理由です。" "この制限に従うと、" (CODE1 "pprint-logical-block") "のボディ部"
     (STRONG "form") "において、" "リストの内容を出力していく際に" "通常の" (CODE1 "pop") "のかわりに"
     (CODE1 "pprint-pop") "を使用することにより、" "実装が容易になります。")))
(setf (gethash '("PPRINT-LOGICAL-BLOCK" . "MACRO") *table*) (gethash "PPRINT-LOGICAL-BLOCK" *table*))
(setf (gethash "PPRINT-NEWLINE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PPRINT-NEWLINE"))
    (CHAPTER ("## 構文") 2 (CODE1 "pprint-newline") " " (STRONG "kind") " "
     (CODE1 "&optional") " " (STRONG "stream") " => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "kind") " - " (CODE1 ":linear") ", " (CODE1 ":fill")
     ", " (CODE1 ":miser") ", " (CODE1 ":mandatory") "のうちのひとつ" EOL1 (STRONG "stream")
     " - ストリーム指定子。デフォルトは標準出力。")
    (CHAPTER ("## 定義") 2 "もし" (STRONG "stream") "がプリティプリントのストリームであり、"
     (CODE1 "*print-pretty*") "の値が" (STRONG "true") "のとき、" "下記の示す適切な状況である場合は改行が挿入されます。"
     "それ以外のときは、" (CODE1 "pprint-newline") "は効果を持ちません。" EOL2 (STRONG "kind")
     "は条件付き改行のスタイルを指定します。" "このパラメーターは下記のように扱われます。" EOL2 "- " (CODE1 ":linear")
     "  - 「線形スタイル」の条件付き改行を指定します。" "    もし直前に含まれるセクションが一行で印刷できないときのみ、" "    改行が挿入されます。"
     "    その結果、論理ブロック内のすべての線形スタイルの条件付き改行で" "    改行が行われるか、あるいは全く改行されないかのどちらかになります。" EOL2
     "- " (CODE1 ":miser") "  - 「マイザースタイル」の条件付き改行を指定します。" "    もし直前に含まれるセクションが一行で印刷できず、"
     "    かつ直前に含まれる論理ブロックが" "    マイザースタイルの効果を持っているときのみ、" "    改行が挿入されます。"
     "    その結果、マイザースタイルの条件付き改行は" "    線形スタイルの条件付き改行と似た動作をしますが、"
     "    ただマイザースタイルの効果を持ったもののみ出力を行います。" "    論理ブロックのマイザースタイルは、"
     "    論理ブロックの開始位置が左マージンから" "    " (CODE1 "*print-miser-width*") " " (CODE1 "ems")
     "以下のときのみ効果を持ちます。" EOL2 "- " (CODE1 ":fill") "  - 「フィルスタイル」の条件付き改行を指定します。"
     "    もし下記のいずれかの状況の場合に改行が挿入されます。" "      - (a) 後に続くセクションが現在の行の終わりに印刷できないとき。"
     "      - (b) 前のセクションが一行で印刷できないとき。" "      - (c) 直前に含まれるセクションが一行で印刷できず、"
     "        かつ直前に含まれる論理ブロックがマイザースタイルの効果を持っている。" "  - もし論理ブロックがフィルスタイルの条件付き改行によって"
     "    いくつかのサブセクションに分割されるとき、" "    基本的な効果は、論理ブロックが各行にできるだけ多くの"
     "    サブセクションを持つように印刷することです。" EOL2 "- " (CODE1 ":mandatory")
     "  - 「強制スタイル」の条件付き改行を指定します。" "    改行は常に挿入されます。" "    これは暗に一行で印刷できるセクションが存在せず、"
     "    したがってこれらのセクション内のにある" "    線形スタイルの条件付き改行が" "    改行を挿入するトリガーになることを意味します。" EOL2
     "何らかのタイプの条件付き改行によって改行が挿入されたとき、" "先行する条件付き改行の直前の空白は出力から省かれ、" "次の行の先頭にインデントが挿入されます。"
     "標準では、インデントは" " 直前に含まれる論理ブロック内の最初の文字と同じ水平位置から始まるように、" "次の行の開始位置を調整します" "（インデントは"
     (CODE1 "pprint-indent") "によって変更できます）。" EOL2 "条件付きではない改行は様々あり、その出力を行うことができます" "（例えば"
     (CODE1 "terpri") "や文字列に含まれる改行文字の出力など）。" "強制スタイルの条件付き改行と同様に、"
     "これを含むセクションが一行に印刷されないようにすることができます。" "一般的に、条件付きではない改行に遭遇したとき、"
     "前に現れる空白を抑制し、続くインデントを行わずに出力します。" "しかしもし" (CODE1 ":per-line-prefix") "が指定されたとき" "（"
     (CODE1 "pprint-logical-block") "を参照）、" "このプレフィックスは改行がどのように発生しても常に表示されます。")
    (CHAPTER ("## 例文") 2 "22.2.2. プリティプリンターの使用例")
    (CHAPTER ("## 副作用") 2 (STRONG "stream") "へ出力を行います。")
    (CHAPTER ("## 影響") 2 (CODE1 "*print-pretty*") "," (CODE1 "*print-miser-width*") "。"
     "論理ブロックに含まれる存在。" "改行と条件付き改行の場所。")
    (CHAPTER ("## 例外") 2 (STRONG "kind") "が" (CODE1 ":linear") ", " (CODE1 ":fill") ", "
     (CODE1 ":miser") ", " (CODE1 ":mandatory") "のどれでもないときは、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 "22.3.5.1. チルダ" (CODE1 "_") ": {conditional-newline},"
     "22.2.2. プリティプリンターの使用例")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PPRINT-NEWLINE" . "FUNCTION") *table*) (gethash "PPRINT-NEWLINE" *table*))
(setf (gethash "PPRINT-POP" *table*)
  '((CHAPTER NIL 0 "Local Macro " (CODE1 "PPRINT-POP"))
    (CHAPTER ("## 構文") 2 (CODE1 "pprint-pop") " " (CODE1 "<引数なし>") " => "
     (STRONG "object"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - レキシカルな現在の論理ブロック内における" "印刷されるリストの要素か、"
     (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "レキシカルな現在の論理ブロック内における印刷されるリストの要素のひとつを" (CODE1 "pop") "し、"
     "下記に定義に従い" (CODE1 "*print-length*") "と" (CODE1 "*print-circle*") "を処理します。" EOL2
     (CODE1 "pprint-pop") "が呼び出されるたびに、" "レキシカルな現在の論理ブロックへ通されたリストの次の値を" (CODE1 "pop") "し、"
     "その値を返却します。" "しかし、実行する前に下記の3つのテストを行います。" EOL2 "- もし残りの" (CODE1 "list")
     "がリストではなかったとき、" (CODE1 ".") "と続いて" (CODE1 "list") "の残りが印刷されます"
     "  （これにより不正な引数に直面しても堅牢な印刷関数を簡単に書くことができます）。" "- もし" (CODE1 "*print-length*") "が"
     (CODE1 "nil") "ではなく、" "  直前の論理ブロックに含まれる中で" (CODE1 "pprint-pop") "が" "  すでに"
     (CODE1 "*print-length*") "の回数分呼び出されたとき、" (CODE1 "...") "を印刷します" "  （これにより"
     (CODE1 "*print-length*") "を適切に扱う印刷関数を簡単に書くことができます）。" "- もし" (CODE1 "*print-circle*")
     "が" (CODE1 "nil") "ではなく、" "  のこりのリストが循環か共有の参照であるとき、" "  " (CODE1 ".") "が印刷され続けて適切な"
     (CODE1 "#n#") "の印が印刷されます" "  （これは、リスト内の" (CODE1 "cdr") "の部分に循環か共有があったということです）。" EOL2
     "もし上記3つの状態のどれかが生じたとき、" "指示された出力が" "直前に含まれる" (CODE1 "pprint-logical-block")
     "によって生成された" "プリティプリントのストリームへ出力され、" "直前に含まれる" (CODE1 "pprint-logical-block") "の実行は"
     "サフィックスの出力を除いて終了されます。" EOL2 "もし" (CODE1 "pprint-logical-block") "が" "引数の"
     (CODE1 "list") "に" (CODE1 "nil") "を与えられたとき、" "リストの処理はできませんが、" (CODE1 "pprint-pop")
     "はまだ" (CODE1 "*print-length*") "の" "サポートを得るために使うことができます。" "このような状況では、"
     "上記の最初のテストと3つめのテストは実施できず、" (CODE1 "pprint-pop") "は常に" (CODE1 "nil") "を返却します。"
     "22.2.2. プリティプリンターの使用例の、特に" (CODE1 "pprint-vector") "の例をご確認ください" EOL2 "グローバル環境において"
     (CODE1 "pprint-pop") "が" (CODE1 "fbound") "かどうかは" "実装依存です。" "しかし、グローバル環境で"
     (CODE1 "fbound") "にある" (CODE1 "COMMON-LISP") "パッケージ内の" (CODE1 "pprint-pop")
     "と同じシンボルを" "再定義したりシャドウすることは制限されています。" (CODE1 "pprint-logical-block") "の外側で"
     (CODE1 "pprint-pop") "を使用しようとしたときの結果は未定義です。")
    (CHAPTER ("## 例文") 2 "なし。")
    (CHAPTER ("## 副作用") 2 "現在の論理ブロックにレキシカルで関連づいたプリティプリントのストリームへ" "出力が生じるかもしれません。")
    (CHAPTER ("## 影響") 2 (CODE1 "*print-length*") "," (CODE1 "*print-circle*"))
    (CHAPTER ("## 例外") 2 (CODE1 "pprint-logical-block") "フォームのレキシカルではない場所で"
     (CODE1 "pprint-pop") "が使用されたときは、" "（マクロ展開時か実行時かのどちらかで）エラーが発生します。" EOL2
     (CODE1 "pprint-pop") "が、" (CODE1 "pprint-logical-block") "の"
     "動的エクステントの外側で実行されたときの結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "pprint-exit-if-list-exhausted") ","
     (CODE1 "pprint-logical-block"))
    (CHAPTER ("## 備考") 2 (CODE1 "pprint-pop") "を呼び出す前に"
     (CODE1 "pprint-exit-if-list-exhausted") "を呼ぶという状況は" "頻繁にあります。")))
(setf (gethash '("PPRINT-POP" . "LOCAL-MACRO") *table*) (gethash "PPRINT-POP" *table*))
(setf (gethash "PPRINT-TAB" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PPRINT-TAB"))
    (CHAPTER ("## 構文") 2 (CODE1 "pprint-tab") " " (STRONG "kind") " " (STRONG "colnum")
     " " (STRONG "colinc") " " (CODE1 "&optional") " " (STRONG "stream") " => "
     (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "kind") " - " (CODE1 ":line") ", "
     (CODE1 ":section") ", " (CODE1 ":line-relative") ", " (CODE1 ":section-relative")
     "のうちのひとつ" EOL1 (STRONG "colnum") " - 非負の整数" EOL1 "colinc - 非負の整数" EOL1
     (STRONG "stream") " - 出力ストリーム指定子")
    (CHAPTER ("## 定義") 2 "標準の" (CODE1 "format") "指示子である" (CODE1 "~T") "として実行される"
     (STRONG "stream") "へのタブを指定します。" "もし" (STRONG "stream") "がプリティプリントのストリームであり、"
     (CODE1 "*print-pretty*") "が" (STRONG "true") "のとき、" "タブは実行されます。" "それ以外のときは"
     (CODE1 "pprint-tab") "は効果を持ちません。" EOL2 "引数の" (STRONG "colnum") "と" (STRONG "clink")
     "は" (CODE1 "~T") "の2つのパラメーターに対応し、" "単位は" (CODE1 "ems") "になります。" "引数の"
     (STRONG "kind") "は、タブのスタイルを指定します。" "それは、" (CODE1 ":line") "（" (CODE1 "~T") "によるタブ）、"
     (CODE1 ":section") "（" (CODE1 "~T") "によるタブですが、計測される水平位置は" "動的に囲まれたセクションの開始からの相対位置）、"
     (CODE1 ":line-relative") "（" (CODE1 "~T") "によるタブ）、" (CODE1 ":section-relative") "（"
     (CODE1 "~T") "によるタブですが、計測される水平位置は" "動的に囲まれたセクションの開始からの相対位置）のうちの" "ひとつでなければなりません。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "kind") "が" (CODE1 ":line") ", " (CODE1 ":section") ", "
     (CODE1 ":line-relative") ", " (CODE1 ":section-relative") "の"
     "うちのひとつではなかったとき、エラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "pprint-logical-block")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PPRINT-TAB" . "FUNCTION") *table*) (gethash "PPRINT-TAB" *table*))
(setf (gethash "PPRINT-TABULAR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PPRINT-FILL") ", " (CODE1 "PPRINT-LINEAR") ", "
     (CODE1 "PPRINT-TABULAR"))
    (CHAPTER ("## 構文") 2 (CODE1 "pprint-fill") " " (STRONG "stream") " "
     (STRONG "object") " " (CODE1 "&optional") " " (STRONG "colon-p") " "
     (STRONG "at-sign-p") " => " (CODE1 "nil") EOL1 (CODE1 "pprint-linear") " "
     (STRONG "stream") " " (STRONG "object") " " (CODE1 "&optional") " "
     (STRONG "colon-p") " " (STRONG "at-sign-p") " => " (CODE1 "nil") EOL1
     (CODE1 "pprint-tabular") " " (STRONG "stream") " " (STRONG "object") " "
     (CODE1 "&optional") " " (STRONG "colon-p") " " (STRONG "at-sign-p") " "
     (STRONG "tabsize") " => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream") " - 出力ストリーム指定子" EOL1 (STRONG "object")
     " - オブジェクト" EOL1 (STRONG "colon-p") " - generalized-boolean。デフォルトは" (STRONG "true")
     "。" EOL1 (STRONG "at-sign-p") " - generalized-boolean。デフォルトは実装依存。" EOL1
     (STRONG "tabsize") " - 非負の整数。デフォルトは" (CODE1 "16") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "pprint-fill") ", " (CODE1 "pprint-linear") ", "
     (CODE1 "pprint-tabular") "の関数は、" (STRONG "stream") "に対してリストをどのように"
     "プリティプリントとして出力するか特定の方法を指定します。" (STRONG "colon-p") "が" (STRONG "true") "のときは、"
     "各関数は出力の周りを囲うようにカッコを出力します。" "各関数は、" (STRONG "at-sign-p") "の引数を無視します。"
     "（両方の引数が、ひとつの引数しか必要ないにもかかわらず含まれるのは、" (CODE1 "~/.../") "を経由して使用される関数や、"
     (CODE1 "set-pprint-dispatch") "関数によって直接使われるからです）" "各関数は省略形を扱い、循環構造を検出し、"
     "共有構造を正しく検出し、" "そしてリストではないものが指定されたときは" (CODE1 "write") "を使用して" (STRONG "object")
     "を印字します。" EOL2 (STRONG "object") "がリストであり、" (CODE1 "*print-pretty*") "の値が"
     (STRONG "false") "のときは、" "これらの関数は" (STRONG "object") "を出力する際に"
     "22.1.3.5. リストとコンスの印字の定義に従い最小の空白を使用します。" "それ以外のときは" "（" (STRONG "object") "がリストであり、"
     (CODE1 "*print-pretty*") "の値が" (STRONG "true") "のとき）、" "次のように出力します。" EOL2 "- 関数"
     (CODE1 "pprint-linear") "はリストを、" "ひとつの行に全てを出力するか、" "あるいは各要素を行で区切るかのどちらかです。" "- 関数"
     (CODE1 "pprint-fill") "はリストに対して、" "可能な限り一行に多くの要素を出力します。" "- 関数"
     (CODE1 "pprint-tabular") "は" (CODE1 "pprint-fill") "と同じですが、" "各要素が列をなして並ぶように印字します。"
     (STRONG "tabsize") "は列の間隔を" (CODE1 "ems") "で指定し、"
     "これはある列の前の開始位置から次の列の開始位置までの合計の間隔です。")
    (CHAPTER ("## 例文") 2 "一行の長さが" (CODE1 "25") "のときの" "下記が評価されたときの出力を示します。"
     (CODE3 "```lisp" "```" "(progn (princ \"Roads \") "
      "       (pprint-tabular *standard-output* '(elm main maple center) nil nil 8))"
      "Roads ELM     MAIN" "      MAPLE   CENTER"))
    (CHAPTER ("## 副作用") 2 "指定したストリームに出力されます。")
    (CHAPTER ("## 影響") 2 "もし決定できるならば、指定したストリームのカーソルの位置。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 "関数" (CODE1 "pprint-tabular") "は次のように定義できます。"
     (CODE3 "```lisp" "```"
      "(defun pprint-tabular (s list &optional (colon-p t) at-sign-p (tabsize nil))"
      "  (declare (ignore at-sign-p))" "  (when (null tabsize) (setq tabsize 16))"
      "  (pprint-logical-block (s list :prefix (if colon-p \"(\" \"\")"
      "                                :suffix (if colon-p \")\" \"\"))"
      "    (pprint-exit-if-list-exhausted)" "    (loop (write (pprint-pop) :stream s)"
      "          (pprint-exit-if-list-exhausted)" "          (write-char #\\Space s)"
      "          (pprint-tab :section-relative 0 tabsize s)"
      "          (pprint-newline :fill s))))")
     EOL2 "これは" (CODE1 "format") "を使用して" "この関数を定義するには不便であることに注意してください。"
     "なぜならリストの繰り返し内にある" (CODE1 "format") "の命令" (CODE1 "~:T") "に" (CODE1 "tabsize")
     "引数を渡す必要があるためです。")))
(setf (gethash '("PPRINT-TABULAR" . "FUNCTION") *table*) (gethash "PPRINT-TABULAR" *table*))
(setf (gethash "PRIN1" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "WRITE") ", " (CODE1 "PRIN1") ", " (CODE1 "PRINT")
     ", " (CODE1 "PPRINT") ", " (CODE1 "PRINC"))
    (CHAPTER ("## 構文") 2 (CODE1 "write") " " (STRONG "object") " " (CODE1 "&key") " "
     (STRONG "array") " " (STRONG "base") " " (STRONG "case") " " (STRONG "circle") " "
     (STRONG "escape") " " (STRONG "gensym") " " (STRONG "length") " " (STRONG "level")
     " " (STRONG "lines") " " (STRONG "miser-width") " " (STRONG "pprint-dispatch") " "
     (STRONG "pretty") " " (STRONG "radix") " " (STRONG "readably") " "
     (STRONG "right-margin") " " (STRONG "stream") " => " (STRONG "object") EOL1
     (CODE1 "prin1") " " (STRONG "object") " " (CODE1 "&optional") " "
     (STRONG "output-stream") " => " (STRONG "object") EOL1 (CODE1 "princ") " "
     (STRONG "object") " " (CODE1 "&optional") " " (STRONG "output-stream") " => "
     (STRONG "object") EOL1 (CODE1 "print") " " (STRONG "object") " " (CODE1 "&optional")
     " " (STRONG "output-stream") " => " (STRONG "object") EOL1 (CODE1 "pprint") " "
     (STRONG "object") " " (CODE1 "&optional") " " (STRONG "output-stream") " => "
     (CODE1 "<返却値なし>"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "output-stream")
     " - 出力ストリーム指定子。デフォルトは標準出力。" EOL1 (STRONG "array") " - generalized-boolean" EOL1
     (STRONG "base") " - 基数" EOL1 (STRONG "case") " - 型"
     (CODE1 "(member :upcase :downcase :capitalize)") "のシンボル" EOL1 (STRONG "circle")
     " - generalized-boolean" EOL1 (STRONG "escape") " - generalized-boolean" EOL1
     (STRONG "gensym") " - generalized-boolean" EOL1 (STRONG "length") " - 非負の整数か、"
     (CODE1 "nil") EOL1 (STRONG "level") " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "lines")
     " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "miser-width") " - 非負の整数か、" (CODE1 "nil")
     EOL1 (STRONG "pprint-dispatch") " - " (CODE1 "pprint") "ディスパッチテーブル" EOL1
     (STRONG "pretty") " - generalized-boolean" EOL1 (STRONG "radix")
     " - generalized-boolean" EOL1 (STRONG "readably") " - generalized-boolean" EOL1
     (STRONG "right-margin") " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "stream")
     " - 出力ストリーム指定子。デフォルトは標準出力。")
    (CHAPTER ("## 定義") 2 (CODE1 "write") ", " (CODE1 "prin1") ", " (CODE1 "princ") ", "
     (CODE1 "print") ", " (CODE1 "pprint") "は、" (STRONG "object") "の印刷表現を"
     (STRONG "output-stream") "に書き込みます。" EOL2 (CODE1 "write") "は、Lispプリンターの一般的な入り口です。"
     "次の表で示されるような名前のキーワードパラメーターが明に指定されたとき、" "印刷が実行されている間はそれらの値が対応する"
     "プリンター制御変数に動的に束縛されます。" "次の表で示されるような名前のキーワードパラメーターが明に指定されなかったとき、" "対応するプリンター制御変数の値は"
     (CODE1 "write") "が実行された時点でのものと同じになります。" "いちど適切な束縛が確立されたら、"
     "オブジェクトはLispプリンターによって出力されます。" EOL2 "|パラメーター     |対応する動的変数               |"
     "|:----------------|:------------------------------|" "|array            |"
     (CODE1 "*print-array*") "           |" "|base             |" (CODE1 "*print-base*")
     "            |" "|case             |" (CODE1 "*print-case*") "            |"
     "|circle           |" (CODE1 "*print-circle*") "          |" "|escape           |"
     (CODE1 "*print-escape*") "          |" "|gensym           |"
     (CODE1 "*print-gensym*") "          |" "|length           |"
     (CODE1 "*print-length*") "          |" "|level            |" (CODE1 "*print-level*")
     "           |" "|lines            |" (CODE1 "*print-lines*") "           |"
     "|miser-width      |" (CODE1 "*print-miser-width*") "     |" "|pprint-dispatch  |"
     (CODE1 "*print-pprint-dispatch*") " |" "|pretty           |"
     (CODE1 "*print-pretty*") "          |" "|radix            |" (CODE1 "*print-radix*")
     "           |" "|readably         |" (CODE1 "*print-readably*") "        |"
     "|right-margin     |" (CODE1 "*print-right-margin*") "    |" EOL2 "Figure 22-7. "
     (CODE1 "WRITE") "関数の引数の対応" EOL2 (CODE1 "prin1") ", " (CODE1 "princ") ", "
     (CODE1 "print") ", " (CODE1 "pprint") "は、" "特定の印刷パラメーターを特定の値に暗に束縛します。"
     "残りのパラメーターの値は、" (CODE1 "*print-array*") "," (CODE1 "*print-base*") ","
     (CODE1 "*print-case*") "," (CODE1 "*print-circle*") "," (CODE1 "*print-escape*") ","
     (CODE1 "*print-gensym*") "," (CODE1 "*print-length*") "," (CODE1 "*print-level*")
     "," (CODE1 "*print-lines*") "," (CODE1 "*print-miser-width*") ","
     (CODE1 "*print-pprint-dispatch*") "," (CODE1 "*print-pretty*") ","
     (CODE1 "*print-radix*") "," (CODE1 "*print-right-margin*") "から取得します。" EOL2
     (CODE1 "prin1") "は、" (CODE1 "read") "からの入力に適切な出力を生成します。" "それは"
     (CODE1 "*print-escape*") "を" (STRONG "true") "に束縛します。" EOL2 (CODE1 "princ") "は、ちょうど"
     (CODE1 "prin1") "と似ていますが、" "出力にエスケープ文字を含めない所が違っています。" (CODE1 "*print-escape*") "を"
     (STRONG "false") "に、" (CODE1 "*print-readably*") "を" (STRONG "false") "に束縛します。"
     "一般的なルールは、" (CODE1 "princ") "による出力は人に見やすいことを意図しており、" (CODE1 "prin1") "による出力は"
     (CODE1 "read") "に受け入れられることを意図しています。" EOL2 (CODE1 "print") "は、ちょうど" (CODE1 "prin1")
     "に似ていますが、" (STRONG "object") "の印刷表現の前に改行を、" "その後にスペースを入れるところが違っています。" EOL2
     (CODE1 "pprint") "は、ちょうど" (CODE1 "print") "に似ていますが、" "末尾の空白が省略され、かつ"
     (STRONG "object") "を印刷するときに" (CODE1 "*print-pretty*") "に" (CODE1 "nil") "以外の値を指定し、"
     "プリティプリントの出力を行うということが違っています。" EOL2 (STRONG "output-stream") "は出力を送信するストリームを指定します。")
    (CHAPTER ("## 影響") 2 (CODE1 "*standard-output*") "," (CODE1 "*terminal-io*") ","
     (CODE1 "*print-escape*") "," (CODE1 "*print-radix*") "," (CODE1 "*print-base*") ","
     (CODE1 "*print-circle*") "," (CODE1 "*print-pretty*") "," (CODE1 "*print-level*")
     "," (CODE1 "*print-length*") "," (CODE1 "*print-case*") "," (CODE1 "*print-gensym*")
     "," (CODE1 "*print-array*") "," (CODE1 "*read-default-float-format*"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "readtable-case") "," "22.3.4. " (CODE1 "FORMAT")
     "プリンター操作")
    (CHAPTER ("## 備考") 2 "関数の" (CODE1 "prin1") "と" (CODE1 "print") "は、"
     (CODE1 "*print-readably*") "を束縛しません。"
     (CODE3 "```lisp" "```" "(prin1 object output-stream)"
      "==  (write object :stream output-stream :escape t)" NIL
      "(princ object output-stream)"
      "==  (write object stream output-stream :escape nil :readably nil)" NIL
      "(print object output-stream)" "==  (progn (terpri output-stream)"
      "           (write object :stream output-stream"
      "                         :escape t)"
      "           (write-char #\\space output-stream))" NIL
      "(pprint object output-stream)"
      "==  (write object :stream output-stream :escape t :pretty t)"))))
(setf (gethash '("PRIN1" . "FUNCTION") *table*) (gethash "PRIN1" *table*))
(setf (gethash "PRIN1-TO-STRING" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "WRITE-TO-STRING") ", " (CODE1 "PRIN1-TO-STRING")
     ", " (CODE1 "PRINC-TO-STRING"))
    (CHAPTER ("## 構文") 2 (CODE1 "write-to-string") " " (STRONG "object") " "
     (CODE1 "&key") " " (STRONG "array") " " (STRONG "base") " " (STRONG "case") " "
     (STRONG "circle") " " (STRONG "escape") " " (STRONG "gensym") " " (STRONG "length")
     " " (STRONG "level") " " (STRONG "lines") " " (STRONG "miser-width") " "
     (STRONG "pprint-dispatch") " " (STRONG "pretty") " " (STRONG "radix") " "
     (STRONG "readably") " " (STRONG "right-margin") " => " (STRONG "string") EOL1
     (CODE1 "prin1-to-string") " " (STRONG "object") " => " (STRONG "string") EOL1
     (CODE1 "princ-to-string") " " (STRONG "object") " => " (STRONG "string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "array")
     " - generalized-boolean" EOL1 (STRONG "base") " - 基数" EOL1 (STRONG "case") " - 型"
     (CODE1 "(member :upcase :downcase :capitalize)") "のシンボル" EOL1 (STRONG "circle")
     " - generalized-boolean" EOL1 (STRONG "escape") " - generalized-boolean" EOL1
     (STRONG "gensym") " - generalized-boolean" EOL1 (STRONG "length") " - 非負の整数か、"
     (CODE1 "nil") EOL1 (STRONG "level") " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "lines")
     " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "miser-width") " - 非負の整数か、" (CODE1 "nil")
     EOL1 (STRONG "pprint-dispatch") " - " (CODE1 "pprint") "ディスパッチテーブル" EOL1
     (STRONG "pretty") " - generalized-boolean" EOL1 (STRONG "radix")
     " - generalized-boolean" EOL1 (STRONG "readably") " - generalized-boolean" EOL1
     (STRONG "right-margin") " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "string") " - 文字列")
    (CHAPTER ("## 定義") 2 (CODE1 "write-to-string") ", " (CODE1 "prin1-to-string") ", "
     (CODE1 "princ-to-string") "は、" (STRONG "object") "の印刷表現を含む文字列を生成するときに使用されます。"
     (STRONG "object") "は、それぞれ" (CODE1 "write") ", " (CODE1 "prin1") ", " (CODE1 "princ")
     "によるものとして" "効率的に印刷され、" "出力の文字が文字列の中に作成されます。" EOL2 (CODE1 "write-to-string")
     "は一般的な出力関数です。" "これは指定されたすべてのパラメーターを適切に扱い" (STRONG "object") "を印刷する能力があります。" EOL2
     (CODE1 "prin1-to-string") "は、" (CODE1 "write-to-string") "に" (CODE1 ":escape t")
     "を付与したように動作し、" "これはエスケープ文字が適切な場所に記載されることを意味しています。" EOL2 (CODE1 "princ-to-string")
     "は、" (CODE1 "write-to-string") "に" (CODE1 ":escape nil :readably nil")
     "を付与したように動作します。" "したがってエスケープ文字は記載されません。" EOL2 (CODE1 "prin1-to-string") "か"
     (CODE1 "princ-to-string") "が実行されたとき、" "他の全てのキーワードは" (CODE1 "write-to-string")
     "に指定されたもののデフォルト値になります。" EOL2 "この意味は、" (CODE1 "write-to-string") "のキーワード引数のデフォルトは、"
     (CODE1 "write") "のものと同じであるということです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(prin1-to-string \"abc\") =>  \"\\\"abc\\\"\""
      "(princ-to-string \"abc\") =>  \"abc\""))
    (CHAPTER ("## 副作用") 2 "なし。")
    (CHAPTER ("## 影響") 2 (CODE1 "*print-escape*") "," (CODE1 "*print-radix*") ","
     (CODE1 "*print-base*") "," (CODE1 "*print-circle*") "," (CODE1 "*print-pretty*") ","
     (CODE1 "*print-level*") "," (CODE1 "*print-length*") "," (CODE1 "*print-case*") ","
     (CODE1 "*print-gensym*") "," (CODE1 "*print-array*") ","
     (CODE1 "*read-default-float-format*"))
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "write"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(write-to-string object {key argument}*)"
      "==  (with-output-to-string (#1=#:string-stream) "
      "      (write object :stream #1# {key argument}*))" NIL "(princ-to-string object)"
      "==  (with-output-to-string (string-stream)" "      (princ object string-stream))"
      NIL "(prin1-to-string object)" "==  (with-output-to-string (string-stream)"
      "      (prin1 object string-stream))"))))
(setf (gethash '("PRIN1-TO-STRING" . "FUNCTION") *table*) (gethash "PRIN1-TO-STRING" *table*))
(setf (gethash "PRINC" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "WRITE") ", " (CODE1 "PRIN1") ", " (CODE1 "PRINT")
     ", " (CODE1 "PPRINT") ", " (CODE1 "PRINC"))
    (CHAPTER ("## 構文") 2 (CODE1 "write") " " (STRONG "object") " " (CODE1 "&key") " "
     (STRONG "array") " " (STRONG "base") " " (STRONG "case") " " (STRONG "circle") " "
     (STRONG "escape") " " (STRONG "gensym") " " (STRONG "length") " " (STRONG "level")
     " " (STRONG "lines") " " (STRONG "miser-width") " " (STRONG "pprint-dispatch") " "
     (STRONG "pretty") " " (STRONG "radix") " " (STRONG "readably") " "
     (STRONG "right-margin") " " (STRONG "stream") " => " (STRONG "object") EOL1
     (CODE1 "prin1") " " (STRONG "object") " " (CODE1 "&optional") " "
     (STRONG "output-stream") " => " (STRONG "object") EOL1 (CODE1 "princ") " "
     (STRONG "object") " " (CODE1 "&optional") " " (STRONG "output-stream") " => "
     (STRONG "object") EOL1 (CODE1 "print") " " (STRONG "object") " " (CODE1 "&optional")
     " " (STRONG "output-stream") " => " (STRONG "object") EOL1 (CODE1 "pprint") " "
     (STRONG "object") " " (CODE1 "&optional") " " (STRONG "output-stream") " => "
     (CODE1 "<返却値なし>"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "output-stream")
     " - 出力ストリーム指定子。デフォルトは標準出力。" EOL1 (STRONG "array") " - generalized-boolean" EOL1
     (STRONG "base") " - 基数" EOL1 (STRONG "case") " - 型"
     (CODE1 "(member :upcase :downcase :capitalize)") "のシンボル" EOL1 (STRONG "circle")
     " - generalized-boolean" EOL1 (STRONG "escape") " - generalized-boolean" EOL1
     (STRONG "gensym") " - generalized-boolean" EOL1 (STRONG "length") " - 非負の整数か、"
     (CODE1 "nil") EOL1 (STRONG "level") " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "lines")
     " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "miser-width") " - 非負の整数か、" (CODE1 "nil")
     EOL1 (STRONG "pprint-dispatch") " - " (CODE1 "pprint") "ディスパッチテーブル" EOL1
     (STRONG "pretty") " - generalized-boolean" EOL1 (STRONG "radix")
     " - generalized-boolean" EOL1 (STRONG "readably") " - generalized-boolean" EOL1
     (STRONG "right-margin") " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "stream")
     " - 出力ストリーム指定子。デフォルトは標準出力。")
    (CHAPTER ("## 定義") 2 (CODE1 "write") ", " (CODE1 "prin1") ", " (CODE1 "princ") ", "
     (CODE1 "print") ", " (CODE1 "pprint") "は、" (STRONG "object") "の印刷表現を"
     (STRONG "output-stream") "に書き込みます。" EOL2 (CODE1 "write") "は、Lispプリンターの一般的な入り口です。"
     "次の表で示されるような名前のキーワードパラメーターが明に指定されたとき、" "印刷が実行されている間はそれらの値が対応する"
     "プリンター制御変数に動的に束縛されます。" "次の表で示されるような名前のキーワードパラメーターが明に指定されなかったとき、" "対応するプリンター制御変数の値は"
     (CODE1 "write") "が実行された時点でのものと同じになります。" "いちど適切な束縛が確立されたら、"
     "オブジェクトはLispプリンターによって出力されます。" EOL2 "|パラメーター     |対応する動的変数               |"
     "|:----------------|:------------------------------|" "|array            |"
     (CODE1 "*print-array*") "           |" "|base             |" (CODE1 "*print-base*")
     "            |" "|case             |" (CODE1 "*print-case*") "            |"
     "|circle           |" (CODE1 "*print-circle*") "          |" "|escape           |"
     (CODE1 "*print-escape*") "          |" "|gensym           |"
     (CODE1 "*print-gensym*") "          |" "|length           |"
     (CODE1 "*print-length*") "          |" "|level            |" (CODE1 "*print-level*")
     "           |" "|lines            |" (CODE1 "*print-lines*") "           |"
     "|miser-width      |" (CODE1 "*print-miser-width*") "     |" "|pprint-dispatch  |"
     (CODE1 "*print-pprint-dispatch*") " |" "|pretty           |"
     (CODE1 "*print-pretty*") "          |" "|radix            |" (CODE1 "*print-radix*")
     "           |" "|readably         |" (CODE1 "*print-readably*") "        |"
     "|right-margin     |" (CODE1 "*print-right-margin*") "    |" EOL2 "Figure 22-7. "
     (CODE1 "WRITE") "関数の引数の対応" EOL2 (CODE1 "prin1") ", " (CODE1 "princ") ", "
     (CODE1 "print") ", " (CODE1 "pprint") "は、" "特定の印刷パラメーターを特定の値に暗に束縛します。"
     "残りのパラメーターの値は、" (CODE1 "*print-array*") "," (CODE1 "*print-base*") ","
     (CODE1 "*print-case*") "," (CODE1 "*print-circle*") "," (CODE1 "*print-escape*") ","
     (CODE1 "*print-gensym*") "," (CODE1 "*print-length*") "," (CODE1 "*print-level*")
     "," (CODE1 "*print-lines*") "," (CODE1 "*print-miser-width*") ","
     (CODE1 "*print-pprint-dispatch*") "," (CODE1 "*print-pretty*") ","
     (CODE1 "*print-radix*") "," (CODE1 "*print-right-margin*") "から取得します。" EOL2
     (CODE1 "prin1") "は、" (CODE1 "read") "からの入力に適切な出力を生成します。" "それは"
     (CODE1 "*print-escape*") "を" (STRONG "true") "に束縛します。" EOL2 (CODE1 "princ") "は、ちょうど"
     (CODE1 "prin1") "と似ていますが、" "出力にエスケープ文字を含めない所が違っています。" (CODE1 "*print-escape*") "を"
     (STRONG "false") "に、" (CODE1 "*print-readably*") "を" (STRONG "false") "に束縛します。"
     "一般的なルールは、" (CODE1 "princ") "による出力は人に見やすいことを意図しており、" (CODE1 "prin1") "による出力は"
     (CODE1 "read") "に受け入れられることを意図しています。" EOL2 (CODE1 "print") "は、ちょうど" (CODE1 "prin1")
     "に似ていますが、" (STRONG "object") "の印刷表現の前に改行を、" "その後にスペースを入れるところが違っています。" EOL2
     (CODE1 "pprint") "は、ちょうど" (CODE1 "print") "に似ていますが、" "末尾の空白が省略され、かつ"
     (STRONG "object") "を印刷するときに" (CODE1 "*print-pretty*") "に" (CODE1 "nil") "以外の値を指定し、"
     "プリティプリントの出力を行うということが違っています。" EOL2 (STRONG "output-stream") "は出力を送信するストリームを指定します。")
    (CHAPTER ("## 影響") 2 (CODE1 "*standard-output*") "," (CODE1 "*terminal-io*") ","
     (CODE1 "*print-escape*") "," (CODE1 "*print-radix*") "," (CODE1 "*print-base*") ","
     (CODE1 "*print-circle*") "," (CODE1 "*print-pretty*") "," (CODE1 "*print-level*")
     "," (CODE1 "*print-length*") "," (CODE1 "*print-case*") "," (CODE1 "*print-gensym*")
     "," (CODE1 "*print-array*") "," (CODE1 "*read-default-float-format*"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "readtable-case") "," "22.3.4. " (CODE1 "FORMAT")
     "プリンター操作")
    (CHAPTER ("## 備考") 2 "関数の" (CODE1 "prin1") "と" (CODE1 "print") "は、"
     (CODE1 "*print-readably*") "を束縛しません。"
     (CODE3 "```lisp" "```" "(prin1 object output-stream)"
      "==  (write object :stream output-stream :escape t)" NIL
      "(princ object output-stream)"
      "==  (write object stream output-stream :escape nil :readably nil)" NIL
      "(print object output-stream)" "==  (progn (terpri output-stream)"
      "           (write object :stream output-stream"
      "                         :escape t)"
      "           (write-char #\\space output-stream))" NIL
      "(pprint object output-stream)"
      "==  (write object :stream output-stream :escape t :pretty t)"))))
(setf (gethash '("PRINC" . "FUNCTION") *table*) (gethash "PRINC" *table*))
(setf (gethash "PRINC-TO-STRING" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "WRITE-TO-STRING") ", " (CODE1 "PRIN1-TO-STRING")
     ", " (CODE1 "PRINC-TO-STRING"))
    (CHAPTER ("## 構文") 2 (CODE1 "write-to-string") " " (STRONG "object") " "
     (CODE1 "&key") " " (STRONG "array") " " (STRONG "base") " " (STRONG "case") " "
     (STRONG "circle") " " (STRONG "escape") " " (STRONG "gensym") " " (STRONG "length")
     " " (STRONG "level") " " (STRONG "lines") " " (STRONG "miser-width") " "
     (STRONG "pprint-dispatch") " " (STRONG "pretty") " " (STRONG "radix") " "
     (STRONG "readably") " " (STRONG "right-margin") " => " (STRONG "string") EOL1
     (CODE1 "prin1-to-string") " " (STRONG "object") " => " (STRONG "string") EOL1
     (CODE1 "princ-to-string") " " (STRONG "object") " => " (STRONG "string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "array")
     " - generalized-boolean" EOL1 (STRONG "base") " - 基数" EOL1 (STRONG "case") " - 型"
     (CODE1 "(member :upcase :downcase :capitalize)") "のシンボル" EOL1 (STRONG "circle")
     " - generalized-boolean" EOL1 (STRONG "escape") " - generalized-boolean" EOL1
     (STRONG "gensym") " - generalized-boolean" EOL1 (STRONG "length") " - 非負の整数か、"
     (CODE1 "nil") EOL1 (STRONG "level") " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "lines")
     " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "miser-width") " - 非負の整数か、" (CODE1 "nil")
     EOL1 (STRONG "pprint-dispatch") " - " (CODE1 "pprint") "ディスパッチテーブル" EOL1
     (STRONG "pretty") " - generalized-boolean" EOL1 (STRONG "radix")
     " - generalized-boolean" EOL1 (STRONG "readably") " - generalized-boolean" EOL1
     (STRONG "right-margin") " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "string") " - 文字列")
    (CHAPTER ("## 定義") 2 (CODE1 "write-to-string") ", " (CODE1 "prin1-to-string") ", "
     (CODE1 "princ-to-string") "は、" (STRONG "object") "の印刷表現を含む文字列を生成するときに使用されます。"
     (STRONG "object") "は、それぞれ" (CODE1 "write") ", " (CODE1 "prin1") ", " (CODE1 "princ")
     "によるものとして" "効率的に印刷され、" "出力の文字が文字列の中に作成されます。" EOL2 (CODE1 "write-to-string")
     "は一般的な出力関数です。" "これは指定されたすべてのパラメーターを適切に扱い" (STRONG "object") "を印刷する能力があります。" EOL2
     (CODE1 "prin1-to-string") "は、" (CODE1 "write-to-string") "に" (CODE1 ":escape t")
     "を付与したように動作し、" "これはエスケープ文字が適切な場所に記載されることを意味しています。" EOL2 (CODE1 "princ-to-string")
     "は、" (CODE1 "write-to-string") "に" (CODE1 ":escape nil :readably nil")
     "を付与したように動作します。" "したがってエスケープ文字は記載されません。" EOL2 (CODE1 "prin1-to-string") "か"
     (CODE1 "princ-to-string") "が実行されたとき、" "他の全てのキーワードは" (CODE1 "write-to-string")
     "に指定されたもののデフォルト値になります。" EOL2 "この意味は、" (CODE1 "write-to-string") "のキーワード引数のデフォルトは、"
     (CODE1 "write") "のものと同じであるということです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(prin1-to-string \"abc\") =>  \"\\\"abc\\\"\""
      "(princ-to-string \"abc\") =>  \"abc\""))
    (CHAPTER ("## 副作用") 2 "なし。")
    (CHAPTER ("## 影響") 2 (CODE1 "*print-escape*") "," (CODE1 "*print-radix*") ","
     (CODE1 "*print-base*") "," (CODE1 "*print-circle*") "," (CODE1 "*print-pretty*") ","
     (CODE1 "*print-level*") "," (CODE1 "*print-length*") "," (CODE1 "*print-case*") ","
     (CODE1 "*print-gensym*") "," (CODE1 "*print-array*") ","
     (CODE1 "*read-default-float-format*"))
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "write"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(write-to-string object {key argument}*)"
      "==  (with-output-to-string (#1=#:string-stream) "
      "      (write object :stream #1# {key argument}*))" NIL "(princ-to-string object)"
      "==  (with-output-to-string (string-stream)" "      (princ object string-stream))"
      NIL "(prin1-to-string object)" "==  (with-output-to-string (string-stream)"
      "      (prin1 object string-stream))"))))
(setf (gethash '("PRINC-TO-STRING" . "FUNCTION") *table*) (gethash "PRINC-TO-STRING" *table*))
(setf (gethash "PRINT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "WRITE") ", " (CODE1 "PRIN1") ", " (CODE1 "PRINT")
     ", " (CODE1 "PPRINT") ", " (CODE1 "PRINC"))
    (CHAPTER ("## 構文") 2 (CODE1 "write") " " (STRONG "object") " " (CODE1 "&key") " "
     (STRONG "array") " " (STRONG "base") " " (STRONG "case") " " (STRONG "circle") " "
     (STRONG "escape") " " (STRONG "gensym") " " (STRONG "length") " " (STRONG "level")
     " " (STRONG "lines") " " (STRONG "miser-width") " " (STRONG "pprint-dispatch") " "
     (STRONG "pretty") " " (STRONG "radix") " " (STRONG "readably") " "
     (STRONG "right-margin") " " (STRONG "stream") " => " (STRONG "object") EOL1
     (CODE1 "prin1") " " (STRONG "object") " " (CODE1 "&optional") " "
     (STRONG "output-stream") " => " (STRONG "object") EOL1 (CODE1 "princ") " "
     (STRONG "object") " " (CODE1 "&optional") " " (STRONG "output-stream") " => "
     (STRONG "object") EOL1 (CODE1 "print") " " (STRONG "object") " " (CODE1 "&optional")
     " " (STRONG "output-stream") " => " (STRONG "object") EOL1 (CODE1 "pprint") " "
     (STRONG "object") " " (CODE1 "&optional") " " (STRONG "output-stream") " => "
     (CODE1 "<返却値なし>"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "output-stream")
     " - 出力ストリーム指定子。デフォルトは標準出力。" EOL1 (STRONG "array") " - generalized-boolean" EOL1
     (STRONG "base") " - 基数" EOL1 (STRONG "case") " - 型"
     (CODE1 "(member :upcase :downcase :capitalize)") "のシンボル" EOL1 (STRONG "circle")
     " - generalized-boolean" EOL1 (STRONG "escape") " - generalized-boolean" EOL1
     (STRONG "gensym") " - generalized-boolean" EOL1 (STRONG "length") " - 非負の整数か、"
     (CODE1 "nil") EOL1 (STRONG "level") " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "lines")
     " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "miser-width") " - 非負の整数か、" (CODE1 "nil")
     EOL1 (STRONG "pprint-dispatch") " - " (CODE1 "pprint") "ディスパッチテーブル" EOL1
     (STRONG "pretty") " - generalized-boolean" EOL1 (STRONG "radix")
     " - generalized-boolean" EOL1 (STRONG "readably") " - generalized-boolean" EOL1
     (STRONG "right-margin") " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "stream")
     " - 出力ストリーム指定子。デフォルトは標準出力。")
    (CHAPTER ("## 定義") 2 (CODE1 "write") ", " (CODE1 "prin1") ", " (CODE1 "princ") ", "
     (CODE1 "print") ", " (CODE1 "pprint") "は、" (STRONG "object") "の印刷表現を"
     (STRONG "output-stream") "に書き込みます。" EOL2 (CODE1 "write") "は、Lispプリンターの一般的な入り口です。"
     "次の表で示されるような名前のキーワードパラメーターが明に指定されたとき、" "印刷が実行されている間はそれらの値が対応する"
     "プリンター制御変数に動的に束縛されます。" "次の表で示されるような名前のキーワードパラメーターが明に指定されなかったとき、" "対応するプリンター制御変数の値は"
     (CODE1 "write") "が実行された時点でのものと同じになります。" "いちど適切な束縛が確立されたら、"
     "オブジェクトはLispプリンターによって出力されます。" EOL2 "|パラメーター     |対応する動的変数               |"
     "|:----------------|:------------------------------|" "|array            |"
     (CODE1 "*print-array*") "           |" "|base             |" (CODE1 "*print-base*")
     "            |" "|case             |" (CODE1 "*print-case*") "            |"
     "|circle           |" (CODE1 "*print-circle*") "          |" "|escape           |"
     (CODE1 "*print-escape*") "          |" "|gensym           |"
     (CODE1 "*print-gensym*") "          |" "|length           |"
     (CODE1 "*print-length*") "          |" "|level            |" (CODE1 "*print-level*")
     "           |" "|lines            |" (CODE1 "*print-lines*") "           |"
     "|miser-width      |" (CODE1 "*print-miser-width*") "     |" "|pprint-dispatch  |"
     (CODE1 "*print-pprint-dispatch*") " |" "|pretty           |"
     (CODE1 "*print-pretty*") "          |" "|radix            |" (CODE1 "*print-radix*")
     "           |" "|readably         |" (CODE1 "*print-readably*") "        |"
     "|right-margin     |" (CODE1 "*print-right-margin*") "    |" EOL2 "Figure 22-7. "
     (CODE1 "WRITE") "関数の引数の対応" EOL2 (CODE1 "prin1") ", " (CODE1 "princ") ", "
     (CODE1 "print") ", " (CODE1 "pprint") "は、" "特定の印刷パラメーターを特定の値に暗に束縛します。"
     "残りのパラメーターの値は、" (CODE1 "*print-array*") "," (CODE1 "*print-base*") ","
     (CODE1 "*print-case*") "," (CODE1 "*print-circle*") "," (CODE1 "*print-escape*") ","
     (CODE1 "*print-gensym*") "," (CODE1 "*print-length*") "," (CODE1 "*print-level*")
     "," (CODE1 "*print-lines*") "," (CODE1 "*print-miser-width*") ","
     (CODE1 "*print-pprint-dispatch*") "," (CODE1 "*print-pretty*") ","
     (CODE1 "*print-radix*") "," (CODE1 "*print-right-margin*") "から取得します。" EOL2
     (CODE1 "prin1") "は、" (CODE1 "read") "からの入力に適切な出力を生成します。" "それは"
     (CODE1 "*print-escape*") "を" (STRONG "true") "に束縛します。" EOL2 (CODE1 "princ") "は、ちょうど"
     (CODE1 "prin1") "と似ていますが、" "出力にエスケープ文字を含めない所が違っています。" (CODE1 "*print-escape*") "を"
     (STRONG "false") "に、" (CODE1 "*print-readably*") "を" (STRONG "false") "に束縛します。"
     "一般的なルールは、" (CODE1 "princ") "による出力は人に見やすいことを意図しており、" (CODE1 "prin1") "による出力は"
     (CODE1 "read") "に受け入れられることを意図しています。" EOL2 (CODE1 "print") "は、ちょうど" (CODE1 "prin1")
     "に似ていますが、" (STRONG "object") "の印刷表現の前に改行を、" "その後にスペースを入れるところが違っています。" EOL2
     (CODE1 "pprint") "は、ちょうど" (CODE1 "print") "に似ていますが、" "末尾の空白が省略され、かつ"
     (STRONG "object") "を印刷するときに" (CODE1 "*print-pretty*") "に" (CODE1 "nil") "以外の値を指定し、"
     "プリティプリントの出力を行うということが違っています。" EOL2 (STRONG "output-stream") "は出力を送信するストリームを指定します。")
    (CHAPTER ("## 影響") 2 (CODE1 "*standard-output*") "," (CODE1 "*terminal-io*") ","
     (CODE1 "*print-escape*") "," (CODE1 "*print-radix*") "," (CODE1 "*print-base*") ","
     (CODE1 "*print-circle*") "," (CODE1 "*print-pretty*") "," (CODE1 "*print-level*")
     "," (CODE1 "*print-length*") "," (CODE1 "*print-case*") "," (CODE1 "*print-gensym*")
     "," (CODE1 "*print-array*") "," (CODE1 "*read-default-float-format*"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "readtable-case") "," "22.3.4. " (CODE1 "FORMAT")
     "プリンター操作")
    (CHAPTER ("## 備考") 2 "関数の" (CODE1 "prin1") "と" (CODE1 "print") "は、"
     (CODE1 "*print-readably*") "を束縛しません。"
     (CODE3 "```lisp" "```" "(prin1 object output-stream)"
      "==  (write object :stream output-stream :escape t)" NIL
      "(princ object output-stream)"
      "==  (write object stream output-stream :escape nil :readably nil)" NIL
      "(print object output-stream)" "==  (progn (terpri output-stream)"
      "           (write object :stream output-stream"
      "                         :escape t)"
      "           (write-char #\\space output-stream))" NIL
      "(pprint object output-stream)"
      "==  (write object :stream output-stream :escape t :pretty t)"))))
(setf (gethash '("PRINT" . "FUNCTION") *table*) (gethash "PRINT" *table*))
(setf (gethash "PRINT-OBJECT" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "PRINT-OBJECT"))
    (CHAPTER ("## 構文") 2 (CODE1 "print-object") " " (STRONG "object") " "
     (STRONG "stream") " => " (STRONG "object"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "print-object") " " (CODE1 "(") " " (STRONG "object")
     " " (CODE1 "standard-object") " " (CODE1 ")") " " (STRONG "stream") EOL1
     (CODE1 "print-object") " " (CODE1 "(") " " (STRONG "object") " "
     (CODE1 "structure-object") " " (CODE1 ")") " " (STRONG "stream"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "stream")
     " - ストリーム")
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "print-object") "は、" (STRONG "object")
     "の印刷表現を" (STRONG "stream") "へ書き込みます。" "この関数" (CODE1 "print-object") "は、"
     (CODE1 "Lisp") "のプリンターによって呼び出されるものであり、" "ユーザーが呼び出すべきではありません。" EOL2 "各実装は、クラス"
     (CODE1 "standard-object") "とクラス" (CODE1 "structure-object") "の"
     "それぞれのクラスを提供するよう要求されます。" "さらに各実装は、常に適切なメソッドが存在することが保証されるよう、"
     "その他の十分なクラスを提供しなければなりません。" "その他のクラスのメソッドを追加するかどうかは実装の自由です。" "ユーザーは、自身のクラスに対して"
     "その実装依存のメソッドを継承したくないときは、" (CODE1 "print-object") "のメソッドを書くことができます。" EOL2
     (CODE1 "structure-object") "のメソッドは" "デフォルトでは" (CODE1 "#S") "表記によってオブジェクトを印刷します。"
     "22.1.3.2. 文字の印字をご確認ください。" EOL2 (CODE1 "print-object") "のメソッドは、"
     "下記に示すプリンター制御の変数の意味の一部を実装する責任があります。" EOL2 "- " (CODE1 "*print-readably*") "  - "
     (CODE1 "print-object") "の全てのメソッドは、" "    " (CODE1 "*print-readably*") "に従う必要があります。"
     "    これはユーザー定義メソッドと実装定義のメソッドの両方が含まれます。" "    構造体と" (CODE1 "standard-object")
     "のオブジェクトの" "    読み込み可能な印刷を制御するのは" "    それらの" (CODE1 "print-object") "のメソッドであり、"
     "    それらの" (CODE1 "make-load-form") "メソッドによってではありません。"
     "    これらのオブジェクトの類似性はアプリケーションに依存するので、" "    したがってこれらのメソッドが行うことは何でも定義できます。"
     "    3.2.4.2. リテラルオブジェクトの類似性をご確認ください。" EOL2 "- " (CODE1 "*print-escape*")
     "  - 各メソッドは" (CODE1 "*print-escape*") "を実装しなければなりません。" EOL2 "- "
     (CODE1 "*print-pretty*") "  - メソッドは" (CODE1 "*print-pretty*") "の値によって"
     "    改行やその他の出力の状態を特別に実行したいかもしれません。" "    より詳しい情報は、（例えば）マクロ" (CODE1 "pprint-fill")
     "をご確認ください。" "    22.2.1.4. プリティプリンターのディスパッチテーブルと22.2.2. プリティプリンターの使用例も合わせてご確認ください。"
     EOL2 "- " (CODE1 "*print-length*") "  - 長さが不定の出力を行うメソッドは、" "    "
     (CODE1 "*print-length*") "に従わなければなりません。" "    より詳しい情報は、（例えば）マクロ"
     (CODE1 "pprint-logical-block") "や" "    " (CODE1 "pprint-pop") "をご確認ください。"
     "    22.2.1.4. プリティプリンターのディスパッチテーブルと22.2.2. プリティプリンターの使用例も合わせてご確認ください。" EOL2 "- "
     (CODE1 "*print-level*") "  - プリンターは自動的に" (CODE1 "*print-level*") "を扱い、"
     "    各メソッドは正確にひとつの構造の階層として扱うように提供されます。" "    よって、より深い階層のときでも" (CODE1 "write")
     "（あるいは同等の関数）を" "    再帰的に呼び出すことができます。" "    プリンターによるオブジェクトが要素を持つかどうかの決定"
     "    （したがって印刷の階層が" (CODE1 "*print-level*") "未満ではないときに" "    印刷するべきではないという決定）は、"
     "    実装依存です。" "    いくつかの実装は" (CODE1 "print-object") "メソッドが呼ばれず、"
     "    他のメソッドが呼び出され、そしてオブジェクトが要素を持つかどうかの決定は、" "    " (STRONG "stream")
     "へ書き込みが行われようとしたときが元になります。" EOL2 "- " (CODE1 "*print-circle*") "  - "
     (CODE1 "*print-circle*") "の値が" (STRONG "true") "Nおとき、" "    " (CODE1 "print-object")
     "のユーザー定義メソッドは、" "    " (CODE1 "write") ", " (CODE1 "prin1") ", " (CODE1 "princ")
     ", " (CODE1 "format") "の" "    どれかを使用することで、ストリームに対してオブジェクトを印刷できますが、"
     "    例外として循環が検出されたときは、" (CODE1 "#n#") "構文が使われて印刷されます。" "    もし"
     (CODE1 "print-object") "のユーザー定義メソッドが" "    指定されたストリーム以外のストリームに印刷するときは、"
     "    循環の検出はそのストリームに対してやり直されます。" "    " (CODE1 "*print-circle*") "をご確認ください。" EOL2
     "- " (CODE1 "*print-base*") ", " (CODE1 "*print-radix*") ", " (CODE1 "*print-case*")
     ", " (CODE1 "*print-gensym*") ", " (CODE1 "*print-array*")
     "  - これらのプリンター制御変数は指定したオブジェクトの型により適用され、" "    それらのオブジェクトのメソッドによって捕捉されます。" EOL2
     "もしこれらのルールに従わなかったときの結果は未定義です。" EOL2 "一般的にプリンターと" (CODE1 "print-object") "のメソッドは、"
     "構造を通して再帰的に操作されるため" "プリンター制御変数を再束縛するべきではありません。" EOL2 "いくつかの実装では、"
     (CODE1 "print-object") "メソッドに渡される引数の" (STRONG "stream") "が" "元のストリームではななく、"
     "プリンターの一部として実装された中間のストリームになるため、" "したがってメソッドはこのストリームの" "同一性に依存するべきではありません。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "pprint-fill") "," (CODE1 "pprint-logical-block") ","
     (CODE1 "pprint-pop") "," (CODE1 "write") "," (CODE1 "*print-readably*") ","
     (CODE1 "*print-escape*") "," (CODE1 "*print-pretty*") "," (CODE1 "*print-length*")
     "," "22.1.3. 標準のPrint-Objectメソッド," "22.1.3.12. 構造体の印字,"
     "22.2.1.4. プリティプリンターのディスパッチテーブル," "22.2.2. プリティプリンターの使用例")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PRINT-OBJECT" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "PRINT-OBJECT" *table*))
(setf (gethash "PRINT-UNREADABLE-OBJECT" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "PRINT-UNREADABLE-OBJECT"))
    (CHAPTER ("## 構文") 2 (CODE1 "print-unreadable-object") " " (CODE1 "(") " "
     (STRONG "object") " " (STRONG "stream") " " (CODE1 "&key") " " (STRONG "type") " "
     (STRONG "identity") " " (CODE1 ")") " " (STRONG "form\\*") " => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト。評価されます。" EOL1 (STRONG "stream")
     " - ストリーム指定子。評価されます。" EOL1 (STRONG "type") " - generalized-boolean。評価されます。" EOL1
     (STRONG "identity") " - generalized-boolean。評価されます。" EOL1 (STRONG "form")
     " - 暗黙のprogn")
    (CHAPTER ("## 定義") 2 (STRONG "stream") "へ" (STRONG "object") "の表現として、" (CODE1 "#<")
     "で始まり" (CODE1 ">") "で終わるような印刷を出力します。" EOL2 "ボディ部である" (STRONG "form") "によって"
     (STRONG "stream") "へ出力された全てのものは、" "山かっこで囲まれます。" "もし" (STRONG "type") "が"
     (STRONG "true") "のとき、 フォーム" (STRONG "form") "による出力の前に、" (STRONG "object")
     "の型の簡潔な説明と空白文字が出力されます。" "もし" (STRONG "identity") "が" (STRONG "true") "のとき、フォーム"
     (STRONG "form") "による出力に続き、" "スペース文字と" (STRONG "object") "の同一性の表現が出力され、"
     "それは典型的にはストレージのアドレスになります。" EOL2 "もし" (STRONG "type") "か" (STRONG "identity")
     "が指定されなかったとき、その値は" (STRONG "false") "になります。" "ボディ部の" (STRONG "form") "を省略するのは正当です。"
     "もし" (STRONG "type") "と" (STRONG "identity") "が両方" (STRONG "true") "であり、" "ボディ部の"
     (STRONG "form") "がない場合は、" "ただひとつのスペースだけが型と同一性の区切りに使用されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; この例の正確なフォームの出力は実装依存であることに注意してください。" NIL
      "(defmethod print-object ((obj airplane) stream)"
      "  (print-unreadable-object (obj stream :type t :identity t)"
      "    (princ (tail-number obj) stream)))" NIL "(prin1-to-string my-airplane)"
      "=>  \"#<Airplane NW0773 36000123135>\"" "OR=>  \"#<FAA:AIRPLANE NW0773 17>\""))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (CODE1 "*print-readably*") "が" (STRONG "true") "のとき、"
     (CODE1 "print-unreadable-object") "は何も印刷せず、" "型" (CODE1 "print-not-readable")
     "のエラーを通知します。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PRINT-UNREADABLE-OBJECT" . "MACRO") *table*) (gethash "PRINT-UNREADABLE-OBJECT" *table*))
(setf (gethash "PROBE-FILE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PROBE-FILE"))
    (CHAPTER ("## 構文") 2 (CODE1 "probe-file") " " (STRONG "pathspec") " => "
     (STRONG "truename"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathspec") " - パス名指定子" EOL1 (STRONG "truename")
     " - 物理パス名か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "probe-file") "は、ファイルが存在するかどうかをテストします。" EOL2
     (CODE1 "probe-file") "は、" (STRONG "pathspec") "と名付けられたファイルが" "存在しないときは"
     (STRONG "false") "を返却し、" "それ以外のときは" (STRONG "pathspec") "の実際の名前を返却します。" EOL2 "もし"
     (STRONG "pathspec") "指定子が開かれたストリームのときは、" (CODE1 "probe-file")
     "はそのファイルに関連付けられた実際の名前を生成します。" "もし" (STRONG "pathspec") "が開いているか閉じられているかに関わらず"
     "ストリームであったときは、" "それは関数" (CODE1 "pathname") "によるもののようにパス名に変換されます。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "ホストコンピューターのファイルシステム")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "pathspec") "がワイルドカードを含んでいたときは、" "型"
     (CODE1 "file-error") "のエラーが発生します。" EOL2 "もしファイルシステムが要求された操作を実行できなかったときは、" "型"
     (CODE1 "file-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "truename") "," (CODE1 "open") ","
     (CODE1 "ensure-directories-exist") "," (CODE1 "pathname") ","
     (CODE1 "logical-pathname") "," "20.1. ファイルシステムの説明," "20.1.2. 開かれた・閉じたストリームのファイル操作,"
     "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PROBE-FILE" . "FUNCTION") *table*) (gethash "PROBE-FILE" *table*))
(setf (gethash "PROCLAIM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "PROCLAIM"))
    (CHAPTER ("## 構文") 2 (CODE1 "proclaim") " " (STRONG "declaration-specifier")
     " => 実装依存")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "declaration-specifier") " - 宣言指定子")
    (CHAPTER ("## 定義") 2 "グローバル環境下で" (STRONG "declaration-specifier") "で指定された宣言を確立します。"
     EOL2 "このような宣言はよくグローバル宣言か" (CODE1 "proclamation") "と呼ばれ、" "ローカルでシャドウされない限り常に有効です。"
     EOL2 (STRONG "declaration-specifier") "に含まれる変数名、関数名は、"
     "それぞれ動的変数、グローバル関数定義として参照されます。" EOL2 "次の表は" (CODE1 "proclaim") "で使用可能な"
     "宣言の識別子のリストです。" EOL2
     "|                   |                 |                |            |"
     "|-------------------|-----------------|----------------|------------|" "|"
     (CODE1 "declaration") " |" (CODE1 "inline") "    |" (CODE1 "optimize") " |"
     (CODE1 "type") " |" "|" (CODE1 "ftype") "       |" (CODE1 "notinline") " |"
     (CODE1 "special") "  |            |" EOL2 "Figure 3-22. グローバル宣言指定子" EOL2
     "実装はその他の（実装定義の）宣言識別子を自由にサポートできます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun declare-variable-types-globally (type vars)"
      "  (proclaim `(type ,type ,@vars))" "  type)" NIL
      ";; 一度下記のフォームを実行したら動的変数*TOLERANCE*は" ";; 常にフロートを格納しなければなりません。"
      "(declare-variable-types-globally 'float '(*tolerance*))" "=>  FLOAT"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "declaim") "," (CODE1 "declare") "," "3.2. コンパイル")
    (CHAPTER ("## 備考") 2 (CODE1 "proclaim") "フォームの実行は" "コンパイルに影響する果を与えるかもしれませんが、"
     "コンパイラーは" (CODE1 "proclaim") "フォームを認識しようとはしませんし、" "特別な処理を行うこともありません。" "下記のような"
     (CODE1 "proclamation") "がトップレベルフォームにあったとしても、" "実行するまで何の効果もありません。"
     (CODE3 "```lisp" "```" "(proclaim '(special *x*))") EOL2 "もしコンパイル時に副作用が必要なのであれば、"
     (CODE1 "eval-when") "が使用できます。" "例えば下記の通り。"
     (CODE3 "```lisp" "```" "(eval-when (:execute :compile-toplevel :load-toplevel)"
      "  (proclaim '(special *x*)))")
     EOL2 "しかしだいたいの場合、" "このような目的には" (CODE1 "declaim") "を使うことが好まれます。" EOL2
     (CODE1 "proclaim") "フォームは通常の関数フォームなので、" "マクロフォームがそれらを展開することができます。")))
(setf (gethash '("PROCLAIM" . "FUNCTION") *table*) (gethash "PROCLAIM" *table*))
(setf (gethash "PROG" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "PROG") ", " (CODE1 "PROG*"))
    (CHAPTER ("## 構文") 2 (CODE1 "prog") " (" (CODE1 "{") (STRONG "var") " " (CODE1 "|")
     " (" (STRONG "var") " [" (STRONG "init-form") "])" (CODE1 "}") "\\*)" " "
     (STRONG "declaration\\*") " " (CODE1 "{") (STRONG "tag") " " (CODE1 "|") " "
     (STRONG "statement") (CODE1 "}") "\\*" EOL1 "=> " (STRONG "result\\*") EOL2
     (CODE1 "prog*") " (" (CODE1 "{") (STRONG "var") " " (CODE1 "|") " (" (STRONG "var")
     " [" (STRONG "init-form") "])" (CODE1 "}") "\\*)" " " (STRONG "declaration\\*") " "
     (CODE1 "{") (STRONG "tag") " " (CODE1 "|") " " (STRONG "statement") (CODE1 "}")
     "\\*" EOL1 "=> " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - 変数名" EOL1 (STRONG "init-form") " - フォーム"
     EOL1 (STRONG "declaration") " - 宣言式。評価されません。" EOL1 (STRONG "tag") " - " (CODE1 "go")
     "タグ。評価されません。" EOL1 (STRONG "statement") " - compound-form。下記の説明に従って評価されます。" EOL1
     (STRONG "result") " - 通常の返却のときは" (CODE1 "nil") "、" "そうではなく" (CODE1 "return-from")
     "による明示的な返却のときは転送された返却値。")
    (CHAPTER ("## 定義") 2 (CODE1 "prog") "と" (CODE1 "prog*") "によって" "3つの異なった操作が実行されます。"
     "それは、ローカル変数の束縛と、" (CODE1 "return") "構文の使用の許可と、" (CODE1 "go") "構文の使用の許可です。" "典型的な"
     (CODE1 "prog") "の見た目は次のようになります。"
     (CODE3 "```lisp" "```"
      "(prog (var1 var2 (var3 init-form-3) var4 (var5 init-form-5))" "      declaration*"
      "      statement1" " tag1" "      statement2" "      statement3" "      statement4"
      " tag2" "      statement5" "      ..." "      )")
     EOL2 (CODE1 "prog") "では、" "最初に各" (STRONG "init-form") "が指定された順に評価されます。" "そのあと"
     (STRONG "var") "が対応する値と並列に束縛されます。" "もし" (STRONG "var") "に対して" (STRONG "init-form")
     "が存在しないとき、" "その" (STRONG "var") "には" (CODE1 "nil") "が束縛されます。" EOL2 (CODE1 "prog")
     "のボディ部は" "それが" (CODE1 "tagbody") "フォームであるかのように実行されます。" (CODE1 "go") "構文は"
     (STRONG "tag") "へ制御を移すときに使うことができます。" (STRONG "tag") "は" (STRONG "statement")
     "にラベル付けされます。" EOL2 (CODE1 "prog") "は暗黙に、" (CODE1 "prog") "フォーム全体を囲うようにして、"
     (CODE1 "nil") "という" (CODE1 "block") "が確立しており、" (CODE1 "return") "を使って"
     (CODE1 "prog") "フォームからいつでも退出できます。" EOL2 (CODE1 "prog*") "と" (CODE1 "prog") "の違いは、"
     (CODE1 "prog*") "は" (STRONG "var") "の束縛と初期化は連続的に行われ、" "各変数の" (STRONG "init-form")
     "の値は、以前の変数の値によって使用することができます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(prog* ((y z) (x (car y)))" "       (return x))") EOL2 "上記は"
     (CODE1 "z") "の値の" (CODE1 "car") "を返却します。"
     (CODE3 "```lisp" "```" "(setq a 1) =>  1"
      "(prog ((a 2) (b a)) (return (if (= a b) '= '/=))) =>  /="
      "(prog* ((a 2) (b a)) (return (if (= a b) '= '/=))) =>  ="
      "(prog () 'no-return-value) =>  NIL" "(defun king-of-confusion (w)"
      "  \"Take a cons of two lists and make a list of conses."
      "   Think of this function as being like a zipper.\""
      "  (prog (x y z)          ;Initialize x, y, z to NIL"
      "       (setq y (car w) z (cdr w))" "   loop" "       (cond ((null y) (return x))"
      "             ((null z) (go err)))" "   rejoin"
      "       (setq x (cons (cons (car y) (car z)) x))"
      "       (setq y (cdr y) z (cdr z))" "       (go loop)" "   err"
      "       (cerror \"Will self-pair extraneous items\""
      "               \"Mismatch - gleep!  ~S\" y)" "       (setq z y)"
      "       (go rejoin))) =>  KING-OF-CONFUSION ")
     EOL2 "これは下記に示すように、より明確に達成できます。"
     (CODE3 "```lisp" "```" "(defun prince-of-clarity (w)"
      "  \"Take a cons of two lists and make a list of conses."
      "   Think of this function as being like a zipper.\"" "  (do ((y (car w) (cdr y))"
      "       (z (cdr w) (cdr z))" "       (x '() (cons (cons (car y) (car z)) x)))"
      "      ((null y) x)" "    (when (null z)"
      "      (cerror \"Will self-pair extraneous items\""
      "             \"Mismatch - gleep!  ~S\" y)"
      "      (setq z y)))) =>  PRINCE-OF-CLARITY "))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "block") "," (CODE1 "let") "," (CODE1 "tagbody") ","
     (CODE1 "go") "," (CODE1 "return") "," "3.1. 評価")
    (CHAPTER ("## 備考") 2 (CODE1 "prog") "は、" (CODE1 "block") "と" (CODE1 "let") "と"
     (CODE1 "tagbody") "の語を用いて" "下記のように説明することができます。"
     (CODE3 "```lisp" "```" "(prog variable-list declaration . body)"
      "   ==  (block nil (let variable-list declaration (tagbody . body)))"))))
(setf (gethash '("PROG" . "MACRO") *table*) (gethash "PROG" *table*))
(setf (gethash "PROG*" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "PROG") ", " (CODE1 "PROG*"))
    (CHAPTER ("## 構文") 2 (CODE1 "prog") " (" (CODE1 "{") (STRONG "var") " " (CODE1 "|")
     " (" (STRONG "var") " [" (STRONG "init-form") "])" (CODE1 "}") "\\*)" " "
     (STRONG "declaration\\*") " " (CODE1 "{") (STRONG "tag") " " (CODE1 "|") " "
     (STRONG "statement") (CODE1 "}") "\\*" EOL1 "=> " (STRONG "result\\*") EOL2
     (CODE1 "prog*") " (" (CODE1 "{") (STRONG "var") " " (CODE1 "|") " (" (STRONG "var")
     " [" (STRONG "init-form") "])" (CODE1 "}") "\\*)" " " (STRONG "declaration\\*") " "
     (CODE1 "{") (STRONG "tag") " " (CODE1 "|") " " (STRONG "statement") (CODE1 "}")
     "\\*" EOL1 "=> " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - 変数名" EOL1 (STRONG "init-form") " - フォーム"
     EOL1 (STRONG "declaration") " - 宣言式。評価されません。" EOL1 (STRONG "tag") " - " (CODE1 "go")
     "タグ。評価されません。" EOL1 (STRONG "statement") " - compound-form。下記の説明に従って評価されます。" EOL1
     (STRONG "result") " - 通常の返却のときは" (CODE1 "nil") "、" "そうではなく" (CODE1 "return-from")
     "による明示的な返却のときは転送された返却値。")
    (CHAPTER ("## 定義") 2 (CODE1 "prog") "と" (CODE1 "prog*") "によって" "3つの異なった操作が実行されます。"
     "それは、ローカル変数の束縛と、" (CODE1 "return") "構文の使用の許可と、" (CODE1 "go") "構文の使用の許可です。" "典型的な"
     (CODE1 "prog") "の見た目は次のようになります。"
     (CODE3 "```lisp" "```"
      "(prog (var1 var2 (var3 init-form-3) var4 (var5 init-form-5))" "      declaration*"
      "      statement1" " tag1" "      statement2" "      statement3" "      statement4"
      " tag2" "      statement5" "      ..." "      )")
     EOL2 (CODE1 "prog") "では、" "最初に各" (STRONG "init-form") "が指定された順に評価されます。" "そのあと"
     (STRONG "var") "が対応する値と並列に束縛されます。" "もし" (STRONG "var") "に対して" (STRONG "init-form")
     "が存在しないとき、" "その" (STRONG "var") "には" (CODE1 "nil") "が束縛されます。" EOL2 (CODE1 "prog")
     "のボディ部は" "それが" (CODE1 "tagbody") "フォームであるかのように実行されます。" (CODE1 "go") "構文は"
     (STRONG "tag") "へ制御を移すときに使うことができます。" (STRONG "tag") "は" (STRONG "statement")
     "にラベル付けされます。" EOL2 (CODE1 "prog") "は暗黙に、" (CODE1 "prog") "フォーム全体を囲うようにして、"
     (CODE1 "nil") "という" (CODE1 "block") "が確立しており、" (CODE1 "return") "を使って"
     (CODE1 "prog") "フォームからいつでも退出できます。" EOL2 (CODE1 "prog*") "と" (CODE1 "prog") "の違いは、"
     (CODE1 "prog*") "は" (STRONG "var") "の束縛と初期化は連続的に行われ、" "各変数の" (STRONG "init-form")
     "の値は、以前の変数の値によって使用することができます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(prog* ((y z) (x (car y)))" "       (return x))") EOL2 "上記は"
     (CODE1 "z") "の値の" (CODE1 "car") "を返却します。"
     (CODE3 "```lisp" "```" "(setq a 1) =>  1"
      "(prog ((a 2) (b a)) (return (if (= a b) '= '/=))) =>  /="
      "(prog* ((a 2) (b a)) (return (if (= a b) '= '/=))) =>  ="
      "(prog () 'no-return-value) =>  NIL" "(defun king-of-confusion (w)"
      "  \"Take a cons of two lists and make a list of conses."
      "   Think of this function as being like a zipper.\""
      "  (prog (x y z)          ;Initialize x, y, z to NIL"
      "       (setq y (car w) z (cdr w))" "   loop" "       (cond ((null y) (return x))"
      "             ((null z) (go err)))" "   rejoin"
      "       (setq x (cons (cons (car y) (car z)) x))"
      "       (setq y (cdr y) z (cdr z))" "       (go loop)" "   err"
      "       (cerror \"Will self-pair extraneous items\""
      "               \"Mismatch - gleep!  ~S\" y)" "       (setq z y)"
      "       (go rejoin))) =>  KING-OF-CONFUSION ")
     EOL2 "これは下記に示すように、より明確に達成できます。"
     (CODE3 "```lisp" "```" "(defun prince-of-clarity (w)"
      "  \"Take a cons of two lists and make a list of conses."
      "   Think of this function as being like a zipper.\"" "  (do ((y (car w) (cdr y))"
      "       (z (cdr w) (cdr z))" "       (x '() (cons (cons (car y) (car z)) x)))"
      "      ((null y) x)" "    (when (null z)"
      "      (cerror \"Will self-pair extraneous items\""
      "             \"Mismatch - gleep!  ~S\" y)"
      "      (setq z y)))) =>  PRINCE-OF-CLARITY "))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "block") "," (CODE1 "let") "," (CODE1 "tagbody") ","
     (CODE1 "go") "," (CODE1 "return") "," "3.1. 評価")
    (CHAPTER ("## 備考") 2 (CODE1 "prog") "は、" (CODE1 "block") "と" (CODE1 "let") "と"
     (CODE1 "tagbody") "の語を用いて" "下記のように説明することができます。"
     (CODE3 "```lisp" "```" "(prog variable-list declaration . body)"
      "   ==  (block nil (let variable-list declaration (tagbody . body)))"))))
(setf (gethash '("PROG*" . "MACRO") *table*) (gethash "PROG*" *table*))
(setf (gethash "PROG1" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "PROG1") ", " (CODE1 "PROG2"))
    (CHAPTER ("## 構文") 2 (CODE1 "prog1") " " (STRONG "first-form") " " (STRONG "form\\*")
     " => " (STRONG "result-1") EOL1 (CODE1 "prog2") " " (STRONG "first-form") " "
     (STRONG "second-form") " " (STRONG "form\\*") " => " (STRONG "result-2"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "first-form") " - フォーム。下記の説明に従って評価されます。" EOL1
     (STRONG "second-form") " - フォーム。下記の説明に従って評価されます。" EOL1 (STRONG "form")
     " - フォーム。下記の説明に従って評価されます。" EOL1 (STRONG "result-1") " - " (STRONG "first-form")
     "の評価の返却値の主値" EOL1 (STRONG "result-2") " - " (STRONG "second-form") "の評価の返却値の主値")
    (CHAPTER ("## 定義") 2 (CODE1 "prog1") "は" (STRONG "first-form") "を評価したあとで"
     (STRONG "form") "を評価し、" (STRONG "first-form") "によって生成された主値のみを返却します。" EOL2
     (CODE1 "prog2") "は最初に" (STRONG "first-form") "を評価し、" "その次に" (STRONG "second-form")
     "を評価し、" "そのあと" (STRONG "form") "を評価して、" (STRONG "second-form")
     "によって生成された主値のみを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq temp 1) =>  1"
      "(prog1 temp (print temp) (incf temp) (print temp))" ">>  1" ">>  2" "=>  1"
      "(prog1 temp (setq temp nil)) =>  2" "temp =>  NIL"
      "(prog1 (values 1 2 3) 4) =>  1 " "(setq temp (list 'a 'b 'c))"
      "(prog1 (car temp) (setf (car temp) 'alpha)) =>  A" "temp =>  (ALPHA B C)"
      "(flet ((swap-symbol-values (x y)" "         (setf (symbol-value x) "
      "               (prog1 (symbol-value y)"
      "                      (setf (symbol-value y) (symbol-value x))))))"
      "  (let ((*foo* 1) (*bar* 2))" "    (declare (special *foo* *bar*))"
      "    (swap-symbol-values '*foo* '*bar*)" "    (values *foo* *bar*)))" "=>  2, 1"
      "(setq temp 1) =>  1" "(prog2 (incf temp) (incf temp) (incf temp)) =>  3"
      "temp =>  4" "(prog2 1 (values 2 3 4) 5) =>  2"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "multiple-value-prog1") "," (CODE1 "progn"))
    (CHAPTER ("## 備考") 2 (CODE1 "prog1") "と" (CODE1 "prog2") "は通常、"
     "副作用のあるひとつか複数のフォームを評価し、" "その副作用の一部かあるいはすべてが起こる前に計算されなければならない" "値を返すために使用されます。")))
(setf (gethash '("PROG1" . "MACRO") *table*) (gethash "PROG1" *table*))
(setf (gethash "PROG2" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "PROG1") ", " (CODE1 "PROG2"))
    (CHAPTER ("## 構文") 2 (CODE1 "prog1") " " (STRONG "first-form") " " (STRONG "form\\*")
     " => " (STRONG "result-1") EOL1 (CODE1 "prog2") " " (STRONG "first-form") " "
     (STRONG "second-form") " " (STRONG "form\\*") " => " (STRONG "result-2"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "first-form") " - フォーム。下記の説明に従って評価されます。" EOL1
     (STRONG "second-form") " - フォーム。下記の説明に従って評価されます。" EOL1 (STRONG "form")
     " - フォーム。下記の説明に従って評価されます。" EOL1 (STRONG "result-1") " - " (STRONG "first-form")
     "の評価の返却値の主値" EOL1 (STRONG "result-2") " - " (STRONG "second-form") "の評価の返却値の主値")
    (CHAPTER ("## 定義") 2 (CODE1 "prog1") "は" (STRONG "first-form") "を評価したあとで"
     (STRONG "form") "を評価し、" (STRONG "first-form") "によって生成された主値のみを返却します。" EOL2
     (CODE1 "prog2") "は最初に" (STRONG "first-form") "を評価し、" "その次に" (STRONG "second-form")
     "を評価し、" "そのあと" (STRONG "form") "を評価して、" (STRONG "second-form")
     "によって生成された主値のみを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq temp 1) =>  1"
      "(prog1 temp (print temp) (incf temp) (print temp))" ">>  1" ">>  2" "=>  1"
      "(prog1 temp (setq temp nil)) =>  2" "temp =>  NIL"
      "(prog1 (values 1 2 3) 4) =>  1 " "(setq temp (list 'a 'b 'c))"
      "(prog1 (car temp) (setf (car temp) 'alpha)) =>  A" "temp =>  (ALPHA B C)"
      "(flet ((swap-symbol-values (x y)" "         (setf (symbol-value x) "
      "               (prog1 (symbol-value y)"
      "                      (setf (symbol-value y) (symbol-value x))))))"
      "  (let ((*foo* 1) (*bar* 2))" "    (declare (special *foo* *bar*))"
      "    (swap-symbol-values '*foo* '*bar*)" "    (values *foo* *bar*)))" "=>  2, 1"
      "(setq temp 1) =>  1" "(prog2 (incf temp) (incf temp) (incf temp)) =>  3"
      "temp =>  4" "(prog2 1 (values 2 3 4) 5) =>  2"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "multiple-value-prog1") "," (CODE1 "progn"))
    (CHAPTER ("## 備考") 2 (CODE1 "prog1") "と" (CODE1 "prog2") "は通常、"
     "副作用のあるひとつか複数のフォームを評価し、" "その副作用の一部かあるいはすべてが起こる前に計算されなければならない" "値を返すために使用されます。")))
(setf (gethash '("PROG2" . "MACRO") *table*) (gethash "PROG2" *table*))
(setf (gethash "PROGN" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "PROGN"))
    (CHAPTER ("## 構文") 2 (CODE1 "progn") " " (STRONG "form\\*") " => "
     (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "form") " - 暗黙のprogn" EOL1 (STRONG "result") " - "
     (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "progn") "は" (STRONG "form") "を与えられた順に評価します。" EOL2
     "最後以外の各" (STRONG "form") "の値は切り捨てられます。" EOL2 "もし" (CODE1 "progn")
     "がトップレベルフォームに現れたら、" (CODE1 "progn") "内の全てのフォームは、" "コンパイラによってトップレベルフォームであると見なされます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(progn) =>  NIL" "(progn 1 2 3) =>  3"
      "(progn (values 1 2 3)) =>  1, 2, 3" "(setq a 1) =>  1" "(if a"
      "     (progn (setq a nil) 'here)" "     (progn (setq a t) 'there)) =>  HERE"
      "a =>  NIL"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "prog1") "," (CODE1 "prog2") "," "3.1. 評価")
    (CHAPTER ("## 備考") 2 "Common Lispでは、多くの場所で暗黙のprognという構文で使われています。" "これは、それらの構文の部分は、"
     "多くのフォーム書くことができ、 連続で評価され、" "最後以外のすべてのフォームの返却値は無視され、"
     "最後のフォームの結果が返却されるということを意味しています。" "そのような場所が制限なしに含まれる場所として、" "例えば下記のようなものがあげられます。"
     "ラムダ式のボディ部、" "様々な制御文や条件文のフォームのボディ部" "（例えば、" (CODE1 "case") ", " (CODE1 "catch") ", "
     (CODE1 "progn") ", " (CODE1 "when") "）。")))
(setf (gethash '("PROGN" . "SPECIAL-OPERATOR") *table*) (gethash "PROGN" *table*))
(setf (gethash "PROGRAM-ERROR" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "PROGRAM-ERROR"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "program-error") "," (CODE1 "error") ","
     (CODE1 "serious-condition") "," (CODE1 "condition") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "program-error") "は、" "正しくないプログラムの構文に関係する"
     "エラーの状態で構成されています。" (CODE1 "go") "タグや" (CODE1 "block") "タグの名前がレキシカルに存在しない結果のエラーは、"
     (CODE1 "program-error") "の型になります。")))
(setf (gethash '("PROGRAM-ERROR" . "CONDITION-TYPE") *table*) (gethash "PROGRAM-ERROR" *table*))
(setf (gethash "PROGV" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "PROGV"))
    (CHAPTER ("## 構文") 2 (CODE1 "progv") " " (STRONG "symbols") " " (STRONG "values") " "
     (STRONG "form\\*") " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbols") " シンボルのリスト、評価されます。" EOL1
     (STRONG "values") " - オブジェクトのリスト、評価されます。" EOL1 (STRONG "form") " - 暗黙のprogn" EOL1
     (STRONG "result") " - " (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "progv") "は、新しい動的変数の束縛を作成し、" "それらの束縛を使う" (STRONG "form")
     "を実行します。" "各" (STRONG "form") "は順番に実行されます。" EOL2 (CODE1 "progv")
     "は、実行時に名前を決めることができる、" "ひとつか複数の動的変数の束縛をします。" "各" (STRONG "form") "は、"
     (STRONG "symbols") "内の名前の動的変数に対応する" (STRONG "values") "を束縛した状態で、" "順番に評価されます。" "もし"
     (STRONG "values") "の値が少ないときは、" "残りの" (STRONG "symbols") "は束縛され、"
     "そのあとで値を持っていない状態にします。" "もし" (STRONG "values") "の値が多いときは、余分の値は無視されます。" "動的変数の束縛は、"
     (CODE1 "progv") "の終了時に元に戻されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq *x* 1) =>  1" "(progv '(*x*) '(2) *x*) =>  2"
      "*x* =>  1" NIL ";; *x*がグローバルでspecialではないとき、" NIL "(let ((*x* 3)) "
      "   (progv '(*x*) '(4) " "     (list *x* (symbol-value '*x*)))) =>  (3 4)"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "let") "," "3.1. 評価")
    (CHAPTER ("## 備考") 2 "特に、" (CODE1 "progv") "はLisp内に組み込まれた言語の" "インタプリタを書くときに便利で、"
     "動的変数を束縛する機構を提供します。")))
(setf (gethash '("PROGV" . "SPECIAL-OPERATOR") *table*) (gethash "PROGV" *table*))
(setf (gethash "PSETF" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "SETF") ", " (CODE1 "PSETF"))
    (CHAPTER ("## 構文") 2 (CODE1 "setf") " " (CODE1 "{") (STRONG "pair") (CODE1 "}")
     "\\* => " (STRONG "result\\*") EOL1 (CODE1 "psetf") " " (CODE1 "{") (STRONG "pair")
     (CODE1 "}") "\\* => " (CODE1 "nil") (CODE3 "```" "```" "pair ::= place newvalue "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "place") " - " (CODE1 "place") EOL1
     (STRONG "newvalue") " - フォーム" EOL1 (STRONG "result") " - 最後の" (CODE1 "place")
     "の格納フォームから返却された多値か、" (STRONG "pair") "がないときは" (CODE1 "nil") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "setf") "は、" (CODE1 "place") "の値を" (STRONG "newvalue")
     "に変更します。" EOL2 (CODE1 "(setf place newvalue)") "は、" (STRONG "newvalue") "の評価結果が"
     (CODE1 "place") "の場所へ保存されるような" "更新フォームに展開されます。" "いくつかの" (CODE1 "place") "フォームは、"
     "オプションの引数を取るアクセッサを使用して実行します。" "それらのオプション引数が" (CODE1 "setf") "によって許可されるかどうか、"
     "あるいはどのように使うかは" (CODE1 "setf") "の展開関数次第であり、" (CODE1 "setf") "の制御下にはありません。"
     (CODE1 "setf") "の使用時に" "引数" (CODE1 "&optional") ", " (CODE1 "&rest") ", ..., "
     (CODE1 "&key") "を" "受け付けるような関数のドキュメントは、" "どのようにそれらの引数を扱うのかを指定しなければなりません。" EOL2
     "もし複数の" (STRONG "pair") "が指定されたら、" "各" (STRONG "pair") "は順番に処理されます。" "次の式は、"
     (CODE3 "```lisp" "```" "(setf place-1 newvalue-1" "      place-2 newvalue-2"
      "      ..." "      place-N newvalue-N)")
     EOL2 "下記の式と同等です。"
     (CODE3 "```lisp" "```" "(progn (setf place-1 newvalue-1)"
      "       (setf place-2 newvalue-2)" "       ..."
      "       (setf place-N newvalue-N))")
     EOL2 (CODE1 "psetf") "は複数の" (STRONG "pair") "が指定されたとき、" (CODE1 "place")
     "への新しい値の代入を並行に行います。" "もっと正確に言うと、" "全てのサブフォーム（" (STRONG "place") "と"
     (STRONG "newvalue") "の両方のフォーム）が" "左から右に評価され、全ての評価が実行されたあとで、" "全ての代入が順不同で行われます。" EOL2
     (CODE1 "setf") "と" (CODE1 "psetf") "の展開の扱いの詳細は、" "5.1.2. " (CODE1 "place")
     "の種類をご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq x (cons 'a 'b) y (list 1 2 3)) =>  (1 2 3) "
      "(setf (car x) 'x (cadr y) (car x) (cdr x) y) =>  (1 X 3) " "x =>  (X 1 X 3) "
      "y =>  (1 X 3) " "(setq x (cons 'a 'b) y (list 1 2 3)) =>  (1 2 3) "
      "(psetf (car x) 'x (cadr y) (car x) (cdr x) y) =>  NIL " "x =>  (X 1 A 3) "
      "y =>  (1 A 3) "))
    (CHAPTER ("## 影響") 2 (CODE1 "define-setf-expander") "," (CODE1 "defsetf") ","
     (CODE1 "*macroexpand-hook*"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "define-setf-expander") "," (CODE1 "defsetf") ","
     (CODE1 "macroexpand-1") "," (CODE1 "rotatef") "," (CODE1 "shiftf") ","
     "5.1. 一般化された参照")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PSETF" . "MACRO") *table*) (gethash "PSETF" *table*))
(setf (gethash "PSETQ" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "PSETQ"))
    (CHAPTER ("## 構文") 2 (CODE1 "psetq") " " (CODE1 "{") (STRONG "pair") (CODE1 "}")
     "\\* => " (CODE1 "nil") (CODE3 "```" "```" "*pair* ::= var form "))
    (CHAPTER ("## 発音") 2 (CODE1 "psetq") ": [;pee'set,kyoo]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - 定数ではない変数名のシンボル" EOL1 (STRONG "form")
     " - フォーム")
    (CHAPTER ("## 定義") 2 "変数に値を代入します。" EOL2 "ちょうど" (CODE1 "setq")
     "と似ていますが、代入を「並列」に行うところが違っています。" "つまり、最初にすべての" (STRONG "form") "が評価され、"
     "そのあと初めて変数に返却値がセットされます。" "この方法では、ある変数への代入によって、" (CODE1 "setq") "による順次代入のときのような"
     "計算値への影響が生じるということはありません。" EOL2 "もし、どの" (STRONG "var") "でも" (CODE1 "symbol-macrolet")
     "によって" "作られた束縛を参照したときは、" "その" (STRONG "var") "は" (CODE1 "psetq") "ではなく"
     (CODE1 "psetf") "として扱われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; 変数へ値を代入する単純なPSETQの使用。" ";; スタイルについて、このような単純な状況においては"
      ";; 並列の代入は必要ないため、多くのプログラマーにとっては" ";; SETQの方が好まれます。しかしどちらも同等の効果を持ちます。"
      "(psetq a 1 b 2 c 3) =>  NIL" "a =>  1" "b =>  2" "c =>  3" NIL
      ";; 値を順次代入して更新するPSETQの使用。" ";; この効果は、SETQ使用のときと全く異なります。"
      "(psetq a (1+ b) b (1+ a) c (+ a b)) =>  NIL" "a =>  3" "b =>  2" "c =>  3" NIL
      ";; シンボルマクロ上でのPSETQの使用。" "(let ((x (list 10 20 30)))"
      "  (symbol-macrolet ((y (car x)) (z (cadr x)))" "    (psetq y (1+ z) z (1+ y))"
      "    (list x y z)))" "=>  ((21 11 30) 21 11)" NIL ";; 並列代入の使用による値AとBの交換。"
      "(let ((a 1) (b 2))" "  (psetq a b  b a)" "  (values a b))" "=>  2, 1"))
    (CHAPTER ("## 副作用") 2 "各" (STRONG "form") "の値が対応する" (STRONG "var") "に代入されます。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "psetf") "," (CODE1 "setq")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("PSETQ" . "MACRO") *table*) (gethash "PSETQ" *table*))
(setf (gethash "PUSH" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "PUSH"))
    (CHAPTER ("## 構文") 2 (CODE1 "push") " " (STRONG "item") " " (STRONG "place") " => "
     (STRONG "new-place-value"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "place") " - "
     (CODE1 "place") ", 任意のオブジェクトの値" EOL1 (STRONG "new-place-value") " - リスト（"
     (CODE1 "place") "の新しい値）")
    (CHAPTER ("## 定義") 2 (CODE1 "push") "は" (STRONG "place") "に保存されているリストの先頭に"
     (STRONG "item") "を追加し、" (STRONG "place") "にその結果のリストを保存して返却します。" EOL2
     (STRONG "place") "のサブフォームの評価については、" "5.1.1.1. " (CODE1 "place")
     "のサブフォームの評価をご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq llst '(nil)) =>  (NIL)" "(push 1 (car llst)) =>  (1)"
      "llst =>  ((1))" "(push 1 (car llst)) =>  (1 1)" "llst =>  ((1 1))"
      "(setq x '(a (b c) d)) =>  (A (B C) D)" "(push 5 (cadr x)) =>  (5 B C)  "
      "x =>  (A (5 B C) D)"))
    (CHAPTER ("## 副作用") 2 (STRONG "place") "の内容は修正されます。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "pop") "," (CODE1 "pushnew") "," "5.1. 一般化された参照")
    (CHAPTER ("## 備考") 2 (CODE1 "(push item place)") "の効果は、次と同等です。"
     (CODE3 "```lisp" "```" "(setf place (cons item place))") EOL2 "ただし、"
     (STRONG "place") "のサブフォームはただ一度しか評価されず、" (STRONG "item") "は" (STRONG "place")
     "のあとに評価されます。")))
(setf (gethash '("PUSH" . "MACRO") *table*) (gethash "PUSH" *table*))
(setf (gethash "PUSHNEW" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "PUSHNEW"))
    (CHAPTER ("## 構文") 2 (CODE1 "pushnew") " " (STRONG "item") " " (STRONG "place")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") EOL1 "=> "
     (STRONG "new-place-value"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "place") " - "
     (CODE1 "place") "、通常のリストの値" EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "new-place-value") " - リスト（" (CODE1 "place") "の新しい値）")
    (CHAPTER ("## 定義") 2 (CODE1 "pushnew") "は、" (STRONG "item") "と同じものが、"
     (STRONG "place") "のリストの既存の要素にあるかどうかをテストします。" "もし" (STRONG "item") "が既存の要素に存在しないときは、"
     "リストの前に配置し、新しいリストを" (CODE1 "place") "に保存します。" EOL2 (CODE1 "pushnew") "は、"
     (CODE1 "place") "に格納された新しいリストを返却します。" EOL2 (STRONG "item") "がすでに" (CODE1 "place")
     "のリストのメンバーかどうかは、" (CODE1 ":test") "か" (CODE1 ":test-not") "が比較に使用されて決定します。"
     (CODE1 ":test") "か" (CODE1 ":test-not") "の関数の最初の引数は" (STRONG "item") "であり、"
     "二番目の引数は" (CODE1 "place") "のリストの要素であり、" (CODE1 ":key") "が指定されていればその関数の返却値が使われます。"
     EOL2 "もし" (CODE1 ":key") "が指定されていれば、" (CODE1 "adjoin") "のように、" (STRONG "item")
     "とリストの要素両方からテストの部分を引き出すために使われます。" EOL2 (CODE1 ":key") "関数の引数は、" (CODE1 "place")
     "に格納されたリストの要素です。" (CODE1 ":key") "関数のは、通常はリストの要素の部分を返却します。" "もし" (CODE1 ":key")
     "が指定されなかったか、あるいは" (CODE1 "nil") "のときは、" "リストの要素が使用されます。" EOL2 (CODE1 "place")
     "のサブフォームの評価についての情報は、" "5.1.1.1. " (CODE1 "place") "のサブフォームの評価をご確認ください。" EOL2
     (STRONG "iterm") "がすでに" (CODE1 "place") "のリストのメンバーであった場合に、" (CODE1 "pushnew") "が実際に"
     (CODE1 "place") "に対して" "格納フォームを実行するかどうかは実装依存です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq x '(a (b c) d)) =>  (A (B C) D)"
      "(pushnew 5 (cadr x)) =>  (5 B C)   " "x =>  (A (5 B C) D)"
      "(pushnew 'b (cadr x)) =>  (5 B C)  " "x =>  (A (5 B C) D)"
      "(setq lst '((1) (1 2) (1 2 3))) =>  ((1) (1 2) (1 2 3))"
      "(pushnew '(2) lst) =>  ((2) (1) (1 2) (1 2 3))"
      "(pushnew '(1) lst) =>  ((1) (2) (1) (1 2) (1 2 3))"
      "(pushnew '(1) lst :test 'equal) =>  ((1) (2) (1) (1 2) (1 2 3))"
      "(pushnew '(1) lst :key #'car) =>  ((1) (2) (1) (1 2) (1 2 3)) "))
    (CHAPTER ("## 副作用") 2 (CODE1 "place") "の内容は修正されるでしょう。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "push") "," (CODE1 "adjoin") "," "5.1. 一般化された参照")
    (CHAPTER ("## 備考") 2 "下記の効果は、" (CODE3 "```lisp" "```" "(pushnew item place :test p)")
     EOL2 "だいたい次と同等です。"
     (CODE3 "```lisp" "```" "(setf place (adjoin item place :test p))") EOL2 "ただし、"
     (CODE1 "place") "のサブフォームはただ一度だけ評価され、" (STRONG "item") "は" (CODE1 "place")
     "の前に評価されます。")))
(setf (gethash '("PUSHNEW" . "FUNCTION") *table*) (gethash "PUSHNEW" *table*))
(setf (gethash "QUOTE" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "QUOTE"))
    (CHAPTER ("## 構文") 2 (CODE1 "quote") " " (STRONG "object") " => " (STRONG "object"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト。評価はされません。")
    (CHAPTER ("## 定義") 2 "特殊オペレーターの" (CODE1 "quote") "は、" (STRONG "object") "を返却します。"
     EOL2 "もし（クォートされたオブジェクトに含まれる）" "リテラルオブジェクトが破壊的に修正された結果は未定義です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq a 1) =>  1" "(quote (setq a 3)) =>  (SETQ A 3)"
      "a =>  1" "'a =>  A" "''a =>  (QUOTE A) " "'''a =>  (QUOTE (QUOTE A))"
      "(setq a 43) =>  43" "(list a (cons a 3)) =>  (43 (43 . 3))"
      "(list (quote a) (quote (cons a 3))) =>  (A (CONS A 3)) " "1 =>  1" "'1 =>  1"
      "\"foo\" =>  \"foo\"" "'\"foo\" =>  \"foo\"" "(car '(a b)) =>  A"
      "'(car '(a b)) =>  (CAR (QUOTE (A B)))" "#(car '(a b)) =>  #(CAR (QUOTE (A B)))"
      "'#(car '(a b)) =>  #(CAR (QUOTE (A B)))"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "3.1. 評価," "2.4.3. シングルクォート," "3.2.1. コンパイラーの用語")
    (CHAPTER ("## 備考") 2 "文章としての表記" (CODE1 "'object") "は、" (CODE1 "(quote object)")
     "と等価です。" "3.2.1. コンパイラーの用語をご確認ください。" EOL2 "いくつかの自己評価型オブジェクトと呼ばれるものは、"
     (CODE1 "quote") "によるクォートを必要としません。" "しかしシンボルとリストは、" "プログラムの部分として表現するときには使われますし、"
     "プログラムの中においては" (CODE1 "quote") "なしで" "定数のデータとして利用することはできません。" (CODE1 "quote")
     "はそれらのオブジェクトの評価を抑制するので、" "それらはプログラムではなくデータになります。")))
(setf (gethash '("QUOTE" . "SPECIAL-OPERATOR") *table*) (gethash "QUOTE" *table*))
(setf (gethash "RASSOC" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "RASSOC") ", " (CODE1 "RASSOC-IF") ", "
     (CODE1 "RASSOC-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "rassoc") " " (STRONG "item") " " (STRONG "alist")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "entry") EOL1 (CODE1 "rassoc-if") " " (STRONG "predicate") " "
     (STRONG "alist") " &key " (STRONG "key") " => " (STRONG "entry") EOL1
     (CODE1 "rassoc-if-not") " " (STRONG "predicate") " " (STRONG "alist") " &key "
     (STRONG "key") " => " (STRONG "entry"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "alist") " - 連想リスト"
     EOL1 (STRONG "predicate") " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "entry") " - " (STRONG "alist")
     "の要素であるコンスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "rassoc") ", " (CODE1 "rassoc-if") ", "
     (CODE1 "rassoc-if-not") "は、" (STRONG "alist") "に" (CODE1 "cdr") "が" (STRONG "test")
     "を満たすようなコンスがあれば返却し、" "そのようなコンスが見つからないときは" (CODE1 "nil") "を返却します。" EOL2 "もし"
     (STRONG "alist") "のペアが現れる場所に" (CODE1 "nil") "あったとは無視します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq alist '((1 . \"one\") (2 . \"two\") (3 . 3))) "
      "=>  ((1 . \"one\") (2 . \"two\") (3 . 3))" "(rassoc 3 alist) =>  (3 . 3)"
      "(rassoc \"two\" alist) =>  NIL"
      "(rassoc \"two\" alist :test 'equal) =>  (2 . \"two\")"
      "(rassoc 1 alist :key #'(lambda (x) (if (numberp x) (/ x 3)))) =>  (3 . 3)"
      "(rassoc 'a '((a . b) (b . c) (c . a) (z . a))) =>  (C . A)"
      "(rassoc-if #'stringp alist) =>  (1 . \"one\")"
      "(rassoc-if-not #'vectorp alist) =>  (3 . 3)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "assoc") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "は、非推奨です。" EOL2 "関数" (CODE1 "rassoc-if-not")
     "は、非推奨です。" EOL2 (STRONG "alist") "を更新するために、" (CODE1 "rassoc") "の結果が" (CODE1 "nil")
     "でなければ、" (CODE1 "rplaca") "を使うことができます。" EOL2 "次の2つの式"
     (CODE3 "```lisp" "```" "(rassoc item list :test fn)"
      "(find item list :test fn :key #'cdr)")
     EOL2 "これらは、ひとつの例外を除いては同じ意味です。" "例外は、" (STRONG "item") "が" (CODE1 "nil") "であり、" "かつ"
     (STRONG "alist") "のペアの場所に" (CODE1 "nil") "が現れるときです。" "関数" (CODE1 "assoc")
     "をご確認下さい。")))
(setf (gethash '("RASSOC" . "FUNCTION") *table*) (gethash "RASSOC" *table*))
(setf (gethash "RASSOC-IF" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "RASSOC") ", " (CODE1 "RASSOC-IF") ", "
     (CODE1 "RASSOC-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "rassoc") " " (STRONG "item") " " (STRONG "alist")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "entry") EOL1 (CODE1 "rassoc-if") " " (STRONG "predicate") " "
     (STRONG "alist") " &key " (STRONG "key") " => " (STRONG "entry") EOL1
     (CODE1 "rassoc-if-not") " " (STRONG "predicate") " " (STRONG "alist") " &key "
     (STRONG "key") " => " (STRONG "entry"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "alist") " - 連想リスト"
     EOL1 (STRONG "predicate") " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "entry") " - " (STRONG "alist")
     "の要素であるコンスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "rassoc") ", " (CODE1 "rassoc-if") ", "
     (CODE1 "rassoc-if-not") "は、" (STRONG "alist") "に" (CODE1 "cdr") "が" (STRONG "test")
     "を満たすようなコンスがあれば返却し、" "そのようなコンスが見つからないときは" (CODE1 "nil") "を返却します。" EOL2 "もし"
     (STRONG "alist") "のペアが現れる場所に" (CODE1 "nil") "あったとは無視します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq alist '((1 . \"one\") (2 . \"two\") (3 . 3))) "
      "=>  ((1 . \"one\") (2 . \"two\") (3 . 3))" "(rassoc 3 alist) =>  (3 . 3)"
      "(rassoc \"two\" alist) =>  NIL"
      "(rassoc \"two\" alist :test 'equal) =>  (2 . \"two\")"
      "(rassoc 1 alist :key #'(lambda (x) (if (numberp x) (/ x 3)))) =>  (3 . 3)"
      "(rassoc 'a '((a . b) (b . c) (c . a) (z . a))) =>  (C . A)"
      "(rassoc-if #'stringp alist) =>  (1 . \"one\")"
      "(rassoc-if-not #'vectorp alist) =>  (3 . 3)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "assoc") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "は、非推奨です。" EOL2 "関数" (CODE1 "rassoc-if-not")
     "は、非推奨です。" EOL2 (STRONG "alist") "を更新するために、" (CODE1 "rassoc") "の結果が" (CODE1 "nil")
     "でなければ、" (CODE1 "rplaca") "を使うことができます。" EOL2 "次の2つの式"
     (CODE3 "```lisp" "```" "(rassoc item list :test fn)"
      "(find item list :test fn :key #'cdr)")
     EOL2 "これらは、ひとつの例外を除いては同じ意味です。" "例外は、" (STRONG "item") "が" (CODE1 "nil") "であり、" "かつ"
     (STRONG "alist") "のペアの場所に" (CODE1 "nil") "が現れるときです。" "関数" (CODE1 "assoc")
     "をご確認下さい。")))
(setf (gethash '("RASSOC-IF" . "FUNCTION") *table*) (gethash "RASSOC-IF" *table*))
(setf (gethash "RASSOC-IF-NOT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "RASSOC") ", " (CODE1 "RASSOC-IF") ", "
     (CODE1 "RASSOC-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "rassoc") " " (STRONG "item") " " (STRONG "alist")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "entry") EOL1 (CODE1 "rassoc-if") " " (STRONG "predicate") " "
     (STRONG "alist") " &key " (STRONG "key") " => " (STRONG "entry") EOL1
     (CODE1 "rassoc-if-not") " " (STRONG "predicate") " " (STRONG "alist") " &key "
     (STRONG "key") " => " (STRONG "entry"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL1 (STRONG "alist") " - 連想リスト"
     EOL1 (STRONG "predicate") " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "entry") " - " (STRONG "alist")
     "の要素であるコンスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "rassoc") ", " (CODE1 "rassoc-if") ", "
     (CODE1 "rassoc-if-not") "は、" (STRONG "alist") "に" (CODE1 "cdr") "が" (STRONG "test")
     "を満たすようなコンスがあれば返却し、" "そのようなコンスが見つからないときは" (CODE1 "nil") "を返却します。" EOL2 "もし"
     (STRONG "alist") "のペアが現れる場所に" (CODE1 "nil") "あったとは無視します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq alist '((1 . \"one\") (2 . \"two\") (3 . 3))) "
      "=>  ((1 . \"one\") (2 . \"two\") (3 . 3))" "(rassoc 3 alist) =>  (3 . 3)"
      "(rassoc \"two\" alist) =>  NIL"
      "(rassoc \"two\" alist :test 'equal) =>  (2 . \"two\")"
      "(rassoc 1 alist :key #'(lambda (x) (if (numberp x) (/ x 3)))) =>  (3 . 3)"
      "(rassoc 'a '((a . b) (b . c) (c . a) (z . a))) =>  (C . A)"
      "(rassoc-if #'stringp alist) =>  (1 . \"one\")"
      "(rassoc-if-not #'vectorp alist) =>  (3 . 3)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "assoc") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "は、非推奨です。" EOL2 "関数" (CODE1 "rassoc-if-not")
     "は、非推奨です。" EOL2 (STRONG "alist") "を更新するために、" (CODE1 "rassoc") "の結果が" (CODE1 "nil")
     "でなければ、" (CODE1 "rplaca") "を使うことができます。" EOL2 "次の2つの式"
     (CODE3 "```lisp" "```" "(rassoc item list :test fn)"
      "(find item list :test fn :key #'cdr)")
     EOL2 "これらは、ひとつの例外を除いては同じ意味です。" "例外は、" (STRONG "item") "が" (CODE1 "nil") "であり、" "かつ"
     (STRONG "alist") "のペアの場所に" (CODE1 "nil") "が現れるときです。" "関数" (CODE1 "assoc")
     "をご確認下さい。")))
(setf (gethash '("RASSOC-IF-NOT" . "FUNCTION") *table*) (gethash "RASSOC-IF-NOT" *table*))
(setf (gethash "READ-BYTE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "READ-BYTE"))
    (CHAPTER ("## 構文") 2 (CODE1 "read-byte") " " (STRONG "stream") " "
     (CODE1 "&optional") " " (STRONG "eof-error-p") " " (STRONG "eof-value") " => "
     (STRONG "byte"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream") " - バイナリ入力ストリーム" EOL1
     (STRONG "eof-error-p") " - generalized-boolean。デフォルトは" (STRONG "true") "。" EOL1
     (STRONG "eof-value") " - オブジェクト。デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "byte")
     " - 整数か、" (STRONG "eof-value") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "read-byte") "は、" (STRONG "stream")
     "からひとつのバイトを読み込み返却します。" EOL2 "もしファイルの終わりに到達したとき、" (STRONG "eof-error-p") "が"
     (STRONG "false") "のときは、" (STRONG "eof-value") "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-open-file (s \"temp-bytes\" "
      "                    :direction :output"
      "                    :element-type 'unsigned-byte)"
      "   (write-byte 101 s)) =>  101"
      "(with-open-file (s \"temp-bytes\" :element-type 'unsigned-byte)"
      "   (format t \"~S ~S\" (read-byte s) (read-byte s nil 'eof)))" ">>  101 EOF"
      "=>  NIL"))
    (CHAPTER ("## 副作用") 2 (STRONG "stream") "を変更します。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "stream") "がストリームではないときは、" "型" (CODE1 "type-error")
     "のエラーを通知するべきです。" EOL2 (STRONG "stream") "がバイナリ入力ストリームではないときは、" "型"
     (CODE1 "type-error") "のエラーを通知するべきです。" EOL2 "もし" (STRONG "eof-error-p") "が"
     (STRONG "true") "であり、" (STRONG "stream") "に残りのバイトが存在しないときは、" "型"
     (CODE1 "end-of-file") "のエラーが通知されます。")
    (CHAPTER ("## 参考") 2 (CODE1 "read-char") "," (CODE1 "read-sequence") ","
     (CODE1 "write-byte"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("READ-BYTE" . "FUNCTION") *table*) (gethash "READ-BYTE" *table*))
(setf (gethash "READ-CHAR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "READ-CHAR"))
    (CHAPTER ("## 構文") 2 (CODE1 "read-char") " " (CODE1 "&optional") " "
     (STRONG "input-stream") " " (STRONG "eof-error-p") " " (STRONG "eof-value") " "
     (STRONG "recursive-p") " => " (STRONG "char"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "input-stream") " - 入力ストリーム指定子。デフォルトは標準入力。" EOL1
     (STRONG "eof-error-p") " - generalized-boolean。デフォルトは" (STRONG "true") "。" EOL1
     (STRONG "eof-value") " - オブジェクト。デフォルトは" (CODE1 "nil") "。" EOL1
     (STRONG "recursive-p") " - generalized-boolean。デフォルトは" (STRONG "false") "。" EOL1
     (STRONG "char") " - 文字か、" (STRONG "eof-value"))
    (CHAPTER ("## 定義") 2 (CODE1 "read-char") "は、" (STRONG "input-stream") "から次の文字を返却します。"
     EOL2 (STRONG "input-stream") "が" (CODE1 "echo") "ストリームであるとき、" "その文字は"
     (STRONG "input-stream") "上の最初の文字として現れたものがエコーされます。" (CODE1 "unread-char")
     "によって配置された文字は" (CODE1 "read-char") "によってエコーされません。" "その文字は前回の" (CODE1 "read-char")
     "呼び出し時によって" "すでにエコーされていると見なされるためです。" EOL2 "もし" (STRONG "recursive-p") "が"
     (STRONG "true") "のとき、" "この呼び出しはより上位レベルの" (CODE1 "read") "によるものか、"
     "Lispのリーダーによって使われる似たような関数から" "埋め込まれたものであると見なされます。" EOL2 "もしファイルの終わりが発生し、"
     (STRONG "eof-error-p") "が" (STRONG "false") "であるときは、" (STRONG "eof-value")
     "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-input-from-string (is \"0123\")"
      "   (do ((c (read-char is) (read-char is nil 'the-end)))"
      "       ((not (characterp c)))" "    (format t \"~S \" c)))"
      ">>  #\\0 #\\1 #\\2 #\\3" "=>  NIL"))
    (CHAPTER ("## 影響") 2 (CODE1 "*standard-input*") "," (CODE1 "*terminal-io*"))
    (CHAPTER ("## 例外") 2 (STRONG "eof-error-p") "が" (STRONG "true")
     "でありファイルの終わりに到達したときは、" "型" (CODE1 "end-of-file") "のエラーが通知されます。")
    (CHAPTER ("## 参考") 2 (CODE1 "read-byte") "," (CODE1 "read-sequence") ","
     (CODE1 "write-char") "," (CODE1 "read"))
    (CHAPTER ("## 備考") 2 "対応する出力関数は" (CODE1 "write-char") "です。")))
(setf (gethash '("READ-CHAR" . "FUNCTION") *table*) (gethash "READ-CHAR" *table*))
(setf (gethash "READ-CHAR-NO-HANG" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "READ-CHAR-NO-HANG"))
    (CHAPTER ("## 構文") 2 (CODE1 "read-char-no-hang") " " (CODE1 "&optional") " "
     (STRONG "input-stream") " " (STRONG "eof-error-p") " " (STRONG "eof-value") " "
     (STRONG "recursive-p") " => " (STRONG "char"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "input-stream") " - 入力ストリーム指定子。デフォルトは標準入力。" EOL1
     (STRONG "eof-error-p") " - generalized-boolean。デフォルトは" (STRONG "true") "。" EOL1
     (STRONG "eof-value") " - オブジェクト。デフォルトは" (CODE1 "nil") "。" EOL1
     (STRONG "recursive-p") " - generalized-boolean。デフォルトは" (STRONG "false") "。" EOL1
     (STRONG "char") " - 文字か、" (STRONG "eof-value"))
    (CHAPTER ("## 定義") 2 (CODE1 "read-char-no-hang") "は、" (STRONG "input-stream")
     "に利用可能な文字があるとき、" "その文字を返却します。" "もし文字が利用可能ではないとき、" (CODE1 "read-char-no-hang") "は"
     (CODE1 "nil") "を返却します。" EOL2 "もし" (STRONG "recursive-p") "が" (STRONG "true") "のとき、"
     "この呼び出しはより上位レベルの" (CODE1 "read") "によるものか、" "Lispのリーダーによって使われる似たような関数から"
     "埋め込まれたものであると見なされます。" EOL2 "もしファイルの終わりが発生し、" (STRONG "eof-error-p") "が"
     (STRONG "false") "であるときは、" (STRONG "eof-value") "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; このコードは実装がコンソールからの入力の終端に" ";; 改行を必要としないことを仮定しています。"
      "(defun test-it ()" "  (unread-char (read-char))" "  (list (read-char-no-hang) "
      "        (read-char-no-hang) " "        (read-char-no-hang)))" "=>  TEST-IT"
      ";; 実装Aは、コンソールのインタラクティブな入力の終端に" ";; 改行を必要としません。" " (test-it)" ">>  a"
      "=>  (#\\a NIL NIL)" ";; 実装Bは、コンソールのインタラクティブな入力の終端に"
      ";; 改行を必要とし、その開業は入力ストリームに残します。" "(test-it)" ">>  a<NEWLINE>"
      "=>  (#\\a #\\Newline NIL)"))
    (CHAPTER ("## 影響") 2 (CODE1 "*standard-input*") "," (CODE1 "*terminal-io*"))
    (CHAPTER ("## 例外") 2 (STRONG "eof-error-p") "が" (STRONG "true")
     "でありファイルの終わりに到達したときは、" "型" (CODE1 "end-of-file") "のエラーが通知されます。")
    (CHAPTER ("## 参考") 2 (CODE1 "listen"))
    (CHAPTER ("## 備考") 2 (CODE1 "read-char-no-hang") "は正確に" (CODE1 "read-char")
     "と似ていますが、" "もし文字を（例えばキーボードから）取得するために" "待機する必要があるような場合は違っており、" "このような場合は待つことなしに即座に"
     (CODE1 "nil") "を返却します。")))
(setf (gethash '("READ-CHAR-NO-HANG" . "FUNCTION") *table*) (gethash "READ-CHAR-NO-HANG" *table*))
(setf (gethash "READ-LINE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "READ-LINE"))
    (CHAPTER ("## 構文") 2 (CODE1 "read-line") " " (CODE1 "&optional") " "
     (STRONG "input-stream") " " (STRONG "eof-error-p") " " (STRONG "eof-value") " "
     (STRONG "recursive-p") EOL1 "=> " (STRONG "line") ", " (STRONG "missing-newline-p"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "input-stream") " - 入力ストリーム指定子。デフォルトは標準入力。" EOL1
     (STRONG "eof-error-p") " - generalized-boolean。デフォルトは" (STRONG "true") "。" EOL1
     (STRONG "eof-value") " - オブジェクト。デフォルトは" (CODE1 "nil") "。" EOL1
     (STRONG "recursive-p") " - generalized-boolean。デフォルトは" (STRONG "false") "。" EOL1
     (STRONG "line") " - 文字列か、" (STRONG "eof-value") EOL1 (STRONG "missing-newline-p")
     " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "input-stream") "から、改行かファイルの終わりを終端とする" "テキストの行を読み込みます。"
     EOL2 "もし" (STRONG "recursive-p") "が" (STRONG "true") "のとき、" "この呼び出しはより上位レベルの"
     (CODE1 "read") "によるものか、" "Lispのリーダーによって使われる似たような関数から" "埋め込まれたものであると見なされます。" EOL2
     "第一返却値の" (STRONG "line") "は、読み込まれた行であり、" "文字列として（もし読み込まれたものに改行があるなら、"
     "それを取り除いたもの）表現されます。" "もし" (STRONG "eof-error-p") "が" (STRONG "false") "であり、"
     "何らかの文字が読み込まれる前に" (STRONG "input-stream") "がファイルの終わりに到達していたときは、"
     (STRONG "eof-value") "が" (STRONG "line") "として返却されます。" EOL2 "第二返却値の"
     (STRONG "missing-newline-p") "はgeneralized-booleanであり、" "もし" (STRONG "line")
     "が改行で終わっていたときは" (STRONG "false") "を、" "あるいは" (STRONG "line") "が"
     (STRONG "input-stream") "からのファイルの終わりによって" "終端されていたとき（あるいは" (STRONG "line") "が"
     (STRONG "eof-value") "のとき）は、" (STRONG "true") "になります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq a \"line 1" "line2\")" "=>  \"line 1" "line2\""
      "(read-line (setq input-stream (make-string-input-stream a)))"
      "=>  \"line 1\", false" "(read-line input-stream)" "=>  \"line2\", true"
      "(read-line input-stream nil nil)" "=>  NIL, true"))
    (CHAPTER ("## 副作用") 2 "なし。")
    (CHAPTER ("## 影響") 2 (CODE1 "*standard-input*") "," (CODE1 "*terminal-io*"))
    (CHAPTER ("## 例外") 2 "もし行中で何らかの文字を読み込む前にファイルの終わりにが発生したときは、" (STRONG "eof-error-p")
     "が" (STRONG "true") "のときはエラーが通知されます。")
    (CHAPTER ("## 参考") 2 (CODE1 "read"))
    (CHAPTER ("## 備考") 2 "対応する出力関数は" (CODE1 "write-line") "です。")))
(setf (gethash '("READ-LINE" . "FUNCTION") *table*) (gethash "READ-LINE" *table*))
(setf (gethash "READ-SEQUENCE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "READ-SEQUENCE"))
    (CHAPTER ("## 構文") 2 (CODE1 "read-sequence") " " (STRONG "sequence") " "
     (STRONG "stream") " " (CODE1 "&key") " " (STRONG "start") " " (STRONG "end") " => "
     (STRONG "position"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "sequence") " - シーケンス" EOL1 (STRONG "stream")
     " - 入力ストリーム" EOL1 (STRONG "start") ", " (STRONG "end") " - " (STRONG "string")
     "の境界インデックス指定子。" "デフォルトは" (STRONG "start") ", " (STRONG "end") "それぞれ" (CODE1 "0") "と"
     (CODE1 "nil") "。" EOL1 (STRONG "position") " - " (CODE1 "0") "以上かつ"
     (STRONG "sequence") "の長さ以下の整数")
    (CHAPTER ("## 定義") 2 (STRONG "stream") "から要素を読み込み、" (STRONG "sequence") "の"
     (STRONG "start") "から" (STRONG "end") "の境界内の要素を" "破壊的に修正して置き換えます。" EOL2
     (STRONG "sequence") "は破壊的に修正され、" (STRONG "stream") "から一連の要素がコピーされます。"
     "もし部分シーケンスの全ての要素をコピーする前に" (STRONG "stream") "がファイルの終わりに到達したとき、" (STRONG "sequence")
     "の終端付近の残りの要素は更新されません。" EOL2 (STRONG "position") "は、更新が生じなかった" (STRONG "sequence")
     "の" "最初の要素のインデックスであり、" "ファイルの終わりに到達したときは" (STRONG "end") "未満になることがあります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defvar *data* (make-array 15 :initial-element nil))"
      "(values (read-sequence *data* (make-string-input-stream \"test string\")) *data*)"
      "=>  11, #(#\\t #\\e #\\s #\\t #\\Space #\\s #\\t #\\r #\\i #\\n #\\g NIL NIL NIL NIL)"))
    (CHAPTER ("## 副作用") 2 (STRONG "stream") "と" (STRONG "sequence") "は修正されます。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスではなかったときは、" "型"
     (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。" (STRONG "start") "が非負の整数ではなかったときは、"
     "型" (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。" (STRONG "end") "が非負の整数か"
     (CODE1 "nil") "ではなかったときは、" "型" (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。" EOL2
     (STRONG "stream") "から読み込まれた要素が、" (STRONG "sequence") "の要素の型ではなかったときは、" "型"
     (CODE1 "type-error") "のエラーを通知されるかもしれません。")
    (CHAPTER ("## 参考") 2 "3.2.1. コンパイラーの用語," (CODE1 "write-sequence") ","
     (CODE1 "read-line"))
    (CHAPTER ("## 備考") 2 (CODE1 "read-sequence") "は、指定した部分シーケンスに対して" (STRONG "stream")
     "からひとつの要素を読み込みその都度" (STRONG "sequence") "に" "格納していく繰り返しと同じ効果ですが、"
     "おそらくは同等のループよりもより効率的になります。" EOL2 "ある効率の良い実装では、" (STRONG "sequence") "が"
     (STRONG "stream") "の要素と同じ型の" (CODE1 "vector") "である場合に" "より効率的になるかもしれません。")))
(setf (gethash '("READ-SEQUENCE" . "FUNCTION") *table*) (gethash "READ-SEQUENCE" *table*))
(setf (gethash "REDUCE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "REDUCE"))
    (CHAPTER ("## 構文") 2 (CODE1 "reduce") " " (STRONG "function") " " (STRONG "sequence")
     "&key " (STRONG "key") " " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "initial-value") " => " (STRONG "result"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "function") " - 引数なしか2つの引数を取る関数の指定子" EOL1
     (STRONG "sequences") " - 正常なシーケンス" EOL1 (STRONG "key") " - 1つの引数を取る関数の指定子、または"
     (CODE1 "nil") EOL1 (STRONG "from-end") " - generalized-boolean、デフォルトは"
     (STRONG "false") EOL1 (STRONG "start") ", " (STRONG "end") " - " (STRONG "sequence")
     "の境界インデックス指定子。" "デフォルトは" (STRONG "start") ", " (STRONG "end") "それぞれ" (CODE1 "0") "と"
     (CODE1 "nil") "。" EOL1 (STRONG "initial-value") " - オブジェクト" EOL1 (STRONG "result")
     " - オブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "reduce") "は、" (STRONG "function") "で二項演算を行うために使われ、"
     (STRONG "sequence") "の" (STRONG "stard") ", " (STRONG "end") "の境界内にある要素を結び付けます。"
     EOL2 (STRONG "function") "は、引数に" (STRONG "sequence") "の2つの要素か、"
     "それらの要素が結合された結果を受け付ける必要があります。" (STRONG "function") "はまた、引数なしも受け付けなければなりません。" EOL2
     "もし" (STRONG "key") "が与えられたとき、" (CODE1 "reduce") "された値の展開に使われます。" (STRONG "key")
     "関数は、もし" (STRONG "initial-value") "が与えられなかったとき、" (STRONG "sequence") "の各要素に対して、"
     (CODE1 "reduce") "の実行順に、正確に一度だけ適用されます。" (STRONG "key") "関数は通常" (STRONG "sequence")
     "の要素の、判定に使われる要素の部分を返却します。" "もし" (STRONG "key") "が与えられないか、あるいは" (CODE1 "nil")
     "が指定されたとき、" (STRONG "sequence") "の要素そのものが使われます。" EOL2 (CODE1 "reduce")
     "は左結合で行われますが、" (STRONG "from-end") "が" (STRONG "true") "のときは右結合です。" EOL2 "もし"
     (STRONG "initial-value") "が与えられたとき、" "それは論理的にサブシーケンスの前に配置され" "（ただし"
     (STRONG "from-end") "が" (STRONG "true") "の場合は後に配置されます）" "それを含めて" (CODE1 "reduce")
     "操作が行われます。" EOL2 "通常の場合、" (CODE1 "reduce") "の返却値は、" (STRONG "sequence")
     "の要素の連続した組み合わせを" (STRONG "function") "で適用した結果を組み合わせたものです。" "もしサブシーケンスが正確にひとつの要素であり、"
     (STRONG "initial-value") "が与えられていなかったときは、" "その要素が返却され、" (STRONG "function")
     "は呼び出されません。" "もしサブシーケンスが空であり、" (STRONG "initial-value") "が与えられらときは、"
     (STRONG "initial-value") "が返却され、" (STRONG "function") "は呼び出されません。" "もしサブシーケンスが空であり、"
     (STRONG "initial-value") "が与えられなかったときは、" (STRONG "function") "は引数なしで呼び出され、"
     (CODE1 "reduce") "の返却値は、" "どんな値であれ" (STRONG "function") "の結果が返却されます。"
     (STRONG "function") "が2つの引数ではない方法で呼び出されるのは、" "この場合のみです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(reduce #'* '(1 2 3 4 5)) =>  120"
      "(reduce #'append '((1) (2)) :initial-value '(i n i t)) =>  (I N I T 1 2)"
      "(reduce #'append '((1) (2)) :from-end t                  "
      "                            :initial-value '(i n i t)) =>  (1 2 I N I T) "
      "(reduce #'- '(1 2 3 4)) ==  (- (- (- 1 2) 3) 4) =>  -8"
      "(reduce #'- '(1 2 3 4) :from-end t)    ;Alternating sum."
      "==  (- 1 (- 2 (- 3 4))) =>  -2" "(reduce #'+ '()) =>  0" "(reduce #'+ '(3)) =>  3"
      "(reduce #'+ '(foo)) =>  FOO" "(reduce #'list '(1 2 3 4)) =>  (((1 2) 3) 4)"
      "(reduce #'list '(1 2 3 4) :from-end t) =>  (1 (2 (3 4)))"
      "(reduce #'list '(1 2 3 4) :initial-value 'foo) =>  ((((foo 1) 2) 3) 4)"
      "(reduce #'list '(1 2 3 4)"
      "       :from-end t :initial-value 'foo) =>  (1 (2 (3 (4 foo))))"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "3.6. 横断の規則と副作用") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("REDUCE" . "FUNCTION") *table*) (gethash "REDUCE" *table*))
(setf (gethash "REINITIALIZE-INSTANCE" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "REINITIALIZE-INSTANCE"))
    (CHAPTER ("## 構文") 2 (CODE1 "reinitialize-instance") " " (STRONG "instance") "&rest "
     (STRONG "initargs") " &key &allow-other-keys => " (STRONG "instance"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "reinitialize-instance") " (" (STRONG "instance") " "
     (CODE1 "standard-object") ") &rest " (STRONG "initargs"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "instance") " - オブジェクト" EOL1 (STRONG "initargs")
     " - 初期化引数リスト")
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "reinitialize-instance") "は、"
     (STRONG "instance") "の局所スロットの値を" (STRONG "initargs") "に従って" "変更するときに使われます。"
     "このジェネリック関数は、ユーザーによって呼び出すことができます。" EOL2 "システムが提供する" (CODE1 "reinitialize-instance")
     "のプライマリメソッドは" (STRONG "initargs") "の有効性の確認を行い、" "有効だと宣言されていないものが"
     (STRONG "initargs") "で与えられていた場合は、" "エラーが通知されます。" "このメソッドはジェネリック関数"
     (CODE1 "shared-initialize") "を次の引数で呼び出します。" (STRONG "instance") ", " (CODE1 "nil")
     "（これはinitformでスロットを初期化しないという意味です）, " "そして受け取った" (STRONG "initargs") "。")
    (CHAPTER ("## 例文") 2 "なし。")
    (CHAPTER ("## 副作用") 2 "ジェネリック関数" (CODE1 "reinitialize-instance") "は局所スロットの値を変更します。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "システムが提供する" (CODE1 "reinitialize-instance") "のプライマリメソッドは"
     "有効だと宣言されていないものが" (STRONG "initargs") "で与えられていた場合は、" "エラーが通知されます。")
    (CHAPTER ("## 参考") 2 (CODE1 "initialize-instance") "," (CODE1 "shared-initialize")
     "," (CODE1 "update-instance-for-redefined-class") ","
     (CODE1 "update-instance-for-different-class") "," (CODE1 "slot-boundp") ","
     (CODE1 "slot-makunbound") "," "7.3. インスタンスの再初期化," "7.1.4. 初期化引数の規則,"
     "7.1.2. 初期化引数の有効性の宣言")
    (CHAPTER ("## 備考") 2 (STRONG "initargs") "は、" (CODE1 "defclass") "の"
     (CODE1 ":initarg") "引数によって、" "あるいは" (CODE1 "reinitialize-instance") "か"
     (CODE1 "shared-initialize") "の" "メソッドの宣言によって、有効であると宣言されます。"
     (CODE1 "reinitialize-instance") "か" (CODE1 "shared-initialize") "の"
     "各メソッドの宣言のラムダリストにある、" "各キーワードパラメーター指定子のキーワード名は、" "それらのメソッドが適用されるすべてのクラスに対して、"
     "有効な初期化引数の名前として宣言されます。")))
(setf (gethash '("REINITIALIZE-INSTANCE" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "REINITIALIZE-INSTANCE" *table*))
(setf (gethash "REMF" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "REMF"))
    (CHAPTER ("## 構文") 2 (CODE1 "remf") " " (STRONG "place") " " (STRONG "indicator")
     " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "place") " - " (CODE1 "place") EOL1
     (STRONG "indicator") " - オブジェクト" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "remf") "は、" (STRONG "place") "に保存されているプロパティリストから"
     (STRONG "indicator") "と同一の標識のプロパティを削除します。" "標識に対してキーが同一のプロパティが複数あるときは、"
     (CODE1 "remf") "は最初のプロパティを削除します。" "標識に対するプロパティが存在しないときは" (STRONG "false") "を、"
     "プロパティが見つかった時は" (STRONG "true") "を返却します。" EOL2 "プロパティのindicatorと対応する値は、"
     "プロパティリストを順不同で破壊的につなぎ合わせることにより削除します。" (CODE1 "remf") "は、" (CODE1 "place") "に"
     (CODE1 "setf") "するか、" "あるいは" (CODE1 "setf") "に保持されているリスト構造の" "どの" (CODE1 "car") ", "
     (CODE1 "cdr") "部にも" (CODE1 "setf") "することが許されています。" EOL2 (CODE1 "place")
     "のサブフォームの評価についての情報は、" "5.1.1.1. " (CODE1 "place") "のサブフォームの評価をご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq x (cons () ())) =>  (NIL)"
      "(setf (getf (car x) 'prop1) 'val1) =>  VAL1" "(remf (car x) 'prop1) =>  true"
      "(remf (car x) 'prop1) =>  false"))
    (CHAPTER ("## 副作用") 2 (CODE1 "place") "に保存されているプロパティリストは修正されます。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "remprop") "," (CODE1 "getf"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("REMF" . "MACRO") *table*) (gethash "REMF" *table*))
(setf (gethash "REMHASH" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "REMHASH"))
    (CHAPTER ("## 構文") 2 (CODE1 "remhash") " " (STRONG "key") " " (STRONG "hash-table")
     " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "key") " - オブジェクト" EOL1 (STRONG "hash-table")
     " - ハッシュテーブル" EOL1 (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "hash-table") "内の" (STRONG "key")
     "に対応するエントリーが存在すれば削除します。" "そのようなエントリーが存在したときは" (STRONG "true") "を、" "それ以外は"
     (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32115666>"
      "(setf (gethash 100 table) \"C\") =>  \"C\"" "(gethash 100 table) =>  \"C\", true"
      "(remhash 100 table) =>  true" "(gethash 100 table) =>  NIL, false"
      "(remhash 100 table) =>  false"))
    (CHAPTER ("## 副作用") 2 (STRONG "hash-table") "は修正されます。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("REMHASH" . "FUNCTION") *table*) (gethash "REMHASH" *table*))
(setf (gethash "REMOVE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "REMOVE"))
    (CHAPTER ("## 構文") 2 (CODE1 "remove") " " (STRONG "item") " " (STRONG "sequence")
     " &key " (STRONG "from-end") " " (STRONG "test") " " (STRONG "test-not") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "remove-if") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "remove-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "delete") " " (STRONG "item") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "test") " "
     (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") " => " (STRONG "result-sequence") EOL1 (CODE1 "delete-if") " "
     (STRONG "predicate") " " (STRONG "sequence") " &key " (STRONG "from-end") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "delete-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL2 (STRONG "sequence")
     " - 正常なシーケンス" EOL1 (STRONG "predicate") " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子"
     EOL1 (STRONG "from-end") " - generalized-boolean、デフォルトは" (STRONG "false") EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "count")
     " - 整数か" (CODE1 "nil") "。デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "result-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "remove") "、" (CODE1 "remove-if") "、"
     (CODE1 "remove-if-not") "は、" (STRONG "sequence") "からテストを満たした要素を削除したものを返却します。" EOL2
     (CODE1 "delete") "、" (CODE1 "delete-if") "、" (CODE1 "delete-if-not") "は、" "それぞれ"
     (CODE1 "remove") "、" (CODE1 "remove-if") "、" (CODE1 "remove-if-not") "に"
     "似ていますが、これらは" (STRONG "sequence") "を修正します。" EOL2 "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のとき、返却値は" (CODE1 "vector") "であり、" (STRONG "sequence")
     "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence") "がリストなら、返却値はリストです。" EOL2
     (STRONG "from-end") "が" (STRONG "true") "のときは、" "ただ" (STRONG "count")
     "が指定されたときが重要になります。" "このような場合、右端から（左端ではなく）テストを満たす" (STRONG "count") "の要素だけが削除されます。"
     EOL2 (STRONG "count") "が与えられたとき、削除する要素数を制限できます。" "もしテストを満たす要素が" (STRONG "count")
     "を越えていたときは、" "それらの要素は左端か右端（" (STRONG "from-end") "の値による）から、" "ただ" (STRONG "count")
     "で指定された数だけ削除されます。" "もし" (STRONG "count") "負の値が指定されたときは、" (CODE1 "0")
     "が指定されたかのようにふるまいます。" "もし" (STRONG "count") "が" (CODE1 "nil") "のときは、" (STRONG "item")
     "にマッチした全てに影響します。" EOL2 "これらの全ての関数は、削除されなかった要素は、" "結果内に" (STRONG "sequence")
     "と同じ順序で現れます。" EOL2 (CODE1 "remove") "、" (CODE1 "remove-if") "、"
     (CODE1 "remove-if-not") "は、" (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start")
     ", " (STRONG "end") "に囲まれたサブシーケンスのテストを満たし" "削除されたもの以外は同じ要素を返却します。" "これは非破壊的な操作です。"
     "もし要素の削除が必要になった時は、コピーが返却されます。" (CODE1 "remove") "の返却値は、" (STRONG "sequence")
     "を共有するかもしれません。" "もし要素に削除が生じなかったときは、" "入力の" (STRONG "sequence")
     "と同一のものが返却される可能性があります。" EOL2 (CODE1 "delete") "、" (CODE1 "delete-if") "、"
     (CODE1 "delete-if-not") "は、" (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start")
     ", " (STRONG "end") "に囲まれたサブシーケンスのテストを満たし" "削除されたもの以外は同じ要素を返却します。"
     (STRONG "sequence") "は返却値の構築のために破壊されるかもしれません。" "しかし、返却値は" (STRONG "sequence")
     "と同一の場合もあれば、" "そうではない場合もあります。" EOL2 (CODE1 "delete") "は、" (STRONG "sequence")
     "がリストのときは、" (STRONG "sequence") "のトップレベルのリスト構造の" "どの" (CODE1 "car") ", "
     (CODE1 "cdr") "でも" (CODE1 "setf") "することが許されています。" "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のときは、" (CODE1 "delete") "は" (CODE1 "vector") "の次元を変更し、"
     "その要素を並べ替えをせず、新しい位置にスライドして" "返却値の" (CODE1 "vector") "を構築することが許されています。" EOL2
     "delete-ifは以下のように正確に動作するように制約されています。"
     (CODE3 "```lisp" "```" " (delete nil sequence"
      "             :test #'(lambda (ignore item) (funcall test item))"
      "             ...)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(remove 4 '(1 3 4 5 9)) =>  (1 3 5 9)"
      "(remove 4 '(1 2 4 1 3 4 5)) =>  (1 2 1 3 5)"
      "(remove 4 '(1 2 4 1 3 4 5) :count 1) =>  (1 2 1 3 4 5)"
      "(remove 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) =>  (1 2 4 1 3 5)"
      "(remove 3 '(1 2 4 1 3 4 5) :test #'>) =>  (4 3 4 5)"
      "(setq lst '(list of four elements)) =>  (LIST OF FOUR ELEMENTS)"
      "(setq lst2 (copy-seq lst)) =>  (LIST OF FOUR ELEMENTS)"
      "(setq lst3 (delete 'four lst)) =>  (LIST OF ELEMENTS)"
      "(equal lst lst2) =>  false" "(remove-if #'oddp '(1 2 4 1 3 4 5)) =>  (2 4 4)"
      "(remove-if #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t) " "=>  (1 2 4 1 3 5)"
      "(remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9) :count 2 :from-end t)"
      "=>  (1 2 3 4 5 6 8)" "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester) =>  (1 2 1 3 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester :count 1) =>  (1 2 1 3 4 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester :count 1 :from-end t) =>  (1 2 4 1 3 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 3 tester :test #'>) =>  (4 3 4 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete-if #'oddp tester) =>  (2 4 4)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete-if #'evenp tester :count 1 :from-end t) =>  (1 2 4 1 3 5)    "
      "(setq tester (list 1 2 3 4 5 6)) =>  (1 2 3 4 5 6) "
      "(delete-if #'evenp tester) =>  (1 3 5) " "tester =>  implementation-dependent"
      "(setq foo (list 'a 'b 'c)) =>  (A B C)" "(setq bar (cdr foo)) =>  (B C)"
      "(setq foo (delete 'b foo)) =>  (A C)" "bar =>  ((C)) or ..."
      "(eq (cdr foo) (car bar)) =>  T or ..."))
    (CHAPTER ("## 副作用") 2 (CODE1 "delete") "、" (CODE1 "delete-if") "、"
     (CODE1 "delete-if-not") "の場合、" (STRONG "sequence") "は返却値の構築のために破壊されるかもしれません。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "返却値は"
     (CODE1 "simple") "かもしれませんし、そうでないかもしれません。" "また、返却値は" (STRONG "sequence")
     "と同一かもしれませんし、" "そうでないかもしれません。" EOL2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "delete-if-not") "と" (CODE1 "remove-if-not") "は非推奨です。")))
(setf (gethash '("REMOVE" . "FUNCTION") *table*) (gethash "REMOVE" *table*))
(setf (gethash "REMOVE-DUPLICATES" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "REMOVE-DUPLICATES") ", "
     (CODE1 "DELETE-DUPLICATES"))
    (CHAPTER ("## 構文") 2 (CODE1 "remove-duplicates") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "test") " " (STRONG "test-not") " " (STRONG "start")
     " " (STRONG "end") " " (STRONG "key") EOL1 "=> " (STRONG "result-sequence") EOL2
     (CODE1 "delete-duplicates") " " (STRONG "sequence") " &key " (STRONG "from-end") " "
     (STRONG "test") " " (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " "
     (STRONG "key") EOL1 "=> " (STRONG "result-sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "sequence") " - 正常なシーケンス" EOL1 (STRONG "from-end")
     " - generalized-boolean、デフォルトは" (STRONG "false") EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "result-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "remove-duplicates") "は、" "他の要素とマッチするような要素を削除した"
     (STRONG "sequence") "のコピーを返却します。" EOL2 "もし" (STRONG "sequence") "が" (CODE1 "vector")
     "のとき、返却値は" (CODE1 "vector") "であり、" (STRONG "sequence") "と同じ実際の配列の要素の型を持ちます。" "もし"
     (STRONG "sequence") "がリストなら、返却値はリストです。" EOL2 (STRONG "sequence") "の要素は対で比較され、"
     "どれか2つが一致すれば、先に発生したものが捨てられます。" "ただし，" (STRONG "from-end") "が" (STRONG "true")
     "の場合は、" "後に発生したものが捨てられます。" EOL2 (CODE1 "remove-duplicates") "と"
     (CODE1 "delete-duplicates") "は、" (STRONG "sequence") "と同じ型のシーケンスに、"
     "残りのどの2つの要素にもマッチしないように、" "十分に要素取り除いた内容のものを返却します。" "返却値に残った要素の順序は、"
     (STRONG "sequence") "に現れるものと同じです。" EOL2 (CODE1 "remove-duplicates") "の返却値は、"
     (STRONG "sequence") "を共有するかもしれません。" "もし要素に削除が生じなかったときは、" "入力の" (STRONG "sequence")
     "と同一のものが返却される可能性があります。" EOL2 (CODE1 "delete-duplicates") "は、" (STRONG "sequence")
     "がリストのときは、" (STRONG "sequence") "のトップレベルのリスト構造の" "どの" (CODE1 "car") ", "
     (CODE1 "cdr") "でも" (CODE1 "setf") "することが許されています。" "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のときは、" (CODE1 "delete-duplicates") "は" (CODE1 "vector") "の次元を変更し、"
     "その要素を並べ替えをせず、新しい位置にスライドして" "返却値の" (CODE1 "vector") "を構築することが許されています。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(remove-duplicates \"aBcDAbCd\" :test #'char-equal :from-end t) =>  \"aBcD\""
      "(remove-duplicates '(a b c b d d e)) =>  (A C B D E)"
      "(remove-duplicates '(a b c b d d e) :from-end t) =>  (A B C D E)"
      "(remove-duplicates '((foo #\\a) (bar #\\%) (baz #\\A))"
      "    :test #'char-equal :key #'cadr) =>  ((BAR #\\%) (BAZ #\\A))"
      "(remove-duplicates '((foo #\\a) (bar #\\%) (baz #\\A)) "
      "    :test #'char-equal :key #'cadr :from-end t) =>  ((FOO #\\a) (BAR #\\%))"
      "(setq tester (list 0 1 2 3 4 5 6))"
      "(delete-duplicates tester :key #'oddp :start 1 :end 6) =>  (0 4 5 6)"))
    (CHAPTER ("## 副作用") 2 (CODE1 "delete-duplicates") "は、" (STRONG "sequence")
     "を破壊的に修正するかもしれません。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "返却値は"
     (CODE1 "simple") "かもしれませんし、そうでないかもしれません。" "また、返却値は" (STRONG "sequence")
     "と同一かもしれませんし、" "そうでないかもしれません。" EOL2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2
     "これらの関数は、" (STRONG "sequence") "を集合で表現される" "標準形に変換するのに便利です。")))
(setf (gethash '("REMOVE-DUPLICATES" . "FUNCTION") *table*) (gethash "REMOVE-DUPLICATES" *table*))
(setf (gethash "REMOVE-IF" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "REMOVE"))
    (CHAPTER ("## 構文") 2 (CODE1 "remove") " " (STRONG "item") " " (STRONG "sequence")
     " &key " (STRONG "from-end") " " (STRONG "test") " " (STRONG "test-not") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "remove-if") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "remove-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "delete") " " (STRONG "item") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "test") " "
     (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") " => " (STRONG "result-sequence") EOL1 (CODE1 "delete-if") " "
     (STRONG "predicate") " " (STRONG "sequence") " &key " (STRONG "from-end") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "delete-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL2 (STRONG "sequence")
     " - 正常なシーケンス" EOL1 (STRONG "predicate") " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子"
     EOL1 (STRONG "from-end") " - generalized-boolean、デフォルトは" (STRONG "false") EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "count")
     " - 整数か" (CODE1 "nil") "。デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "result-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "remove") "、" (CODE1 "remove-if") "、"
     (CODE1 "remove-if-not") "は、" (STRONG "sequence") "からテストを満たした要素を削除したものを返却します。" EOL2
     (CODE1 "delete") "、" (CODE1 "delete-if") "、" (CODE1 "delete-if-not") "は、" "それぞれ"
     (CODE1 "remove") "、" (CODE1 "remove-if") "、" (CODE1 "remove-if-not") "に"
     "似ていますが、これらは" (STRONG "sequence") "を修正します。" EOL2 "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のとき、返却値は" (CODE1 "vector") "であり、" (STRONG "sequence")
     "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence") "がリストなら、返却値はリストです。" EOL2
     (STRONG "from-end") "が" (STRONG "true") "のときは、" "ただ" (STRONG "count")
     "が指定されたときが重要になります。" "このような場合、右端から（左端ではなく）テストを満たす" (STRONG "count") "の要素だけが削除されます。"
     EOL2 (STRONG "count") "が与えられたとき、削除する要素数を制限できます。" "もしテストを満たす要素が" (STRONG "count")
     "を越えていたときは、" "それらの要素は左端か右端（" (STRONG "from-end") "の値による）から、" "ただ" (STRONG "count")
     "で指定された数だけ削除されます。" "もし" (STRONG "count") "負の値が指定されたときは、" (CODE1 "0")
     "が指定されたかのようにふるまいます。" "もし" (STRONG "count") "が" (CODE1 "nil") "のときは、" (STRONG "item")
     "にマッチした全てに影響します。" EOL2 "これらの全ての関数は、削除されなかった要素は、" "結果内に" (STRONG "sequence")
     "と同じ順序で現れます。" EOL2 (CODE1 "remove") "、" (CODE1 "remove-if") "、"
     (CODE1 "remove-if-not") "は、" (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start")
     ", " (STRONG "end") "に囲まれたサブシーケンスのテストを満たし" "削除されたもの以外は同じ要素を返却します。" "これは非破壊的な操作です。"
     "もし要素の削除が必要になった時は、コピーが返却されます。" (CODE1 "remove") "の返却値は、" (STRONG "sequence")
     "を共有するかもしれません。" "もし要素に削除が生じなかったときは、" "入力の" (STRONG "sequence")
     "と同一のものが返却される可能性があります。" EOL2 (CODE1 "delete") "、" (CODE1 "delete-if") "、"
     (CODE1 "delete-if-not") "は、" (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start")
     ", " (STRONG "end") "に囲まれたサブシーケンスのテストを満たし" "削除されたもの以外は同じ要素を返却します。"
     (STRONG "sequence") "は返却値の構築のために破壊されるかもしれません。" "しかし、返却値は" (STRONG "sequence")
     "と同一の場合もあれば、" "そうではない場合もあります。" EOL2 (CODE1 "delete") "は、" (STRONG "sequence")
     "がリストのときは、" (STRONG "sequence") "のトップレベルのリスト構造の" "どの" (CODE1 "car") ", "
     (CODE1 "cdr") "でも" (CODE1 "setf") "することが許されています。" "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のときは、" (CODE1 "delete") "は" (CODE1 "vector") "の次元を変更し、"
     "その要素を並べ替えをせず、新しい位置にスライドして" "返却値の" (CODE1 "vector") "を構築することが許されています。" EOL2
     "delete-ifは以下のように正確に動作するように制約されています。"
     (CODE3 "```lisp" "```" " (delete nil sequence"
      "             :test #'(lambda (ignore item) (funcall test item))"
      "             ...)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(remove 4 '(1 3 4 5 9)) =>  (1 3 5 9)"
      "(remove 4 '(1 2 4 1 3 4 5)) =>  (1 2 1 3 5)"
      "(remove 4 '(1 2 4 1 3 4 5) :count 1) =>  (1 2 1 3 4 5)"
      "(remove 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) =>  (1 2 4 1 3 5)"
      "(remove 3 '(1 2 4 1 3 4 5) :test #'>) =>  (4 3 4 5)"
      "(setq lst '(list of four elements)) =>  (LIST OF FOUR ELEMENTS)"
      "(setq lst2 (copy-seq lst)) =>  (LIST OF FOUR ELEMENTS)"
      "(setq lst3 (delete 'four lst)) =>  (LIST OF ELEMENTS)"
      "(equal lst lst2) =>  false" "(remove-if #'oddp '(1 2 4 1 3 4 5)) =>  (2 4 4)"
      "(remove-if #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t) " "=>  (1 2 4 1 3 5)"
      "(remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9) :count 2 :from-end t)"
      "=>  (1 2 3 4 5 6 8)" "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester) =>  (1 2 1 3 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester :count 1) =>  (1 2 1 3 4 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester :count 1 :from-end t) =>  (1 2 4 1 3 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 3 tester :test #'>) =>  (4 3 4 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete-if #'oddp tester) =>  (2 4 4)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete-if #'evenp tester :count 1 :from-end t) =>  (1 2 4 1 3 5)    "
      "(setq tester (list 1 2 3 4 5 6)) =>  (1 2 3 4 5 6) "
      "(delete-if #'evenp tester) =>  (1 3 5) " "tester =>  implementation-dependent"
      "(setq foo (list 'a 'b 'c)) =>  (A B C)" "(setq bar (cdr foo)) =>  (B C)"
      "(setq foo (delete 'b foo)) =>  (A C)" "bar =>  ((C)) or ..."
      "(eq (cdr foo) (car bar)) =>  T or ..."))
    (CHAPTER ("## 副作用") 2 (CODE1 "delete") "、" (CODE1 "delete-if") "、"
     (CODE1 "delete-if-not") "の場合、" (STRONG "sequence") "は返却値の構築のために破壊されるかもしれません。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "返却値は"
     (CODE1 "simple") "かもしれませんし、そうでないかもしれません。" "また、返却値は" (STRONG "sequence")
     "と同一かもしれませんし、" "そうでないかもしれません。" EOL2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "delete-if-not") "と" (CODE1 "remove-if-not") "は非推奨です。")))
(setf (gethash '("REMOVE-IF" . "FUNCTION") *table*) (gethash "REMOVE-IF" *table*))
(setf (gethash "REMOVE-IF-NOT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "REMOVE"))
    (CHAPTER ("## 構文") 2 (CODE1 "remove") " " (STRONG "item") " " (STRONG "sequence")
     " &key " (STRONG "from-end") " " (STRONG "test") " " (STRONG "test-not") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "remove-if") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "remove-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "delete") " " (STRONG "item") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "test") " "
     (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") " => " (STRONG "result-sequence") EOL1 (CODE1 "delete-if") " "
     (STRONG "predicate") " " (STRONG "sequence") " &key " (STRONG "from-end") " "
     (STRONG "start") " " (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence") EOL1 (CODE1 "delete-if-not") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") " => "
     (STRONG "result-sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "item") " - オブジェクト" EOL2 (STRONG "sequence")
     " - 正常なシーケンス" EOL1 (STRONG "predicate") " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子"
     EOL1 (STRONG "from-end") " - generalized-boolean、デフォルトは" (STRONG "false") EOL1
     (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "count")
     " - 整数か" (CODE1 "nil") "。デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "result-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "remove") "、" (CODE1 "remove-if") "、"
     (CODE1 "remove-if-not") "は、" (STRONG "sequence") "からテストを満たした要素を削除したものを返却します。" EOL2
     (CODE1 "delete") "、" (CODE1 "delete-if") "、" (CODE1 "delete-if-not") "は、" "それぞれ"
     (CODE1 "remove") "、" (CODE1 "remove-if") "、" (CODE1 "remove-if-not") "に"
     "似ていますが、これらは" (STRONG "sequence") "を修正します。" EOL2 "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のとき、返却値は" (CODE1 "vector") "であり、" (STRONG "sequence")
     "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence") "がリストなら、返却値はリストです。" EOL2
     (STRONG "from-end") "が" (STRONG "true") "のときは、" "ただ" (STRONG "count")
     "が指定されたときが重要になります。" "このような場合、右端から（左端ではなく）テストを満たす" (STRONG "count") "の要素だけが削除されます。"
     EOL2 (STRONG "count") "が与えられたとき、削除する要素数を制限できます。" "もしテストを満たす要素が" (STRONG "count")
     "を越えていたときは、" "それらの要素は左端か右端（" (STRONG "from-end") "の値による）から、" "ただ" (STRONG "count")
     "で指定された数だけ削除されます。" "もし" (STRONG "count") "負の値が指定されたときは、" (CODE1 "0")
     "が指定されたかのようにふるまいます。" "もし" (STRONG "count") "が" (CODE1 "nil") "のときは、" (STRONG "item")
     "にマッチした全てに影響します。" EOL2 "これらの全ての関数は、削除されなかった要素は、" "結果内に" (STRONG "sequence")
     "と同じ順序で現れます。" EOL2 (CODE1 "remove") "、" (CODE1 "remove-if") "、"
     (CODE1 "remove-if-not") "は、" (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start")
     ", " (STRONG "end") "に囲まれたサブシーケンスのテストを満たし" "削除されたもの以外は同じ要素を返却します。" "これは非破壊的な操作です。"
     "もし要素の削除が必要になった時は、コピーが返却されます。" (CODE1 "remove") "の返却値は、" (STRONG "sequence")
     "を共有するかもしれません。" "もし要素に削除が生じなかったときは、" "入力の" (STRONG "sequence")
     "と同一のものが返却される可能性があります。" EOL2 (CODE1 "delete") "、" (CODE1 "delete-if") "、"
     (CODE1 "delete-if-not") "は、" (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start")
     ", " (STRONG "end") "に囲まれたサブシーケンスのテストを満たし" "削除されたもの以外は同じ要素を返却します。"
     (STRONG "sequence") "は返却値の構築のために破壊されるかもしれません。" "しかし、返却値は" (STRONG "sequence")
     "と同一の場合もあれば、" "そうではない場合もあります。" EOL2 (CODE1 "delete") "は、" (STRONG "sequence")
     "がリストのときは、" (STRONG "sequence") "のトップレベルのリスト構造の" "どの" (CODE1 "car") ", "
     (CODE1 "cdr") "でも" (CODE1 "setf") "することが許されています。" "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のときは、" (CODE1 "delete") "は" (CODE1 "vector") "の次元を変更し、"
     "その要素を並べ替えをせず、新しい位置にスライドして" "返却値の" (CODE1 "vector") "を構築することが許されています。" EOL2
     "delete-ifは以下のように正確に動作するように制約されています。"
     (CODE3 "```lisp" "```" " (delete nil sequence"
      "             :test #'(lambda (ignore item) (funcall test item))"
      "             ...)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(remove 4 '(1 3 4 5 9)) =>  (1 3 5 9)"
      "(remove 4 '(1 2 4 1 3 4 5)) =>  (1 2 1 3 5)"
      "(remove 4 '(1 2 4 1 3 4 5) :count 1) =>  (1 2 1 3 4 5)"
      "(remove 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) =>  (1 2 4 1 3 5)"
      "(remove 3 '(1 2 4 1 3 4 5) :test #'>) =>  (4 3 4 5)"
      "(setq lst '(list of four elements)) =>  (LIST OF FOUR ELEMENTS)"
      "(setq lst2 (copy-seq lst)) =>  (LIST OF FOUR ELEMENTS)"
      "(setq lst3 (delete 'four lst)) =>  (LIST OF ELEMENTS)"
      "(equal lst lst2) =>  false" "(remove-if #'oddp '(1 2 4 1 3 4 5)) =>  (2 4 4)"
      "(remove-if #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t) " "=>  (1 2 4 1 3 5)"
      "(remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9) :count 2 :from-end t)"
      "=>  (1 2 3 4 5 6 8)" "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester) =>  (1 2 1 3 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester :count 1) =>  (1 2 1 3 4 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 4 tester :count 1 :from-end t) =>  (1 2 4 1 3 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete 3 tester :test #'>) =>  (4 3 4 5)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete-if #'oddp tester) =>  (2 4 4)"
      "(setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)"
      "(delete-if #'evenp tester :count 1 :from-end t) =>  (1 2 4 1 3 5)    "
      "(setq tester (list 1 2 3 4 5 6)) =>  (1 2 3 4 5 6) "
      "(delete-if #'evenp tester) =>  (1 3 5) " "tester =>  implementation-dependent"
      "(setq foo (list 'a 'b 'c)) =>  (A B C)" "(setq bar (cdr foo)) =>  (B C)"
      "(setq foo (delete 'b foo)) =>  (A C)" "bar =>  ((C)) or ..."
      "(eq (cdr foo) (car bar)) =>  T or ..."))
    (CHAPTER ("## 副作用") 2 (CODE1 "delete") "、" (CODE1 "delete-if") "、"
     (CODE1 "delete-if-not") "の場合、" (STRONG "sequence") "は返却値の構築のために破壊されるかもしれません。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "返却値は"
     (CODE1 "simple") "かもしれませんし、そうでないかもしれません。" "また、返却値は" (STRONG "sequence")
     "と同一かもしれませんし、" "そうでないかもしれません。" EOL2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "delete-if-not") "と" (CODE1 "remove-if-not") "は非推奨です。")))
(setf (gethash '("REMOVE-IF-NOT" . "FUNCTION") *table*) (gethash "REMOVE-IF-NOT" *table*))
(setf (gethash "REMOVE-METHOD" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "REMOVE-METHOD"))
    (CHAPTER ("## 構文") 2 (CODE1 "remove-method") " " (STRONG "generic-function") " "
     (STRONG "method") " => " (STRONG "generic-function"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "remove-method") " (" (STRONG "generic-function") " "
     (CODE1 "standard-generic-function") ") " (STRONG "method"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "generic-function") " - ジェネリック関数" EOL1
     (STRONG "method") " - メソッド")
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "remove-method") "は、"
     (STRONG "generic-function") "から" (STRONG "method") "を、" "必要なら"
     (STRONG "generic-function") "を修正して削除します。" EOL2 "もし" (STRONG "method") "が"
     (STRONG "generic-function") "のメソッドではないとき、" (CODE1 "remove-method")
     "はエラーを発生させてはいけません。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "find-method")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("REMOVE-METHOD" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "REMOVE-METHOD" *table*))
(setf (gethash "REMPROP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "REMPROP"))
    (CHAPTER ("## 構文") 2 (CODE1 "remprop") " " (STRONG "symbol") " " (STRONG "indicator")
     " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - シンボル" EOL1 (STRONG "indicator")
     " - オブジェクト" EOL1 (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "remprop") "は、" (STRONG "symbol") "のプロパティリストから"
     (STRONG "indicator") "と同一の標識のプロパティを削除します。" "標識に対してキーが同一のプロパティが複数あるときは、"
     (CODE1 "remprop") "は最初のプロパティを削除します。" "標識に対するプロパティが存在しないときは" (STRONG "false") "を、"
     "プロパティが見つかった時は" (STRONG "true") "を返却します。" EOL2 "プロパティのindicatorと対応する値は、"
     "プロパティリストを順不同で破壊的につなぎ合わせることにより削除します。" "許容される副作用は、" (CODE1 "remf") "のものに対応します。"
     "つまり、下記のようになります。"
     (CODE3 "```lisp" "```" "(remprop x y) ==  (remf (symbol-plist x) y)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq test (make-symbol \"PSEUDO-PI\")) =>  #:PSEUDO-PI"
      "(symbol-plist test) =>  ()" "(setf (get test 'constant) t) =>  T"
      "(setf (get test 'approximation) 3.14) =>  3.14"
      "(setf (get test 'error-range) 'noticeable) =>  NOTICEABLE" "(symbol-plist test) "
      "=>  (ERROR-RANGE NOTICEABLE APPROXIMATION 3.14 CONSTANT T)"
      "(setf (get test 'approximation) nil) =>  NIL" "(symbol-plist test) "
      "=>  (ERROR-RANGE NOTICEABLE APPROXIMATION NIL CONSTANT T)"
      "(get test 'approximation) =>  NIL" "(remprop test 'approximation) =>  true"
      "(get test 'approximation) =>  NIL" "(symbol-plist test)"
      "=>  (ERROR-RANGE NOTICEABLE CONSTANT T)" "(remprop test 'approximation) =>  NIL"
      "(symbol-plist test)" "=>  (ERROR-RANGE NOTICEABLE CONSTANT T)"
      "(remprop test 'error-range) =>  true" "(setf (get test 'approximation) 3) =>  3"
      "(symbol-plist test)" "=>  (APPROXIMATION 3 CONSTANT T)"))
    (CHAPTER ("## 副作用") 2 "シンボルのプロパティリストは修正されます。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "symbol") "がシンボルではないとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "remf") "," (CODE1 "symbol-plist"))
    (CHAPTER ("## 備考") 2 (CODE1 "remprop") "は" (STRONG "indicator") "のテストに" (CODE1 "eql")
     "ではなく" (CODE1 "eq") "を用いるため、" "移植しやすいコードとして、" (STRONG "indicator")
     "に数と文字を使うことは推奨されません。" "そのため、そのような" (STRONG "indicator") "を使ったときの効果は" "実装依存です。"
     "もちろん、そのようなプロパティを削除する必要がある場合は、" "仕方がないことです。" "プロパティに対して" (CODE1 "get") "の"
     (CODE1 "setf") "を使うことを" "考えてみて下さい。")))
(setf (gethash '("REMPROP" . "FUNCTION") *table*) (gethash "REMPROP" *table*))
(setf (gethash "RENAME-FILE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "RENAME-FILE"))
    (CHAPTER ("## 構文") 2 (CODE1 "rename-file") " " (STRONG "filespec") " "
     (STRONG "new-name") " => " (STRONG "defaulted-new-name") ", "
     (STRONG "old-truename") ", " (STRONG "new-truename"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "filespec") " - パス名指定子" EOL1 (STRONG "new-name")
     " - ストリームではないパス名指定子" EOL1 (STRONG "defaulted-new-name") " - パス名" EOL1
     (STRONG "old-truename") " - 物理パス名" EOL1 (STRONG "new-truename") " - 物理パス名")
    (CHAPTER ("## 定義") 2 (CODE1 "rename-file") "は、" (STRONG "filespec") "で指定されるファイルを"
     (STRONG "defaulted-new-name") "という名前に変更するように、" "ファイルシステムへの修正を行います。" EOL2
     "ファイル名にワイルドカードが含まれているか、" "ファイルシステムが要素に" (CODE1 "nil") "を許可していないものに対して"
     (STRONG "filespec") "に" (CODE1 "nil") "が含まれているか、" "あるいはファイルシステムが要素に" (CODE1 "nil")
     "を許可していないものに対して" (STRONG "filespec") "から" (STRONG "new-name") "へ欠落した要素の"
     "デフォルト値を埋め合わせた結果" (CODE1 "nil") "が含まれているようなとき、" "エラーになります。" EOL2 "もし"
     (STRONG "new-name") "が論理パス名のとき、" (CODE1 "rename-file") "は第一返却値は論理パス名として返却されます。" EOL2
     (CODE1 "rename-file") "は成功したときは3つの値を返却します。" "第一返却値" (STRONG "defaulted-new-name")
     "は、" (STRONG "new-name") "を構築し欠落した要素を" (CODE1 "merge-pathnames") "処理の実行により"
     (STRONG "filespec") "を用いて" "デフォルト値として補完した結果の名前を返却します。" "第二返却値"
     (STRONG "old-truename") "は、" "名前の変更を行う前のファイルの実際の名前を返却します。" "第三返却値"
     (STRONG "new-truename") "は、" "名前の変更を行ったあとのファイルの実際の名前を返却します。" EOL2 "もし"
     (STRONG "filespec") "の指定子が開いたストリームのとき、" "そのストリーム自身と関連付けられたファイルに"
     "影響を及ぼします（もしファイルシステムが許容するならば）。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; この例は論理パス名を使用します。"
      "(with-open-file (stream \"sys:chemistry;lead.text\""
      "                        :direction :output :if-exists :error)"
      "  (princ \"eureka\" stream)" "  (values (pathname stream) (truename stream)))"
      "=>  #P\"SYS:CHEMISTRY;LEAD.TEXT.NEWEST\", #P\"Q:>sys>chem>lead.text.1\""
      "(rename-file \"sys:chemistry;lead.text\" \"gold.text\")"
      "=>  #P\"SYS:CHEMISTRY;GOLD.TEXT.NEWEST\"," "  #P\"Q:>sys>chem>lead.text.1\","
      "  #P\"Q:>sys>chem>gold.text.1\""))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし名前の変更処理が成功しなかったときは、" "型" (CODE1 "file-error") "のエラーが発生します。"
     EOL2 "もし" (STRONG "filespec") "がワイルドカードを含んでいたときは、" "型" (CODE1 "file-error")
     "のエラーが発生するかもしれません。")
    (CHAPTER ("## 参考") 2 (CODE1 "truename") "," (CODE1 "pathname") ","
     (CODE1 "logical-pathname") "," "20.1. ファイルシステムの説明," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("RENAME-FILE" . "FUNCTION") *table*) (gethash "RENAME-FILE" *table*))
(setf (gethash "RENAME-PACKAGE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "RENAME-PACKAGE"))
    (CHAPTER ("## 構文") 2 (CODE1 "rename-package") " " (STRONG "package") " "
     (STRONG "new-name") " " (CODE1 "&optional") " " (STRONG "new-nicknames") " => "
     (STRONG "package-object"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "package") " - パッケージ指定子" EOL1 (STRONG "new-name")
     " - パッケージ指定子" EOL1 (STRONG "new-nicknames") " - 文字列指定子のリスト。デフォルトは空のリスト。" EOL1
     (STRONG "package-object") " - 名前が変更されたパッケージオブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "package") "の名前とニックネームを置き換えます。" (STRONG "package")
     "の古い名前と全ての古いニックネームは消滅し、" (STRONG "new-name") "と" (STRONG "new-nicknames")
     "によって置き換わります。" EOL2 (STRONG "new-name") "か" (STRONG "new-nicknames") "のどれかが、"
     "存在するパッケージのどれかの名前と衝突していたときの結果は未定義です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(make-package 'temporary :nicknames '(\"TEMP\")) =>  #<PACKAGE \"TEMPORARY\">"
      "(rename-package 'temp 'ephemeral) =>  #<PACKAGE \"EPHEMERAL\">"
      "(package-nicknames (find-package 'ephemeral)) =>  ()"
      "(find-package 'temporary) =>  NIL"
      "(rename-package 'ephemeral 'temporary '(temp fleeting))"
      "=>  #<PACKAGE \"TEMPORARY\">"
      "(package-nicknames (find-package 'temp)) =>  (\"TEMP\" \"FLEETING\")"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-package")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("RENAME-PACKAGE" . "FUNCTION") *table*) (gethash "RENAME-PACKAGE" *table*))
(setf (gethash "REPLACE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "REPLACE"))
    (CHAPTER ("## 構文") 2 (CODE1 "replace") " " (STRONG "sequence-1") " "
     (STRONG "sequence-2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "sequence-1"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "sequence-1") " - シーケンス" EOL1 (STRONG "sequence-2")
     " - シーケンス" EOL1 (STRONG "start1") ", " (STRONG "end1") " - " (STRONG "sequence-1")
     "の境界インデックス指定子。" "デフォルトは" (STRONG "start1") ", " (STRONG "end1") "それぞれ" (CODE1 "0")
     "と" (CODE1 "nil") "。" EOL1 (STRONG "start2") ", " (STRONG "end2") " - "
     (STRONG "sequence-2") "の境界インデックス指定子。" "デフォルトは" (STRONG "start2") ", "
     (STRONG "end2") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。")
    (CHAPTER ("## 定義") 2 (STRONG "sequence-1") "の" (STRONG "start1") "と" (STRONG "end1")
     "に囲まれた要素が" (STRONG "sequence-2") "の" (STRONG "start2") "と" (STRONG "end2")
     "に囲まれた要素によって" "置換されることによって、" (STRONG "sequence-1") "が破壊的に修正されます。" EOL2
     (STRONG "sequence-1") "は、" (STRONG "sequence-2") "から連続した要素をコピーすることによって"
     "破壊的に修正されます。" (STRONG "sequence-2") "の" (STRONG "start2") "と" (STRONG "end2")
     "に囲まれたサブシーケンスの各要素は、" (STRONG "sequence-1") "の" (STRONG "start1") "と" (STRONG "end1")
     "に囲まれたサブシーケンスにコピーされます。" "もしこれらのサブシーケンスの長さが等しくないときは、" "コピーされる要素数はもっとも短い方で決定されます。"
     "長いサブシーケンスの終わり付近の余分な要素は、" "操作には影響されません。" "コピーされる要素数は、次のようにあらわされます。"
     (CODE3 "```lisp" "```" "(min (- end1 start1) (- end2 start2))") EOL2
     (STRONG "sequence-1") "と" (STRONG "sequence-2") "が同じオブジェクトであり、"
     "変更する領域がコピーされる領域と重複しているときは、" "コピー元の領域全体を別の場所にコピーし、" "コピー元の領域だけをコピー元に戻したように行われます。"
     "しかし、" (STRONG "sequence-1") "と" (STRONG "sequence-2") "が同じではなく、"
     "しかし変更される領域とコピーされる領域が重複している場合" "（おそらくリスト構造が共有されているか、displaced-arrayのとき）、" "置換操作後の"
     (STRONG "sequence-1") "のサブシーケンスは" "予想できない内容になっているでしょう。" "もし" (STRONG "sequence-2")
     "の要素が、" (STRONG "sequence-1") "に格納できる型ではないときは" "エラーが発生します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(replace \"abcdefghij\" \"0123456789\" :start1 4 :end1 7 :start2 4) "
      "=>  \"abcd456hij\"" "(setq lst \"012345678\") =>  \"012345678\""
      "(replace lst lst :start1 2 :start2 0) =>  \"010123456\"" "lst =>  \"010123456\""))
    (CHAPTER ("## 副作用") 2 (STRONG "sequence-1") "は修正されます。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "fill"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("REPLACE" . "FUNCTION") *table*) (gethash "REPLACE" *table*))
(setf (gethash "REST" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "REST"))
    (CHAPTER ("## 構文") 2 (CODE1 "rest") " " (STRONG "list") " => " (STRONG "tail") EOL1
     "(" (CODE1 "setf") " (" (CODE1 "rest") " " (STRONG "list") ") " (STRONG "new-tail")
     ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト。ドットリストと循環リストを受け付けます。" EOL1
     (STRONG "tail") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "rest") "は" (CODE1 "cdr") "としての操作と同じ動作をします。" "覚えやすいように"
     (CODE1 "first") "を補完しています。" "具体的には下記のとおりです。"
     (CODE3 "```lisp" "```" "(rest list) ==  (cdr list)"
      "(setf (rest list) new-tail) ==  (setf (cdr list) new-tail)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(rest '(1 2)) =>  (2)" "(rest '(1 . 2)) =>  2"
      "(rest '(1)) =>  NIL" "(setq *cons* '(1 . 2)) =>  (1 . 2)"
      "(setf (rest *cons*) \"two\") =>  \"two\"" "*cons* =>  (1 . \"two\")"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "cdr") "," (CODE1 "nthcdr"))
    (CHAPTER ("## 備考") 2 (CODE1 "rest") "は、様式上として" (CODE1 "cdr") "よりも好まれる場合があり、"
     "それは引数が主観的にコンスというよりもならリストとして見られるときです。")))
(setf (gethash '("REST" . "ACCESSOR") *table*) (gethash "REST" *table*))
(setf (gethash "RESTART" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "RESTART"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "restart") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "restart") "のオブジェクトは" "いくつかの回復アクションのフォームを"
     "実行するために呼ばれる関数を表現しており、" "通常は実行しているプログラムの外側のポイントに" "制御を遷移させることで行います。" EOL2 "実装は"
     (CODE1 "restart") "の実装をもっともやりやすい方法で自由に実装できます。" (CODE1 "restart")
     "はそれが確立して束縛されるフォームのスコープと関係している" "動的エクステントだけを持ちます。")))
(setf (gethash '("RESTART" . "SYSTEM-CLASS") *table*) (gethash "RESTART" *table*))
(setf (gethash "RESTART-BIND" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "RESTART-BIND"))
    (CHAPTER ("## 構文") 2 (CODE1 "restart-bind") " (" (CODE1 "{") "(" (STRONG "name") " "
     (STRONG "function") " " (CODE1 "{") (STRONG "key-val-pair") (CODE1 "}") "\\*)"
     (CODE1 "}") ") " (STRONG "form\\*") EOL1 "=> " (STRONG "result\\*")
     (CODE3 "```" "```" "key-val-pair::= :interactive-function interactive-function |  "
      "                :report-function report-function |  "
      "                :test-function test-function "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - シンボル。評価されません。" EOL1 (STRONG "function")
     " - フォーム。評価されます。" EOL1 (STRONG "form") " - 暗黙のprogn" EOL1
     (STRONG "interactive-function") " - フォーム。評価されます。" EOL1 (STRONG "report-function")
     " - フォーム。評価されます。" EOL1 (STRONG "test-function") " - フォーム。評価されます。" EOL1
     (STRONG "result") " - " (STRONG "form") "による返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "restart-bind") "は、" "与えられた" (STRONG "name") "の"
     (CODE1 "restart") "の効果がある" "動的環境下で" (STRONG "form") "を実行します。" EOL2 "もし"
     (STRONG "name") "が" (CODE1 "nil") "なら、" "それは匿名の" (CODE1 "restart") "を意味しており、"
     (STRONG "name") "が" (CODE1 "nil") "でないシンボルのときは、" "名前付き" (CODE1 "restart")
     "を意味しています。" EOL2 (STRONG "function") ", " (STRONG "interactive-function") ", "
     (STRONG "report-function") "は、" "現在のレキシカルな環境と" "ボディ部を評価する前の動的環境下で" "無条件に評価されます。"
     "これらの各フォームは、関数に評価しなければなりません。" EOL2 "もし" (CODE1 "invoke-restart") "がその"
     (CODE1 "restart") "を実行したとき、" (STRONG "function") "を評価された結果の関数を、"
     (CODE1 "invoke-restart") "の動的環境下で" (CODE1 "invoke-restart") "に与えた引数ともに呼び出します。"
     "その関数は、非局所的な遷移の制御が行われるか、" "あるいは通常の返却をするかのどちらかになります。" EOL2 "もし" (CODE1 "restart")
     "がデバッガーから" "（" (CODE1 "invoke-restart-interactively") "を使って）" "対話的に起動されたとき、"
     "その引数は、" (STRONG "interactive-function") "を評価した結果の引数を" "呼び出すことによって指定します。"
     (CODE1 "restart") "が起動されたとき、その関数はオプションで" "対話的に" (CODE1 "query-io")
     "からプロンプトで問い合わせを行い、" (CODE1 "invoke-restart-interactively") "によって使われる"
     "引数のリストを返却しなければなりません。" EOL2 "もし" (CODE1 "restart") "が対話的に実行されたものの、"
     (STRONG "interactive-function") "がなかったときは、" "引数のリストは" (CODE1 "nil") "が使用されます。"
     "このよう場合、関数は空の引数リストと互換がなければなりません。" EOL2 "もし" (CODE1 "restart")
     "の表示が対話中に行われたとき（例えばデバッガーによって）、" "その表示は" (STRONG "report-function") "が評価された結果の関数を"
     "呼び出すことによって行われます。" "その関数はひとつの引数にストリームを取る関数でなければなりません。" "それはストリームを受け取った"
     (CODE1 "restart") "が行うことの" "説明の印刷を期待しています。" "この関数は、" (CODE1 "*print-escape*") "が"
     (CODE1 "nil") "で" (CODE1 "restart") "が印刷されるときはいつでも呼ばれます。" EOL2
     "対話式の介入があるときは、 その結果は下記で説明するような" (CODE1 ":interactive-function") "の値に依存します。" EOL2
     "- " (CODE1 ":interactive-function") "  - 値は現在のレキシカルな環境で評価され、"
     "    引数なしの関数を返却しなければなりません。" "    その関数は、この" (CODE1 "restart") "が実行されたとき、" "    "
     (CODE1 "invoke-restart-interactively") "によって使われる" "    引数のリストの構築を行います。"
     "    <br><br>" EOL2 "- " (CODE1 ":report-function") "  - 値は現在のレキシカルな環境で評価され、"
     "    ひとつの引数にストリームを受け取る関数を返却しなければなりません。" "    その関数は、ストリームにこの" (CODE1 "restart")
     "が取る行動の" "    要約を印刷します。" "    <br><br>" EOL2 "- " (CODE1 ":test-function")
     "  - 値は現在のレキシカルな環境で評価され、" "    ひとつの引数にコンディションを受け取る関数を返却しなければなりません。" "    その関数は、もしこの"
     (CODE1 "restart") "が見えていると" "    考えられるときは" (STRONG "true") "を返却します。" "    <br><br>")
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 (CODE1 "*query-io*"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "restart-case") "," (CODE1 "with-simple-restart"))
    (CHAPTER ("## 備考") 2 (CODE1 "restart-bind") "は、" "主に" (CODE1 "restart-case")
     "を実装するときに" "使用されることを意図しており、" "他のマクロを実装するときにも有用である可能性があります。" (CODE1 "restart-case")
     "と" (CODE1 "restart-bind") "のどちらを使うか" "迷っているプログラマーは、" (CODE1 "restart-case")
     "がこのような場合には十分に強力で好まれますし、" "完全な一般性が本当に必要な場合のみ" (CODE1 "restart-bind")
     "を使うことをお勧めします。")))
(setf (gethash '("RESTART-BIND" . "MACRO") *table*) (gethash "RESTART-BIND" *table*))
(setf (gethash "RESTART-CASE" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "RESTART-CASE"))
    (CHAPTER ("## 構文") 2 (CODE1 "restart-case") " " (STRONG "restartable-form") " "
     (CODE1 "{") (STRONG "clause") (CODE1 "}") " " "=> " (STRONG "result\\*")
     (CODE3 "```" "```" "clause::= (case-name lambda-list  "
      "           [[:interactive interactive-expression | :report report-expression | :test test-expression]]  "
      "           declaration* form*) "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "restartable-form") " - フォーム" EOL1
     (STRONG "case-name") " - シンボルか、" (CODE1 "nil") EOL1 (STRONG "lambda-list")
     " - 通常のラムダリスト" EOL1 (STRONG "interactive-expression") " - シンボルか、ラムダ式" EOL1
     (STRONG "report-expression") " - 文字列か、シンボルか、ラムダ式" EOL1 (STRONG "test-expression")
     " - シンボルか、ラムダ式" EOL1 (STRONG "declaration") " - 宣言式。評価されません。" EOL1 (STRONG "form")
     " - フォーム" EOL1 (STRONG "result") " - " (STRONG "restartable-form") "の評価の返却値か、"
     "選択された" (STRONG "clause") "内の最後の" (STRONG "form") "の返却値か、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (CODE1 "restart-case") "は、" (STRONG "clause")
     "制御の遷移先として特別な意味を持つ動的環境下で" (STRONG "restartable-form") "を評価します。" "もし"
     (STRONG "restartable-form") "の実行が終わり何らかの値を返却したときは、" "そのすべての値は"
     (CODE1 "restart-case") "の返却値となり処理が完了します" (STRONG "restartable-form") "が実行中に、"
     "どんなコードでも" (STRONG "clause") "のどれかに" "制御を遷移するかもしれません（" (CODE1 "invoke-restart")
     "を参照）。" "もし遷移が起こったとき、その" (STRONG "clause") "本体内の" (STRONG "form") "は評価され、" "そして最後の"
     (STRONG "form") "の返却値が" (CODE1 "restart-case") "によって返却されます。" "この場合、動的状態は"
     (STRONG "clause") "を実行する前に適切に巻き戻されます" "（つまり" (STRONG "restartable-form") "の周りで確立された"
     (CODE1 "restart") "は" "もはや有効ではありません）。" EOL2 "もし" (STRONG "form") "が存在しない"
     (STRONG "clause") "が選択された場合、" (CODE1 "restart-case") "は" (CODE1 "nil") "が返却されます。"
     EOL2 "もし" (STRONG "case-name") "がシンボルなら、それは" (CODE1 "restart") "の名前です。" EOL2 "同じ名前の"
     (STRONG "case-name") "を使った" (STRONG "clause") "は複数存在できます。" "このような場合、その名前の最初の"
     (STRONG "clause") "が" (CODE1 "find-restart") "によって発見されます。" "他の" (STRONG "clause")
     "は" (CODE1 "compute-restarts") "を使うことでアクセスできます。" EOL2 "各" (STRONG "arglist")
     "は通常のラムダリスト、" "対応する" (STRONG "form") "を実行中に束縛されます。" "これらのパラメーターは"
     (CODE1 "restart-case") "の" (STRONG "clause") "が" (CODE1 "invoke-restart")
     "呼び出しから必要なデータを受け取って使われます。" EOL2 "標準では、" (CODE1 "invoke-restart-interactively")
     "は引数を受け取らず、" "全ての引数は" (CODE1 "restart") "から対話式で集めるための" "オプションでなければなりません。" "しかし、もし"
     (CODE1 "invoke-restart-interactively") "へ" "どのように正しい引数リストを計算するのかについて" "知らせるときに使われる"
     (CODE1 ":interactive") "キーワードを持っている場合は、" "その引数はオプションである必要はありません。" EOL2
     "キーワードオプションは次のような意味を持ちます。" EOL2 "- " (CODE1 ":interactive") "  - "
     (CODE1 ":interactive") "によって指定された値は、" "    適切な引数を取る関数でなければなりません。" "    "
     (CODE1 "(function value)") "が現在のレキシカルな環境上で評価されます。" "    これは引数なしの関数を返却しなければならず、"
     "    その関数が起動されると" (CODE1 "invoke-restart-interactively") "によって" "    使われる引数を返却します。"
     "    " (CODE1 "invoke-restart-interactively") "は、" "    " (CODE1 "restart")
     "が試行される前にその利用可能な動的環境下で呼び出され、" "    " (CODE1 "query-io") "がユーザーとの対話で使用されます。"
     "    <br><br>" "    もし" (CODE1 "restart") "が対話式に呼ばれたものの" "    "
     (CODE1 ":interactive") "オプションが指定されていなかったときは、" "    その引数リストは空リストのものが呼び出しに使われます。"
     "    <br><br>" EOL2 "- " (CODE1 ":report") "  - もし" (CODE1 ":report")
     "による値がラムダ式かシンボルのとき、" "    それは" (CODE1 "function") "で受け付けられるものでなければなりません。" "    "
     (CODE1 "(function value)") "が現在のレキシカルな環境上で評価されます。"
     "    これは引数をストリームひとつ取る関数を返却しなければならず、" "    その関数は" (CODE1 "restart")
     "の定義をストリームへ印刷するものです。" "    この関数は" (CODE1 "restart") "が印刷されるとき" "    "
     (CODE1 "*print-escape*") "が" (CODE1 "nil") "であれば" "    いつでも呼び出されます。" "    <br><br>"
     "    もし値が文字列のとき、これは次の省略形です。" EOL1 "    "
     (CODE1 "(lambda (stream) (write-string value stream))") EOL1 "    もし名前付きの"
     (CODE1 "restart") "が報告を尋ねられたものの" "    引数に" (CODE1 ":report") "が指定されていなかったときは、"
     "    その" (CODE1 "restart") "の名前がデフォルトの報告のテキストを" "    生成するときに使用されます。" "    <br><br>"
     "    " (CODE1 "*print-escape*") "が" (CODE1 "nil") "のとき、" "    プリンターは"
     (CODE1 "restart") "の報告情報を使います。" "    例えば、デバッガーは" (CODE1 "continue") "コマンドが"
     "    入力されたときのアクションを次のように説明するかもしれません。" EOL1 "    "
     (CODE1 "(format t \"~&~S -- ~A~%\" ':continue some-restart)") EOL1
     "    これは次のように表示されるでしょう。" EOL1 "    " (CODE1 ":CONTINUE -- Return to command level")
     EOL1 "    指定された名前なしの" (CODE1 "restart") "に" "    " (CODE1 ":report")
     "オプションが提供されていなかったときの" "    結果は未定義です。" "    <br><br>" EOL2 "- " (CODE1 ":test")
     "  - " (CODE1 ":test") "によって指定された値は、" "    適切な引数を取る関数でなければなりません。" "    "
     (CODE1 "(function value)") "が現在のレキシカルな環境上で評価されます。"
     "    これは引数をコンディションひとつ取る関数を返却しなければならず、" "    その関数はもしその" (CODE1 "restart")
     "が見えていると考えられるなら" "    " (STRONG "true") "を返却するようなものです。" "    <br><br>"
     "    このオプションのデフォルトは" "    " (CODE1 "(lambda (c) (declare (ignore c)) t)") "と同等です。"
     "    <br><br>" EOL2 "もし" (STRONG "restartable-form") "がリストであり、" (CODE1 "car") "部が"
     (CODE1 "signal") ", " (CODE1 "error") ", " (CODE1 "cerror") "," " " (CODE1 "warn")
     "のシンボルののどれか出るとき" "（またはマクロフォームで展開したらこのようなリストになるとき）、"
     (CODE1 "with-condition-restarts") "が暗黙的に使用され、" "指定した" (CODE1 "restart")
     "と通知されるコンディションが関連付けられます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(restart-case" "    (handler-bind ((error #'(lambda (c)"
      "                            (declare (ignore condition))"
      "                            (invoke-restart 'my-restart 7))))"
      "      (error \"Foo.\"))" "  (my-restart (&optional v) v))" "=>  7" NIL
      "(define-condition food-error (error) ())" "=>  FOOD-ERROR"
      "(define-condition bad-tasting-sundae (food-error) "
      "  ((ice-cream :initarg :ice-cream :reader bad-tasting-sundae-ice-cream)"
      "   (sauce :initarg :sauce :reader bad-tasting-sundae-sauce)"
      "   (topping :initarg :topping :reader bad-tasting-sundae-topping))"
      "  (:report (lambda (condition stream)"
      "             (format stream \"Bad tasting sundae with ~S, ~S, and ~S\""
      "                     (bad-tasting-sundae-ice-cream condition)"
      "                     (bad-tasting-sundae-sauce condition)"
      "                     (bad-tasting-sundae-topping condition)))))"
      "=>  BAD-TASTING-SUNDAE"
      "(defun all-start-with-same-letter (symbol1 symbol2 symbol3)"
      "  (let ((first-letter (char (symbol-name symbol1) 0)))"
      "    (and (eql first-letter (char (symbol-name symbol2) 0))"
      "         (eql first-letter (char (symbol-name symbol3) 0)))))"
      "=>  ALL-START-WITH-SAME-LETTER" "(defun read-new-value ()"
      "  (format t \"Enter a new value: \")" "  (multiple-value-list (eval (read))))"
      "=>  READ-NEW-VALUE"
      "(defun verify-or-fix-perfect-sundae (ice-cream sauce topping)" "  (do ()"
      "     ((all-start-with-same-letter ice-cream sauce topping))" "    (restart-case"
      "      (error 'bad-tasting-sundae" "             :ice-cream ice-cream"
      "             :sauce sauce" "             :topping topping)"
      "      (use-new-ice-cream (new-ice-cream)"
      "        :report \"Use a new ice cream.\"" "        :interactive read-new-value  "
      "        (setq ice-cream new-ice-cream))" "      (use-new-sauce (new-sauce)"
      "        :report \"Use a new sauce.\"" "        :interactive read-new-value"
      "        (setq sauce new-sauce))" "      (use-new-topping (new-topping)"
      "        :report \"Use a new topping.\"" "        :interactive read-new-value"
      "        (setq topping new-topping))))" "  (values ice-cream sauce topping))"
      "=>  VERIFY-OR-FIX-PERFECT-SUNDAE"
      "(verify-or-fix-perfect-sundae 'vanilla 'caramel 'cherry)"
      ">>  Error: Bad tasting sundae with VANILLA, CARAMEL, and CHERRY."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Use a new ice cream." ">>   2: Use a new sauce."
      ">>   3: Use a new topping." ">>   4: Return to Lisp Toplevel."
      ">>  Debug> :continue 1" ">>  Use a new ice cream."
      ">>  Enter a new ice cream: 'chocolate" "=>  CHOCOLATE, CARAMEL, CHERRY"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "restart-bind") "," (CODE1 "with-simple-restart") ",")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(restart-case expression"
      "   (name1 arglist1 ...options1... . body1)"
      "   (name2 arglist2 ...options2... . body2))")
     EOL2 "上記のフォームは下記のものと同等です。"
     (CODE3 "```lisp" "```" "(block #1=#:g0001" "  (let ((#2=#:g0002 nil))"
      "       (tagbody" "       (restart-bind ((name1 #'(lambda (&rest temp)"
      "                               (setq #2# temp)"
      "                               (go #3=#:g0003))"
      "                         ...slightly-transformed-options1...)"
      "                      (name2 #'(lambda (&rest temp)"
      "                               (setq #2# temp)"
      "                               (go #4=#:g0004))"
      "                         ...slightly-transformed-options2...))"
      "       (return-from #1# expression))" "         #3# (return-from #1#"
      "                 (apply #'(lambda arglist1 . body1) #2#))"
      "         #4# (return-from #1#"
      "                 (apply #'(lambda arglist2 . body2) #2#)))))")
     EOL2 "名前なしの" (CODE1 "restart") "は一般的に対話式でのみ使用され、" (CODE1 ":interactive")
     "オプションは定義を持たず小さな値です。" "実装は名前なしの" (CODE1 "restart") "が" (CODE1 ":report") "情報なしで"
     "コンパイル時に提供されていたときは、警告を出すことが推奨されます。" "実行時では、このエラーはデバッガーに入ったときに通知されるかもしれません。"
     "エラーを通知すると、" "デバッガーに再帰的に入場される可能性があるため" "（さらに別の再帰的なエラーを引き起こすなど）、"
     "デバッガーはエラーが起こっても実際にはエラーを通知せず、" "その問題の何らかの指示を印刷するようにお勧めします。"
     (CODE3 "```lisp" "```" "(restart-case (signal fred)" "  (a ...)" "  (b ...))" "== "
      "(restart-case" "    (with-condition-restarts fred "
      "                             (list (find-restart 'a) "
      "                                   (find-restart 'b))" "      (signal fred))"
      "  (a ...)" "  (b ...))"))))
(setf (gethash '("RESTART-CASE" . "MACRO") *table*) (gethash "RESTART-CASE" *table*))
(setf (gethash "RESTART-NAME" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "RESTART-NAME"))
    (CHAPTER ("## 構文") 2 (CODE1 "restart-name") " " (STRONG "restart") " => "
     (STRONG "name"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "restart") " - " (CODE1 "restart") EOL1
     (STRONG "name") " - シンボル")
    (CHAPTER ("## 定義") 2 (STRONG "restart") "の名前を返却しますが、" "もし" (STRONG "restart")
     "が名前を持っていなかったときは、" (CODE1 "nil") "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(restart-case "
      "    (loop for restart in (compute-restarts)"
      "              collect (restart-name restart))"
      "  (case1 () :report \"Return 1.\" 1)" "  (nil   () :report \"Return 2.\" 2)"
      "  (case3 () :report \"Return 3.\" 3)" "  (case1 () :report \"Return 4.\" 4))"
      "=>  (CASE1 NIL CASE3 CASE1 ABORT)" ";; 上記の例はABORTという名前のrestartを明に作成していませんが"
      ";; しかし暗黙的にシステムによって提供されます。"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "compute-restarts") "," (CODE1 "find-restart"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("RESTART-NAME" . "FUNCTION") *table*) (gethash "RESTART-NAME" *table*))
(setf (gethash "RETURN" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "RETURN"))
    (CHAPTER ("## 構文") 2 (CODE1 "return") " [" (STRONG "result") "] =>" (CODE1 "|"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "result") " - フォーム、評価されます。デフォルトは" (CODE1 "nil")
     "です。")
    (CHAPTER ("## 定義") 2 (CODE1 "return-from") "によって、" (CODE1 "nil") "という名前の"
     (CODE1 "block") "から返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(block nil (return) 1) =>  NIL"
      "(block nil (return 1) 2) =>  1" "(block nil (return (values 1 2)) 3) =>  1, 2"
      "(block nil (block alpha (return 1) 2)) =>  1"
      "(block alpha (block nil (return 1)) 2) =>  2"
      "(block nil (block nil (return 1) 2)) =>  1"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## コンディション") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "block") "," (CODE1 "return-from") "," "3.1. 評価")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(return) == (return-from nil)"
      "(return form) == (return-from nil form)")
     EOL2 "暗黙の" (CODE1 "block") "として確立される" (CODE1 "do") "のようなマクロは、" "よく名前に" (CODE1 "nil")
     "が使われるため、" (CODE1 "return") "はそのようなフォームから" "退出するときに使われます。")))
(setf (gethash '("RETURN" . "MACRO") *table*) (gethash "RETURN" *table*))
(setf (gethash "RETURN-FROM" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "RETURN-FROM"))
    (CHAPTER ("## 構文") 2 (CODE1 "return-from") " " (STRONG "name") " [" (STRONG "result")
     "] =>" (CODE1 "|"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - " (CODE1 "block") "タグ、評価はされません。" EOL1
     (STRONG "result") " - フォーム、評価されます。デフォルトは" (CODE1 "nil") "です。")
    (CHAPTER ("## 定義") 2 "レキシカルに囲まれた" (CODE1 "block") "から制御と多値を返却します。" EOL2
     (STRONG "name") "という名前の" (CODE1 "block") "フォームは、" (CODE1 "return-from")
     "の出現場所をレキシカルに囲む必要があります。" (STRONG "result") "の評価によって得られたどんな多値でも、" (CODE1 "block")
     "によってレキシカルに囲まれたもっとも内側のものから" "直ちに返却されます。" EOL2 (CODE1 "return-from")
     "によって開始される制御の遷移の実行についての説明は、" "5.2. 終了地点への制御の遷移をご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(block alpha (return-from alpha) 1) =>  NIL"
      "(block alpha (return-from alpha 1) 2) =>  1"
      "(block alpha (return-from alpha (values 1 2)) 3) =>  1, 2" "(let ((a 0))"
      "   (dotimes (i 10) (incf a) (when (oddp i) (return)))" "   a) =>  2"
      "(defun temp (x)" "   (if x (return-from temp 'dummy))" "   44) =>  TEMP"
      "(temp nil) =>  44" "(temp t) =>  DUMMY" "(block out"
      "  (flet ((exit (n) (return-from out n)))" "    (block out (exit 1)))" "  2) =>  1"
      "(block nil   " "  (unwind-protect (return-from nil 1)" "    (return-from nil 2)))"
      "=>  2" "(dolist (flag '(nil t))" "  (block nil" "    (let ((x 5))"
      "      (declare (special x))" "      (unwind-protect (return-from nil)"
      "        (print x))))" "  (print 'here))" ">>  5" ">>  HERE" ">>  5" ">>  HERE"
      "=>  NIL" "(dolist (flag '(nil t))" "  (block nil" "    (let ((x 5))"
      "      (declare (special x))" "      (unwind-protect"
      "          (if flag (return-from nil))" "        (print x))))" "  (print 'here))"
      ">>  5" ">>  HERE" ">>  5" ">>  HERE" "=>  NIL")
     EOL2 "下記の例は、" (CODE1 "return-from") "が適用される前に" (CODE1 "block")
     "フォームが通常の終了を行っているため結果は未定義です。"
     (CODE3 "```lisp" "```"
      "(funcall (block nil #'(lambda () (return-from nil)))) ;;はエラー"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "block") "," (CODE1 "return") "," "3.1. 評価")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("RETURN-FROM" . "SPECIAL-OPERATOR") *table*) (gethash "RETURN-FROM" *table*))
(setf (gethash "REVAPPEND" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "REVAPPEND") ", " (CODE1 "NRECONC"))
    (CHAPTER ("## 構文") 2 (CODE1 "revappend") " " (STRONG "list") " " (STRONG "tail")
     " => " (STRONG "result-list") EOL1 (CODE1 "nreconc") " " (STRONG "list") " "
     (STRONG "tail") " => " (STRONG "result-list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - 通常のリスト" EOL1 (STRONG "tail") " - オブジェクト"
     EOL1 (STRONG "result-list") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "revappend") "は、" (STRONG "list") "の各要素を逆順でコピーします。"
     "そして、逆順のリストに" (STRONG "tail") "を（" (CODE1 "nconc") "のように）追加し、" "その結果を返却します。" EOL2
     (CODE1 "nreconc") "は、" (STRONG "list") "の要素を（" (CODE1 "nreverse") "のように）反転させます。"
     "そして、逆順のリストに" (STRONG "tail") "を（" (CODE1 "nconc") "のように）追加し、" "その結果を返却します。" EOL2
     "結果のリストは、" (STRONG "tail") "とリスト構造を共有します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(let ((list-1 (list 1 2 3))"
      "      (list-2 (list 'a 'b 'c)))" "  (print (revappend list-1 list-2))"
      "  (print (equal list-1 '(1 2 3)))" "  (print (equal list-2 '(a b c))))"
      ">>  (3 2 1 A B C) " ">>  T" ">>  T" "=>  T" NIL
      "(revappend '(1 2 3) '()) =>  (3 2 1)"
      "(revappend '(1 2 3) '(a . b)) =>  (3 2 1 A . B)"
      "(revappend '() '(a b c)) =>  (A B C)" "(revappend '(1 2 3) 'a) =>  (3 2 1 . A)"
      "(revappend '() 'a) =>  A   ;degenerate case" NIL "(let ((list-1 '(1 2 3))"
      "      (list-2 '(a b c)))" "  (print (nreconc list-1 list-2))"
      "  (print (equal list-1 '(1 2 3)))" "  (print (equal list-2 '(a b c))))"
      ">>  (3 2 1 A B C) " ">>  NIL" ">>  T" "=>  T"))
    (CHAPTER ("## 副作用") 2 (CODE1 "revappend") "は、どんな引数も修正しません。" (CODE1 "nreconc") "は、"
     (STRONG "list") "の修正を許可しますが、" (STRONG "tail") "はそうではありません。" EOL2 "違った実装になるかもしれませんが、"
     (CODE1 "nreconc") "は、下記の動作と同等の副作用を持つように制限されています。"
     (CODE3 "```lisp" "```" " (nconc (nreverse list) tail)"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "reverse") "," (CODE1 "nreverse") "," (CODE1 "nconc"))
    (CHAPTER ("## 備考") 2 "下記の機能の等号式は真ですが、" "良い実装は、通常同じ効果が得られるより速いアルゴリズムを使用しているでしょう。"
     (CODE3 "```lisp" "```" "(revappend list tail) ==  (nconc (reverse list) tail)"
      "(nreconc list tail) ==  (nconc (nreverse list) tail)"))))
(setf (gethash '("REVAPPEND" . "FUNCTION") *table*) (gethash "REVAPPEND" *table*))
(setf (gethash "REVERSE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "REVERSE") ", " (CODE1 "NREVERSE"))
    (CHAPTER ("## 構文") 2 (CODE1 "reverse") " " (STRONG "sequence") " => "
     (STRONG "reversed-sequence") (CODE1 "nreverse") " " (STRONG "sequence") " => "
     (STRONG "reversed-sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "sequence") " - 正常なシーケンス" EOL1
     (STRONG "reversed-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "reverse") "と" (CODE1 "nreverse") "は、"
     (STRONG "sequence") "と同じ種類の、同じ要素が逆順に配置された、" "新しいシーケンスを返却します。" EOL2 (CODE1 "reverse")
     "と" (CODE1 "nreverse") "の違いは、" (CODE1 "reverse") "は常に新しいシーケンスを作成して返却するのに対して、"
     (CODE1 "nreverse") "はおそらく引数の" (STRONG "sequence") "を修正して返却します。" EOL2
     (CODE1 "reverse") "は、もし" (STRONG "sequence") "が" (CODE1 "vector") "のとき、"
     "返却値は新しい一次元のsimple-arrayであり、" (STRONG "sequence") "と同じ実際の配列の要素の型を持ちます。" "もし"
     (STRONG "sequence") "がリストなら、返却値は新しいリストです。" EOL2 (CODE1 "nreverse") "は、もし"
     (STRONG "sequence") "が" (CODE1 "vector") "のとき、" "返却値は一次元のsimple-arrayであり、"
     (STRONG "sequence") "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence")
     "がリストなら、返却値はリストです。" EOL2 (CODE1 "nreverse") "は、" (STRONG "sequence") "を破壊して再利用して、"
     "返却値を生成するかもしれません。" "返却値は" (STRONG "sequence") "と同一かもしれませんし、そうでないかもしれません。" "特に、"
     (STRONG "sequence") "がリストのとき、" (CODE1 "nreverse") "は、" (STRONG "sequence")
     "のリスト構造の部分にあるどのコンスの" (CODE1 "car") ", " (CODE1 "cdr") "部分でも、" (CODE1 "setf")
     "を実行することが許されます。" (STRONG "sequence") "が" (CODE1 "vector") "のとき、" (CODE1 "nreverse")
     "は、返却値の" (CODE1 "vector") "を求めるために、" (STRONG "sequence") "の要素の順番を変更することが許されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq str \"abc\") =>  \"abc\"" "(reverse str) =>  \"cba\""
      "str =>  \"abc\"" "(setq str (copy-seq str)) =>  \"abc\""
      "(nreverse str) =>  \"cba\"" "str =>  implementation-dependent"
      "(setq l (list 1 2 3)) =>  (1 2 3)" "(nreverse l) =>  (3 2 1)"
      "l =>  implementation-dependent"))
    (CHAPTER ("## 副作用") 2 (CODE1 "nreverse") "は、新しいシーケンスを作成するか、" (STRONG "sequence")
     "の引数を変更するか、" "あるいはその両方をするかもしれません。" "（" (CODE1 "reverse") "は" (STRONG "seqeunce")
     "の修正を行いません）")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("REVERSE" . "FUNCTION") *table*) (gethash "REVERSE" *table*))
(setf (gethash "ROTATEF" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "ROTATEF"))
    (CHAPTER ("## 構文") 2 (CODE1 "rotatef") " " (STRONG "place\\*") " => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "place") " - " (CODE1 "place"))
    (CHAPTER ("## 定義") 2 (CODE1 "rotatef") "は、ある" (CODE1 "place") "から他のものへ値の回転をすることで、"
     "各" (CODE1 "place") "を修正します。" EOL2 "もし" (STRONG "newvalue")
     "が格納変数より多い値を生成したときは、余分な値は無視されます。" "もし" (STRONG "newvalue")
     "が格納変数より少ない値しか生成しなかったときは、" "値のないものは" (CODE1 "nil") "がセットされます。" EOL2 "フォームが"
     (CODE1 "(rotatef place1 place2 ... placen newvalue)") "のとき、" (STRONG "place1") "～"
     (STRONG "placen") "までの値を読み込み書き込まれます。" (CODE1 "2") "～" (CODE1 "n") "個目の値は、それぞれ"
     (STRONG "place1") "～" (STRONG "placen") "に格納されます。" EOL2 "それは全て" (STRONG "place")
     "フォームが、" "終端が周期的になっているシフトレジスタであるかのように扱われます。" "それは各" (CODE1 "place") "が左へひとつ回転され、"
     (STRONG "place1") "の値は周期的に終わりの方である" (STRONG "placen") "へシフトされます。" EOL2
     (CODE1 "place") "のサブフォームの評価については、5.1.1.1. " (CODE1 "place") "のサブフォームの評価をご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(let ((n 0)" "       (x (list 'a 'b 'c 'd 'e 'f 'g)))"
      "   (rotatef (nth (incf n) x)" "            (nth (incf n) x)"
      "            (nth (incf n) x))" "   x) =>  (A C D B E F G)"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "define-setf-expander") "," (CODE1 "defsetf") ","
     (CODE1 "setf") "," (CODE1 "shiftf") "," (CODE1 "*macroexpand-hook*") ","
     "5.1. 一般化された参照")
    (CHAPTER ("## 備考") 2 (CODE1 "(rotatef place1 place2 ... placen newvalue)")
     "の効果は、だいたい次と同等です。"
     (CODE3 "```lisp" "```" " (psetf place1 place2" "        place2 place3" "        ..."
      "        placen place1)")
     EOL2 "ただし、これは各" (CODE1 "place") "のサブフォームを2度評価していますが、" (CODE1 "rotatef")
     "はただ一度だけです。")))
(setf (gethash '("ROTATEF" . "MACRO") *table*) (gethash "ROTATEF" *table*))
(setf (gethash "ROW-MAJOR-AREF" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "ROW-MAJOR-AREF"))
    (CHAPTER ("## 構文") 2 (CODE1 "row-major-aref") " " (STRONG "array") " "
     (STRONG "index") " => " (STRONG "element") EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "row-major-aref") " " (STRONG "array") " " (STRONG "index") ") "
     (STRONG "new-element") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "array") " - 配列" EOL1 (STRONG "index") " - "
     (STRONG "array") "の有効な配列の" (CODE1 "row-major") "インデックス" EOL1 (STRONG "element") ", "
     (STRONG "new-element") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "配列を" (CODE1 "row-major") "の順番に要素が配置されているような" (CODE1 "vector")
     "であると考え、" "指定した" (STRONG "index") "で参照される" (CODE1 "vector") "の要素を返却します。" EOL2
     (CODE1 "row-major-aref") "は" (CODE1 "setf") "での使用が有効です。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "aref") "," (CODE1 "array-row-major-index"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(row-major-aref array index) == "
      "  (aref (make-array (array-total-size array)"
      "                    :displaced-to array"
      "                    :element-type (array-element-type array))" "        index)")
     (CODE3 "```lisp" "```" "(aref array i1 i2 ...) == "
      "    (row-major-aref array (array-row-major-index array i1 i2))"))))
(setf (gethash '("ROW-MAJOR-AREF" . "ACCESSOR") *table*) (gethash "ROW-MAJOR-AREF" *table*))
(setf (gethash "RPLACA" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "RPLACA") ", " (CODE1 "RPLACD"))
    (CHAPTER ("## 構文") 2 (CODE1 "rplaca") " " (STRONG "cons") " " (STRONG "object")
     " => " (STRONG "cons") EOL1 (CODE1 "rplacd") " " (STRONG "cons") " "
     (STRONG "object") " => " (STRONG "cons"))
    (CHAPTER ("## 発音") 2 (CODE1 "rplaca") ": [,ree'plakuh] or [,ruh'plakuh]" EOL1
     (CODE1 "rplacd")
     ": [,ree'plakduh] or [,ruh'plakduh] or [,ree'plakdee] or [,ruh'plakdee]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "cons") " - コンス" EOL1 (STRONG "object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "rplaca") "は、" (STRONG "cons") "の" (CODE1 "car") "部を"
     (STRONG "object") "に置き換えます。" EOL2 (CODE1 "rplacd") "は、" (STRONG "cons") "の"
     (CODE1 "cdr") "部を" (STRONG "object") "に置き換えます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(defparameter *some-list* (list* 'one 'two 'three 'four)) =>  *some-list*"
      "*some-list* =>  (ONE TWO THREE . FOUR)"
      "(rplaca *some-list* 'uno) =>  (UNO TWO THREE . FOUR)"
      "*some-list* =>  (UNO TWO THREE . FOUR)"
      "(rplacd (last *some-list*) (list 'IV)) =>  (THREE IV)"
      "*some-list* =>  (UNO TWO THREE IV)"))
    (CHAPTER ("## 副作用") 2 (STRONG "cons") "は修正されます。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "cons") "がコンスではないとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("RPLACA" . "FUNCTION") *table*) (gethash "RPLACA" *table*))
(setf (gethash "RPLACD" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "RPLACA") ", " (CODE1 "RPLACD"))
    (CHAPTER ("## 構文") 2 (CODE1 "rplaca") " " (STRONG "cons") " " (STRONG "object")
     " => " (STRONG "cons") EOL1 (CODE1 "rplacd") " " (STRONG "cons") " "
     (STRONG "object") " => " (STRONG "cons"))
    (CHAPTER ("## 発音") 2 (CODE1 "rplaca") ": [,ree'plakuh] or [,ruh'plakuh]" EOL1
     (CODE1 "rplacd")
     ": [,ree'plakduh] or [,ruh'plakduh] or [,ree'plakdee] or [,ruh'plakdee]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "cons") " - コンス" EOL1 (STRONG "object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "rplaca") "は、" (STRONG "cons") "の" (CODE1 "car") "部を"
     (STRONG "object") "に置き換えます。" EOL2 (CODE1 "rplacd") "は、" (STRONG "cons") "の"
     (CODE1 "cdr") "部を" (STRONG "object") "に置き換えます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(defparameter *some-list* (list* 'one 'two 'three 'four)) =>  *some-list*"
      "*some-list* =>  (ONE TWO THREE . FOUR)"
      "(rplaca *some-list* 'uno) =>  (UNO TWO THREE . FOUR)"
      "*some-list* =>  (UNO TWO THREE . FOUR)"
      "(rplacd (last *some-list*) (list 'IV)) =>  (THREE IV)"
      "*some-list* =>  (UNO TWO THREE IV)"))
    (CHAPTER ("## 副作用") 2 (STRONG "cons") "は修正されます。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "cons") "がコンスではないとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("RPLACD" . "FUNCTION") *table*) (gethash "RPLACD" *table*))
(setf (gethash "SATISFIES" *table*)
  '((CHAPTER NIL 0 "Type Specifier " (CODE1 "SATISFIES")) (CHAPTER ("## 型指定子の種類") 2 "述部")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "satisfies") " " (STRONG "predicate-name"))
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "predicate-name") " - シンボル")
    (CHAPTER ("## 型指定子の定義") 2 "全てのオブジェクトの集合は、" (STRONG "predicate-name")
     "の述部を満たすことを示します。" (STRONG "predicate-name") "はひとつの引数を受け取る"
     "グローバル関数定義のシンボルでなければなりません。" (STRONG "predicate-name") "は名前を要求するため、" "ラムダ式は許されません。"
     "例えば、型指定子" (CODE1 "(and integer (satisfies evenp))") "は、" "全ての偶数の整数を示します。"
     (CODE1 "(typep x '(satisfies p))") "フォームは、" (CODE1 "(if (p x) t nil)") "と同等です。" EOL2
     "引数は要求されます。" "シンボル" (CODE1 "*") "は引数に指定できますが、" "しかしそれは自分自身（つまりシンボル" (CODE1 "*")
     "）を示しているのであって、" "未指定の値を表現しているのではありません。" EOL2 "シンボルとしての" (CODE1 "satisfies")
     "は、有効な型指定子ではありません。")))
(setf (gethash '("SATISFIES" . "TYPE-SPECIFIER") *table*) (gethash "SATISFIES" *table*))
(setf (gethash "SBIT" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "BIT") ", " (CODE1 "SBIT"))
    (CHAPTER ("## 構文") 2 (CODE1 "bit") " " (STRONG "bit-array") " " (CODE1 "&rest") " "
     (STRONG "subscripts") " => " (STRONG "bit") EOL1 (CODE1 "sbit") " "
     (STRONG "bit-array") " " (CODE1 "&rest") " " (STRONG "subscripts") " => "
     (STRONG "bit") EOL1 "(" (CODE1 "setf") " (" (CODE1 "bit") " " (STRONG "bit-array")
     " " (CODE1 "&rest") " " (STRONG "subscripts") ") " (STRONG "new-bit") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "sbit") " " (STRONG "bit-array") " " (CODE1 "&rest") " "
     (STRONG "subscripts") ") " (STRONG "new-bit") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "bit-array") " - " (CODE1 "bit") "はビット配列であり、"
     (CODE1 "sbit") "は" (CODE1 "simple") "なビット配列" EOL1 (STRONG "subscripts")
     " - ビット配列への有効な配列のインデックスのリスト" EOL1 (STRONG "bit") " - ビット")
    (CHAPTER ("## 定義") 2 (CODE1 "bit") "と" (CODE1 "sbit") "は、" (STRONG "subscripts")
     "によって指定された" "ビット配列の要素にアクセスします。" EOL2 "これらの関数は、要素にアクセスするときにfill-pointerを無視します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(bit (setq ba (make-array 8 "
      "                           :element-type 'bit "
      "                           :initial-element 1))" "      3) =>  1"
      "(setf (bit ba 3) 0) =>  0" "(bit ba 3) =>  0" "(sbit ba 5) =>  1"
      "(setf (sbit ba 5) 1) =>  1" "(sbit ba 5) =>  1"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "aref") "," "3.2.1. コンパイラーの用語")
    (CHAPTER ("## 備考") 2 (CODE1 "bit") "と" (CODE1 "sbit") "は" (CODE1 "aref") "に似ていますが、"
     (STRONG "array") "がそれぞれビット配列と" (CODE1 "simple") "のビット配列であることを" "要求することが違っています。" EOL2
     (CODE1 "bit") "と" (CODE1 "sbit") "は" (CODE1 "char") "と" (CODE1 "schar") "とは似ておらず、"
     "最初の引数はどんなランクの配列でも許されます。")))
(setf (gethash '("SBIT" . "ACCESSOR") *table*) (gethash "SBIT" *table*))
(setf (gethash "SCHAR" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "CHAR") ", " (CODE1 "SCHAR"))
    (CHAPTER ("## 構文") 2 (CODE1 "char") " " (STRONG "string") " " (STRONG "index") " => "
     (STRONG "character") EOL1 (CODE1 "schar") " " (STRONG "string") " " (STRONG "index")
     " => " (STRONG "character") EOL1 "(setf (" (CODE1 "char") " " (STRONG "string") " "
     (STRONG "index") ") " (STRONG "new-character") ")" EOL1 "(setf (" (CODE1 "schar")
     " " (STRONG "string") " " (STRONG "index") ") " (STRONG "new-character") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string") " - " (CODE1 "char") "の場合は文字列、"
     (CODE1 "schar") "の場合はsimple-string" EOL1 (STRONG "index") " - 文字列の有効な配列のインデックス" EOL1
     (STRONG "character") ", " (STRONG "new-character") " - 文字")
    (CHAPTER ("## 定義") 2 (CODE1 "char") "と" (CODE1 "schar") "は、" (STRONG "index")
     "で指定された文字列の要素にアクセスします。" EOL2 (CODE1 "char") "は要素にアクセスする際にfill-pointerを無視します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq my-simple-string (make-string 6 :initial-element #\\A)) =>  \"AAAAAA\""
      "(schar my-simple-string 4) =>  #\\A"
      "(setf (schar my-simple-string 4) #\\B) =>  #\\B" "my-simple-string =>  \"AAAABA\""
      "(setq my-filled-string" "      (make-array 6 :element-type 'character"
      "                    :fill-pointer 5"
      "                    :initial-contents my-simple-string))" "=>  \"AAAAB\""
      "(char my-filled-string 4) =>  #\\B" "(char my-filled-string 5) =>  #\\A"
      "(setf (char my-filled-string 3) #\\C) =>  #\\C"
      "(setf (char my-filled-string 5) #\\D) =>  #\\D"
      "(setf (fill-pointer my-filled-string) 6) =>  6"
      "my-filled-string =>  \"AAACBD\""))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "aref") ", " (CODE1 "elt") ", 3.2.1. コンパイラーの用語")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(char s j) ==  (aref (the string s) j)"))))
(setf (gethash '("SCHAR" . "ACCESSOR") *table*) (gethash "SCHAR" *table*))
(setf (gethash "SEARCH" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SEARCH"))
    (CHAPTER ("## 構文") 2 (CODE1 "search") " " (STRONG "sequence-1") " "
     (STRONG "sequence-2") " &key " (STRONG "from-end") " " (STRONG "test") " "
     (STRONG "test-not") " " (STRONG "key") " " (STRONG "start1") " " (STRONG "start2")
     " " (STRONG "end1") " " (STRONG "end2") EOL1 "=> " (STRONG "position"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "sequence-1") " - 正常なシーケンス" EOL1
     (STRONG "sequence-2") " - 正常なシーケンス" EOL1 (STRONG "from-end")
     " - generalized-boolean、デフォルトは" (STRONG "false") EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "start1") ", " (STRONG "end1")
     " - " (STRONG "sequence-1") "の境界インデックス指定子。" "デフォルトは" (STRONG "start1") ", "
     (STRONG "end1") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "start2") ", "
     (STRONG "end2") " - " (STRONG "sequence-2") "の境界インデックス指定子。" "デフォルトは"
     (STRONG "start2") ", " (STRONG "end2") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1
     (STRONG "position") " - " (STRONG "sequence-2") "の境界インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 (STRONG "sequence-2") "のサブシーケンスと" (STRONG "sequence-1")
     "がマッチする場所を探します。" EOL2 "実装は、" (STRONG "sequence-2") "をどのような順番で検索するか選べます。"
     "テストの回数を保証することはできません。" "例えば、各" (STRONG "start") "、" (STRONG "end") "に値があるとき、"
     "シーケンスは実際には右から左ではなく、" "左から右に検索されるかもしれません" "（ただしどちらの場合でも、右側にマッチする" "サブシーケンスが返却されます）。"
     "もし検索が成功したときは、" (CODE1 "search") "は、" (STRONG "from-end") "に応じて、"
     (STRONG "sequence-2") "の左端または右端にマッチする" "サブシーケンスの最初の要素のオフセットを返却します。" "それ以外の場合は、"
     (CODE1 "nil") "を返却します。" EOL2 "もし" (STRONG "from-end") "が" (STRONG "true") "のときは、"
     "もっとも右側にマッチしたサブシーケンスの、" "左端の要素のインデックスを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(search \"dog\" \"it's a dog's life\") =>  7"
      "(search '(0 1) '(2 4 6 1 3 5) :key #'oddp) =>  2"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。")))
(setf (gethash '("SEARCH" . "FUNCTION") *table*) (gethash "SEARCH" *table*))
(setf (gethash "SECOND" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "FIRST") ", " (CODE1 "SECOND") ", " (CODE1 "THIRD")
     ", " (CODE1 "FOURTH") ", " (CODE1 "FIFTH") "," (CODE1 "SIXTH") ", "
     (CODE1 "SEVENTH") ", " (CODE1 "EIGHTH") ", " (CODE1 "NINTH") ", " (CODE1 "TENTH"))
    (CHAPTER ("## 構文") 2 (CODE1 "first") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "second") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "third") " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fourth")
     " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fifth") " "
     (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "sixth") " " (STRONG "list")
     " => " (STRONG "object") EOL1 (CODE1 "seventh") " " (STRONG "list") " => "
     (STRONG "object") EOL1 (CODE1 "eighth") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "ninth") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "tenth") " " (STRONG "list") " => " (STRONG "object") EOL1 "(" (CODE1 "setf")
     " (" (CODE1 "first") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "second") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "third") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "fourth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "fifth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "sixth") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "seventh") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "eighth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "ninth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "tenth") " " (STRONG "list") ") " (STRONG "new-object")
     ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト、ドットリストと循環リストも受け付けます。" EOL1
     (STRONG "object") ", " (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "関数" (CODE1 "first") ", " (CODE1 "second") ", " (CODE1 "third")
     ", " (CODE1 "fourth") ", " (CODE1 "fifth") "," (CODE1 "sixth") ", "
     (CODE1 "seventh") ", " (CODE1 "eighth") ", " (CODE1 "ninth") ", " (CODE1 "tenth")
     "は、" "それぞれリストの1番目、2番目、3番目、4番目、5番目、" "6番目、7番目、8番目、9番目、10番目の要素にアクセスします。"
     "具体的には次のようになります。"
     (CODE3 "```lisp" "```" "(first list)    ==   (car list)"
      "(second list)   ==   (car (cdr list))" "(third list)    ==   (car (cddr list))"
      "(fourth list)   ==   (car (cdddr list))"
      "(fifth list)    ==   (car (cddddr list))"
      "(sixth list)    ==   (car (cdr (cddddr list)))"
      "(seventh list)  ==   (car (cddr (cddddr list)))"
      "(eighth list)   ==   (car (cdddr (cddddr list)))"
      "(ninth list)    ==   (car (cddddr (cddddr list)))"
      "(tenth list)    ==   (car (cdr (cddddr (cddddr list))))")
     EOL2 (CODE1 "setf") "は、これらの関数を使うことによって" "既存の構成要素を変更することもできます。"
     "上記の等価な関係を用いて同じように適用できます。" "例えば次のようになります。"
     (CODE3 "```lisp" "```"
      "(setf (fifth list) new-object) == (setf (car (cddddr list)) new-object)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst '(1 2 3 (4 5 6) ((V)) vi 7 8 9 10)) "
      "=>  (1 2 3 (4 5 6) ((V)) VI 7 8 9 10)" "(first lst) =>  1" "(tenth lst) =>  10"
      "(fifth lst) =>  ((V))" "(second (fourth lst)) =>  5" "(sixth '(1 2 3)) =>  NIL"
      "(setf (fourth lst) \"four\") =>  \"four\""
      "lst =>  (1 2 3 \"four\" ((V)) VI 7 8 9 10)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "car") "," (CODE1 "nth"))
    (CHAPTER ("## 備考") 2 (CODE1 "first") "は機能的には" (CODE1 "car") "と同じです。" (CODE1 "second")
     "は機能的には" (CODE1 "cadr") "と同じです。" (CODE1 "third") "は機能的には" (CODE1 "caddr") "と同じです。"
     (CODE1 "fourth") "は機能的には" (CODE1 "cadddr") "と同じです。" EOL2 "通常の番号付けは1から開始しますが、"
     (CODE1 "nth") "によって使われる採番は0開始であり、" "次の関係が成り立ちます。"
     (CODE3 "```lisp" "```" "(fifth x) == (nth 4 x)"))))
(setf (gethash '("SECOND" . "ACCESSOR") *table*) (gethash "SECOND" *table*))
(setf (gethash "SEQUENCE" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "SEQUENCE"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "sequence") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "シーケンスとは、オブジェクトを順序付けして集めたものであり、" "そのオブジェクトはシーケンスの要素と呼ばれます。" EOL2
     "型" (CODE1 "vector") "と型" (CODE1 "list") "は、" "互いに疎な型" (CODE1 "sequence")
     "のサブタイプであり、" "しかしシーケンスの完全な分割である必要はありません。" EOL2 (CODE1 "vector") "をシーケンスとして見た場合、"
     "その" (CODE1 "vector") "のアクティブな要素のみがシーケンスの要素であるとみなされます。" "つまり、シーケンスが"
     (CODE1 "vector") "として与えられたら、" "そのシーケンスを操作するときは、" "fill-pointerを考慮する必要があるということです。")))
(setf (gethash '("SEQUENCE" . "SYSTEM-CLASS") *table*) (gethash "SEQUENCE" *table*))
(setf (gethash "SERIOUS-CONDITION" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "SERIOUS-CONDITION"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "serious-condition") "," (CODE1 "condition") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "もし捕捉されないと対話的な介入が必要になるくらい深刻な" "全てのコンディションは、型"
     (CODE1 "serious-condition") "を継承しなければなりません。" "この型のコンディションは、主に他のコンディションの型の"
     "スーパークラスとして含まれるような機能を提供します。" "これが直接通知されることは意図していません。")
    (CHAPTER ("## 備考") 2 (CODE1 "serious-condition") "の通知は、" "それ自身が強制的にデバッガーを起動しません。"
     "しかし、プログラマーが" (CODE1 "serious-condition") "の捕捉に失敗しても" "障害が起こらないと保証できるような異常な状況を除いて、"
     "そのようなコンディションは通常は" (CODE1 "signal") "ではなく" (CODE1 "error") "を用いて通知することで、"
     "プログラムがそのコンディションを捕捉しなかった場合は" "継続しないことを保証します。" "（そして逆に、通常"
     (CODE1 "serious-condition") "ではない" "コンディションの捕捉に失敗したときでも"
     "デバッガーに入るほどではないという理由があるときは、" "その" (CODE1 "serious-condition") "ではないコンディションを"
     (CODE1 "error") "ではなく" (CODE1 "signal") "を用いて" "通知するのが一般的です。）")))
(setf (gethash '("SERIOUS-CONDITION" . "CONDITION-TYPE") *table*) (gethash "SERIOUS-CONDITION" *table*))
(setf (gethash "SET" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SET"))
    (CHAPTER ("## 構文") 2 (CODE1 "set") " " (STRONG "symbol") " " (STRONG "value") " => "
     (STRONG "value"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - シンボル" EOL1 (STRONG "value")
     " - オブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "set") "は、" (STRONG "symbol") "の値のセルの内容を、引数"
     (STRONG "value") "に変更します。"
     (CODE3 "```lisp" "```" "(set symbol value) ==  (setf (symbol-value symbol) value)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setf (symbol-value 'n) 1) =>  1" "(set 'n 2) =>  2"
      "(symbol-value 'n) =>  2" "(let ((n 3))" "  (declare (special n))"
      "  (setq n (+ n 1))" "  (setf (symbol-value 'n) (* n 10))"
      "  (set 'n (+ (symbol-value 'n) n))" "  n) =>  80" "n =>  2" "(let ((n 3))"
      "  (setq n (+ n 1))" "  (setf (symbol-value 'n) (* n 10))"
      "  (set 'n (+ (symbol-value 'n) n))" "  n) =>  4" "n =>  44" "(defvar *n* 2)"
      "(let ((*n* 3))" "  (setq *n* (+ *n* 1))" "  (setf (symbol-value '*n*) (* *n* 10))"
      "  (set '*n* (+ (symbol-value '*n*) *n*))" "  *n*) =>  80" " *n* =>  2"
      "(defvar *even-count* 0) =>  *EVEN-COUNT*" "(defvar *odd-count* 0) =>  *ODD-COUNT*"
      "(defun tally-list (list)" "  (dolist (element list)"
      "    (set (if (evenp element) '*even-count* '*odd-count*)"
      "         (+ element (if (evenp element) *even-count* *odd-count*)))))"
      "(tally-list '(1 9 4 3 2 7)) =>  NIL" "*even-count* =>  6" "*odd-count* =>  20"))
    (CHAPTER ("## 副作用") 2 (STRONG "symbol") "の値が変更されます。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "setq") "," (CODE1 "progv") "," (CODE1 "symbol-value"))
    (CHAPTER ("## 備考") 2 "関数" (CODE1 "set") "は非推奨です。" EOL2 (CODE1 "set")
     "は、レキシカルな変数の値を変更できません。")))
(setf (gethash '("SET" . "FUNCTION") *table*) (gethash "SET" *table*))
(setf (gethash "SET-DIFFERENCE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SET-DIFFERENCE") ", " (CODE1 "NSET-DIFFERENCE"))
    (CHAPTER ("## 構文") 2 (CODE1 "set-difference") " " (STRONG "list-1") " "
     (STRONG "list-2") " &key " (STRONG "key") " " (STRONG "test") " "
     (STRONG "test-not") " => " (STRONG "result-list") EOL1 (CODE1 "nset-difference") " "
     (STRONG "list-1") " " (STRONG "list-2") " &key " (STRONG "key") " " (STRONG "test")
     " " (STRONG "test-not") " => " (STRONG "result-list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list-1") " - 通常のリスト" EOL1 (STRONG "list-2")
     " - 通常のリスト" EOL1 (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test-not") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "result-list") " - リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "set-difference") "は、" (STRONG "list-2") "には現れない、"
     (STRONG "list-1") "の要素のリストを返却します。" EOL2 (CODE1 "nset-difference") "は、"
     (CODE1 "set-difference") "の破壊的バージョンです。" (STRONG "list-1") "はおそらく破壊されます。" EOL2
     (STRONG "list-1") "のひとつの要素と、" (STRONG "list-2") "のひとつの要素からなる、" "全ての順序付けされたペアに対して、"
     (CODE1 ":test") "か" (CODE1 ":test-not") "を使ってテストが満たされるかどうかを決定します。" (CODE1 ":test")
     "か" (CODE1 ":test-not") "の関数の最初の要素は" (STRONG "list-1") "の要素であり、" (CODE1 ":key")
     "関数によって返却されたものです（もし" (CODE1 ":key") "が指定されたなら）。" "二番目の引数は" (STRONG "list-2")
     "の要素であり、" (CODE1 ":key") "関数によって返却されたものです（もし" (CODE1 ":key") "が指定されたなら）。" EOL2 "もし"
     (CODE1 ":key") "が与えられたなら、" "その引数は、" (STRONG "list-1") "か" (STRONG "list-2") "の要素です。"
     (CODE1 ":key") "関数は通常与えられた要素の部分を返却します。" "もし" (CODE1 ":key") "が与えられないか、あるいは"
     (CODE1 "nil") "が指定されたとき、" (STRONG "list-1") "と" (STRONG "list-2") "の要素が使われます。" EOL2
     (STRONG "list-1") "の要素は、" (STRONG "list-2") "のどの要素にもマッチしないときのみ、" "結果に現れます。" EOL2
     "どんな方法で引数の順番を変えたとしても、" "結果の要素の順番に反映できる保証はありません。" "結果のリストは、適切であれば、" (STRONG "list-1")
     "か" (STRONG "list-2") "のどちらかとセルを共有するか、" "あるいは" (CODE1 "eq") "になる可能性があります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst1 (list \"A\" \"b\" \"C\" \"d\")"
      "      lst2 (list \"a\" \"B\" \"C\" \"d\")) =>  (\"a\" \"B\" \"C\" \"d\")"
      "(set-difference lst1 lst2) =>  (\"d\" \"C\" \"b\" \"A\")"
      "(set-difference lst1 lst2 :test 'equal) =>  (\"b\" \"A\")"
      "(set-difference lst1 lst2 :test #'equalp) =>  NIL "
      "(nset-difference lst1 lst2 :test #'string=) =>  (\"A\" \"b\")"
      "(setq lst1 '((\"a\" . \"b\") (\"c\" . \"d\") (\"e\" . \"f\")))"
      "=>  ((\"a\" . \"b\") (\"c\" . \"d\") (\"e\" . \"f\")) "
      "(setq lst2 '((\"c\" . \"a\") (\"e\" . \"b\") (\"d\" . \"a\")))"
      "=>  ((\"c\" . \"a\") (\"e\" . \"b\") (\"d\" . \"a\")) "
      "(nset-difference lst1 lst2 :test #'string= :key #'cdr)"
      "=>  ((\"c\" . \"d\") (\"e\" . \"f\")) "
      "lst1 =>  ((\"a\" . \"b\") (\"c\" . \"d\") (\"e\" . \"f\")) "
      "lst2 =>  ((\"c\" . \"a\") (\"e\" . \"b\") (\"d\" . \"a\")) "
      ";; 名前に\"c\"か\"w\"を含む全ての食べ物は削除される"
      "(set-difference '(\"strawberry\" \"chocolate\" \"banana\""
      "                 \"lemon\" \"pistachio\" \"rhubarb\")" "         '(#\\c #\\w)"
      "         :test #'(lambda (s c) (find c s)))"
      "=>  (\"banana\" \"rhubarb\" \"lemon\")    ;One possible ordering."))
    (CHAPTER ("## 副作用") 2 (CODE1 "nset-difference") "は" (STRONG "list-1") "を破壊するでしょう。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list-1") "と" (STRONG "list-2") "が通常のリストではないとき、" "型"
     (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。")))
(setf (gethash '("SET-DIFFERENCE" . "FUNCTION") *table*) (gethash "SET-DIFFERENCE" *table*))
(setf (gethash "SET-EXCLUSIVE-OR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SET-EXCLUSIVE-OR") ", "
     (CODE1 "NSET-EXCLUSIVE-OR"))
    (CHAPTER ("## 構文") 2 (CODE1 "set-exclusive-or") " " (STRONG "list-1") " "
     (STRONG "list-2") " &key " (STRONG "key") " " (STRONG "test") " "
     (STRONG "test-not") " => " (STRONG "result-list") EOL1 (CODE1 "nset-exclusive-or")
     " " (STRONG "list-1") " " (STRONG "list-2") " &key " (STRONG "key") " "
     (STRONG "test") " " (STRONG "test-not") " => " (STRONG "result-list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list-1") " - 通常のリスト" EOL1 (STRONG "list-2")
     " - 通常のリスト" EOL1 (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test-not") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "result-list") " - リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "set-difference") "は、" (STRONG "list-1") "と"
     (STRONG "list-2") "に" "正確に一度現れている要素をリストで返却します。" EOL2 (CODE1 "nset-exclusive-or")
     "は、" (CODE1 "set-exclusive-or") "の破壊的バージョンです。" EOL2 (STRONG "list-1") "のひとつの要素と、"
     (STRONG "list-2") "のひとつの要素からなる、" "全ての順序付けされたペアに対して、" (CODE1 ":test") "か"
     (CODE1 ":test-not") "を使ってテストが満たされるかどうかを決定します。" EOL2 "もし" (CODE1 ":key") "が与えられたなら、"
     (STRONG "list-1") "か" (STRONG "list-2") "の要素をテストする部分を引き出すときに使われます。" (CODE1 ":test")
     "か" (CODE1 ":test-not") "の関数の最初の要素は" (STRONG "list-1") "の要素であり、" (CODE1 ":key")
     "関数によって返却されたものです（もし" (CODE1 ":key") "が指定されたなら）。" "二番目の引数は" (STRONG "list-2")
     "の要素であり、" (CODE1 ":key") "関数によって返却されたものです（もし" (CODE1 ":key") "が指定されたなら）。" "もし"
     (CODE1 ":key") "が与えられないか、あるいは" (CODE1 "nil") "が指定されたとき、" (STRONG "list-1") "と"
     (STRONG "list-2") "の要素が使われます。" EOL2 "結果は、" (STRONG "list-1") "と" (STRONG "list-2")
     "の要素のうち、" "マッチするペアがないものを正確に含んでいます。" EOL2 (CODE1 "set-difference") "の結果のリストは、"
     (STRONG "list-1") "か" (STRONG "list-2") "のどちらかが" "ストレージ上で共有されているかもしれません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst1 (list 1 \"a\" \"b\")"
      "      lst2 (list 1 \"A\" \"b\")) =>  (1 \"A\" \"b\")"
      "(set-exclusive-or lst1 lst2) =>  (\"b\" \"A\" \"b\" \"a\")"
      "(set-exclusive-or lst1 lst2 :test #'equal) =>  (\"A\" \"a\")"
      "(set-exclusive-or lst1 lst2 :test 'equalp) =>  NIL "
      "(nset-exclusive-or lst1 lst2) =>  (\"a\" \"b\" \"A\" \"b\") "
      "(setq lst1 (list ((\"a\" . \"b\") (\"c\" . \"d\") (\"e\" . \"f\"))))"
      "=>  ((\"a\" . \"b\") (\"c\" . \"d\") (\"e\" . \"f\"))"
      "(setq lst2 (list ((\"c\" . \"a\") (\"e\" . \"b\") (\"d\" . \"a\"))))"
      "=>  ((\"c\" . \"a\") (\"e\" . \"b\") (\"d\" . \"a\")) "
      "(nset-exclusive-or lst1 lst2 :test #'string= :key #'cdr)"
      "=>  ((\"c\" . \"d\") (\"e\" . \"f\") (\"c\" . \"a\") (\"d\" . \"a\")) "
      "lst1 =>  ((\"a\" . \"b\") (\"c\" . \"d\") (\"e\" . \"f\"))"
      "lst2 =>  ((\"c\" . \"a\") (\"d\" . \"a\")) "))
    (CHAPTER ("## 副作用") 2 (CODE1 "nset-exclusive-or") "は、" (STRONG "list-1") "か"
     (STRONG "list-2") "のリスト構造の" (CODE1 "car") ", " (CODE1 "cdr") "の"
     "どの部分も修正することが許されています。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list-1") "と" (STRONG "list-2") "が通常のリストではないとき、" "型"
     (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "3.2.1. コンパイラーの用語")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2
     (CODE1 "nset-exclusive-or") "の副作用は必要ないため、" "移植可能なコードにおいては副作用のみを期待した姿勢で使うべきではありません。")))
(setf (gethash '("SET-EXCLUSIVE-OR" . "FUNCTION") *table*) (gethash "SET-EXCLUSIVE-OR" *table*))
(setf (gethash "SET-PPRINT-DISPATCH" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SET-PPRINT-DISPATCH"))
    (CHAPTER ("## 構文") 2 (CODE1 "set-pprint-dispatch") " " (STRONG "type-specifier") " "
     (STRONG "function") " " (CODE1 "&optional") " " (STRONG "priority") " "
     (STRONG "table") " => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "type-specifier") " - 型指定子" EOL1 (STRONG "function")
     " - 関数か、関数名か、" (CODE1 "nil") EOL1 (STRONG "priority") " - 実数。デフォルトは" (CODE1 "0") "。"
     EOL1 (STRONG "table") " - " (CODE1 "pprint") "ディスパッチテーブル。デフォルトは"
     (CODE1 "*print-pprint-dispatch*") "の値。")
    (CHAPTER ("## 定義") 2 (STRONG "table") "で指定された" (CODE1 "pprint")
     "ディスパッチテーブルにエントリーを導入します。" EOL2 (STRONG "type-specifier") "はエントリーのキーです。"
     (CODE1 "set-pprint-dispatch") "の最初の動作は、" (STRONG "type-specifier") "に関連付けられた"
     "以前に存在していたエントリーを削除することです。" "これにより、与えられた" (CODE1 "pprint") "ディスパッチテーブル内において"
     "同じ型指定子に関連付けられるエントリーが" "2つになることがあり得ないことを保証します。" "型指定子の同一性は" (CODE1 "equal")
     "によってテストします。" EOL2 (CODE1 "pprint") "ディスパッチテーブル内の各型指定子にには、" (STRONG "function") "と"
     (STRONG "priority") "の2つの値が 関連付けられます。" (STRONG "function") "は2つの引数を受け付ける必要があり、"
     "最初の引数は出力を送信するストリーム、" "次の引数は印刷するオブジェクトです。" (STRONG "function") "はオブジェクトをストリームへ"
     "プリティプリントとして印刷とするべきです。" (STRONG "function") "はオブジェクトが与えられた"
     (STRONG "type-specifier") "を" "満たすと仮定することができます。" (STRONG "function") "は"
     (CODE1 "*print-readably*") "に従うべきです。" (STRONG "function") "によって返却されるどんな値も無視されます。"
     EOL2 (STRONG "priority") "は、オブジェクトがひとつ以上のエントリーと" "マッチするような衝突を解決するための優先順位です。" EOL2
     (STRONG "function") "は" (CODE1 "nil") "であることが許されます。" "このような状況においては、"
     (CODE1 "set-pprint-dispatch") "が返却されたあとは、" (STRONG "table") "内に"
     (STRONG "type-specifier") "のエントリーが無くなります。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "priority") "が実数ではないときは、エラーが発生します。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 (CODE1 "pprint") "ディスパッチテーブルは"
     "Lispコードのプリティプリンターを制御するときによく使用され、" "次のような式のフォームによって示される型指定子が使われることが多いです。"
     (CODE3 "```lisp" "```" "(cons car-type cdr-type)") EOL2 "これは対応するオブジェクトが"
     (CODE1 "cons") "のセルであり、" (CODE1 "car") "部は" (STRONG "car-type") "という型指定子にマッチし、"
     (CODE1 "cdr") "部は" (STRONG "cdr-type") "という型指定子にマッチするようなことを意味しています。"
     (STRONG "cdr-type") "は省略することができ、" "そのような場合はデフォルトでは" (CODE1 "t") "になります。")))
(setf (gethash '("SET-PPRINT-DISPATCH" . "FUNCTION") *table*) (gethash "SET-PPRINT-DISPATCH" *table*))
(setf (gethash "SETF" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "SETF") ", " (CODE1 "PSETF"))
    (CHAPTER ("## 構文") 2 (CODE1 "setf") " " (CODE1 "{") (STRONG "pair") (CODE1 "}")
     "\\* => " (STRONG "result\\*") EOL1 (CODE1 "psetf") " " (CODE1 "{") (STRONG "pair")
     (CODE1 "}") "\\* => " (CODE1 "nil") (CODE3 "```" "```" "pair ::= place newvalue "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "place") " - " (CODE1 "place") EOL1
     (STRONG "newvalue") " - フォーム" EOL1 (STRONG "result") " - 最後の" (CODE1 "place")
     "の格納フォームから返却された多値か、" (STRONG "pair") "がないときは" (CODE1 "nil") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "setf") "は、" (CODE1 "place") "の値を" (STRONG "newvalue")
     "に変更します。" EOL2 (CODE1 "(setf place newvalue)") "は、" (STRONG "newvalue") "の評価結果が"
     (CODE1 "place") "の場所へ保存されるような" "更新フォームに展開されます。" "いくつかの" (CODE1 "place") "フォームは、"
     "オプションの引数を取るアクセッサを使用して実行します。" "それらのオプション引数が" (CODE1 "setf") "によって許可されるかどうか、"
     "あるいはどのように使うかは" (CODE1 "setf") "の展開関数次第であり、" (CODE1 "setf") "の制御下にはありません。"
     (CODE1 "setf") "の使用時に" "引数" (CODE1 "&optional") ", " (CODE1 "&rest") ", ..., "
     (CODE1 "&key") "を" "受け付けるような関数のドキュメントは、" "どのようにそれらの引数を扱うのかを指定しなければなりません。" EOL2
     "もし複数の" (STRONG "pair") "が指定されたら、" "各" (STRONG "pair") "は順番に処理されます。" "次の式は、"
     (CODE3 "```lisp" "```" "(setf place-1 newvalue-1" "      place-2 newvalue-2"
      "      ..." "      place-N newvalue-N)")
     EOL2 "下記の式と同等です。"
     (CODE3 "```lisp" "```" "(progn (setf place-1 newvalue-1)"
      "       (setf place-2 newvalue-2)" "       ..."
      "       (setf place-N newvalue-N))")
     EOL2 (CODE1 "psetf") "は複数の" (STRONG "pair") "が指定されたとき、" (CODE1 "place")
     "への新しい値の代入を並行に行います。" "もっと正確に言うと、" "全てのサブフォーム（" (STRONG "place") "と"
     (STRONG "newvalue") "の両方のフォーム）が" "左から右に評価され、全ての評価が実行されたあとで、" "全ての代入が順不同で行われます。" EOL2
     (CODE1 "setf") "と" (CODE1 "psetf") "の展開の扱いの詳細は、" "5.1.2. " (CODE1 "place")
     "の種類をご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq x (cons 'a 'b) y (list 1 2 3)) =>  (1 2 3) "
      "(setf (car x) 'x (cadr y) (car x) (cdr x) y) =>  (1 X 3) " "x =>  (X 1 X 3) "
      "y =>  (1 X 3) " "(setq x (cons 'a 'b) y (list 1 2 3)) =>  (1 2 3) "
      "(psetf (car x) 'x (cadr y) (car x) (cdr x) y) =>  NIL " "x =>  (X 1 A 3) "
      "y =>  (1 A 3) "))
    (CHAPTER ("## 影響") 2 (CODE1 "define-setf-expander") "," (CODE1 "defsetf") ","
     (CODE1 "*macroexpand-hook*"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "define-setf-expander") "," (CODE1 "defsetf") ","
     (CODE1 "macroexpand-1") "," (CODE1 "rotatef") "," (CODE1 "shiftf") ","
     "5.1. 一般化された参照")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("SETF" . "MACRO") *table*) (gethash "SETF" *table*))
(setf (gethash "SETQ" *table*)
  '((CHAPTER NIL 0 "Special Form " (CODE1 "SETQ"))
    (CHAPTER ("## 構文") 2 (CODE1 "setq") " " (CODE1 "{") (STRONG "pair") (CODE1 "}")
     "\\* => " (STRONG "result") (CODE3 "```" "```" "*pair* ::= var form "))
    (CHAPTER ("## 発音") 2 "['set,kyoo]")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - 定数ではない変数名のシンボル" EOL1 (STRONG "form")
     " - フォーム" EOL1 (STRONG "result") " - 最後の" (STRONG "form") "の第一返却値か、" (STRONG "pair")
     "がないときは" (CODE1 "nil") "。")
    (CHAPTER ("## 定義") 2 "変数に値を代入します。" EOL2 (CODE1 "(setq var1 form1 var2 form2 ...)")
     "がLispの単純な変数への代入構文です。" "最初に" (STRONG "form1") "が評価されて結果を変数" (STRONG "var1") "に保存し、"
     "そのあと" (STRONG "form2") "が評価されて結果を変数" (STRONG "var2") "に保存し、くり返します。" (CODE1 "setq")
     "は、レキシカル変数と動的変数の両方の代入に使われます。" EOL2 "もし、どの" (STRONG "var") "でも"
     (CODE1 "symbol-macrolet") "によって" "作られた束縛を参照したときは、" "その" (STRONG "var") "は"
     (CODE1 "setq") "ではなく" (CODE1 "setf") "として扱われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; 変数へ値を代入する単純なSETQの使用" "(setq a 1 b 2 c 3) =>  3" "a =>  1"
      "b =>  2" "c =>  3" NIL ";; 値を順次代入して更新するSETQの使用"
      "(setq a (1+ b) b (1+ a) c (+ a b)) =>  7" "a =>  3" "b =>  4" "c =>  7" NIL
      ";; シンボルマクロ上のSETQの使用例" "(let ((x (list 10 20 30)))"
      "  (symbol-macrolet ((y (car x)) (z (cadr x)))" "    (setq y (1+ z) z (1+ y))"
      "    (list x y z)))" "=>  ((21 22 30) 21 22)"))
    (CHAPTER ("## 副作用") 2 "各" (STRONG "form") "の第一返却値が対応する" (STRONG "var") "に代入されます。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "psetq") "," (CODE1 "set") "," (CODE1 "setf"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("SETQ" . "SPECIAL-FORM") *table*) (gethash "SETQ" *table*))
(setf (gethash "SEVENTH" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "FIRST") ", " (CODE1 "SECOND") ", " (CODE1 "THIRD")
     ", " (CODE1 "FOURTH") ", " (CODE1 "FIFTH") "," (CODE1 "SIXTH") ", "
     (CODE1 "SEVENTH") ", " (CODE1 "EIGHTH") ", " (CODE1 "NINTH") ", " (CODE1 "TENTH"))
    (CHAPTER ("## 構文") 2 (CODE1 "first") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "second") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "third") " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fourth")
     " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fifth") " "
     (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "sixth") " " (STRONG "list")
     " => " (STRONG "object") EOL1 (CODE1 "seventh") " " (STRONG "list") " => "
     (STRONG "object") EOL1 (CODE1 "eighth") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "ninth") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "tenth") " " (STRONG "list") " => " (STRONG "object") EOL1 "(" (CODE1 "setf")
     " (" (CODE1 "first") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "second") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "third") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "fourth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "fifth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "sixth") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "seventh") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "eighth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "ninth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "tenth") " " (STRONG "list") ") " (STRONG "new-object")
     ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト、ドットリストと循環リストも受け付けます。" EOL1
     (STRONG "object") ", " (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "関数" (CODE1 "first") ", " (CODE1 "second") ", " (CODE1 "third")
     ", " (CODE1 "fourth") ", " (CODE1 "fifth") "," (CODE1 "sixth") ", "
     (CODE1 "seventh") ", " (CODE1 "eighth") ", " (CODE1 "ninth") ", " (CODE1 "tenth")
     "は、" "それぞれリストの1番目、2番目、3番目、4番目、5番目、" "6番目、7番目、8番目、9番目、10番目の要素にアクセスします。"
     "具体的には次のようになります。"
     (CODE3 "```lisp" "```" "(first list)    ==   (car list)"
      "(second list)   ==   (car (cdr list))" "(third list)    ==   (car (cddr list))"
      "(fourth list)   ==   (car (cdddr list))"
      "(fifth list)    ==   (car (cddddr list))"
      "(sixth list)    ==   (car (cdr (cddddr list)))"
      "(seventh list)  ==   (car (cddr (cddddr list)))"
      "(eighth list)   ==   (car (cdddr (cddddr list)))"
      "(ninth list)    ==   (car (cddddr (cddddr list)))"
      "(tenth list)    ==   (car (cdr (cddddr (cddddr list))))")
     EOL2 (CODE1 "setf") "は、これらの関数を使うことによって" "既存の構成要素を変更することもできます。"
     "上記の等価な関係を用いて同じように適用できます。" "例えば次のようになります。"
     (CODE3 "```lisp" "```"
      "(setf (fifth list) new-object) == (setf (car (cddddr list)) new-object)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst '(1 2 3 (4 5 6) ((V)) vi 7 8 9 10)) "
      "=>  (1 2 3 (4 5 6) ((V)) VI 7 8 9 10)" "(first lst) =>  1" "(tenth lst) =>  10"
      "(fifth lst) =>  ((V))" "(second (fourth lst)) =>  5" "(sixth '(1 2 3)) =>  NIL"
      "(setf (fourth lst) \"four\") =>  \"four\""
      "lst =>  (1 2 3 \"four\" ((V)) VI 7 8 9 10)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "car") "," (CODE1 "nth"))
    (CHAPTER ("## 備考") 2 (CODE1 "first") "は機能的には" (CODE1 "car") "と同じです。" (CODE1 "second")
     "は機能的には" (CODE1 "cadr") "と同じです。" (CODE1 "third") "は機能的には" (CODE1 "caddr") "と同じです。"
     (CODE1 "fourth") "は機能的には" (CODE1 "cadddr") "と同じです。" EOL2 "通常の番号付けは1から開始しますが、"
     (CODE1 "nth") "によって使われる採番は0開始であり、" "次の関係が成り立ちます。"
     (CODE3 "```lisp" "```" "(fifth x) == (nth 4 x)"))))
(setf (gethash '("SEVENTH" . "ACCESSOR") *table*) (gethash "SEVENTH" *table*))
(setf (gethash "SHADOW" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SHADOW"))
    (CHAPTER ("## 構文") 2 (CODE1 "shadow") " " (STRONG "symbol-names") " "
     (CODE1 "&optional") " " (STRONG "package") " => " (CODE1 "t"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol-names") " - 文字列指定子のリストの指定子" EOL1
     (STRONG "package") " - パッケージ指定子。デフォルトは現在のパッケージ。")
    (CHAPTER ("## 定義") 2 (CODE1 "shadow") "は、" (STRONG "symbol-names") "によって与えられ名前のシンボルが"
     (STRONG "package") "内に存在することを保証します。" EOL2 "とくに" (STRONG "package") "は"
     (STRONG "symbol-names") "によって指定された名前を持つシンボルを探します。" "そのようなそれぞれの名前に対して、" "もし"
     (STRONG "package") "の中に対応するシンボルが現れなかったとき" "（直接としてであり、継承によるものではないとき）、"
     "対応するシンボルはその名前で作成され、" (STRONG "pacakge") "へ内部シンボルとして挿入されます。" "対応するシンボルは、"
     "既存のものでも新しく作成されたものでもまだ存在していなければ、" (STRONG "package") "の" (CODE1 "shadowing")
     "シンボルリストに追加されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(package-shadowing-symbols (make-package 'temp)) =>  NIL"
      "(find-symbol 'car 'temp) =>  CAR, :INHERITED" "(shadow 'car 'temp) =>  T"
      "(find-symbol 'car 'temp) =>  TEMP::CAR, :INTERNAL"
      "(package-shadowing-symbols 'temp) =>  (TEMP::CAR)"
      "(make-package 'test-1) =>  #<PACKAGE \"TEST-1\">"
      "(intern \"TEST\" (find-package 'test-1)) =>  TEST-1::TEST, NIL"
      "(shadow 'test-1::test (find-package 'test-1)) =>  T"
      "(shadow 'TEST (find-package 'test-1)) =>  T"
      "(assert (not (null (member 'test-1::test (package-shadowing-symbols"
      "                                           (find-package 'test-1))))))" NIL
      "(make-package 'test-2) =>  #<PACKAGE \"TEST-2\">"
      "(intern \"TEST\" (find-package 'test-2)) =>  TEST-2::TEST, NIL"
      "(export 'test-2::test (find-package 'test-2)) =>  T"
      "(use-package 'test-2 (find-package 'test-1))    ;should not error")
     EOL2 " ")
    (CHAPTER ("## 副作用") 2 (CODE1 "shadow") "は、パッケージの一貫したルールが" "その変更によって保持されないような方法で、"
     "パッケージシステムの状態を変更します。")
    (CHAPTER ("## 影響") 2 "パッケージシステムの現在の状態。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "package-shadowing-symbols") "," "11.1. パッケージの説明")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "package") "内に" (STRONG "symbol-names")
     "という名前のシンボルが既に存在していたときは、" "それが継承によるものであったときは、"
     "継承されたシンボルは新しく作成された内部シンボルによってシャドウされます。")))
(setf (gethash '("SHADOW" . "FUNCTION") *table*) (gethash "SHADOW" *table*))
(setf (gethash "SHADOWING-IMPORT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SHADOWING-IMPORT"))
    (CHAPTER ("## 構文") 2 (CODE1 "shadowing-import") " " (STRONG "symbols") " "
     (CODE1 "&optional") " " (STRONG "package") " => " (CODE1 "t"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbols") " - シンボルのリストの指定子" EOL1 (STRONG "package")
     " - パッケージ指定子。デフォルトは現在のパッケージ。")
    (CHAPTER ("## 定義") 2 (CODE1 "shadowing-import") "は" (CODE1 "import") "と似ていますが、" "もし"
     (CODE1 "import") "するシンボルが" (STRONG "package") "内ですでにアクセス可能ないくつかのシンボルに隠蔽されるようなときでも"
     "エラーを通知しません。" EOL2 (CODE1 "shadowing-import") "は、"
     "この操作によって他の同じ名前のシンボルが隠蔽されるかどうかに関わらず、" "各" (STRONG "symbols") "を" (STRONG "package")
     "へ内部シンボルとして追加します。" "もし" (STRONG "package") "に同じ名前の違うシンボルが現れていたときは、" "そのシンボルは最初に"
     (STRONG "package") "から" (CODE1 "unintern") "します。" "新しいシンボルは、" (STRONG "package") "の"
     (CODE1 "shadowing") "シンボルリストに追加されます。" EOL2 (CODE1 "shadowing-import") "は、"
     "同じ名前を持つ既存の別のシンボルがアクセス可能かどうかという範囲で" "名前の衝突チェックを行います。" "もしそうなら、それは新しいシンボルに"
     (CODE1 "shadow") "され、" "もしそれが" (STRONG "package") "内に存在しているならば、" "それは"
     (CODE1 "unintern") "されなければならないことを意味します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(in-package \"COMMON-LISP-USER\") =>  #<PACKAGE \"COMMON-LISP-USER\">"
      "(setq sym (intern \"CONFLICT\")) =>  CONFLICT"
      "(intern \"CONFLICT\" (make-package 'temp)) =>  TEMP::CONFLICT, NIL"
      "(package-shadowing-symbols 'temp) =>  NIL" "(shadowing-import sym 'temp) =>  T "
      "(package-shadowing-symbols 'temp) =>  (CONFLICT)"))
    (CHAPTER ("## 副作用") 2 (CODE1 "shadowing-import") "は、パッケージの一貫したルールが"
     "その変更によって保持されないような方法で、" "パッケージシステムの状態を変更します。" EOL2 (STRONG "package") "の"
     (CODE1 "shadowing") "シンボルリストは変更されます。")
    (CHAPTER ("## 影響") 2 "パッケージシステムの現在の状態。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "import") "," (CODE1 "unintern") ","
     (CODE1 "package-shadowing-symbols"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("SHADOWING-IMPORT" . "FUNCTION") *table*) (gethash "SHADOWING-IMPORT" *table*))
(setf (gethash "SHARED-INITIALIZE" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "SHARED-INITIALIZE"))
    (CHAPTER ("## 構文") 2 (CODE1 "shared-initialize") " " (STRONG "instance") " "
     (STRONG "slot-names") "&rest " (STRONG "initargs") " &key &allow-other-keys" "=> "
     (STRONG "instance"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "shared-initialize") " (" (STRONG "instance") " "
     (CODE1 "standard-object") ") " (STRONG "slot-names") " &rest " (STRONG "initargs"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "instance") " - オブジェクト" EOL1 (STRONG "slot-names")
     " - リストか" (CODE1 "t") EOL1 (STRONG "initargs")
     " - keyword/valueのペアのリスト（初期化引数の名前と値）")
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "shared-initialize") "はインスタンスのスロットに、" "引数"
     (STRONG "initargs") "と" (CODE1 ":initform") "を用いて値を埋めるときに使われます。"
     "この関数の呼び出しは、インスタンスが作成されるとき、" "インスタンスが再初期化されるとき、" "クラスの再定義によりインスタンスが更新されるとき、"
     "違うクラスにインスタンスを従わせるときに行われます。" "ジェネリック関数" (CODE1 "shared-initialize") "は、"
     "システムにより共有されるメソッドである、" (CODE1 "initialize-instance") ", "
     (CODE1 "reinitialize-instance") "," (CODE1 "update-instance-for-redefined-class")
     "," "そして" (CODE1 "update-instance-for-different-class") "によって呼び出されます。" EOL2
     "ジェネリック関数" (CODE1 "shared-initialize") "は、次のような引数を取ります。" "初期化されるインスタンス、"
     "インスタンスがアクセス可能なスロットの名前の集合、" "そして" (STRONG "initargs") "の集合です。" "最初2つの引数のあとの引数は、"
     "初期化引数リストの形を取らなければなりません。" "システムが提供している" (CODE1 "shared-initialize") "のメソッドは、"
     "スロットの値を" (STRONG "initargs") "で指定された" (CODE1 ":initform") "のフォームによって初期化します。"
     (STRONG "slot-names") "は、もしスロットに対して" (STRONG "initargs") "が指定されていなかった場合、"
     (CODE1 ":initform") "によって初期化するべきスロットを指定します。" EOL2
     "スロットがローカルか共有かにかかわらず、システムが共有するメソッドは、" "下記のような振る舞いをします。" EOL2 "- もしスロットに対して、"
     "初期化引数リストにある" (STRONG "initarg") "が値を特定している場合、" "値はそのスロットに格納されます。"
     "もしそのスロットにはすでに値が格納されている場合でも同様に、値が格納されます。" "値の格納は、メソッドが実行する前に行われます。" EOL2 "- "
     (STRONG "slot-names") "で指定されたどんなスロットでも、" "現時点においてまだ" (CODE1 "unbound") "であった場合は、"
     (CODE1 ":initform") "フォームによって初期化されます。" (CODE1 ":initform") "フォームを持ったどんなスロットでも、"
     "フォーム自体は" (CODE1 "defclass") "フォームが宣言されたレキシカル環境によって評価され、" "結果がスロットへ格納されます。" "例えば、"
     (CODE1 "before") "メソッドがスロットに値を格納した場合は、" (CODE1 ":initform")
     "フォームはスロットへの値の供給には使用されないでしょう。" EOL2 "- 規則7.1.4. 初期化引数の規則に従います。" EOL2
     "もし初期化引数が指定されなかった場合、" (STRONG "slot-names") "引数によって指定されたスロットは" (CODE1 ":initform")
     "フォームに従って初期化されます。" (STRONG "slot-names") "はスロットの名前のリストにすることができます。"
     "この場合は、スロットの名前の集合を指定することになります。" "あるいは、" (STRONG "slot-names") "にシンボルである" (CODE1 "t")
     "を指定することもできます。" "この場合は、スロットのすべての集合を指定したことになります。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "initialize-instance") ","
     (CODE1 "reinitialize-instance") "," (CODE1 "update-instance-for-redefined-class")
     "," (CODE1 "update-instance-for-different-class") "," (CODE1 "slot-boundp") ","
     (CODE1 "slot-makunbound") "," "7.1. オブジェクトの作成と初期化," "7.1.4. 初期化引数の規則,"
     "7.1.2. 初期化引数の有効性の宣言")
    (CHAPTER ("## 備考") 2 (STRONG "initarg") "は、" (CODE1 "defclass") "の"
     (CODE1 ":initarg") "オプションを使用するか、" "あるいは" (CODE1 "shared-initialize")
     "のメソッドを定義することで、" "有効な宣言であるとされます。" (CODE1 "shared-initialize") "で定義されたメソッドのラムダリスト内の"
     "各キーワードパラメータ指定子のキーワード名は、" "そのメソッドが適用される全てのクラスで有効な" (STRONG "initarg")
     "の名前として宣言されます。" EOL2 "処理系は、" (CODE1 ":initform") "のフォームを、" "副作用を生成せず依存もせず、" "また"
     (CODE1 "initialize-instance") "のプライマリメソッドで処理するのではなく、" (CODE1 "initialize-instance")
     "メソッドを実行する前に、" "これらのフォームを評価してスロットに値を格納することが、" "最適化では許可されています。" "（この最適化は、"
     (CODE1 "allocate-instance") "メソッドに" "プロトタイプのインスタンスをコピーさせることで実現できるかもしれません。）" EOL2
     "処理系は、初期化引数リストが渡されるメソッドが" "全て" (CODE1 "standard-object") "上のメソッドのみである場合において、"
     "実際には完全な初期化引数リストを作成せず、" (STRONG "initargs") "とスロットを関連付けるよう、"
     "デフォルト初期値フォームを最適化することが許可されています。" "この場合、デフォルトの初期値フォームは、" (CODE1 ":initform")
     "フォームのように扱うことができます。" "この最適化には、パフォーマンスの向上以外に目に見える効果はありません。")))
(setf (gethash '("SHARED-INITIALIZE" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "SHARED-INITIALIZE" *table*))
(setf (gethash "SHIFTF" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "SHIFTF"))
    (CHAPTER ("## 構文") 2 (CODE1 "shiftf") " " (STRONG "place") "+ " (STRONG "newvalue")
     " => " (STRONG "old-value-1"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "place") " - " (CODE1 "place") EOL1
     (STRONG "newvalue") " - フォーム。評価されます。" EOL1 (STRONG "old-value-1") " - オブジェクト（最初の"
     (CODE1 "place") "の古い値）")
    (CHAPTER ("## 定義") 2 (CODE1 "shiftf") "は、各要素の値の変更を行いますが、" "まず" (STRONG "newvalue")
     "を最後の" (CODE1 "place") "へ格納し、" "そのあと2番目から最後までの" (CODE1 "place") "の値を残りの"
     (CODE1 "place") "にシフトします。" EOL2 "もし" (STRONG "newvalue")
     "が格納変数より多い値を生成したときは、余分な値は無視されます。" "もし" (STRONG "newvalue")
     "が格納変数より少ない値しか生成しなかったときは、" "値のないものは" (CODE1 "nil") "がセットされます。" EOL2 "フォームが"
     (CODE1 "(shiftf place1 place2 ... placen newvalue)") "のとき、" (STRONG "place1") "～"
     (STRONG "placen") "までの値を読み込み保存され、" "そして" (STRONG "newvalue") "が評価され、合計で"
     (CODE1 "n+1") "個の値が用意されます。" (CODE1 "2") "～" (CODE1 "n+1") "個目の値は、それぞれ"
     (STRONG "place1") "～" (STRONG "placen") "に格納されます。" "それは全て" (STRONG "place")
     "フォームがシフトレジスタであるかのように扱われます。" (STRONG "newvalue") "は左からシフトされ、全ての値は左へひとつずつシフトされ、"
     "そしてシフトから外された" (STRONG "place1") "値が返却されます。" EOL2 (CODE1 "place")
     "のサブフォームの評価については、5.1.1.1. " (CODE1 "place") "のサブフォームの評価をご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq x (list 1 2 3) y 'trash) =>  TRASH"
      "(shiftf y x (cdr x) '(hi there)) =>  TRASH" "x =>  (2 3)" "y =>  (1 HI THERE)" NIL
      "(setq x (list 'a 'b 'c)) =>  (A B C)" "(shiftf (cadr x) 'z) =>  B" "x =>  (A Z C)"
      "(shiftf (cadr x) (cddr x) 'q) =>  Z" "x =>  (A (C) . Q)" "(setq n 0) =>  0"
      "(setq x (list 'a 'b 'c 'd)) =>  (A B C D)"
      "(shiftf (nth (setq n (+ n 1)) x) 'z) =>  B" "x =>  (A Z C D)"))
    (CHAPTER ("## 影響") 2 (CODE1 "define-setf-expander") "," (CODE1 "defsetf") ","
     (CODE1 "*macroexpand-hook*"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "setf") "," (CODE1 "rotatef") "," "5.1. 一般化された参照")
    (CHAPTER ("## 備考") 2 (CODE1 "(shiftf place1 place2 ... placen newvalue)")
     "の効果は、だいたい次と同等です。"
     (CODE3 "```lisp" "```" "(let ((var1 place1)" "      (var2 place2)" "      ..."
      "      (varn placen)" "      (var0 newvalue))" "  (setf place1 var2)"
      "  (setf place2 var3)" "  ..." "  (setf placen var0)" "  var1)")
     EOL2 "ただし、これは各" (CODE1 "place") "のサブフォームを2度評価していますが、" (CODE1 "shiftf") "はただ一度だけです。"
     "例えば、下記の通り。"
     (CODE3 "```lisp" "```" "(setq n 0) =>  0"
      "(setq x (list 'a 'b 'c 'd)) =>  (A B C D)" "(prog1 (nth (setq n (+ n 1)) x)"
      "       (setf (nth (setq n (+ n 1)) x) 'z)) =>  B" "x =>  (A B Z D)"))))
(setf (gethash '("SHIFTF" . "MACRO") *table*) (gethash "SHIFTF" *table*))
(setf (gethash "SIGNAL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SIGNAL"))
    (CHAPTER ("## 構文") 2 (CODE1 "signal") " " (STRONG "datum") " &rest "
     (STRONG "arguments") " => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "datum") ", " (STRONG "arguments")
     " - コンディション指定子であり、標準の型は" (CODE1 "simple-error") "。")
    (CHAPTER ("## 定義") 2 (STRONG "datum") "と" (STRONG "arguments") "で指定されたコンディションを通知します。"
     "もしコンディションが捕捉されなかったときは、" (CODE1 "signal") "は" (CODE1 "nil") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun handle-division-conditions (condition)"
      "  (format t \"Considering condition for division condition handling~%\")"
      "  (when (and (typep condition 'arithmetic-error)"
      "             (eq '/ (arithmetic-error-operation condition)))"
      "    (invoke-debugger condition)))" "HANDLE-DIVISION-CONDITIONS"
      "(defun handle-other-arithmetic-errors (condition)"
      "  (format t \"Considering condition for arithmetic condition handling~%\")"
      "  (when (typep condition 'arithmetic-error)" "    (abort)))"
      "HANDLE-OTHER-ARITHMETIC-ERRORS"
      "(define-condition a-condition-with-no-handler (condition) ())"
      "A-CONDITION-WITH-NO-HANDLER" "(signal 'a-condition-with-no-handler)" "NIL"
      "(handler-bind ((condition #'handle-division-conditions)"
      "                 (condition #'handle-other-arithmetic-errors))"
      "  (signal 'a-condition-with-no-handler))"
      "Considering condition for division condition handling"
      "Considering condition for arithmetic condition handling" "NIL"
      "(handler-bind ((arithmetic-error #'handle-division-conditions)"
      "                 (arithmetic-error #'handle-other-arithmetic-errors))"
      "  (signal 'arithmetic-error :operation '* :operands '(1.2 b)))"
      "Considering condition for division condition handling"
      "Considering condition for arithmetic condition handling" "Back to Lisp Toplevel"))
    (CHAPTER ("## 副作用") 2 (CODE1 "*break-on-signals*") "により" "デバッガーに入るかもしれません。" EOL2
     "通知されたコンディションのハンドラーは" "遷移を制御するかもしれません。")
    (CHAPTER ("## 影響") 2 "存在するハンドラーの束縛" EOL2 (CODE1 "*break-on-signals*"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "*break-on-signals*") "," (CODE1 "error") ","
     (CODE1 "simple-condition") "," "9.1.4. コンディションの通知と捕捉")
    (CHAPTER ("## 備考") 2 "もし" (CODE1 "(typep datum *break-on-signals*)") "が"
     (STRONG "true") "のときは、" "通知処理を行う前にデバッガーに入ります。" (CODE1 "continue") " "
     (CODE1 "restart") "は通知処理を継続するときに使われます。" "このことは、条件を通知すべき、あるいは通知しなければならない"
     "他のすべての関数やマクロにも当てはまります。")))
(setf (gethash '("SIGNAL" . "FUNCTION") *table*) (gethash "SIGNAL" *table*))
(setf (gethash "SIMPLE-ARRAY" *table*)
  '((CHAPTER NIL 0 "Type " (CODE1 "SIMPLE-ARRAY"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "simple-array") "," (CODE1 "array") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "この型の配列は、他の配列への" (CODE1 "displaced") "ではなく、"
     "fill-pointerを持っておらず、" (CODE1 "adjustable") "でもないものが、" "型" (CODE1 "simple-array")
     "のサブタイプです。" (CODE1 "simple-array") "の考え方は、" "実装が特別な表現を使用できるようにするためと、" "ユーザーが特定の値を常に"
     (CODE1 "simple-array") "にすることを" "宣言できるようにするために存在します。" EOL2 (CODE1 "simple-vector")
     ", " (CODE1 "simple-string") ", " (CODE1 "simple-bit-vector") "の型は、" "互いに素であり、型"
     (CODE1 "simple-array") "のサブタイプです。" "これらは、それぞれ" (CODE1 "(simple-array t (*))") "、"
     (CODE1 "(simple-array c (*))") "の" (CODE1 "c") "は型" (CODE1 "character") "のサブタイプの何か、"
     (CODE1 "(simple-array bit (*))") "を意味します。")
    (CHAPTER ("## 型指定子の種類") 2 "特定化")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "simple-array") " [" (CODE1 "{")
     (STRONG "element-type") " " (CODE1 "|") " \\*" (CODE1 "}") " ["
     (STRONG "dimension-spec") "]]"
     (CODE3 "```" "```" "dimension-spec::= rank | * | ({dimension | *}*) "))
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "dimension") " - 有効な配列の大きさ" EOL1
     (STRONG "element-type") " - 型指定子" EOL1 (STRONG "rank") " - 非負の" (CODE1 "fixnum"))
    (CHAPTER ("## 型指定子の定義") 2 "この合成された型指定子は、" "正確に型" (CODE1 "array") "の合成された型指定子に"
     "対応するものとして扱われますが、" "これは" (CODE1 "simple-array") "のみ含まれるという"
     "より制約がある集合であることが違っています。")
    (CHAPTER ("## 備考") 2 (CODE1 "displaced") "の配列か、fill-pointerを持つ" (CODE1 "vector") "か、"
     "実際に" (CODE1 "adjustable") "な配列が、" (CODE1 "simple-array") "かどうかは" "実装依存です。" EOL2
     (CODE1 "(simple-array *)") "は要素の型によらず全ての" (CODE1 "simple-array") "を参照し、"
     (CODE1 "(simple-array type-specifier)") "は" (CODE1 "make-array") "の"
     (CODE1 ":element-type") "引数として指定された" (STRONG "type-specifier") "の" "結果の"
     (CODE1 "simple-array") "のみを参照します。")))
(setf (gethash '("SIMPLE-ARRAY" . "TYPE") *table*) (gethash "SIMPLE-ARRAY" *table*))
(setf (gethash "SIMPLE-BASE-STRING" *table*)
  '((CHAPTER NIL 0 "Type " (CODE1 "SIMPLE-BASE-STRING"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "simple-base-string") ", " (CODE1 "base-string")
     ", " (CODE1 "simple-string") "," (CODE1 "string") ", " (CODE1 "vector") ","
     (CODE1 "simple-array") ", " (CODE1 "array") ", " (CODE1 "sequence") ", "
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "simple-base-string") "は、"
     (CODE1 "(simple-array base-char (*))") "と同一です。")
    (CHAPTER ("## 型指定子の種類") 2 "省略。")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "simple-base-string") " " (STRONG "[size]"))
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "size") " - 非負の" (CODE1 "fixnum") "か、シンボル"
     (CODE1 "*"))
    (CHAPTER ("## 型指定子の定義") 2 "型" (CODE1 "(simple-array base-char (size))") "と同一です。"
     "このとき、" (STRONG "size") "はsimple-base-stringの集合のサイズです。")))
(setf (gethash '("SIMPLE-BASE-STRING" . "TYPE") *table*) (gethash "SIMPLE-BASE-STRING" *table*))
(setf (gethash "SIMPLE-BIT-VECTOR" *table*)
  '((CHAPTER NIL 0 "Type " (CODE1 "SIMPLE-BIT-VECTOR"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "simple-bit-vector") "," (CODE1 "bit-vector") ","
     (CODE1 "vector") "," (CODE1 "simple-array") "," (CODE1 "array") ","
     (CODE1 "sequence") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "この" (CODE1 "bit-vector") "の型は、他の配列への" (CODE1 "displaced")
     "ではなく、" "fill-pointerを持っておらず、" (CODE1 "adjustable") "でもないものが、" "型"
     (CODE1 "simple-bit-vector") "のサブタイプです。")
    (CHAPTER ("## 型指定子の種類") 2 "省略形")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "simple-bit-vector") " [" (STRONG "size") "]")
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "size") " - 非負の" (CODE1 "fixnum") "か、シンボル"
     (CODE1 "*") "。デフォルトはシンボル" (CODE1 "*") "。")
    (CHAPTER ("## 型指定子の定義") 2 "これは型" (CODE1 "(simple-array bit (size))") "と同じであり、"
     "つまりサイズ" (STRONG "size") "の" (CODE1 "simple-bit-vector") "の集合です。")))
(setf (gethash '("SIMPLE-BIT-VECTOR" . "TYPE") *table*) (gethash "SIMPLE-BIT-VECTOR" *table*))
(setf (gethash "SIMPLE-BIT-VECTOR-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SIMPLE-BIT-VECTOR-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "simple-bit-vector-p") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が型" (CODE1 "simple-bit-vector") "のときは"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(simple-bit-vector-p (make-array 6)) =>  false"
      "(simple-bit-vector-p #*) =>  true"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "simple-vector-p"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```"
      "(simple-bit-vector-p object) ==  (typep object 'simple-bit-vector)"))))
(setf (gethash '("SIMPLE-BIT-VECTOR-P" . "FUNCTION") *table*) (gethash "SIMPLE-BIT-VECTOR-P" *table*))
(setf (gethash "SIMPLE-CONDITION" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "SIMPLE-CONDITION"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "simple-condition") "," (CODE1 "condition") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "simple-condition") "は、" (CODE1 "signal") "関数が"
     "その最初の引数を" (STRONG "format-control") "で指定して" "いつでも通知できるようなコンディションの表現です。"
     (STRONG "format-control") "と" (STRONG "format-arguments") "は、"
     (CODE1 "make-condition") "によって" "それぞれ" (CODE1 ":format-control") "と"
     (CODE1 ":format-arguments") "という" "初期化引数で初期化され、" "またそれらは"
     (CODE1 "simple-condition-format-control") "と"
     (CODE1 "simple-condition-format-arguments") "という関数でアクセスできます。" "もし"
     (CODE1 "make-condition") "で" (STRONG "format-arguments") "が指定されなかったときは、" "デフォルト値として"
     (CODE1 "nil") "が使用されます。")
    (CHAPTER ("## 参考") 2 (CODE1 "simple-condition-format-control") ","
     (CODE1 "simple-condition-format-arguments"))))
(setf (gethash '("SIMPLE-CONDITION" . "CONDITION-TYPE") *table*) (gethash "SIMPLE-CONDITION" *table*))
(setf (gethash "SIMPLE-CONDITION-FORMAT-ARGUMENTS" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SIMPLE-CONDITION-FORMAT-CONTROL") ", "
     (CODE1 "SIMPLE-CONDITION-FORMAT-ARGUMENTS"))
    (CHAPTER ("## 構文") 2 (CODE1 "simple-condition-format-control") " "
     (STRONG "condition") " => " (STRONG "format-control") EOL1
     (CODE1 "simple-condition-format-arguments") " " (STRONG "condition") " => "
     (STRONG "format-arguments"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "condition") " - 型" (CODE1 "simple-condition")
     "のコンディション" EOL1 (STRONG "format-control") " - format-control" EOL1
     (STRONG "format-arguments") " - リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "simple-condition-format-control") "は、"
     (STRONG "condition") "の" (STRONG "format-arguments") "の処理で必要になる"
     (STRONG "format-control") "を返却します。" EOL2 (CODE1 "simple-condition-format-arguments")
     "は、" (STRONG "condition") "の" (STRONG "format-control") "の処理で必要になる"
     (STRONG "format-arguments") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq foo (make-condition 'simple-condition"
      "                         :format-control \"Hi ~S\""
      "                         :format-arguments '(ho)))"
      "=>  #<SIMPLE-CONDITION 26223553>"
      "(apply #'format nil (simple-condition-format-control foo)"
      "                    (simple-condition-format-arguments foo))" "=>  \"Hi HO\""))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "simple-condition") "," "9.1. コンディションシステムの説明")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("SIMPLE-CONDITION-FORMAT-ARGUMENTS" . "FUNCTION") *table*) (gethash "SIMPLE-CONDITION-FORMAT-ARGUMENTS" *table*))
(setf (gethash "SIMPLE-CONDITION-FORMAT-CONTROL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SIMPLE-CONDITION-FORMAT-CONTROL") ", "
     (CODE1 "SIMPLE-CONDITION-FORMAT-ARGUMENTS"))
    (CHAPTER ("## 構文") 2 (CODE1 "simple-condition-format-control") " "
     (STRONG "condition") " => " (STRONG "format-control") EOL1
     (CODE1 "simple-condition-format-arguments") " " (STRONG "condition") " => "
     (STRONG "format-arguments"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "condition") " - 型" (CODE1 "simple-condition")
     "のコンディション" EOL1 (STRONG "format-control") " - format-control" EOL1
     (STRONG "format-arguments") " - リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "simple-condition-format-control") "は、"
     (STRONG "condition") "の" (STRONG "format-arguments") "の処理で必要になる"
     (STRONG "format-control") "を返却します。" EOL2 (CODE1 "simple-condition-format-arguments")
     "は、" (STRONG "condition") "の" (STRONG "format-control") "の処理で必要になる"
     (STRONG "format-arguments") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq foo (make-condition 'simple-condition"
      "                         :format-control \"Hi ~S\""
      "                         :format-arguments '(ho)))"
      "=>  #<SIMPLE-CONDITION 26223553>"
      "(apply #'format nil (simple-condition-format-control foo)"
      "                    (simple-condition-format-arguments foo))" "=>  \"Hi HO\""))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "simple-condition") "," "9.1. コンディションシステムの説明")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("SIMPLE-CONDITION-FORMAT-CONTROL" . "FUNCTION") *table*) (gethash "SIMPLE-CONDITION-FORMAT-CONTROL" *table*))
(setf (gethash "SIMPLE-ERROR" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "SIMPLE-ERROR"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "simple-error") "," (CODE1 "simple-condition")
     "," (CODE1 "error") "," (CODE1 "serious-condition") "," (CODE1 "condition") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "simple-error") "は、" (CODE1 "error") "か"
     (CODE1 "cerror") "によって" "format-controlが関数の最初の引数として与えられたときに" "通知されるコンディションを含みます。")))
(setf (gethash '("SIMPLE-ERROR" . "CONDITION-TYPE") *table*) (gethash "SIMPLE-ERROR" *table*))
(setf (gethash "SIMPLE-STRING" *table*)
  '((CHAPTER NIL 0 "Type " (CODE1 "SIMPLE-STRING"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "simple-string") ", " (CODE1 "string") ", "
     (CODE1 "vector") "," (CODE1 "simple-array") ", " (CODE1 "array") ", "
     (CODE1 "sequence") ", " (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "simple-stringとは、一次元に特化したsimple-arrayであり、" "その要素は"
     (CODE1 "character") "か、" "あるいは" (CODE1 "character") "のサブタイプです。" EOL2
     "オブジェクトの生成時に型指定子として使用された場合、" (CODE1 "simple-string") "は"
     (CODE1 "(simple-array character (size))") "を意味します。")
    (CHAPTER ("## 型指定子の種類") 2 "省略。")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "simple-string") " " (STRONG "[size]"))
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "size") " - 非負の" (CODE1 "fixnum") "か、シンボル"
     (CODE1 "*"))
    (CHAPTER ("## 型指定子の定義") 2 (CODE1 "character") "の全てのサブタイプを" (CODE1 "c") "としたとき、" "全ての"
     (CODE1 "(simple-array c (size))") "の和集合を示します。" "このとき、" (STRONG "size")
     "はsimple-stringの集合のサイズです。")))
(setf (gethash '("SIMPLE-STRING" . "TYPE") *table*) (gethash "SIMPLE-STRING" *table*))
(setf (gethash "SIMPLE-STRING-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SIMPLE-STRING-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "simple-string-p") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が型" (CODE1 "simple-string") "なら"
     (STRONG "true") "、それ以外は" (STRONG "false") "を返却。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(simple-string-p \"aaaaaa\") =>  true"
      "(simple-string-p (make-array 6 "
      "                             :element-type 'character "
      "                             :fill-pointer t)) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```"
      "(simple-string-p object) ==  (typep object 'simple-string)"))))
(setf (gethash '("SIMPLE-STRING-P" . "FUNCTION") *table*) (gethash "SIMPLE-STRING-P" *table*))
(setf (gethash "SIMPLE-TYPE-ERROR" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "SIMPLE-TYPE-ERROR"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "simple-type-error") ","
     (CODE1 "simple-condition") "," (CODE1 "type-error") "," (CODE1 "error") ","
     (CODE1 "serious-condition") "," (CODE1 "condition") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "simple-type-error") "のコンディションは、" "型"
     (CODE1 "type-error") "のコンディションと似ていますが、" "どのようにコンディションを報告するか指定するための"
     "別の機能が提供されている点が違っています。" "型" (CODE1 "simple-condition") "をご確認ください。")
    (CHAPTER ("## 参考") 2 (CODE1 "simple-condition") ","
     (CODE1 "simple-condition-format-control") ","
     (CODE1 "simple-condition-format-arguments") "," (CODE1 "type-error-datum") ","
     (CODE1 "type-error-expected-type"))))
(setf (gethash '("SIMPLE-TYPE-ERROR" . "CONDITION-TYPE") *table*) (gethash "SIMPLE-TYPE-ERROR" *table*))
(setf (gethash "SIMPLE-VECTOR" *table*)
  '((CHAPTER NIL 0 "Type " (CODE1 "SIMPLE-VECTOR"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "simple-vector") "," (CODE1 "vector") ","
     (CODE1 "simple-array") "," (CODE1 "array") "," (CODE1 "sequence") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "この" (CODE1 "vector") "の型は、他の配列への" (CODE1 "displaced") "ではなく、"
     "fill-pointerを持っておらず、" (CODE1 "adjustable") "でもなく、" "どんな型の要素でも格納できるものが、" "型"
     (CODE1 "simple-vector") "のサブタイプです。" EOL2 "型" (CODE1 "simple-vector") "は、型"
     (CODE1 "vector") "のサブタイプであり、" "型" (CODE1 "(vector t)") "のサブタイプです。")
    (CHAPTER ("## 型指定子の種類") 2 "特定化")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "simple-vector") " [" (STRONG "size") "]")
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "size") " - 非負の" (CODE1 "fixnum") "か、シンボル"
     (CODE1 "*") "。デフォルトはシンボル" (CODE1 "*") "。")
    (CHAPTER ("## 型指定子の定義") 2 (CODE1 "(simple-array t (size))") "と同じ。")))
(setf (gethash '("SIMPLE-VECTOR" . "TYPE") *table*) (gethash "SIMPLE-VECTOR" *table*))
(setf (gethash "SIMPLE-VECTOR-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SIMPLE-VECTOR-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "simple-vector-p") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が型" (CODE1 "simple-vector") "のときは"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(simple-vector-p (make-array 6)) =>  true"
      "(simple-vector-p \"aaaaaa\") =>  false"
      "(simple-vector-p (make-array 6 :fill-pointer t)) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "simple-vector"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(simple-vector-p object) == (typep object 'simple-vector)"))))
(setf (gethash '("SIMPLE-VECTOR-P" . "FUNCTION") *table*) (gethash "SIMPLE-VECTOR-P" *table*))
(setf (gethash "SIMPLE-WARNING" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "SIMPLE-WARNING"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "simple-warning") "," (CODE1 "simple-condition")
     "," (CODE1 "warning") "," (CODE1 "condition") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "simple-warning") "は、" (CODE1 "warn") "関数が"
     "その最初の引数を" (STRONG "format-control") "で指定して" "いつでも通知できるようなコンディションの表現です。")))
(setf (gethash '("SIMPLE-WARNING" . "CONDITION-TYPE") *table*) (gethash "SIMPLE-WARNING" *table*))
(setf (gethash "SIXTH" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "FIRST") ", " (CODE1 "SECOND") ", " (CODE1 "THIRD")
     ", " (CODE1 "FOURTH") ", " (CODE1 "FIFTH") "," (CODE1 "SIXTH") ", "
     (CODE1 "SEVENTH") ", " (CODE1 "EIGHTH") ", " (CODE1 "NINTH") ", " (CODE1 "TENTH"))
    (CHAPTER ("## 構文") 2 (CODE1 "first") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "second") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "third") " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fourth")
     " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fifth") " "
     (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "sixth") " " (STRONG "list")
     " => " (STRONG "object") EOL1 (CODE1 "seventh") " " (STRONG "list") " => "
     (STRONG "object") EOL1 (CODE1 "eighth") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "ninth") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "tenth") " " (STRONG "list") " => " (STRONG "object") EOL1 "(" (CODE1 "setf")
     " (" (CODE1 "first") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "second") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "third") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "fourth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "fifth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "sixth") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "seventh") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "eighth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "ninth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "tenth") " " (STRONG "list") ") " (STRONG "new-object")
     ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト、ドットリストと循環リストも受け付けます。" EOL1
     (STRONG "object") ", " (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "関数" (CODE1 "first") ", " (CODE1 "second") ", " (CODE1 "third")
     ", " (CODE1 "fourth") ", " (CODE1 "fifth") "," (CODE1 "sixth") ", "
     (CODE1 "seventh") ", " (CODE1 "eighth") ", " (CODE1 "ninth") ", " (CODE1 "tenth")
     "は、" "それぞれリストの1番目、2番目、3番目、4番目、5番目、" "6番目、7番目、8番目、9番目、10番目の要素にアクセスします。"
     "具体的には次のようになります。"
     (CODE3 "```lisp" "```" "(first list)    ==   (car list)"
      "(second list)   ==   (car (cdr list))" "(third list)    ==   (car (cddr list))"
      "(fourth list)   ==   (car (cdddr list))"
      "(fifth list)    ==   (car (cddddr list))"
      "(sixth list)    ==   (car (cdr (cddddr list)))"
      "(seventh list)  ==   (car (cddr (cddddr list)))"
      "(eighth list)   ==   (car (cdddr (cddddr list)))"
      "(ninth list)    ==   (car (cddddr (cddddr list)))"
      "(tenth list)    ==   (car (cdr (cddddr (cddddr list))))")
     EOL2 (CODE1 "setf") "は、これらの関数を使うことによって" "既存の構成要素を変更することもできます。"
     "上記の等価な関係を用いて同じように適用できます。" "例えば次のようになります。"
     (CODE3 "```lisp" "```"
      "(setf (fifth list) new-object) == (setf (car (cddddr list)) new-object)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst '(1 2 3 (4 5 6) ((V)) vi 7 8 9 10)) "
      "=>  (1 2 3 (4 5 6) ((V)) VI 7 8 9 10)" "(first lst) =>  1" "(tenth lst) =>  10"
      "(fifth lst) =>  ((V))" "(second (fourth lst)) =>  5" "(sixth '(1 2 3)) =>  NIL"
      "(setf (fourth lst) \"four\") =>  \"four\""
      "lst =>  (1 2 3 \"four\" ((V)) VI 7 8 9 10)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "car") "," (CODE1 "nth"))
    (CHAPTER ("## 備考") 2 (CODE1 "first") "は機能的には" (CODE1 "car") "と同じです。" (CODE1 "second")
     "は機能的には" (CODE1 "cadr") "と同じです。" (CODE1 "third") "は機能的には" (CODE1 "caddr") "と同じです。"
     (CODE1 "fourth") "は機能的には" (CODE1 "cadddr") "と同じです。" EOL2 "通常の番号付けは1から開始しますが、"
     (CODE1 "nth") "によって使われる採番は0開始であり、" "次の関係が成り立ちます。"
     (CODE3 "```lisp" "```" "(fifth x) == (nth 4 x)"))))
(setf (gethash '("SIXTH" . "ACCESSOR") *table*) (gethash "SIXTH" *table*))
(setf (gethash "SLOT-BOUNDP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SLOT-BOUNDP"))
    (CHAPTER ("## 構文") 2 (CODE1 "slot-boundp") " " (STRONG "instance") " "
     (STRONG "slot-name") " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "instance") " - オブジェクト" EOL1 (STRONG "slot-name")
     " - " (STRONG "instance") "のスロットの名前であるシンボル" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "instance") "のスロット" (STRONG "slot-name")
     "に値がある(bound)なら" (STRONG "true") "、" "それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "instance") "に" (STRONG "slot-name") "のスロットがない場合は、"
     "下記のように" (CODE1 "slot-missing") "が呼ばれます。"
     (CODE3 "```lisp" "```" "(slot-missing (class-of instance)" "              instance"
      "              slot-name" "              'slot-boundp)")
     EOL2 "（もし" (CODE1 "slot-missing") "が起動されて値が返却されたとき、" "第一返却値はブール値であるとされて、"
     (CODE1 "slot-boundp") "として返却されます。）" EOL2 "具体的なふるまいは、" (STRONG "instance")
     "のメタクラスに依存します。" "もし" (STRONG "instance") "のメタクラスが" (CODE1 "standard-class") "なら、"
     "決してエラーは発生しません。" "もし" (STRONG "instance") "のメタクラスが" (CODE1 "built-in-class") "なら、"
     "常にエラーが発生します。" "もし" (STRONG "instance") "が他のメタクラスなら結果は規定されておらず、"
     "状況によってエラーが発生するかもしれませんし、" "されないかもしれません。" "特にコンディションと構造体についての動作は規定されていません。")
    (CHAPTER ("## 参考") 2 (CODE1 "slot-makunbound") "," (CODE1 "slot-missing"))
    (CHAPTER ("## 備考") 2 "関数" (CODE1 "slot-boundp") "は、" (CODE1 "initialize-instance")
     "の" (CODE1 "after") "メソッド作成時に、" "まだ値を持っていないスロットのみを初期化するために" "使用することができます。" EOL2
     "実装は必須ではありませんが、" "実装者はMetaobject Protocolで説明されている" "関数"
     (CODE1 "slot-boundp-using-class") "を使用して" "関数" (CODE1 "slot-boundp")
     "を実装することが強く推奨されます。")))
(setf (gethash '("SLOT-BOUNDP" . "FUNCTION") *table*) (gethash "SLOT-BOUNDP" *table*))
(setf (gethash "SLOT-BOUNDP-USING-CLASS" *table*)
  '((CHAPTER NIL 0 "Generic Function " (CODE1 "SLOT-BOUNDP-USING-CLASS"))
    (CHAPTER ("## 構文") 2 (CODE1 "slot-boundp-using-class") " " (STRONG "class") " "
     (STRONG "object") " " (STRONG "slot") " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "class") " - メタオブジェクトのクラス。これは引数" (STRONG "object")
     "のクラスです。" EOL1 (STRONG "object") " - オブジェクト" EOL1 (STRONG "slot") " - "
     (CODE1 "effective-slot-definition") "メタオブジェクト" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "このジェネリック関数は、" (CODE1 "slot-boundp") "関数の振る舞いを実装します。" "これは第一引数が"
     (STRONG "object") "のクラスであり、" "第三引数が" (CODE1 "effective-slot-definition")
     "メタオブジェクトに関連するものが指定されて" (CODE1 "slot-boundp") "によって呼び出されます。" EOL2 "ジェネリック関数"
     (CODE1 "slot-boundp-using-class") "は、" "インスタンスにある指定したスロットが" (CODE1 "bound")
     "であるかどうかを確認します。" EOL2 "もし引数" (STRONG "class") "が引数" (STRONG "object")
     "のクラスではなかったときか、" "あるいはもし引数" (STRONG "slot") "が引数" (STRONG "class") "に関連付けられている"
     (CODE1 "effective-slot") "の集合に存在しなかった場合は、" "結果は未定義です。")
    (CHAPTER ("## メソッド") 2 (CODE1 "slot-boundp-using-class") " (" (STRONG "class") " "
     (CODE1 "standard-class") ")" " " (STRONG "object") " (" (STRONG "slot") " "
     (CODE1 "standard-effective-slot-definition") ")" EOL1
     (CODE1 "slot-boundp-using-class") " (" (STRONG "class") " "
     (CODE1 "funcallable-standard-class") ")" " " (STRONG "object") " (" (STRONG "slot")
     " " (CODE1 "standard-effective-slot-definition") ")" EOL1
     (CODE1 "slot-boundp-using-class") " (" (STRONG "class") " " (CODE1 "built-in-class")
     ") " (STRONG "object") " " (STRONG "slot"))
    (CHAPTER ("## Method " (CODE1 "slot-boundp-using-class") "") 2
     (CODE1 "slot-boundp-using-class") " (" (STRONG "class") " " (CODE1 "standard-class")
     ")" " " (STRONG "object") " (" (STRONG "slot") " "
     (CODE1 "standard-effective-slot-definition") ")" " => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "slot-boundp-using-class") " ("
     (STRONG "class") " " (CODE1 "funcallable-standard-class") ")" " " (STRONG "object")
     " (" (STRONG "slot") " " (CODE1 "standard-effective-slot-definition") ")" " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("### 定義") 3 "このメソッドは、" (CODE1 ":instance") "と" (CODE1 ":class")
     "で確保されたスロットに対しての" "完全な振る舞いを行うジェネリック関数の実装です。" "もしスロットが" (CODE1 ":instance") "か"
     (CODE1 ":class") "ではない" "他の確保の値を持っていたときはエラーが通知されます。" EOL2 "このメソッドの上書きは許されていますが、"
     "他のスロットへのアクセスのプロトコルに対しての" "標準で用意されている実装も上書きする必要があるかもしれません。")
    (CHAPTER ("## Method " (CODE1 "slot-boundp-using-class") "") 2
     (CODE1 "slot-boundp-using-class") " (" (STRONG "class") " " (CODE1 "built-in-class")
     ") " (STRONG "object") " " (STRONG "slot") " => " (CODE1 "|"))
    (CHAPTER ("### 定義") 3 "このメソッドはエラーが発生します。")
    (CHAPTER ("## コメントと備考") 2 "もしクラスのメタオブジェクトのクラスが" "スロットについて" (CODE1 "unbound")
     "かどうか区別がつかないときは、" (STRONG "true") "を返却するべきです。")))
(setf (gethash '("SLOT-BOUNDP-USING-CLASS" . "GENERIC-FUNCTION") *table*) (gethash "SLOT-BOUNDP-USING-CLASS" *table*))
(setf (gethash "SLOT-EXISTS-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SLOT-EXISTS-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "slot-exists-p") " " (STRONG "object") " "
     (STRONG "slot-name") " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "slot-name")
     " - シンボル" EOL1 (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が" (STRONG "slot-name") "という名前のスロットを持っているとき"
     (STRONG "true") "を返却します。")
    (CHAPTER ("## 例文") 2 "なし。")
    (CHAPTER ("## 影響") 2 (CODE1 "defclass") ", " (CODE1 "defstruct"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "defclass") ", " (CODE1 "slot-missing"))
    (CHAPTER ("## 備考") 2 "実装は必須ではありませんが、" "実装者はMetaobject Protocolで説明されている" "関数"
     (CODE1 "slot-exists-p-using-class") "を使用して" "関数" (CODE1 "slot-exists-p")
     "を実装することが強く推奨されます。")))
(setf (gethash '("SLOT-EXISTS-P" . "FUNCTION") *table*) (gethash "SLOT-EXISTS-P" *table*))
(setf (gethash "SLOT-MAKUNBOUND" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SLOT-MAKUNBOUND"))
    (CHAPTER ("## 構文") 2 (CODE1 "slot-makunbound") " " (STRONG "instance") " "
     (STRONG "slot-name") " => " (STRONG "instance"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "instance") " - オブジェクト" EOL1 (STRONG "slot-name")
     " - シンボル")
    (CHAPTER ("## 定義") 2 "関数" (CODE1 "slot-makunbound") "は、" (STRONG "instance") "の"
     (STRONG "slot-name") "という名前のスロットを" (CODE1 "unbound") "状態にします。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "instance") "に" (STRONG "slot-name") "のスロットがない場合は、"
     "下記のように" (CODE1 "slot-missing") "が呼ばれます。"
     (CODE3 "```lisp" "```" "(slot-missing (class-of instance)" "              instance"
      "              slot-name" "              'slot-makunbound)")
     EOL2 "（この場合、" (CODE1 "slot-missing") "から返却されたどんな値も、" (CODE1 "slot-makunbound")
     "によって無視されます。）" EOL2 "具体的なふるまいは、" (STRONG "instance") "のメタクラスに依存します。" "もし"
     (STRONG "instance") "のメタクラスが" (CODE1 "standard-class") "なら、" "決してエラーは発生しません。" "もし"
     (STRONG "instance") "のメタクラスが" (CODE1 "built-in-class") "なら、" "常にエラーが発生します。" "もし"
     (STRONG "instance") "が他のメタクラスなら結果は規定されておらず、" "状況によってエラーが発生するかもしれませんし、"
     "されないかもしれません。" "特にコンディションと構造体についての動作は規定されていません。")
    (CHAPTER ("## 参考") 2 (CODE1 "slot-boundp") "," (CODE1 "slot-missing"))
    (CHAPTER ("## 備考") 2 "実装は必須ではありませんが、" "実装者はMetaobject Protocolで説明されている" "関数"
     (CODE1 "slot-makunbound-using-class") "を使用して" "関数" (CODE1 "slot-makunbound")
     "を実装することが強く推奨されます。")))
(setf (gethash '("SLOT-MAKUNBOUND" . "FUNCTION") *table*) (gethash "SLOT-MAKUNBOUND" *table*))
(setf (gethash "SLOT-MAKUNBOUND-USING-CLASS" *table*)
  '((CHAPTER NIL 0 "Generic Function " (CODE1 "SLOT-MAKUNBOUND-USING-CLASS"))
    (CHAPTER ("## 構文") 2 (CODE1 "slot-makunbound-using-class") " " (STRONG "class") " "
     (STRONG "object") " " (STRONG "slot") " => " (STRONG "object"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "class") " - メタオブジェクトのクラス。これは引数" (STRONG "object")
     "のクラスです。" EOL1 (STRONG "object") " - オブジェクト" EOL1 (STRONG "slot") " - "
     (CODE1 "effective-slot-definition") "メタオブジェクト")
    (CHAPTER ("## 定義") 2 "このジェネリック関数は、" (CODE1 "slot-makunbound") "関数の振る舞いを実装します。"
     "これは第一引数が" (STRONG "object") "のクラスであり、" "第三引数が" (CODE1 "effective-slot-definition")
     "メタオブジェクトに関連するものが指定されて" (CODE1 "slot-makunbound") "によって呼び出されます。" EOL2 "ジェネリック関数"
     (CODE1 "slot-makunbound-using-class") "は、" (STRONG "object") "の" (STRONG "slot") "を"
     (CODE1 "unbound") "の状態に戻します。" "「スロットを" (CODE1 "unbound") "状態に戻す」という解釈は、"
     "クラスのメタオブジェクトクラスに依存します。" EOL2 "もし引数" (STRONG "class") "が引数" (STRONG "object")
     "のクラスではなかったときか、" "あるいはもし引数" (STRONG "slot") "が引数" (STRONG "class") "に関連付けられている"
     (CODE1 "effective-slot") "の集合に存在しなかった場合は、" "結果は未定義です。")
    (CHAPTER ("## メソッド") 2 (CODE1 "slot-makunbound-using-class") " (" (STRONG "class")
     " " (CODE1 "standard-class") ")" " " (STRONG "object") " (" (STRONG "slot") " "
     (CODE1 "standard-effective-slot-definition") ")" EOL1
     (CODE1 "slot-makunbound-using-class") " (" (STRONG "class") " "
     (CODE1 "funcallable-standard-class") ")" " " (STRONG "object") " (" (STRONG "slot")
     " " (CODE1 "standard-effective-slot-definition") ")" EOL1
     (CODE1 "slot-makunbound-using-class") " (" (STRONG "class") " "
     (CODE1 "built-in-class") ") " (STRONG "object") " " (STRONG "slot"))
    (CHAPTER ("## Method " (CODE1 "slot-makunbound-using-class") "") 2
     (CODE1 "slot-makunbound-using-class") " (" (STRONG "class") " "
     (CODE1 "standard-class") ")" " " (STRONG "object") " (" (STRONG "slot") " "
     (CODE1 "standard-effective-slot-definition") ")" " => " (STRONG "object") EOL1
     (CODE1 "slot-makunbound-using-class") " (" (STRONG "class") " "
     (CODE1 "funcallable-standard-class") ")" " " (STRONG "object") " (" (STRONG "slot")
     " " (CODE1 "standard-effective-slot-definition") ")" " => " (STRONG "object"))
    (CHAPTER ("### 定義") 3 "このメソッドは、" (CODE1 ":instance") "と" (CODE1 ":class")
     "で確保されたスロットに対しての" "完全な振る舞いを行うジェネリック関数の実装です。" "もしスロットが" (CODE1 ":instance") "か"
     (CODE1 ":class") "ではない" "他の確保の値を持っていたときはエラーが通知されます。" EOL2 "このメソッドの上書きは許されていますが、"
     "他のスロットへのアクセスのプロトコルに対しての" "標準で用意されている実装も上書きする必要があるかもしれません。")
    (CHAPTER ("## Method " (CODE1 "slot-makunbound-using-class") "") 2
     (CODE1 "slot-makunbound-using-class") " (" (STRONG "class") " "
     (CODE1 "built-in-class") ") " (STRONG "object") " " (STRONG "slot") " => "
     (CODE1 "|"))
    (CHAPTER ("### 定義") 3 "このメソッドはエラーが発生します。")))
(setf (gethash '("SLOT-MAKUNBOUND-USING-CLASS" . "GENERIC-FUNCTION") *table*) (gethash "SLOT-MAKUNBOUND-USING-CLASS" *table*))
(setf (gethash "SLOT-MISSING" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "SLOT-MISSING"))
    (CHAPTER ("## 構文") 2 (CODE1 "slot-missing") " " (STRONG "class") " "
     (STRONG "object") " " (STRONG "slot-name") " " (STRONG "operation") " &optional "
     (STRONG "new-value") "=> " (STRONG "result\\*"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "slot-missing") " (" (STRONG "class") " " (CODE1 "t")
     ")" (STRONG "object") " " (STRONG "slot-name") " " (STRONG "operation")
     " &optional " (STRONG "new-value"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "class") " - " (STRONG "object") "のクラス" EOL1
     (STRONG "object") " - オブジェクト" EOL1 (STRONG "slot-name") " - シンボル（おそらくはスロットの名前）" EOL1
     (STRONG "operation") " - 次のどれかのシンボル、" (CODE1 "setf") ", " (CODE1 "slot-boundp") ", "
     (CODE1 "slot-makunbound") ", " (CODE1 "slot-value") "." EOL1 (STRONG "new-value")
     " - オブジェクト" EOL1 (STRONG "result") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "slot-missing") "は、" "メタクラスが"
     (CODE1 "standard-class") "の" (STRONG "object") "のスロットに" "アクセスしようとしたとき、" "スロットの名前"
     (STRONG "slot-name") "がそのクラスに" "存在しなかったときに呼び出されます。" "標準のメソッドでは、エラーが発生します。" EOL2
     "ジェネリック関数" (CODE1 "slot-missing") "は、" "プログラマーによって呼び出されることを想定していません。"
     "プログラマーはメソッドを書くことができます。" EOL2 "ジェネリック関数" (CODE1 "slot-missing") "は、" "次の関数"
     (CODE1 "slot-value") ", " (CODE1 "(setf slot-value)") "," (CODE1 "slot-boundp") ", "
     (CODE1 "slot-makunbound") "の評価中に" "呼び出されるかもしれません。" "これらの操作は、関数の引数" (STRONG "symbol")
     "に、" "それぞれ" (CODE1 "slot-value") ", " (CODE1 "setf") "," (CODE1 "slot-boundp") ", "
     (CODE1 "slot-makunbound") "で対応します。" EOL2 (CODE1 "slot-missing") "のオプションの"
     (STRONG "new-value") "引数は、" "操作がスロットに値をセットしようとするときに使われます。" EOL2 "もし"
     (CODE1 "slot-missing") "が値を返却したとき、" "その値は次のように扱われます。" EOL2 "- 操作が" (CODE1 "setf")
     "か" (CODE1 "slot-makunbound") "のときは、" "呼び出し側によってどんな返却値でも無視されます。" EOL2 "- 操作が"
     (CODE1 "slot-value") "のときは、" "呼び出し側によって第一返却値が使われ、" "他の全ての値は無視されます。" EOL2 "- 操作が"
     (CODE1 "slot-boundp") "のときは、" "メソッドの第一返却値をブール値とされて使用され、" "他の全ての値は無視されます。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (CODE1 "slot-missing") "の標準のメソッドでは、" "型" (CODE1 "error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "defclass") "," (CODE1 "slot-exists-p") ","
     (CODE1 "slot-value"))
    (CHAPTER ("## 備考") 2 "引数のセット（インスタンスのクラス" (STRONG "class") "を含む）は、"
     (CODE1 "slot-missing") "のメタクラスによるメソッドの定義が容易になります。")))
(setf (gethash '("SLOT-MISSING" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "SLOT-MISSING" *table*))
(setf (gethash "SLOT-UNBOUND" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function " (CODE1 "SLOT-UNBOUND"))
    (CHAPTER ("## 構文") 2 (CODE1 "slot-unbound") " " (STRONG "class") " "
     (STRONG "instance") " " (STRONG "slot-name") " => " (STRONG "result\\*"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "slot-unbound") " (" (STRONG "class") " " (CODE1 "t")
     ") " (STRONG "instance") " " (STRONG "slot-name"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "class") " - インスタンス" (STRONG "instance") "のクラス" EOL1
     (STRONG "instance") " - " (CODE1 "unbound") "スロットから読み込みしたインスタンス" EOL1
     (STRONG "slot-name") " - " (CODE1 "unbound") "スロットの名前" EOL1 (STRONG "result")
     " - オブジェクト")
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "slot-unbound") "は、" "メタクラスが"
     (CODE1 "standard-class") "の" (STRONG "instance") "から" (CODE1 "unbound")
     "スロットを読み込んだ時に呼び出されます。" "デフォルトのメソッドは、型" (CODE1 "unbound-slot") "のエラーが発生します。"
     (CODE1 "unbound-slot") "コンディションの名前のスロットは" "問題の変数の名前で初期化され、" (CODE1 "unbound-slot")
     "コンディションのインスタンスのスロットは" "問題の" (STRONG "instance") "で初期化されます。" EOL2 "ジェネリック関数"
     (CODE1 "slot-unbound") "は、" "プログラマーによって呼び出されることを想定していません。" "プログラマーはメソッドを書くことができます。"
     "関数" (CODE1 "slot-unbound") "は、間接的に" (CODE1 "slot-value") "によってのみ呼び出されます。" EOL2
     (CODE1 "slot-unbound") "の戻り値は、" "ただ第一返却値のみが呼び出し側によって使われ、" "他の全ての返却値は無視されます。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (CODE1 "slot-unbound") "のデフォルトのメソッドは、" "型"
     (CODE1 "unbound-slot") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "slot-makunbound"))
    (CHAPTER ("## 備考") 2 "スロットに" (CODE1 ":initform") "が指定されず値もセットされていないときか、" "あるいは"
     (CODE1 "slot-makunbound") "がスロットに対して呼び出されたとき、" (CODE1 "unbound") "スロットが起こることがあります。")))
(setf (gethash '("SLOT-UNBOUND" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "SLOT-UNBOUND" *table*))
(setf (gethash "SLOT-VALUE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SLOT-VALUE"))
    (CHAPTER ("## 構文") 2 (CODE1 "slot-value") " " (STRONG "object") " "
     (STRONG "slot-name") " => " (STRONG "value"))
    (CHAPTER ("## Arguments and Values:") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "name") " - シンボル" EOL1 (STRONG "value") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "関数" (CODE1 "slot-value") "は、" (STRONG "object") "のスロット名"
     (STRONG "slot-name") "の値を返却します。" "もしスロット名" (STRONG "slot-name") "が存在しないときは"
     (CODE1 "slot-missing") "が呼ばれます。" "もしスロットが" (CODE1 "unbound") "のときは、"
     (CODE1 "slot-unbound") "が呼ばれます。" EOL2 "スロットの値を変更するときに、" "マクロ" (CODE1 "setf") "の"
     (CODE1 "slot-value") "が使えます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defclass foo () "
      "  ((a :accessor foo-a :initarg :a :initform 1)"
      "   (b :accessor foo-b :initarg :b)" "   (c :accessor foo-c :initform 3)))"
      "=>  #<STANDARD-CLASS FOO 244020371>"
      "(setq foo1 (make-instance 'foo :a 'one :b 'two))" "=>  #<FOO 36325624>"
      "(slot-value foo1 'a) =>  ONE" "(slot-value foo1 'b) =>  TWO"
      "(slot-value foo1 'c) =>  3" "(setf (slot-value foo1 'a) 'uno) =>  UNO"
      "(slot-value foo1 'a) =>  UNO" "(defmethod foo-method ((x foo))"
      "  (slot-value x 'a))" "=>  #<STANDARD-METHOD FOO-METHOD (FOO) 42720573>"
      "(foo-method foo1) =>  UNO"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "スロットから読み込むときに、" (STRONG "object") "にはスロット名"
     (STRONG "slot-name") "が存在しないときは、" (CODE1 "slot-missing") "が次のように呼ばれます。"
     (CODE3 "```lisp" "```" "(slot-missing (class-of instance)" "              instance"
      "              slot-name" "              'slot-value)")
     EOL2 "（もし" (CODE1 "slot-missing") "が起動されたときは、" (CODE1 "slot-value")
     "によって第一返却値が返されます。）" EOL2 "スロットに書き込むときに、" (STRONG "object") "にはスロット名"
     (STRONG "slot-name") "が存在しないときは、" (CODE1 "slot-missing") "が次のように呼ばれます。"
     (CODE3 "```lisp" "```" "(slot-missing (class-of instance)" "              instance"
      "              slot-name" "              'setf" "              new-value)")
     EOL2 "（この場合、" (CODE1 "slot-missing") "が返却されたとき、" "全ての値は無視されます。）" EOL2 "具体的なふるまいは、"
     (STRONG "instance") "のメタクラスに依存します。" "もし" (STRONG "instance") "のメタクラスが"
     (CODE1 "standard-class") "なら、" "決してエラーは発生しません。" "もし" (STRONG "instance") "のメタクラスが"
     (CODE1 "built-in-class") "なら、" "常にエラーが発生します。" "もし" (STRONG "instance")
     "が他のメタクラスなら結果は規定されておらず、" "状況によってエラーが発生するかもしれませんし、" "されないかもしれません。"
     "特にコンディションと構造体についての動作は規定されていません。")
    (CHAPTER ("## 参考") 2 (CODE1 "slot-missing") "," (CODE1 "slot-unbound") ","
     (CODE1 "with-slots"))
    (CHAPTER ("## 備考") 2 "実装は必須ではありませんが、" "実装者はMetaobject Protocolで説明されている" "関数"
     (CODE1 "slot-value-using-class") "を使用して" "関数" (CODE1 "slot-value")
     "を実装することが強く推奨されます。" EOL2 "実装者は" (CODE1 "slot-value") "をコンパイル時にインラインに最適化するかもしれません。")))
(setf (gethash '("SLOT-VALUE" . "FUNCTION") *table*) (gethash "SLOT-VALUE" *table*))
(setf (gethash "SLOT-VALUE-USING-CLASS" *table*)
  '((CHAPTER NIL 0 "Generic Function " (CODE1 "SLOT-VALUE-USING-CLASS"))
    (CHAPTER ("## 構文") 2 (CODE1 "slot-value-using-class") " " (STRONG "class") " "
     (STRONG "object") " " (STRONG "slot") " => " (STRONG "value"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "class") " - メタオブジェクトのクラス。これは引数" (STRONG "object")
     "のクラスです。" EOL1 (STRONG "object") " - オブジェクト" EOL1 (STRONG "slot") " - "
     (CODE1 "effective-slot-definition") "メタオブジェクト" EOL1 (STRONG "value") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "このジェネリック関数は、" (CODE1 "slot-value") "関数の振る舞いを実装します。" "これは第一引数が"
     (STRONG "object") "のクラスであり、" "第三引数が" (CODE1 "effective-slot-definition")
     "メタオブジェクトに関連するものが指定されて" (CODE1 "slot-value") "によって呼び出されます。" EOL2 "ジェネリック関数"
     (CODE1 "slot-value-using-class") "は、" "与えられた" (STRONG "object") "の与えられたスロット"
     (STRONG "slot") "に含まれる値を返却します。" "もしスロットが" (CODE1 "unbound") "のときは、"
     (CODE1 "slot-unbound") "が呼び出されます。" EOL2 "もし引数" (STRONG "class") "が引数"
     (STRONG "object") "のクラスではなかったときか、" "あるいはもし引数" (STRONG "slot") "が引数" (STRONG "class")
     "に関連付けられている" (CODE1 "effective-slot") "の集合に存在しなかった場合は、" "結果は未定義です。")
    (CHAPTER ("## メソッド") 2 (CODE1 "slot-value-using-class") " (" (STRONG "class") " "
     (CODE1 "standard-class") ")" " " (STRONG "object") " (" (STRONG "slot") " "
     (CODE1 "standard-effective-slot-definition") ")" EOL1
     (CODE1 "slot-value-using-class") " (" (STRONG "class") " "
     (CODE1 "funcallable-standard-class") ")" " " (STRONG "object") " (" (STRONG "slot")
     " " (CODE1 "standard-effective-slot-definition") ")" EOL1
     (CODE1 "slot-value-using-class") " (" (STRONG "class") " " (CODE1 "built-in-class")
     ") " (STRONG "object") " " (STRONG "slot"))
    (CHAPTER ("## Method " (CODE1 "slot-value-using-class") "") 2
     (CODE1 "slot-value-using-class") " (" (STRONG "class") " " (CODE1 "standard-class")
     ")" " " (STRONG "object") " (" (STRONG "slot") " "
     (CODE1 "standard-effective-slot-definition") ")" " => " (STRONG "value") EOL1
     (CODE1 "slot-value-using-class") " (" (STRONG "class") " "
     (CODE1 "funcallable-standard-class") ")" " " (STRONG "object") " (" (STRONG "slot")
     " " (CODE1 "standard-effective-slot-definition") ")" " => " (STRONG "value"))
    (CHAPTER ("### 定義") 3 "このメソッドは、" (CODE1 ":instance") "と" (CODE1 ":class")
     "で確保されたスロットに対しての" "完全な振る舞いを行うジェネリック関数の実装です。" "もしスロットが" (CODE1 ":instance") "か"
     (CODE1 ":class") "ではない" "他の確保の値を持っていたときはエラーが通知されます。" EOL2 "このメソッドの上書きは許されていますが、"
     "他のスロットへのアクセスのプロトコルに対しての" "標準で用意されている実装も上書きする必要があるかもしれません。")
    (CHAPTER ("## Method " (CODE1 "slot-value-using-class") "") 2
     (CODE1 "slot-value-using-class") " (" (STRONG "class") " " (CODE1 "built-in-class")
     ") " (STRONG "object") " " (STRONG "slot") " => " (CODE1 "|"))
    (CHAPTER ("### 定義") 3 "このメソッドはエラーが発生します。")))
(setf (gethash '("SLOT-VALUE-USING-CLASS" . "GENERIC-FUNCTION") *table*) (gethash "SLOT-VALUE-USING-CLASS" *table*))
(setf (gethash "SOME" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "EVERY") ", " (CODE1 "SOME") ", "
     (CODE1 "NOTEVERY") ", " (CODE1 "NOTANY"))
    (CHAPTER ("## 構文") 2 (CODE1 "every") " " (STRONG "predicate") " &rest "
     (STRONG "sequence") "+ => " (STRONG "generalized-boolean") EOL1 (CODE1 "some") " "
     (STRONG "predicate") " &rest " (STRONG "sequence") "+ => " (STRONG "result") EOL1
     (CODE1 "notevery") " " (STRONG "predicate") " &rest " (STRONG "sequence") "+ => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "notany") " " (STRONG "predicate")
     " &rest " (STRONG "sequence") "+ => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "predicate") " - " (STRONG "sequence")
     "の数だけ引数を受け取る関数指定子" EOL1 (STRONG "sequence") "s - シーケンス" EOL1 (STRONG "result")
     " - オブジェクト" EOL1 (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "every") "、" (CODE1 "some") "、" (CODE1 "notevery") "、"
     (CODE1 "notany") "は、" "引数" (STRONG "predicate") "が" (STRONG "sequence")
     "の要素を満たすかどうかをテストします。" (STRONG "predicate") "の最初の引数は最初の" (STRONG "sequence")
     "の要素であり、" "後続の引数は後続のシーケンスの要素です。" EOL2 (STRONG "predicate") "は、最初は各"
     (STRONG "sequence") "のインデックス0番目の要素で呼び出され、" "そのあと可能であればインデックス1番目の要素で呼ばれ、"
     "以下同様に実行し、終了の基準が満たされるか、" "もっとも短い" (STRONG "sequence") "の終わりに到達するときまで続けられます。" EOL2
     (CODE1 "every") "は、" (STRONG "predicate") "のどれかが" (STRONG "false") "を返却したら、" "すぐに"
     (STRONG "false") "を返却します。" "もし" (STRONG "sequence") "の終わりに到達したら、" (CODE1 "every")
     "は" (STRONG "true") "を返却します。" "したがって" (CODE1 "every") "は、すべての" (STRONG "predicate")
     "が" (STRONG "true") "を返却したときのみ、" (STRONG "true") "を返却します。" EOL2 (CODE1 "some") "は、"
     (STRONG "predicate") "の実行によって返却された" "最初の非" (CODE1 "nil") "を値を返却します。" "もし"
     (STRONG "predicate") "の実行が" (STRONG "true") "を返却することなく" (STRONG "sequence")
     "の終わりに到達したら、" (CODE1 "some") "は" (STRONG "false") "を返却します。" "したがって" (CODE1 "some")
     "は、" "もしどれかの" (STRONG "predicate") "の実行が" (STRONG "true") "を返却したら、" (STRONG "true")
     "を返却します。" EOL2 (CODE1 "notany") "は、" (STRONG "predicate") "のどれかが" (STRONG "true")
     "を返却したら、" "すぐに" (STRONG "false") "を返却します。" "もし" (STRONG "sequence") "の終わりに到達したら、"
     (CODE1 "notany") "は" (STRONG "true") "を返却します。" "したがって" (CODE1 "notany") "は、どの"
     (STRONG "predicate") "も" (STRONG "true") "を返却しない場合にのみ、" (STRONG "true") "を返却します。"
     EOL2 (CODE1 "notevery") "は、" (STRONG "predicate") "のどれかが" (STRONG "false") "を返却したら、"
     "すぐに" (STRONG "true") "を返却します。" "もし" (STRONG "sequence") "の終わりに到達したら、"
     (CODE1 "notevery") "は" (STRONG "false") "を返却します。" "したがって" (CODE1 "notevery")
     "は、すべての" (STRONG "predicate") "が" (STRONG "true") "を返却しない場合にのみ、" (STRONG "true")
     "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(every #'characterp \"abc\") =>  true"
      "(some #'= '(1 2 3 4 5) '(5 4 3 2 1)) =>  true"
      "(notevery #'< '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) =>  false"
      "(notany #'> '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) =>  true "))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "最初の引数がシンボルでも関数でもないときか、" "続く引数のどれかが正常なシーケンスではなかったときは、" "型"
     (CODE1 "type-error") "のエラーが発生します。" EOL2 "他の例外が発生する可能性があり、それは" (STRONG "predicate")
     "の性質に依存します。")
    (CHAPTER ("## 参考") 2 (CODE1 "and") "," (CODE1 "or") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```"
      "(notany predicate sequence*) == (not (some predicate sequence*))"
      "(notevery predicate sequence*) == (not (every predicate sequence*))"))))
(setf (gethash '("SOME" . "FUNCTION") *table*) (gethash "SOME" *table*))
(setf (gethash "SORT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SORT") ", " (CODE1 "STABLE-SORT"))
    (CHAPTER ("## 構文") 2 (CODE1 "sort") " " (STRONG "sequence") " " (STRONG "predicate")
     " &key " (STRONG "key") " => " (STRONG "sorted-sequence") EOL1 (CODE1 "stable-sort")
     " " (STRONG "sequence") " " (STRONG "predicate") " &key " (STRONG "key") " => "
     (STRONG "sorted-sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "sequence") " - 正常なシーケンス" EOL1 (STRONG "predicate")
     " - 2つの引数をとりgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "sorted-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "sort") "と" (CODE1 "stable-sort") "は、"
     (STRONG "predicate") "関数で決められた順番に従って、" (STRONG "sequence") "を破壊的にソートします。" EOL2 "もし"
     (STRONG "sequence") "が" (CODE1 "vector") "のとき、" "返却値は一次元のsimple-arrayであり、"
     (STRONG "sequence") "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence")
     "がリストなら、返却値はリストです。" EOL2 (CODE1 "sort") "は、" (STRONG "key") "による要素の展開と"
     (STRONG "predicate") "の実行によって、" "2つの要素間の関係を決定します。" (STRONG "predicate") "関数の最初の引数は、"
     (STRONG "key") "関数によって展開された（もし" (STRONG "key") "が指定されたのなら）、" "ひとつの要素の部分であり、"
     "二番目の引数は、" (STRONG "key") "関数によって展開された（もし" (STRONG "key") "が指定されたのなら）、" "別の要素の部分です。"
     (STRONG "predicate") "は、第一引数が第二引数より（何らかの適切な意味で）、" "厳密に小さい場合にのみ" (STRONG "true")
     "を返すべきです。" "もし最初の引数が二番目の引数が（何らかの適切な意味で）、" "以上であるときは、" (STRONG "predicate") "は"
     (STRONG "false") "を返却するべきです。" EOL2 (STRONG "key") "関数の引数は、" (STRONG "sequence")
     "の要素です。" (STRONG "key") "関数の返却値は、" (STRONG "predicate") "の引数になります。" "もし"
     (STRONG "key") "が与えられないか、あるいは" (CODE1 "nil") "が指定されたとき、" (STRONG "sequence")
     "の要素そのものが使用されます。" (STRONG "key") "が呼び出される回数を保証する方法はありません。" EOL2 "もし" (STRONG "key")
     "と" (STRONG "predicate") "が常に返却するのであれば、" "ソート操作は常に終了し、" (STRONG "sequence")
     "として同じ要素が含んだシーケンスが生成されます" "（つまり、返却値は" (STRONG "seqeunce") "の並べ替えです）。" "これは"
     (STRONG "predicate") "が実際には全順序の表現が一貫されていなくても保証されます"
     "（そのような場合は、要素は予測不可能な順番でスクランブルされますが、" "要素が失われることはありません）。" "もし" (STRONG "key")
     "が一貫して意味のあるキーを返却し、" (STRONG "predicate") "がそれらのキーにおいて" "何らかの全順序の基準を反映したのであれば、"
     (STRONG "sorted-sequence") "の要素は、おそらく適切にソートされます。" EOL2 (CODE1 "sort")
     "によるソートの操作は、安定性が保証されません。" (STRONG "predicate") "によって等しいとされた要素は、"
     "元の順序のままであるかもしれないし、そうでないかもしれません。" (STRONG "predicate") "は、"
     (CODE1 "(funcall predicate x y)") "と" (CODE1 "(funcall predicate y x)") "が" "両方とも"
     (STRONG "false") "であるときに、" "2つの要素" (CODE1 "x") "と" (CODE1 "y") "が等しいとみなすと仮定しています。"
     (CODE1 "stable-sort") "は、安定性を保証します。" EOL2 "どの場合においても、ソート操作は破壊的です。" (CODE1 "vector")
     "が引数のときは、要素の場所に並べ替えることで行います。" "リストの場合は、" (CODE1 "nreverse") "と同じ方法で"
     "破壊的に並び替えられます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq tester (copy-seq \"lkjashd\")) =>  \"lkjashd\""
      "(sort tester #'char-lessp) =>  \"adhjkls\""
      "(setq tester (list '(1 2 3) '(4 5 6) '(7 8 9))) =>  ((1 2 3) (4 5 6) (7 8 9))"
      "(sort tester #'> :key #'car)  =>  ((7 8 9) (4 5 6) (1 2 3)) "
      "(setq tester (list 1 2 3 4 5 6 7 8 9 0)) =>  (1 2 3 4 5 6 7 8 9 0)"
      "(stable-sort tester #'(lambda (x y) (and (oddp x) (evenp y))))"
      "=>  (1 3 5 7 9 2 4 6 8 0)" "(sort (setq committee-data"
      "            (vector (list (list \"JonL\" \"White\") \"Iteration\")"
      "                    (list (list \"Dick\" \"Waters\") \"Iteration\")"
      "                    (list (list \"Dick\" \"Gabriel\") \"Objects\")"
      "                    (list (list \"Kent\" \"Pitman\") \"Conditions\")"
      "                    (list (list \"Gregor\" \"Kiczales\") \"Objects\")"
      "                    (list (list \"David\" \"Moon\") \"Objects\")"
      "                    (list (list \"Kathy\" \"Chapman\") \"Editorial\")"
      "                    (list (list \"Larry\" \"Masinter\") \"Cleanup\")"
      "                    (list (list \"Sandra\" \"Loosemore\") \"Compiler\")))"
      "      #'string-lessp :key #'cadar)" "=> #(((\"Kathy\" \"Chapman\") \"Editorial\")"
      "    ((\"Dick\" \"Gabriel\") \"Objects\")"
      "    ((\"Gregor\" \"Kiczales\") \"Objects\")"
      "    ((\"Sandra\" \"Loosemore\") \"Compiler\")"
      "    ((\"Larry\" \"Masinter\") \"Cleanup\")"
      "    ((\"David\" \"Moon\") \"Objects\")"
      "    ((\"Kent\" \"Pitman\") \"Conditions\")"
      "    ((\"Dick\" \"Waters\") \"Iteration\")"
      "    ((\"JonL\" \"White\") \"Iteration\"))" ";; \"committees\"内のアルファベット順は保存されます。"
      "(setq committee-data "
      "      (stable-sort committee-data #'string-lessp :key #'cadr))"
      "=> #(((\"Larry\" \"Masinter\") \"Cleanup\")"
      "    ((\"Sandra\" \"Loosemore\") \"Compiler\")"
      "    ((\"Kent\" \"Pitman\") \"Conditions\")"
      "    ((\"Kathy\" \"Chapman\") \"Editorial\")"
      "    ((\"Dick\" \"Waters\") \"Iteration\")"
      "    ((\"JonL\" \"White\") \"Iteration\")"
      "    ((\"Dick\" \"Gabriel\") \"Objects\")"
      "    ((\"Gregor\" \"Kiczales\") \"Objects\")"
      "    ((\"David\" \"Moon\") \"Objects\"))"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "merge") "," "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用,"
     "3.7. 破壊的操作")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "返却値は"
     (CODE1 "simple") "かもしれませんし、そうでないかもしれません。" "また、返却値は" (STRONG "sequence")
     "と同一かもしれませんし、" "そうでないかもしれません。")))
(setf (gethash '("SORT" . "FUNCTION") *table*) (gethash "SORT" *table*))
(setf (gethash "SPECIAL" *table*)
  '((CHAPTER NIL 0 "Declaration " (CODE1 "SPECIAL"))
    (CHAPTER ("## 構文") 2 "(" (CODE1 "special") " " (STRONG "var\\*") ")")
    (CHAPTER ("## 引数") 2 (STRONG "var") " - シンボル")
    (CHAPTER ("## 有効な文脈") 2 (CODE1 "declare") "と" (CODE1 "proclaim"))
    (CHAPTER ("## 影響する束縛の型") 2 "変数")
    (CHAPTER ("## 定義") 2 "全ての" (STRONG "var") "という名前のものを動的に指定します。"
     "この指定子は変数の束縛と参照に影響します。" "全ての影響があった束縛変数は動的束縛になり、" "変数参照は現在の動的束縛を参照します。" "下記に例を示します。"
     (CODE3 "```lisp" "```" "(defun hack (thing *mod*)    ;束縛されたパラメーター*mod*は"
      "  (declare (special *mod*))  ;hack1からも見ることができます。"
      "  (hack1 (car thing)))       ;しかしthingはそうではありません。" "(defun hack1 (arg)"
      "  (declare (special *mod*))  ;hack1内の宣言*mod*は"
      "                             ;specialで参照されます。" "  (if (atom arg) *mod*"
      "      (cons (hack1 (car arg)) (hack1 (cdr arg)))))")
     EOL2 (CODE1 "special") "宣言は、" (STRONG "var") "の束縛の中では影響しません。" "束縛内では暗黙的に"
     (CODE1 "special") "宣言がシャドウします。" "そして明示的に" (CODE1 "special") "として再宣言する必要があります。"
     (CODE1 "special") "宣言は決して関数束縛に適用しません。" EOL2 (CODE1 "special") "宣言は境界宣言として利用可能であり、"
     "束縛と参照の両方に影響します。" "他には自由宣言も利用可能であり、これは参照のみに影響し、" "変数の束縛に付随する宣言に依存します。" EOL2
     (CODE1 "proclaim") "が使用されたとき、" (CODE1 "special") "宣言指定子は" "その変数の全ての束縛と参照に適用されます。"
     "例えば次の通り。" (CODE3 "```lisp" "```" "(declaim (special x))") EOL2
     "この例文の後で次のような関数帝があったとします。" (CODE3 "```lisp" "```" "(defun example (x) ...)") EOL2
     "このときパラメーター" (CODE1 "x") "は" "レキシカル変数ではなく動的変数として束縛されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun declare-eg (y)                  ;このyはspecialです"
      "  (declare (special y))" "  (let ((y t))                         ;このyはレキシカルでｓ"
      "       (list y" "             (locally (declare (special y)) y)))) ;このyの参照先は"
      "                                                  ;special束縛のyです"
      "=>  DECLARE-EG " "(declare-eg nil) =>  (T NIL) " "(setf (symbol-value 'x) 6)"
      "(defun foo (x)                         ;xはレキシカル束縛" "  (print x)"
      "  (let ((x (1+ x)))                    ;xはspecial束縛であり"
      "    (declare (special x))              ;レキシカル参照" "    (bar))" "  (1+ x))"
      "(defun bar () " "  (print (locally (declare (special x))" "           x)))"
      "(foo 10) " ">>  10" ">>  11" "=>  11" "(setf (symbol-value 'x) 6)"
      "(defun bar (x y)            ;[1] 1回目のxの出現"
      "  (let ((old-x x)           ;[2] 2回目のxの出現 -- 1回目と同じ"
      "        (x y))              ;[3] 3回目のxの出現" "    (declare (special x))"
      "    (list old-x x)))" "(bar 'first 'second) =>  (FIRST SECOND)"
      " (defun few (x &optional (y *foo*))" "   (declare (special *foo*))" "   ...)")
     EOL2 "この例の最初の行にある" (CODE1 "*foo*") "の参照は、" "2行目に" (CODE1 "special") "宣言があるにもかかわらず、"
     "1行目は" (CODE1 "special") "ではありません。"
     (CODE3 "```lisp" "```" "(declaim (special prosp)) => 実装依存"
      "(setq prosp 1 reg 1) =>  1"
      "(let ((prosp 2) (reg 2))         ;prospの束縛は前のdeclaimにより"
      "   (set 'prosp 3) (set 'reg 3)   ;specialになります。"
      "   (list prosp reg))             ;reg変数はレキシカルです。" "=>  (3 2)"
      "(list prosp reg) =>  (1 3)" NIL "(declaim (special x))          ;xは常にspecialです。"
      "(defun example (x y)                                 " "  (declare (special y))"
      "  (let ((y 3) (x (* x 2)))" "    (print (+ y (locally (declare (special y)) y)))"
      "    (let ((y 4)) (declare (special y)) (foo x)))) =>  EXAMPLE")
     EOL2 "上記のねじ曲がったコードは、" "最も外側と最も内側の" (CODE1 "y") "の束縛は動的であり、" "しかし中間の束縛はレキシカルです。"
     (CODE1 "+") "の2つの引数は違っており、" "1つ目はレキシカル変数" (CODE1 "y") "の値" (CODE1 "3") "で、"
     "もうひとつは動的変数" (CODE1 "y") "です" "（この束縛は偶然にも外側のレベルでレキシカルに囲まれているものです）。" "しかしながら"
     (CODE1 "proclamation") "によって" (CODE1 "x") "が常に" (CODE1 "special") "なので、" "全ての"
     (CODE1 "x") "の束縛と" (CODE1 "x") "の参照は動的です。")
    (CHAPTER ("## 参考") 2 (CODE1 "defparameter") "," (CODE1 "defvar"))))
(setf (gethash '("SPECIAL" . "DECLARATION") *table*) (gethash "SPECIAL" *table*))
(setf (gethash "SPECIAL-OPERATOR-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SPECIAL-OPERATOR-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "special-operator-p") " " (STRONG "symbol") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - シンボル" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "もし" (STRONG "symbol") "が特殊オペレーターなら" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(special-operator-p 'if) =>  true"
      "(special-operator-p 'car) =>  false" "(special-operator-p 'one) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "引数がシンボルではないとき、" "型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 "歴史的にこの関数は" (CODE1 "special-form-p") "と呼ばれていました。" "この関数は"
     (CODE1 "special form") "ではなく" (CODE1 "special operator") "のときに" (STRONG "true")
     "となるので、" "最終的に誤った名称であると考えられて変更されました。")))
(setf (gethash '("SPECIAL-OPERATOR-P" . "FUNCTION") *table*) (gethash "SPECIAL-OPERATOR-P" *table*))
(setf (gethash "STABLE-SORT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SORT") ", " (CODE1 "STABLE-SORT"))
    (CHAPTER ("## 構文") 2 (CODE1 "sort") " " (STRONG "sequence") " " (STRONG "predicate")
     " &key " (STRONG "key") " => " (STRONG "sorted-sequence") EOL1 (CODE1 "stable-sort")
     " " (STRONG "sequence") " " (STRONG "predicate") " &key " (STRONG "key") " => "
     (STRONG "sorted-sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "sequence") " - 正常なシーケンス" EOL1 (STRONG "predicate")
     " - 2つの引数をとりgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "sorted-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "sort") "と" (CODE1 "stable-sort") "は、"
     (STRONG "predicate") "関数で決められた順番に従って、" (STRONG "sequence") "を破壊的にソートします。" EOL2 "もし"
     (STRONG "sequence") "が" (CODE1 "vector") "のとき、" "返却値は一次元のsimple-arrayであり、"
     (STRONG "sequence") "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence")
     "がリストなら、返却値はリストです。" EOL2 (CODE1 "sort") "は、" (STRONG "key") "による要素の展開と"
     (STRONG "predicate") "の実行によって、" "2つの要素間の関係を決定します。" (STRONG "predicate") "関数の最初の引数は、"
     (STRONG "key") "関数によって展開された（もし" (STRONG "key") "が指定されたのなら）、" "ひとつの要素の部分であり、"
     "二番目の引数は、" (STRONG "key") "関数によって展開された（もし" (STRONG "key") "が指定されたのなら）、" "別の要素の部分です。"
     (STRONG "predicate") "は、第一引数が第二引数より（何らかの適切な意味で）、" "厳密に小さい場合にのみ" (STRONG "true")
     "を返すべきです。" "もし最初の引数が二番目の引数が（何らかの適切な意味で）、" "以上であるときは、" (STRONG "predicate") "は"
     (STRONG "false") "を返却するべきです。" EOL2 (STRONG "key") "関数の引数は、" (STRONG "sequence")
     "の要素です。" (STRONG "key") "関数の返却値は、" (STRONG "predicate") "の引数になります。" "もし"
     (STRONG "key") "が与えられないか、あるいは" (CODE1 "nil") "が指定されたとき、" (STRONG "sequence")
     "の要素そのものが使用されます。" (STRONG "key") "が呼び出される回数を保証する方法はありません。" EOL2 "もし" (STRONG "key")
     "と" (STRONG "predicate") "が常に返却するのであれば、" "ソート操作は常に終了し、" (STRONG "sequence")
     "として同じ要素が含んだシーケンスが生成されます" "（つまり、返却値は" (STRONG "seqeunce") "の並べ替えです）。" "これは"
     (STRONG "predicate") "が実際には全順序の表現が一貫されていなくても保証されます"
     "（そのような場合は、要素は予測不可能な順番でスクランブルされますが、" "要素が失われることはありません）。" "もし" (STRONG "key")
     "が一貫して意味のあるキーを返却し、" (STRONG "predicate") "がそれらのキーにおいて" "何らかの全順序の基準を反映したのであれば、"
     (STRONG "sorted-sequence") "の要素は、おそらく適切にソートされます。" EOL2 (CODE1 "sort")
     "によるソートの操作は、安定性が保証されません。" (STRONG "predicate") "によって等しいとされた要素は、"
     "元の順序のままであるかもしれないし、そうでないかもしれません。" (STRONG "predicate") "は、"
     (CODE1 "(funcall predicate x y)") "と" (CODE1 "(funcall predicate y x)") "が" "両方とも"
     (STRONG "false") "であるときに、" "2つの要素" (CODE1 "x") "と" (CODE1 "y") "が等しいとみなすと仮定しています。"
     (CODE1 "stable-sort") "は、安定性を保証します。" EOL2 "どの場合においても、ソート操作は破壊的です。" (CODE1 "vector")
     "が引数のときは、要素の場所に並べ替えることで行います。" "リストの場合は、" (CODE1 "nreverse") "と同じ方法で"
     "破壊的に並び替えられます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq tester (copy-seq \"lkjashd\")) =>  \"lkjashd\""
      "(sort tester #'char-lessp) =>  \"adhjkls\""
      "(setq tester (list '(1 2 3) '(4 5 6) '(7 8 9))) =>  ((1 2 3) (4 5 6) (7 8 9))"
      "(sort tester #'> :key #'car)  =>  ((7 8 9) (4 5 6) (1 2 3)) "
      "(setq tester (list 1 2 3 4 5 6 7 8 9 0)) =>  (1 2 3 4 5 6 7 8 9 0)"
      "(stable-sort tester #'(lambda (x y) (and (oddp x) (evenp y))))"
      "=>  (1 3 5 7 9 2 4 6 8 0)" "(sort (setq committee-data"
      "            (vector (list (list \"JonL\" \"White\") \"Iteration\")"
      "                    (list (list \"Dick\" \"Waters\") \"Iteration\")"
      "                    (list (list \"Dick\" \"Gabriel\") \"Objects\")"
      "                    (list (list \"Kent\" \"Pitman\") \"Conditions\")"
      "                    (list (list \"Gregor\" \"Kiczales\") \"Objects\")"
      "                    (list (list \"David\" \"Moon\") \"Objects\")"
      "                    (list (list \"Kathy\" \"Chapman\") \"Editorial\")"
      "                    (list (list \"Larry\" \"Masinter\") \"Cleanup\")"
      "                    (list (list \"Sandra\" \"Loosemore\") \"Compiler\")))"
      "      #'string-lessp :key #'cadar)" "=> #(((\"Kathy\" \"Chapman\") \"Editorial\")"
      "    ((\"Dick\" \"Gabriel\") \"Objects\")"
      "    ((\"Gregor\" \"Kiczales\") \"Objects\")"
      "    ((\"Sandra\" \"Loosemore\") \"Compiler\")"
      "    ((\"Larry\" \"Masinter\") \"Cleanup\")"
      "    ((\"David\" \"Moon\") \"Objects\")"
      "    ((\"Kent\" \"Pitman\") \"Conditions\")"
      "    ((\"Dick\" \"Waters\") \"Iteration\")"
      "    ((\"JonL\" \"White\") \"Iteration\"))" ";; \"committees\"内のアルファベット順は保存されます。"
      "(setq committee-data "
      "      (stable-sort committee-data #'string-lessp :key #'cadr))"
      "=> #(((\"Larry\" \"Masinter\") \"Cleanup\")"
      "    ((\"Sandra\" \"Loosemore\") \"Compiler\")"
      "    ((\"Kent\" \"Pitman\") \"Conditions\")"
      "    ((\"Kathy\" \"Chapman\") \"Editorial\")"
      "    ((\"Dick\" \"Waters\") \"Iteration\")"
      "    ((\"JonL\" \"White\") \"Iteration\")"
      "    ((\"Dick\" \"Gabriel\") \"Objects\")"
      "    ((\"Gregor\" \"Kiczales\") \"Objects\")"
      "    ((\"David\" \"Moon\") \"Objects\"))"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "merge") "," "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用,"
     "3.7. 破壊的操作")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "返却値は"
     (CODE1 "simple") "かもしれませんし、そうでないかもしれません。" "また、返却値は" (STRONG "sequence")
     "と同一かもしれませんし、" "そうでないかもしれません。")))
(setf (gethash '("STABLE-SORT" . "FUNCTION") *table*) (gethash "STABLE-SORT" *table*))
(setf (gethash "STANDARD-CHAR" *table*)
  '((CHAPTER NIL 0 "Type " (CODE1 "STANDARD-CHAR"))
    (CHAPTER ("## スーパータイプ") 2 (CODE1 "standard-char") ", " (CODE1 "base-char") ","
     (CODE1 "character") ", " (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "標準準拠の全ての処理系では、" "96個固定の文字を実装する必要があります。" EOL1
     "標準文字は、2.1.3. 標準文字で定義されています。" EOL2 "単純ではない文字（つまり文字の属性が定義されている文字）は、" "標準文字ではありません。")
    (CHAPTER ("## 参考") 2 "2.1.3. 標準文字")))
(setf (gethash '("STANDARD-CHAR" . "TYPE") *table*) (gethash "STANDARD-CHAR" *table*))
(setf (gethash "STANDARD-CHAR-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STANDARD-CHAR-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "standard-char-p") " " (STRONG "character") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " - 文字" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "character") "が型" (CODE1 "standard-char") "のときは"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(standard-char-p #\\Space) =>  true"
      "(standard-char-p #\\~) =>  true" ";; 次の例では、#\\Bellという文字が定義されている処理系を前提にしている。"
      "(standard-char-p #\\Bell) =>  false"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "character") "が文字ではなかったら、型" (CODE1 "type-error")
     "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("STANDARD-CHAR-P" . "FUNCTION") *table*) (gethash "STANDARD-CHAR-P" *table*))
(setf (gethash "STANDARD-CLASS" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "STANDARD-CLASS"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "standard-class") "," (CODE1 "class") ","
     (CODE1 "standard-object") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 (CODE1 "standard-class") "クラスは、" (CODE1 "defclass")
     "によって定義されたクラスの標準のクラスです。")))
(setf (gethash '("STANDARD-CLASS" . "SYSTEM-CLASS") *table*) (gethash "STANDARD-CLASS" *table*))
(setf (gethash "STANDARD-GENERIC-FUNCTION" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "STANDARD-GENERIC-FUNCTION"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "standard-generic-function") ","
     (CODE1 "generic-function") "," (CODE1 "function") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 (CODE1 "standard-generic-function") "クラスは、" (CODE1 "defmethod")
     "," (CODE1 "ensure-generic-function") "," (CODE1 "defgeneric") ","
     (CODE1 "defclass") "のフォームによって確立される" "ジェネリック関数の標準のクラスです。")))
(setf (gethash '("STANDARD-GENERIC-FUNCTION" . "SYSTEM-CLASS") *table*) (gethash "STANDARD-GENERIC-FUNCTION" *table*))
(setf (gethash "STANDARD-METHOD" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "STANDARD-METHOD"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "standard-method") "," (CODE1 "method") ","
     (CODE1 "standard-object") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 (CODE1 "standard-method") "クラスは、" (CODE1 "defmethod") "と"
     (CODE1 "defgeneric") "フォームによって定義された" "メソッドの標準のクラスです。")))
(setf (gethash '("STANDARD-METHOD" . "SYSTEM-CLASS") *table*) (gethash "STANDARD-METHOD" *table*))
(setf (gethash "STANDARD-OBJECT" *table*)
  '((CHAPTER NIL 0 "Class " (CODE1 "STANDARD-OBJECT"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "standard-object") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 (CODE1 "standard-object") "クラスは" (CODE1 "standard-class")
     "のインスタンスであり、" "自分以外の" (CODE1 "standard-class") "のインスタンスの" "全てのクラスのスーパークラスです。")))
(setf (gethash '("STANDARD-OBJECT" . "CLASS") *table*) (gethash "STANDARD-OBJECT" *table*))
(setf (gethash "STORAGE-CONDITION" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "STORAGE-CONDITION"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "storage-condition") ","
     (CODE1 "serious-condition") "," (CODE1 "condition") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "storage-condition") "は、" "メモリ管理の問題に関連するものであったり、"
     "仕様に適合したプログラムの意味的なエラーではなく" "実装依存の限界の可能性であったり、"
     "捕捉されなかった時にデバッガーへ入るという典型的なものであったりといった、" "深刻なコンディションの内容を含みます。" "実装の詳細に依存しており、"
     "これらのものはスタックオーバーフローや、" "メモリ領域のオーバーフロー、 記憶領域の超過などの問題を含みます。")
    (CHAPTER ("## 備考") 2 "いくつかのCommon Lispの操作はオブジェクトの生成の定義によって"
     (CODE1 "storage-condition") "を通知するかもしれませんが、" "オブジェクトの生成が定義されていない操作であっても"
     "とにかく何かの生成が発生する可能性があり、" "そのような時に" (CODE1 "storage-condition") "を通知するかどうかは指定されていません。"
     "同じように評価器自身が何らかのオブジェクトを作成し" (CODE1 "storage-condition") "を通知するかもしれません。"
     "（このようなオブジェクトの生成は当然非効率と" "考えるのが自然かもしれませんが、" "それ自体も実装依存です。）"
     "一般的に、ストレージの確保をどのようにして行うかという質問は" "全体的に実装依存で行われます。" "そしてどんな操作でもいつでも"
     (CODE1 "storage-condition") "が" "通知されるかもしれません。" "このようなコンディションは実装の制限の指標であり、"
     "プログラムのエラーというよりは実装のイメージであるため、" (CODE1 "storage-condition") "の型のオブジェクトは"
     (CODE1 "error") "の型になってはいません。")))
(setf (gethash '("STORAGE-CONDITION" . "CONDITION-TYPE") *table*) (gethash "STORAGE-CONDITION" *table*))
(setf (gethash "STORE-VALUE" *table*)
  '("STORE-VALUE FUNCTION" EOL1 "STORE-VALUE RESTART" EOL1))
(setf (gethash '("STORE-VALUE" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ABORT") ", " (CODE1 "CONTINUE") ", "
     (CODE1 "MUFFLE-WARNING") ", " (CODE1 "STORE-VALUE") ", " (CODE1 "USE-VALUE"))
    (CHAPTER ("## 構文") 2 (CODE1 "abort") " " (CODE1 "&optional") " " (STRONG "condition")
     " => " (CODE1 "|") EOL1 (CODE1 "continue") " " (CODE1 "&optional") " "
     (STRONG "condition") " => " (CODE1 "nil") EOL1 (CODE1 "muffle-warning") " "
     (CODE1 "&optional") " " (STRONG "condition") " => " (CODE1 "|") EOL1
     (CODE1 "store-value") " " (STRONG "value") " " (CODE1 "&optional") " "
     (STRONG "condition") " => " (CODE1 "nil") EOL1 (CODE1 "use-value") " "
     (STRONG "value") " " (CODE1 "&optional") " " (STRONG "condition") " => "
     (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "value") " - オブジェクト" EOL1 (STRONG "condition")
     " - コンディションオブジェクトか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "もっとも最近確立された適用可能な" (CODE1 "restart") "のうち、"
     "関数と同じ名前を持つものへ制御が遷移されます。" "つまり、" (CODE1 "abort") "関数は" "適用可能な" (CODE1 "abort") " "
     (CODE1 "restart") "を探し、" (CODE1 "continue") "関数は" "適用可能な" (CODE1 "continue") " "
     (CODE1 "restart") "を探し、" "他も同様です。" EOL2 "もしそのような" (CODE1 "restart") "が存在しないときは、"
     (CODE1 "continue") ", " (CODE1 "store-value") "," (CODE1 "use-value") "は"
     (CODE1 "nil") "を返却し、" (CODE1 "abort") "と" (CODE1 "muffle-warning") "は" "型"
     (CODE1 "control-error") "のエラーを発生します。" EOL2 "もし" (STRONG "condition") "が"
     (CODE1 "nil") "ではないときは、" "それらの" (CODE1 "restart") "は、明に" (STRONG "condition")
     "と関連付けられているものか、" "あるいはどのコンディションにも関連付けられてないものかの" "どちらかのみが集められます。" "これは、排他された"
     (CODE1 "restart") "というのは、" "関連付けられたコンディションの集合が空ではなく、" "その要素に指定した"
     (STRONG "condition") "が含まれていないということです。" "もし" (STRONG "condition") "が" (CODE1 "nil")
     "のときは、" "全ての" (CODE1 "restart") "が集められます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";;; ABORT restartの例" NIL
      "(defmacro abort-on-error (&body forms)" "  `(handler-bind ((error #'abort))"
      "     ,@forms)) =>  ABORT-ON-ERROR" "(abort-on-error (+ 3 5)) =>  8"
      "(abort-on-error (error \"You lose.\"))" ">>  Returned to Lisp Top Level." NIL
      ";;; CONTINUE restartの例" NIL "(defun real-sqrt (n)" "  (when (minusp n)"
      "    (setq n (- n))"
      "    (cerror \"Return sqrt(~D) instead.\" \"Tried to take sqrt(-~D).\" n))"
      "  (sqrt n))" NIL "(real-sqrt 4) =>  2" "(real-sqrt -9)"
      ">>  Error: Tried to take sqrt(-9)."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Return sqrt(9) instead." ">>   2: Return to Lisp Toplevel."
      ">>  Debug> (continue)" ">>  Return sqrt(9) instead." "=>  3" " "
      " (handler-bind ((error #'(lambda (c) (continue))))" "   (real-sqrt -9)) =>  3" NIL
      ";;; MUFFLE-WARNING restartの例" NIL "(defun count-down (x)"
      "  (do ((counter x (1- counter)))" "      ((= counter 0) 'done)"
      "    (when (= counter 1)" "      (warn \"Almost done\"))"
      "    (format t \"~&~D~%\" counter)))" "=>  COUNT-DOWN" "(count-down 3)" ">>  3"
      ">>  2" ">>  Warning: Almost done" ">>  1" "=>  DONE"
      "(defun ignore-warnings-while-counting (x)"
      "  (handler-bind ((warning #'ignore-warning))" "    (count-down x)))"
      "=>  IGNORE-WARNINGS-WHILE-COUNTING" "(defun ignore-warning (condition)"
      "  (declare (ignore condition))" "  (muffle-warning))" "=>  IGNORE-WARNING"
      " (ignore-warnings-while-counting 3)" ">>  3" ">>  2" ">>  1" "=>  DONE" NIL
      ";;; STORE-VALUE restartとUSE-VALUE restartの例" NIL
      "(defun careful-symbol-value (symbol)" "  (check-type symbol symbol)"
      "  (restart-case (if (boundp symbol)"
      "                    (return-from careful-symbol-value "
      "                                 (symbol-value symbol))"
      "                    (error 'unbound-variable"
      "                           :name symbol))" "    (use-value (value)"
      "      :report \"Specify a value to use this time.\"" "      value)"
      "    (store-value (value)"
      "      :report \"Specify a value to store and use in the future.\""
      "      (setf (symbol-value symbol) value))))" "(setq a 1234) =>  1234"
      "(careful-symbol-value 'a) =>  1234" "(makunbound 'a) =>  A"
      "(careful-symbol-value 'a)" ">>  Error: A is not bound."
      ">>  To continue, type :CONTINUE followed by an option number."
      ">>   1: Specify a value to use this time."
      ">>   2: Specify a value to store and use in the future."
      ">>   3: Return to Lisp Toplevel." ">>  Debug> (use-value 12)" "=>  12"
      "(careful-symbol-value 'a)" ">>  Error: A is not bound."
      ">>  To continue, type :CONTINUE followed by an option number."
      ">>    1: Specify a value to use this time."
      ">>    2: Specify a value to store and use in the future."
      ">>    3: Return to Lisp Toplevel." ">>  Debug> (store-value 24)" "=>  24"
      " (careful-symbol-value 'a)" "=>  24" NIL ";;; USE-VALUE restartの例" NIL
      "(defun add-symbols-with-default (default &rest symbols)"
      "  (handler-bind ((sys:unbound-symbol" "                   #'(lambda (c)"
      "                       (declare (ignore c)) "
      "                       (use-value default))))"
      "    (apply #'+ (mapcar #'careful-symbol-value symbols))))"
      "=>  ADD-SYMBOLS-WITH-DEFAULT" "(setq x 1 y 2) =>  2"
      "(add-symbols-with-default 3 'x 'y 'z) =>  6"))
    (CHAPTER ("## 副作用") 2 "適用可能な" (CODE1 "restart") "が使用可能なときに" "制御の遷移が起こるかもしれませんし、"
     "あるいは（" (CODE1 "abort") "関数か" (CODE1 "muffle-warning") "関数の場合は）" "実行が停止するかもしれません。")
    (CHAPTER ("## 影響") 2 "もし適用可能な" (CODE1 "abort") " " (CODE1 "restart") "が" "利用不可の状態で"
     (CODE1 "abort") "関数が実行されれたときか、" "適用可能な" (CODE1 "muffle-warning") " "
     (CODE1 "restart") "が" "利用不可の状態で" (CODE1 "muffle-warning") "関数が実行されれたときは、" "型"
     (CODE1 "control-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "invoke-restart") "," "9.1.4.2. " (CODE1 "restart") ","
     "9.1.4.2.2. " (CODE1 "restart") "のインターフェイス," (CODE1 "assert") "," (CODE1 "ccase")
     "," (CODE1 "cerror") "," (CODE1 "check-type") "," (CODE1 "ctypecase") ","
     (CODE1 "use-value") "," (CODE1 "warn"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(abort condition) ==  (invoke-restart 'abort)"
      "(muffle-warning)  ==  (invoke-restart 'muffle-warning)"
      "(continue)        ==  (let ((r (find-restart 'continue))) (if r (invoke-restart r)))"
      "(use-value x) ==  (let ((r (find-restart 'use-value))) (if r (invoke-restart r x)))"
      "(store-value x) ==  (let ((r (find-restart 'store-value))) (if r (invoke-restart r x)))")
     EOL2 "この仕様書で" (CODE1 "use-value") " " (CODE1 "restart") "の提供に" "要求される関数定義はありません。")))
(setf (gethash '("STORE-VALUE" . "RESTART") *table*)
  '((CHAPTER NIL 0 "Restart " (CODE1 "STORE-VALUE"))
    (CHAPTER ("## 要求される引数のデータ") 2 "かわりに使う値（基本的に使い続ける）")
    (CHAPTER ("## 定義") 2 (CODE1 "store-value") " " (CODE1 "restart") "は、" "一般的には"
     (CODE1 "cell-error") "か" (CODE1 "type-error") "のような" "エラーの型から回復を試みるハンドラーによって使用されます。"
     "回復は置き換えるデータの希望を指定して" "それに永久に置き換えることによって行います。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun type-error-auto-coerce (c)"
      "  (when (typep c 'type-error)" "    (let ((r (find-restart 'store-value c)))"
      "      (handler-case (let ((v (coerce (type-error-datum c)"
      "                                     (type-error-expected-type c))))"
      "                      (invoke-restart r v))"
      "        (error ()))))) =>  TYPE-ERROR-AUTO-COERCE" "(let ((x 3))"
      "  (handler-bind ((type-error #'type-error-auto-coerce))"
      "    (check-type x float)" "    x)) =>  3.0"))
    (CHAPTER ("## 参考") 2 "9.1.4.2. " (CODE1 "restart") "," "9.1.4.2.2. "
     (CODE1 "restart") "のインターフェイス," (CODE1 "invoke-restart") "," (CODE1 "store-value")
     "（関数）," (CODE1 "ccase") "," (CODE1 "check-type") "," (CODE1 "ctypecase") ","
     (CODE1 "use-value") "（関数）," (CODE1 "use-value") "（" (CODE1 "restart") "）")))
(setf (gethash "STREAM" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "STREAM"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "stream") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "ストリームは、文字とバイトを出したり入れたりするような操作の識別として" "入出力関数に使われるようなオブジェクトです。"
     EOL2 "より完全な情報は21.1. ストリームの説明をご確認ください。")
    (CHAPTER ("## 参考") 2 "21.1. ストリームの説明," "22.1.3.13. 他のオブジェクトの印字," "22. プリンター,"
     "23. リーダー")))
(setf (gethash '("STREAM" . "SYSTEM-CLASS") *table*) (gethash "STREAM" *table*))
(setf (gethash "STREAM-ELEMENT-TYPE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STREAM-ELEMENT-TYPE"))
    (CHAPTER ("## 構文") 2 (CODE1 "stream-element-type") " " (STRONG "stream") " => "
     (STRONG "typespec"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream") " - ストリーム" EOL1 (STRONG "typespec")
     " - 型指定子")
    (CHAPTER ("## 定義") 2 (CODE1 "stream-element-type") "は、" (STRONG "stream")
     "に読み書きされるオブジェクトの型を示す型指定子を返却します。" EOL2 (CODE1 "open") "によって作成されたストリームは、" "整数かあるいは型"
     (CODE1 "character") "のサブタイプに制限される" "要素の型を持っています。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; このストリームは少なくとも指定した型を扱う必要がありますが、"
      ";; 他の型も扱うことができるかもしれないことに注意してください。" ";; より詳しくは正確に指定した型を収容できるとしても、"
      ";; その型は様々な方法で指定されるかもしれません。"
      "(with-open-file (s \"test\" :element-type '(integer 0 1)"
      "                          :if-exists :error"
      "                          :direction :output)" "  (stream-element-type s))"
      "=>  INTEGER" "OR=>  (UNSIGNED-BYTE 16)" "OR=>  (UNSIGNED-BYTE 8)" "OR=>  BIT"
      "OR=>  (UNSIGNED-BYTE 1)" "OR=>  (INTEGER 0 1)" "OR=>  (INTEGER 0 (2))"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "stream") "がストリームではないとき、" "型" (CODE1 "type-error")
     "のエラーを発生させるべきです。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("STREAM-ELEMENT-TYPE" . "FUNCTION") *table*) (gethash "STREAM-ELEMENT-TYPE" *table*))
(setf (gethash "STREAM-ERROR" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "STREAM-ERROR"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "stream-error") "," (CODE1 "error") ","
     (CODE1 "serious-condition") "," (CODE1 "condition") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "stream-error") "は、" "ストリームに対して入力を受信したか出力を送信したかに関係する"
     "エラーのコンディションを含みます。" "「問題のあるストリーム」は" (CODE1 "make-condition") "の" "初期化引数である"
     (CODE1 ":stream") "によって初期化され、" (CODE1 "stream-error-stream") "関数によってアクセスできます。")
    (CHAPTER ("## 参考") 2 (CODE1 "stream-error-stream"))))
(setf (gethash '("STREAM-ERROR" . "CONDITION-TYPE") *table*) (gethash "STREAM-ERROR" *table*))
(setf (gethash "STREAM-ERROR-STREAM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STREAM-ERROR-STREAM"))
    (CHAPTER ("## 構文") 2 (CODE1 "stream-error-stream") " " (STRONG "condition") " => "
     (STRONG "stream"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "condition") " - 型" (CODE1 "stream-error")
     "のコンディション" EOL1 (STRONG "stream") " - ストリーム")
    (CHAPTER ("## 定義") 2 "型" (CODE1 "stream-error") "のコンディションの" "問題のあるストリームを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-input-from-string (s \"(FOO\")"
      "  (handler-case (read s)" "    (end-of-file (c)"
      "      (format nil \"~&End of file on ~S.\" (stream-error-stream c)))))"
      "\"End of file on #<String Stream>.\""))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "stream-error") "," "9. コンディション")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("STREAM-ERROR-STREAM" . "FUNCTION") *table*) (gethash "STREAM-ERROR-STREAM" *table*))
(setf (gethash "STREAM-EXTERNAL-FORMAT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STREAM-EXTERNAL-FORMAT"))
    (CHAPTER ("## 構文") 2 (CODE1 "stream-external-format") " " (STRONG "stream") " => "
     (STRONG "format"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream") " - ファイルストリーム" EOL1 (STRONG "format")
     " - 外部ファイルフォーマット")
    (CHAPTER ("## 定義") 2 (STRONG "stream") "の外部ファイルフォーマット指定子を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-open-file (stream \"test\" :direction :output)"
      "  (stream-external-format stream))" "=>  :DEFAULT" "OR=>  :ISO8859/1-1987"
      "OR=>  (:ASCII :SAIL)" "OR=>  ACME::PROPRIETARY-FILE-FORMAT-17"
      "OR=>  #<FILE-FORMAT :ISO646-1983 2343673>"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "open") "関数と" (CODE1 "with-open-file") "マクロの"
     (CODE1 ":external-format") "引数")
    (CHAPTER ("## 備考") 2 "返却された" (STRONG "format") "は、他の実装で意味がある必要はありません。")))
(setf (gethash '("STREAM-EXTERNAL-FORMAT" . "FUNCTION") *table*) (gethash "STREAM-EXTERNAL-FORMAT" *table*))
(setf (gethash "STREAMP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STREAMP"))
    (CHAPTER ("## 構文") 2 (CODE1 "streamp") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が" (CODE1 "stream") "の型であれば" (STRONG "true")
     "を、" "それ以外は" (STRONG "false") "を返却します。" EOL2 (CODE1 "streamp") "は" (STRONG "object")
     "がストリームであったときに" "開いているか閉じているかによる影響はありません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(streamp *terminal-io*) =>  true" "(streamp 1) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(streamp object) ==  (typep object 'stream)"))))
(setf (gethash '("STREAMP" . "FUNCTION") *table*) (gethash "STREAMP" *table*))
(setf (gethash "STRING" *table*)
  '("STRING FUNCTION" EOL1 "STRING SYSTEM-CLASS" EOL1))
(setf (gethash '("STRING" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING"))
    (CHAPTER ("## 構文") 2 (CODE1 "string") " " (STRONG "x") " => " (STRONG "string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "x") " - 文字列か、シンボルか、文字" EOL1 (STRONG "string")
     " - 文字列")
    (CHAPTER ("## 定義") 2 (STRONG "x") "が次のようなときに文字列を返却します。" EOL2 "- もし" (STRONG "x")
     "が文字列の場合は、それが返却されます" "- もし" (STRONG "x") "がシンボルの場合は、シンボルの名前が返却されます" "- もし"
     (STRONG "x") "が文字の場合は、一文字で構成される文字列が返却されます" "- 加えて、" (CODE1 "string")
     "は実装依存の変換を行います")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string \"already a string\") =>  \"already a string\""
      "(string 'elm) =>  \"ELM\"" "(string #\\c) =>  \"c\""))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし変換が仕様にも実装にも定義されていなかった場合は、" "型" (CODE1 "type-error")
     "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 (CODE1 "coerce") ", " (CODE1 "string") ".")
    (CHAPTER ("## 備考") 2 (CODE1 "coerce") "は、文字のシーケンスを文字列に変換するのに使われます。" EOL2
     (CODE1 "prin1-to-string") ", " (CODE1 "princ-to-string") ", "
     (CODE1 "write-to-string") "," (CODE1 "format") " (最初の引数が" (CODE1 "nil") ")は、"
     "数や他のオブジェクトの文字列の表現を取得するのに使われます。")))
(setf (gethash '("STRING" . "SYSTEM-CLASS") *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "STRING"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "string") ", " (CODE1 "vector") ","
     (CODE1 "array") ", " (CODE1 "sequence") ", " (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "文字列(string)とは、要素が" (CODE1 "character") "か、" "あるいは"
     (CODE1 "string") "のサブタイプである" "specialized-vectorです。" EOL2
     "オブジェクトの生成時に型指定子として使用された場合、" (CODE1 "character") "は" (CODE1 "(vector character)")
     "を意味します。")
    (CHAPTER ("## 型指定子の種類") 2 "省略。")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "string") " " (STRONG "[size]"))
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "size") " - 非負の" (CODE1 "fixnum") "か、シンボル"
     (CODE1 "*"))
    (CHAPTER ("## 型指定子の定義") 2 (CODE1 "character") "の全てのサブタイプを" (CODE1 "c") "としたとき、" "全ての"
     (CODE1 "(array c (size))") "の和集合を示します。" "このとき、" (STRONG "size") "は文字列の集合のサイズです。")
    (CHAPTER ("## 参考") 2 "16.1. 文字の説明, 2.4.5. ダブルクォート, 22.1.3.4. 文字列の印字")))
(setf (gethash "STRING-CAPITALIZE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING-UPCASE") ", " (CODE1 "STRING-DOWNCASE")
     ", " (CODE1 "STRING-CAPITALIZE") "," (CODE1 "NSTRING-UPCASE") ", "
     (CODE1 "NSTRING-DOWNCASE") ", " (CODE1 "NSTRING-CAPITALIZE"))
    (CHAPTER ("## 構文") 2 (CODE1 "string-upcase") " " (STRONG "string") " &key "
     (STRONG "start") " " (STRONG "end") " => " (STRONG "cased-string") EOL1
     (CODE1 "string-downcase") " " (STRONG "string") " &key " (STRONG "start") " "
     (STRONG "end") " => " (STRONG "cased-string") EOL1 (CODE1 "string-capitalize") " "
     (STRONG "string") " &key " (STRONG "start") " " (STRONG "end") " => "
     (STRONG "cased-string") EOL1 (CODE1 "nstring-upcase") " " (STRONG "string") " &key "
     (STRONG "start") " " (STRONG "end") " => " (STRONG "string") EOL1
     (CODE1 "string-downcase") " " (STRONG "string") " &key " (STRONG "start") " "
     (STRONG "end") " => " (STRONG "string") EOL1 (CODE1 "string-capitalize") " "
     (STRONG "string") " &key " (STRONG "start") " " (STRONG "end") " => "
     (STRONG "string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string") " - string-designator。ただし、"
     (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") "の場合は、" "文字列出なければならない。" EOL1 (STRONG "start") ", "
     (STRONG "end") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end") "の標準値はそれぞれ"
     (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "cased-string") " - 文字列。")
    (CHAPTER ("## 定義") 2 (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "," (CODE1 "nstring-upcase") ", "
     (CODE1 "nstring-downcase") ", " (CODE1 "nstring-capitalize") "は、" "文字列の"
     (STRONG "start") ", " (STRONG "end") "の境界間の列のケース（大文字小文字）を次のように変更します。" EOL2 "- "
     (CODE1 "string-upcase") EOL1 (CODE1 "string-upcase") "は、" (STRONG "string")
     "の全ての小文字を、" "対応する大文字に全て置き換えた文字列を返却します。" "正確には、返却された文字列の各文字は、" (STRONG "string")
     "の各文字に対して関数" (CODE1 "char-upcase") "の実行によって生成されたものです。" EOL2 "- "
     (CODE1 "string-downcase") EOL1 (CODE1 "string-downcase") "は、"
     (CODE1 "string-upcase") "と似ていますが、" "全ての大文字を小文字に置き換えるところが違っています" "("
     (CODE1 "char-downcase") "を使用します）。" EOL2 "- " (CODE1 "string-capitalize") EOL1
     (CODE1 "string-capitalize") "は、すべての単語" (CODE1 "word") "について、" (CODE1 "word")
     "の最初の文字が大文字であり、" "その他の文字が小文字であるような文字列のコピーを作成します。" (CODE1 "string-capitalize") "では、"
     "英数字からなる連続した文字列の両端を、" "英数字以外の文字か、" "または文字列の終端で区切ったものを単語" (CODE1 "word") "と定義しています。"
     EOL2 "- " (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") EOL1 (CODE1 "nstring-upcase") ", "
     (CODE1 "nstring-downcase") ", " (CODE1 "nstring-capitalize") "は、" "それぞれ"
     (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "と" "同一ですが、" (STRONG "string") "を変更するところが違っています。" EOL2
     (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "は、" (STRONG "string") "を変更しません。" "しかし文字列に変更する文字がない場合は、"
     "処理系の判断により、返却値は" (STRONG "string") "かあるいはそのコピーのどちらかになります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string-upcase \"abcde\") =>  \"ABCDE\""
      "(string-upcase \"Dr. Livingston, I presume?\")"
      "=>  \"DR. LIVINGSTON, I PRESUME?\""
      "(string-upcase \"Dr. Livingston, I presume?\" :start 6 :end 10)"
      "=>  \"Dr. LiVINGston, I presume?\""
      "(string-downcase \"Dr. Livingston, I presume?\")"
      "=>  \"dr. livingston, i presume?\"" NIL
      "(string-capitalize \"elm 13c arthur;fig don't\") =>  \"Elm 13c Arthur;Fig Don'T\""
      "(string-capitalize \" hello \") =>  \" Hello \""
      "(string-capitalize \"occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION\")"
      "=>   \"Occluded Casements Forestall Inadvertent Defenestration\""
      "(string-capitalize 'kludgy-hash-search) =>  \"Kludgy-Hash-Search\""
      "(string-capitalize \"DON'T!\") =>  \"Don'T!\"    ;not \"Don't!\""
      "(string-capitalize \"pipe 13a, foo16c\") =>  \"Pipe 13a, Foo16c\"" NIL
      "(setq str (copy-seq \"0123ABCD890a\")) =>  \"0123ABCD890a\""
      "(nstring-downcase str :start 5 :end 7) =>  \"0123AbcD890a\""
      "str =>  \"0123AbcD890a\""))
    (CHAPTER ("## 副作用") 2 (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") "は、" "新しい文字列を構築するのではなく、" (STRONG "string") "を変更します。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char-upcase") ", " (CODE1 "char-downcase") ".")
    (CHAPTER ("## 備考") 2 "返却値は常に" (STRONG "string") "と同じ長さです。")))
(setf (gethash '("STRING-CAPITALIZE" . "FUNCTION") *table*) (gethash "STRING-CAPITALIZE" *table*))
(setf (gethash "STRING-DOWNCASE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING-UPCASE") ", " (CODE1 "STRING-DOWNCASE")
     ", " (CODE1 "STRING-CAPITALIZE") "," (CODE1 "NSTRING-UPCASE") ", "
     (CODE1 "NSTRING-DOWNCASE") ", " (CODE1 "NSTRING-CAPITALIZE"))
    (CHAPTER ("## 構文") 2 (CODE1 "string-upcase") " " (STRONG "string") " &key "
     (STRONG "start") " " (STRONG "end") " => " (STRONG "cased-string") EOL1
     (CODE1 "string-downcase") " " (STRONG "string") " &key " (STRONG "start") " "
     (STRONG "end") " => " (STRONG "cased-string") EOL1 (CODE1 "string-capitalize") " "
     (STRONG "string") " &key " (STRONG "start") " " (STRONG "end") " => "
     (STRONG "cased-string") EOL1 (CODE1 "nstring-upcase") " " (STRONG "string") " &key "
     (STRONG "start") " " (STRONG "end") " => " (STRONG "string") EOL1
     (CODE1 "string-downcase") " " (STRONG "string") " &key " (STRONG "start") " "
     (STRONG "end") " => " (STRONG "string") EOL1 (CODE1 "string-capitalize") " "
     (STRONG "string") " &key " (STRONG "start") " " (STRONG "end") " => "
     (STRONG "string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string") " - string-designator。ただし、"
     (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") "の場合は、" "文字列出なければならない。" EOL1 (STRONG "start") ", "
     (STRONG "end") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end") "の標準値はそれぞれ"
     (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "cased-string") " - 文字列。")
    (CHAPTER ("## 定義") 2 (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "," (CODE1 "nstring-upcase") ", "
     (CODE1 "nstring-downcase") ", " (CODE1 "nstring-capitalize") "は、" "文字列の"
     (STRONG "start") ", " (STRONG "end") "の境界間の列のケース（大文字小文字）を次のように変更します。" EOL2 "- "
     (CODE1 "string-upcase") EOL1 (CODE1 "string-upcase") "は、" (STRONG "string")
     "の全ての小文字を、" "対応する大文字に全て置き換えた文字列を返却します。" "正確には、返却された文字列の各文字は、" (STRONG "string")
     "の各文字に対して関数" (CODE1 "char-upcase") "の実行によって生成されたものです。" EOL2 "- "
     (CODE1 "string-downcase") EOL1 (CODE1 "string-downcase") "は、"
     (CODE1 "string-upcase") "と似ていますが、" "全ての大文字を小文字に置き換えるところが違っています" "("
     (CODE1 "char-downcase") "を使用します）。" EOL2 "- " (CODE1 "string-capitalize") EOL1
     (CODE1 "string-capitalize") "は、すべての単語" (CODE1 "word") "について、" (CODE1 "word")
     "の最初の文字が大文字であり、" "その他の文字が小文字であるような文字列のコピーを作成します。" (CODE1 "string-capitalize") "では、"
     "英数字からなる連続した文字列の両端を、" "英数字以外の文字か、" "または文字列の終端で区切ったものを単語" (CODE1 "word") "と定義しています。"
     EOL2 "- " (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") EOL1 (CODE1 "nstring-upcase") ", "
     (CODE1 "nstring-downcase") ", " (CODE1 "nstring-capitalize") "は、" "それぞれ"
     (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "と" "同一ですが、" (STRONG "string") "を変更するところが違っています。" EOL2
     (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "は、" (STRONG "string") "を変更しません。" "しかし文字列に変更する文字がない場合は、"
     "処理系の判断により、返却値は" (STRONG "string") "かあるいはそのコピーのどちらかになります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string-upcase \"abcde\") =>  \"ABCDE\""
      "(string-upcase \"Dr. Livingston, I presume?\")"
      "=>  \"DR. LIVINGSTON, I PRESUME?\""
      "(string-upcase \"Dr. Livingston, I presume?\" :start 6 :end 10)"
      "=>  \"Dr. LiVINGston, I presume?\""
      "(string-downcase \"Dr. Livingston, I presume?\")"
      "=>  \"dr. livingston, i presume?\"" NIL
      "(string-capitalize \"elm 13c arthur;fig don't\") =>  \"Elm 13c Arthur;Fig Don'T\""
      "(string-capitalize \" hello \") =>  \" Hello \""
      "(string-capitalize \"occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION\")"
      "=>   \"Occluded Casements Forestall Inadvertent Defenestration\""
      "(string-capitalize 'kludgy-hash-search) =>  \"Kludgy-Hash-Search\""
      "(string-capitalize \"DON'T!\") =>  \"Don'T!\"    ;not \"Don't!\""
      "(string-capitalize \"pipe 13a, foo16c\") =>  \"Pipe 13a, Foo16c\"" NIL
      "(setq str (copy-seq \"0123ABCD890a\")) =>  \"0123ABCD890a\""
      "(nstring-downcase str :start 5 :end 7) =>  \"0123AbcD890a\""
      "str =>  \"0123AbcD890a\""))
    (CHAPTER ("## 副作用") 2 (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") "は、" "新しい文字列を構築するのではなく、" (STRONG "string") "を変更します。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char-upcase") ", " (CODE1 "char-downcase") ".")
    (CHAPTER ("## 備考") 2 "返却値は常に" (STRONG "string") "と同じ長さです。")))
(setf (gethash '("STRING-DOWNCASE" . "FUNCTION") *table*) (gethash "STRING-DOWNCASE" *table*))
(setf (gethash "STRING-EQUAL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING=") ", " (CODE1 "STRING/=") ", "
     (CODE1 "STRING<") ", " (CODE1 "STRING>") ", " (CODE1 "STRING<=") ", "
     (CODE1 "STRING>=") ", " (CODE1 "STRING-EQUAL") ", " (CODE1 "STRING-NOT-EQUAL") ", "
     (CODE1 "STRING-LESSP") ", " (CODE1 "STRING-GREATERP") ", "
     (CODE1 "STRING-NOT-GREATERP") ", " (CODE1 "STRING-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "string=") " " (STRONG "string1") " " (STRONG "string2")
     " &key " (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " "
     (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1 (CODE1 "string/=") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string<") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string<=") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>=") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-equal") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1
     (CODE1 "string-not-equal") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-lessp") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string-greaterp") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-not-greaterp") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string-not-lessp") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string1") " - string-designator" EOL1
     (STRONG "string2") " - string-designator" EOL1 (STRONG "start1") ", "
     (STRONG "end1") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "start2") ", "
     (STRONG "end2") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean" (STRONG "mismatch-index") " - " (STRONG "string1")
     "の境界内インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "string1") "と" (STRONG "string2")
     "の辞書式比較を行います。" (CODE1 "string=") "と" (CODE1 "string-equal") "は等式関数と呼ばれます。"
     "その他の関数は不等式関数です。" "これらの関数が行う比較演算は、" (STRONG "start1") "と" (STRONG "end1") "で囲まれた"
     (STRONG "string1") "の部分文字列と、" (STRONG "start2") "と" (STRONG "end2") "で囲まれた"
     (STRONG "string2") "の部分文字列に限定されます。" EOL2 "文字列" (CODE1 "a") "と文字列" (CODE1 "b")
     "が等しいとは、" "どちらも同じ個数の文字を保有しており、" "各文字が" (CODE1 "char=") "か" (CODE1 "char-equal")
     "の適用において等しい場合です。" EOL2 "文字列" (CODE1 "a") "が文字列" (CODE1 "b") "より小さいとは、"
     "両者の文字が異なる最初の位置で、" (CODE1 "a") "の文字が" (CODE1 "char<") "または" (CODE1 "char-lessp")
     "に従って" (CODE1 "b") "の対応する文字より小さい場合、" "あるいは文字列" (CODE1 "a") "が文字列" (CODE1 "b")
     "のプレフィックス" "（文字の長さが短く、" (CODE1 "a") "のすべての文字に一致する）の場合です。" EOL2 "等式関数は、文字列が等しい場合は"
     (STRONG "generalized-boolean") "に" (STRONG "true") "を返却し、" "それ以外は" (STRONG "false")
     "を返却します。" EOL2 "不等式関数は、文字列が等しくない場合は" (STRONG "mismatch-index") "に" (STRONG "true")
     "を返却し、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "もし" (STRONG "mismatch-index") "が"
     (STRONG "true") "の場合は、" (STRONG "string1") "の開始位置をオフセット値として、"
     "2つの部分文字列が異なっている最初の文字の位置を整数で返却します。" EOL2 "比較は次のように行われます。" EOL2 "- "
     (CODE1 "string=") EOL1 (CODE1 "string=") "は、部分文字列の長さが同じであり、" "対応する位置に同じ文字が含まれているとき"
     (STRONG "true") "を返却します。" "それ以外は" (STRONG "false") "です。" EOL2 "- "
     (CODE1 "string/=") EOL1 (CODE1 "string/=") "は、部分文字列が異なっているときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-equal") EOL1
     (CODE1 "string-equal") "は、" (CODE1 "string=") "と似ていますが、"
     "大文字小文字の違いを無視するところが異なっています。" "2つの文字は" (CODE1 "char-equal") "が" (STRONG "true")
     "であれば同一とみなされます。" EOL2 "- " (CODE1 "string<") EOL1 (CODE1 "string<")
     "は、部分文字列1が部分文字列2よりも小さいときは" (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。"
     EOL2 "- " (CODE1 "string>") EOL1 (CODE1 "string>") "は、部分文字列1が部分文字列2よりも大きいときは"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "- "
     (CODE1 "string-lessp") ", " (CODE1 "string-greaterp") EOL1 (CODE1 "string-lessp")
     ", " (CODE1 "string-greaterp") "は、" "それぞれ" (CODE1 "string<") ", " (CODE1 "string>")
     "と似ていますが、" "大文字小文字を無視するところが異なっています。" EOL2 "- " (CODE1 "string<=") EOL1
     (CODE1 "string<=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは小さいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string>=") EOL1
     (CODE1 "string>=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは大きいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-not-greaterp") ", "
     (CODE1 "string-not-lessp") EOL1 (CODE1 "string-not-greaterp") "と"
     (CODE1 "string-not-lessp") "は、" "それぞれ" (CODE1 "string<=") "と" (CODE1 "string>=")
     "に似ていますが、" "大文字小文字を無視するところが異なっています。" "文字を比較するときに、" (CODE1 "char<") "の代わりに"
     (CODE1 "char-lessp") "が使用されたかのように行われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string= \"foo\" \"foo\") =>  true"
      "(string= \"foo\" \"Foo\") =>  false" "(string= \"foo\" \"bar\") =>  false"
      "(string= \"together\" \"frog\" :start1 1 :end1 3 :start2 2) =>  true"
      "(string-equal \"foo\" \"Foo\") =>  true"
      "(string= \"abcd\" \"01234abcd9012\" :start2 5 :end2 9) =>  true"
      "(string< \"aaaa\" \"aaab\") =>  3" "(string>= \"aaaaa\" \"aaaa\") =>  4"
      "(string-not-greaterp \"Abcde\" \"abcdE\") =>  5"
      "(string-lessp \"012AAAA789\" \"01aaab6\" :start1 3 :end1 7"
      "                                     :start2 2 :end2 6) =>  6"
      "(string-not-equal \"AAAA\" \"aaaA\") =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char="))
    (CHAPTER ("## 備考") 2 (CODE1 "equal") "は、2つの文字列を比較するとき" (CODE1 "string=") "を呼び出します。")))
(setf (gethash '("STRING-EQUAL" . "FUNCTION") *table*) (gethash "STRING-EQUAL" *table*))
(setf (gethash "STRING-GREATERP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING=") ", " (CODE1 "STRING/=") ", "
     (CODE1 "STRING<") ", " (CODE1 "STRING>") ", " (CODE1 "STRING<=") ", "
     (CODE1 "STRING>=") ", " (CODE1 "STRING-EQUAL") ", " (CODE1 "STRING-NOT-EQUAL") ", "
     (CODE1 "STRING-LESSP") ", " (CODE1 "STRING-GREATERP") ", "
     (CODE1 "STRING-NOT-GREATERP") ", " (CODE1 "STRING-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "string=") " " (STRONG "string1") " " (STRONG "string2")
     " &key " (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " "
     (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1 (CODE1 "string/=") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string<") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string<=") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>=") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-equal") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1
     (CODE1 "string-not-equal") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-lessp") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string-greaterp") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-not-greaterp") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string-not-lessp") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string1") " - string-designator" EOL1
     (STRONG "string2") " - string-designator" EOL1 (STRONG "start1") ", "
     (STRONG "end1") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "start2") ", "
     (STRONG "end2") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean" (STRONG "mismatch-index") " - " (STRONG "string1")
     "の境界内インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "string1") "と" (STRONG "string2")
     "の辞書式比較を行います。" (CODE1 "string=") "と" (CODE1 "string-equal") "は等式関数と呼ばれます。"
     "その他の関数は不等式関数です。" "これらの関数が行う比較演算は、" (STRONG "start1") "と" (STRONG "end1") "で囲まれた"
     (STRONG "string1") "の部分文字列と、" (STRONG "start2") "と" (STRONG "end2") "で囲まれた"
     (STRONG "string2") "の部分文字列に限定されます。" EOL2 "文字列" (CODE1 "a") "と文字列" (CODE1 "b")
     "が等しいとは、" "どちらも同じ個数の文字を保有しており、" "各文字が" (CODE1 "char=") "か" (CODE1 "char-equal")
     "の適用において等しい場合です。" EOL2 "文字列" (CODE1 "a") "が文字列" (CODE1 "b") "より小さいとは、"
     "両者の文字が異なる最初の位置で、" (CODE1 "a") "の文字が" (CODE1 "char<") "または" (CODE1 "char-lessp")
     "に従って" (CODE1 "b") "の対応する文字より小さい場合、" "あるいは文字列" (CODE1 "a") "が文字列" (CODE1 "b")
     "のプレフィックス" "（文字の長さが短く、" (CODE1 "a") "のすべての文字に一致する）の場合です。" EOL2 "等式関数は、文字列が等しい場合は"
     (STRONG "generalized-boolean") "に" (STRONG "true") "を返却し、" "それ以外は" (STRONG "false")
     "を返却します。" EOL2 "不等式関数は、文字列が等しくない場合は" (STRONG "mismatch-index") "に" (STRONG "true")
     "を返却し、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "もし" (STRONG "mismatch-index") "が"
     (STRONG "true") "の場合は、" (STRONG "string1") "の開始位置をオフセット値として、"
     "2つの部分文字列が異なっている最初の文字の位置を整数で返却します。" EOL2 "比較は次のように行われます。" EOL2 "- "
     (CODE1 "string=") EOL1 (CODE1 "string=") "は、部分文字列の長さが同じであり、" "対応する位置に同じ文字が含まれているとき"
     (STRONG "true") "を返却します。" "それ以外は" (STRONG "false") "です。" EOL2 "- "
     (CODE1 "string/=") EOL1 (CODE1 "string/=") "は、部分文字列が異なっているときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-equal") EOL1
     (CODE1 "string-equal") "は、" (CODE1 "string=") "と似ていますが、"
     "大文字小文字の違いを無視するところが異なっています。" "2つの文字は" (CODE1 "char-equal") "が" (STRONG "true")
     "であれば同一とみなされます。" EOL2 "- " (CODE1 "string<") EOL1 (CODE1 "string<")
     "は、部分文字列1が部分文字列2よりも小さいときは" (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。"
     EOL2 "- " (CODE1 "string>") EOL1 (CODE1 "string>") "は、部分文字列1が部分文字列2よりも大きいときは"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "- "
     (CODE1 "string-lessp") ", " (CODE1 "string-greaterp") EOL1 (CODE1 "string-lessp")
     ", " (CODE1 "string-greaterp") "は、" "それぞれ" (CODE1 "string<") ", " (CODE1 "string>")
     "と似ていますが、" "大文字小文字を無視するところが異なっています。" EOL2 "- " (CODE1 "string<=") EOL1
     (CODE1 "string<=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは小さいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string>=") EOL1
     (CODE1 "string>=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは大きいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-not-greaterp") ", "
     (CODE1 "string-not-lessp") EOL1 (CODE1 "string-not-greaterp") "と"
     (CODE1 "string-not-lessp") "は、" "それぞれ" (CODE1 "string<=") "と" (CODE1 "string>=")
     "に似ていますが、" "大文字小文字を無視するところが異なっています。" "文字を比較するときに、" (CODE1 "char<") "の代わりに"
     (CODE1 "char-lessp") "が使用されたかのように行われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string= \"foo\" \"foo\") =>  true"
      "(string= \"foo\" \"Foo\") =>  false" "(string= \"foo\" \"bar\") =>  false"
      "(string= \"together\" \"frog\" :start1 1 :end1 3 :start2 2) =>  true"
      "(string-equal \"foo\" \"Foo\") =>  true"
      "(string= \"abcd\" \"01234abcd9012\" :start2 5 :end2 9) =>  true"
      "(string< \"aaaa\" \"aaab\") =>  3" "(string>= \"aaaaa\" \"aaaa\") =>  4"
      "(string-not-greaterp \"Abcde\" \"abcdE\") =>  5"
      "(string-lessp \"012AAAA789\" \"01aaab6\" :start1 3 :end1 7"
      "                                     :start2 2 :end2 6) =>  6"
      "(string-not-equal \"AAAA\" \"aaaA\") =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char="))
    (CHAPTER ("## 備考") 2 (CODE1 "equal") "は、2つの文字列を比較するとき" (CODE1 "string=") "を呼び出します。")))
(setf (gethash '("STRING-GREATERP" . "FUNCTION") *table*) (gethash "STRING-GREATERP" *table*))
(setf (gethash "STRING-LEFT-TRIM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING-TRIM") ", " (CODE1 "STRING-LEFT-TRIM") ", "
     (CODE1 "STRING-RIGHT-TRIM"))
    (CHAPTER ("## 構文") 2 (CODE1 "string-trim") " " (STRONG "character-bag") " "
     (STRONG "string") " => " (STRONG "trimmed-string") EOL1 (CODE1 "string-left-trim")
     " " (STRONG "character-bag") " " (STRONG "string") " => " (STRONG "trimmed-string")
     EOL1 (CODE1 "string-right-trim") " " (STRONG "character-bag") " " (STRONG "string")
     " => " (STRONG "trimmed-string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character-bag") " - 文字列を含むシーケンス" EOL1
     (STRONG "string") " - string-designator" EOL1 (STRONG "trimmed-string") " - 文字列")
    (CHAPTER ("## 定義") 2 (CODE1 "string-trim") "は、" (STRONG "string") "の先頭と末尾から"
     (STRONG "character-bag") "内のすべての文字を取り除いた文字列を返します。" (CODE1 "string-left-trim")
     "は似た動作をしますが、" "文字列の先頭からのみ文字を取り除きます。" (CODE1 "string-right-trim") "は末尾からのみ取り除きます。"
     EOL2 "もし" (STRONG "string") "から取り除く必要がない場合は、" "処理系の判断により、" (STRONG "string")
     "そのものか、あるいはそのコピーが返却されます。" EOL2 "全ての関数はfill-pointerを考慮します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string-trim \"abc\" \"abcaakaaakabcaaa\") =>  \"kaaak\""
      "(string-trim '(#\\Space #\\Tab #\\Newline) \" garbanzo beans"
      "       \") =>  \"garbanzo beans\"" NIL
      "(string-trim \" (*)\" \" ( *three (silly) words* ) \")"
      "=>  \"three (silly) words\"" NIL
      "(string-left-trim \"abc\" \"labcabcabc\") =>  \"labcabcabc\""
      "(string-left-trim \" (*)\" \" ( *three (silly) words* ) \")"
      "=>  \"three (silly) words* ) \"" NIL
      "(string-right-trim \" (*)\" \" ( *three (silly) words* ) \") "
      "=>  \" ( *three (silly) words\""))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "処理系。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("STRING-LEFT-TRIM" . "FUNCTION") *table*) (gethash "STRING-LEFT-TRIM" *table*))
(setf (gethash "STRING-LESSP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING=") ", " (CODE1 "STRING/=") ", "
     (CODE1 "STRING<") ", " (CODE1 "STRING>") ", " (CODE1 "STRING<=") ", "
     (CODE1 "STRING>=") ", " (CODE1 "STRING-EQUAL") ", " (CODE1 "STRING-NOT-EQUAL") ", "
     (CODE1 "STRING-LESSP") ", " (CODE1 "STRING-GREATERP") ", "
     (CODE1 "STRING-NOT-GREATERP") ", " (CODE1 "STRING-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "string=") " " (STRONG "string1") " " (STRONG "string2")
     " &key " (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " "
     (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1 (CODE1 "string/=") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string<") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string<=") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>=") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-equal") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1
     (CODE1 "string-not-equal") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-lessp") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string-greaterp") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-not-greaterp") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string-not-lessp") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string1") " - string-designator" EOL1
     (STRONG "string2") " - string-designator" EOL1 (STRONG "start1") ", "
     (STRONG "end1") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "start2") ", "
     (STRONG "end2") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean" (STRONG "mismatch-index") " - " (STRONG "string1")
     "の境界内インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "string1") "と" (STRONG "string2")
     "の辞書式比較を行います。" (CODE1 "string=") "と" (CODE1 "string-equal") "は等式関数と呼ばれます。"
     "その他の関数は不等式関数です。" "これらの関数が行う比較演算は、" (STRONG "start1") "と" (STRONG "end1") "で囲まれた"
     (STRONG "string1") "の部分文字列と、" (STRONG "start2") "と" (STRONG "end2") "で囲まれた"
     (STRONG "string2") "の部分文字列に限定されます。" EOL2 "文字列" (CODE1 "a") "と文字列" (CODE1 "b")
     "が等しいとは、" "どちらも同じ個数の文字を保有しており、" "各文字が" (CODE1 "char=") "か" (CODE1 "char-equal")
     "の適用において等しい場合です。" EOL2 "文字列" (CODE1 "a") "が文字列" (CODE1 "b") "より小さいとは、"
     "両者の文字が異なる最初の位置で、" (CODE1 "a") "の文字が" (CODE1 "char<") "または" (CODE1 "char-lessp")
     "に従って" (CODE1 "b") "の対応する文字より小さい場合、" "あるいは文字列" (CODE1 "a") "が文字列" (CODE1 "b")
     "のプレフィックス" "（文字の長さが短く、" (CODE1 "a") "のすべての文字に一致する）の場合です。" EOL2 "等式関数は、文字列が等しい場合は"
     (STRONG "generalized-boolean") "に" (STRONG "true") "を返却し、" "それ以外は" (STRONG "false")
     "を返却します。" EOL2 "不等式関数は、文字列が等しくない場合は" (STRONG "mismatch-index") "に" (STRONG "true")
     "を返却し、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "もし" (STRONG "mismatch-index") "が"
     (STRONG "true") "の場合は、" (STRONG "string1") "の開始位置をオフセット値として、"
     "2つの部分文字列が異なっている最初の文字の位置を整数で返却します。" EOL2 "比較は次のように行われます。" EOL2 "- "
     (CODE1 "string=") EOL1 (CODE1 "string=") "は、部分文字列の長さが同じであり、" "対応する位置に同じ文字が含まれているとき"
     (STRONG "true") "を返却します。" "それ以外は" (STRONG "false") "です。" EOL2 "- "
     (CODE1 "string/=") EOL1 (CODE1 "string/=") "は、部分文字列が異なっているときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-equal") EOL1
     (CODE1 "string-equal") "は、" (CODE1 "string=") "と似ていますが、"
     "大文字小文字の違いを無視するところが異なっています。" "2つの文字は" (CODE1 "char-equal") "が" (STRONG "true")
     "であれば同一とみなされます。" EOL2 "- " (CODE1 "string<") EOL1 (CODE1 "string<")
     "は、部分文字列1が部分文字列2よりも小さいときは" (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。"
     EOL2 "- " (CODE1 "string>") EOL1 (CODE1 "string>") "は、部分文字列1が部分文字列2よりも大きいときは"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "- "
     (CODE1 "string-lessp") ", " (CODE1 "string-greaterp") EOL1 (CODE1 "string-lessp")
     ", " (CODE1 "string-greaterp") "は、" "それぞれ" (CODE1 "string<") ", " (CODE1 "string>")
     "と似ていますが、" "大文字小文字を無視するところが異なっています。" EOL2 "- " (CODE1 "string<=") EOL1
     (CODE1 "string<=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは小さいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string>=") EOL1
     (CODE1 "string>=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは大きいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-not-greaterp") ", "
     (CODE1 "string-not-lessp") EOL1 (CODE1 "string-not-greaterp") "と"
     (CODE1 "string-not-lessp") "は、" "それぞれ" (CODE1 "string<=") "と" (CODE1 "string>=")
     "に似ていますが、" "大文字小文字を無視するところが異なっています。" "文字を比較するときに、" (CODE1 "char<") "の代わりに"
     (CODE1 "char-lessp") "が使用されたかのように行われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string= \"foo\" \"foo\") =>  true"
      "(string= \"foo\" \"Foo\") =>  false" "(string= \"foo\" \"bar\") =>  false"
      "(string= \"together\" \"frog\" :start1 1 :end1 3 :start2 2) =>  true"
      "(string-equal \"foo\" \"Foo\") =>  true"
      "(string= \"abcd\" \"01234abcd9012\" :start2 5 :end2 9) =>  true"
      "(string< \"aaaa\" \"aaab\") =>  3" "(string>= \"aaaaa\" \"aaaa\") =>  4"
      "(string-not-greaterp \"Abcde\" \"abcdE\") =>  5"
      "(string-lessp \"012AAAA789\" \"01aaab6\" :start1 3 :end1 7"
      "                                     :start2 2 :end2 6) =>  6"
      "(string-not-equal \"AAAA\" \"aaaA\") =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char="))
    (CHAPTER ("## 備考") 2 (CODE1 "equal") "は、2つの文字列を比較するとき" (CODE1 "string=") "を呼び出します。")))
(setf (gethash '("STRING-LESSP" . "FUNCTION") *table*) (gethash "STRING-LESSP" *table*))
(setf (gethash "STRING-NOT-EQUAL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING=") ", " (CODE1 "STRING/=") ", "
     (CODE1 "STRING<") ", " (CODE1 "STRING>") ", " (CODE1 "STRING<=") ", "
     (CODE1 "STRING>=") ", " (CODE1 "STRING-EQUAL") ", " (CODE1 "STRING-NOT-EQUAL") ", "
     (CODE1 "STRING-LESSP") ", " (CODE1 "STRING-GREATERP") ", "
     (CODE1 "STRING-NOT-GREATERP") ", " (CODE1 "STRING-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "string=") " " (STRONG "string1") " " (STRONG "string2")
     " &key " (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " "
     (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1 (CODE1 "string/=") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string<") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string<=") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>=") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-equal") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1
     (CODE1 "string-not-equal") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-lessp") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string-greaterp") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-not-greaterp") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string-not-lessp") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string1") " - string-designator" EOL1
     (STRONG "string2") " - string-designator" EOL1 (STRONG "start1") ", "
     (STRONG "end1") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "start2") ", "
     (STRONG "end2") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean" (STRONG "mismatch-index") " - " (STRONG "string1")
     "の境界内インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "string1") "と" (STRONG "string2")
     "の辞書式比較を行います。" (CODE1 "string=") "と" (CODE1 "string-equal") "は等式関数と呼ばれます。"
     "その他の関数は不等式関数です。" "これらの関数が行う比較演算は、" (STRONG "start1") "と" (STRONG "end1") "で囲まれた"
     (STRONG "string1") "の部分文字列と、" (STRONG "start2") "と" (STRONG "end2") "で囲まれた"
     (STRONG "string2") "の部分文字列に限定されます。" EOL2 "文字列" (CODE1 "a") "と文字列" (CODE1 "b")
     "が等しいとは、" "どちらも同じ個数の文字を保有しており、" "各文字が" (CODE1 "char=") "か" (CODE1 "char-equal")
     "の適用において等しい場合です。" EOL2 "文字列" (CODE1 "a") "が文字列" (CODE1 "b") "より小さいとは、"
     "両者の文字が異なる最初の位置で、" (CODE1 "a") "の文字が" (CODE1 "char<") "または" (CODE1 "char-lessp")
     "に従って" (CODE1 "b") "の対応する文字より小さい場合、" "あるいは文字列" (CODE1 "a") "が文字列" (CODE1 "b")
     "のプレフィックス" "（文字の長さが短く、" (CODE1 "a") "のすべての文字に一致する）の場合です。" EOL2 "等式関数は、文字列が等しい場合は"
     (STRONG "generalized-boolean") "に" (STRONG "true") "を返却し、" "それ以外は" (STRONG "false")
     "を返却します。" EOL2 "不等式関数は、文字列が等しくない場合は" (STRONG "mismatch-index") "に" (STRONG "true")
     "を返却し、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "もし" (STRONG "mismatch-index") "が"
     (STRONG "true") "の場合は、" (STRONG "string1") "の開始位置をオフセット値として、"
     "2つの部分文字列が異なっている最初の文字の位置を整数で返却します。" EOL2 "比較は次のように行われます。" EOL2 "- "
     (CODE1 "string=") EOL1 (CODE1 "string=") "は、部分文字列の長さが同じであり、" "対応する位置に同じ文字が含まれているとき"
     (STRONG "true") "を返却します。" "それ以外は" (STRONG "false") "です。" EOL2 "- "
     (CODE1 "string/=") EOL1 (CODE1 "string/=") "は、部分文字列が異なっているときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-equal") EOL1
     (CODE1 "string-equal") "は、" (CODE1 "string=") "と似ていますが、"
     "大文字小文字の違いを無視するところが異なっています。" "2つの文字は" (CODE1 "char-equal") "が" (STRONG "true")
     "であれば同一とみなされます。" EOL2 "- " (CODE1 "string<") EOL1 (CODE1 "string<")
     "は、部分文字列1が部分文字列2よりも小さいときは" (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。"
     EOL2 "- " (CODE1 "string>") EOL1 (CODE1 "string>") "は、部分文字列1が部分文字列2よりも大きいときは"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "- "
     (CODE1 "string-lessp") ", " (CODE1 "string-greaterp") EOL1 (CODE1 "string-lessp")
     ", " (CODE1 "string-greaterp") "は、" "それぞれ" (CODE1 "string<") ", " (CODE1 "string>")
     "と似ていますが、" "大文字小文字を無視するところが異なっています。" EOL2 "- " (CODE1 "string<=") EOL1
     (CODE1 "string<=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは小さいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string>=") EOL1
     (CODE1 "string>=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは大きいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-not-greaterp") ", "
     (CODE1 "string-not-lessp") EOL1 (CODE1 "string-not-greaterp") "と"
     (CODE1 "string-not-lessp") "は、" "それぞれ" (CODE1 "string<=") "と" (CODE1 "string>=")
     "に似ていますが、" "大文字小文字を無視するところが異なっています。" "文字を比較するときに、" (CODE1 "char<") "の代わりに"
     (CODE1 "char-lessp") "が使用されたかのように行われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string= \"foo\" \"foo\") =>  true"
      "(string= \"foo\" \"Foo\") =>  false" "(string= \"foo\" \"bar\") =>  false"
      "(string= \"together\" \"frog\" :start1 1 :end1 3 :start2 2) =>  true"
      "(string-equal \"foo\" \"Foo\") =>  true"
      "(string= \"abcd\" \"01234abcd9012\" :start2 5 :end2 9) =>  true"
      "(string< \"aaaa\" \"aaab\") =>  3" "(string>= \"aaaaa\" \"aaaa\") =>  4"
      "(string-not-greaterp \"Abcde\" \"abcdE\") =>  5"
      "(string-lessp \"012AAAA789\" \"01aaab6\" :start1 3 :end1 7"
      "                                     :start2 2 :end2 6) =>  6"
      "(string-not-equal \"AAAA\" \"aaaA\") =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char="))
    (CHAPTER ("## 備考") 2 (CODE1 "equal") "は、2つの文字列を比較するとき" (CODE1 "string=") "を呼び出します。")))
(setf (gethash '("STRING-NOT-EQUAL" . "FUNCTION") *table*) (gethash "STRING-NOT-EQUAL" *table*))
(setf (gethash "STRING-NOT-GREATERP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING=") ", " (CODE1 "STRING/=") ", "
     (CODE1 "STRING<") ", " (CODE1 "STRING>") ", " (CODE1 "STRING<=") ", "
     (CODE1 "STRING>=") ", " (CODE1 "STRING-EQUAL") ", " (CODE1 "STRING-NOT-EQUAL") ", "
     (CODE1 "STRING-LESSP") ", " (CODE1 "STRING-GREATERP") ", "
     (CODE1 "STRING-NOT-GREATERP") ", " (CODE1 "STRING-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "string=") " " (STRONG "string1") " " (STRONG "string2")
     " &key " (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " "
     (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1 (CODE1 "string/=") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string<") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string<=") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>=") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-equal") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1
     (CODE1 "string-not-equal") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-lessp") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string-greaterp") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-not-greaterp") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string-not-lessp") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string1") " - string-designator" EOL1
     (STRONG "string2") " - string-designator" EOL1 (STRONG "start1") ", "
     (STRONG "end1") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "start2") ", "
     (STRONG "end2") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean" (STRONG "mismatch-index") " - " (STRONG "string1")
     "の境界内インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "string1") "と" (STRONG "string2")
     "の辞書式比較を行います。" (CODE1 "string=") "と" (CODE1 "string-equal") "は等式関数と呼ばれます。"
     "その他の関数は不等式関数です。" "これらの関数が行う比較演算は、" (STRONG "start1") "と" (STRONG "end1") "で囲まれた"
     (STRONG "string1") "の部分文字列と、" (STRONG "start2") "と" (STRONG "end2") "で囲まれた"
     (STRONG "string2") "の部分文字列に限定されます。" EOL2 "文字列" (CODE1 "a") "と文字列" (CODE1 "b")
     "が等しいとは、" "どちらも同じ個数の文字を保有しており、" "各文字が" (CODE1 "char=") "か" (CODE1 "char-equal")
     "の適用において等しい場合です。" EOL2 "文字列" (CODE1 "a") "が文字列" (CODE1 "b") "より小さいとは、"
     "両者の文字が異なる最初の位置で、" (CODE1 "a") "の文字が" (CODE1 "char<") "または" (CODE1 "char-lessp")
     "に従って" (CODE1 "b") "の対応する文字より小さい場合、" "あるいは文字列" (CODE1 "a") "が文字列" (CODE1 "b")
     "のプレフィックス" "（文字の長さが短く、" (CODE1 "a") "のすべての文字に一致する）の場合です。" EOL2 "等式関数は、文字列が等しい場合は"
     (STRONG "generalized-boolean") "に" (STRONG "true") "を返却し、" "それ以外は" (STRONG "false")
     "を返却します。" EOL2 "不等式関数は、文字列が等しくない場合は" (STRONG "mismatch-index") "に" (STRONG "true")
     "を返却し、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "もし" (STRONG "mismatch-index") "が"
     (STRONG "true") "の場合は、" (STRONG "string1") "の開始位置をオフセット値として、"
     "2つの部分文字列が異なっている最初の文字の位置を整数で返却します。" EOL2 "比較は次のように行われます。" EOL2 "- "
     (CODE1 "string=") EOL1 (CODE1 "string=") "は、部分文字列の長さが同じであり、" "対応する位置に同じ文字が含まれているとき"
     (STRONG "true") "を返却します。" "それ以外は" (STRONG "false") "です。" EOL2 "- "
     (CODE1 "string/=") EOL1 (CODE1 "string/=") "は、部分文字列が異なっているときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-equal") EOL1
     (CODE1 "string-equal") "は、" (CODE1 "string=") "と似ていますが、"
     "大文字小文字の違いを無視するところが異なっています。" "2つの文字は" (CODE1 "char-equal") "が" (STRONG "true")
     "であれば同一とみなされます。" EOL2 "- " (CODE1 "string<") EOL1 (CODE1 "string<")
     "は、部分文字列1が部分文字列2よりも小さいときは" (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。"
     EOL2 "- " (CODE1 "string>") EOL1 (CODE1 "string>") "は、部分文字列1が部分文字列2よりも大きいときは"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "- "
     (CODE1 "string-lessp") ", " (CODE1 "string-greaterp") EOL1 (CODE1 "string-lessp")
     ", " (CODE1 "string-greaterp") "は、" "それぞれ" (CODE1 "string<") ", " (CODE1 "string>")
     "と似ていますが、" "大文字小文字を無視するところが異なっています。" EOL2 "- " (CODE1 "string<=") EOL1
     (CODE1 "string<=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは小さいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string>=") EOL1
     (CODE1 "string>=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは大きいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-not-greaterp") ", "
     (CODE1 "string-not-lessp") EOL1 (CODE1 "string-not-greaterp") "と"
     (CODE1 "string-not-lessp") "は、" "それぞれ" (CODE1 "string<=") "と" (CODE1 "string>=")
     "に似ていますが、" "大文字小文字を無視するところが異なっています。" "文字を比較するときに、" (CODE1 "char<") "の代わりに"
     (CODE1 "char-lessp") "が使用されたかのように行われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string= \"foo\" \"foo\") =>  true"
      "(string= \"foo\" \"Foo\") =>  false" "(string= \"foo\" \"bar\") =>  false"
      "(string= \"together\" \"frog\" :start1 1 :end1 3 :start2 2) =>  true"
      "(string-equal \"foo\" \"Foo\") =>  true"
      "(string= \"abcd\" \"01234abcd9012\" :start2 5 :end2 9) =>  true"
      "(string< \"aaaa\" \"aaab\") =>  3" "(string>= \"aaaaa\" \"aaaa\") =>  4"
      "(string-not-greaterp \"Abcde\" \"abcdE\") =>  5"
      "(string-lessp \"012AAAA789\" \"01aaab6\" :start1 3 :end1 7"
      "                                     :start2 2 :end2 6) =>  6"
      "(string-not-equal \"AAAA\" \"aaaA\") =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char="))
    (CHAPTER ("## 備考") 2 (CODE1 "equal") "は、2つの文字列を比較するとき" (CODE1 "string=") "を呼び出します。")))
(setf (gethash '("STRING-NOT-GREATERP" . "FUNCTION") *table*) (gethash "STRING-NOT-GREATERP" *table*))
(setf (gethash "STRING-NOT-LESSP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING=") ", " (CODE1 "STRING/=") ", "
     (CODE1 "STRING<") ", " (CODE1 "STRING>") ", " (CODE1 "STRING<=") ", "
     (CODE1 "STRING>=") ", " (CODE1 "STRING-EQUAL") ", " (CODE1 "STRING-NOT-EQUAL") ", "
     (CODE1 "STRING-LESSP") ", " (CODE1 "STRING-GREATERP") ", "
     (CODE1 "STRING-NOT-GREATERP") ", " (CODE1 "STRING-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "string=") " " (STRONG "string1") " " (STRONG "string2")
     " &key " (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " "
     (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1 (CODE1 "string/=") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string<") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string<=") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>=") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-equal") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1
     (CODE1 "string-not-equal") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-lessp") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string-greaterp") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-not-greaterp") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string-not-lessp") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string1") " - string-designator" EOL1
     (STRONG "string2") " - string-designator" EOL1 (STRONG "start1") ", "
     (STRONG "end1") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "start2") ", "
     (STRONG "end2") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean" (STRONG "mismatch-index") " - " (STRONG "string1")
     "の境界内インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "string1") "と" (STRONG "string2")
     "の辞書式比較を行います。" (CODE1 "string=") "と" (CODE1 "string-equal") "は等式関数と呼ばれます。"
     "その他の関数は不等式関数です。" "これらの関数が行う比較演算は、" (STRONG "start1") "と" (STRONG "end1") "で囲まれた"
     (STRONG "string1") "の部分文字列と、" (STRONG "start2") "と" (STRONG "end2") "で囲まれた"
     (STRONG "string2") "の部分文字列に限定されます。" EOL2 "文字列" (CODE1 "a") "と文字列" (CODE1 "b")
     "が等しいとは、" "どちらも同じ個数の文字を保有しており、" "各文字が" (CODE1 "char=") "か" (CODE1 "char-equal")
     "の適用において等しい場合です。" EOL2 "文字列" (CODE1 "a") "が文字列" (CODE1 "b") "より小さいとは、"
     "両者の文字が異なる最初の位置で、" (CODE1 "a") "の文字が" (CODE1 "char<") "または" (CODE1 "char-lessp")
     "に従って" (CODE1 "b") "の対応する文字より小さい場合、" "あるいは文字列" (CODE1 "a") "が文字列" (CODE1 "b")
     "のプレフィックス" "（文字の長さが短く、" (CODE1 "a") "のすべての文字に一致する）の場合です。" EOL2 "等式関数は、文字列が等しい場合は"
     (STRONG "generalized-boolean") "に" (STRONG "true") "を返却し、" "それ以外は" (STRONG "false")
     "を返却します。" EOL2 "不等式関数は、文字列が等しくない場合は" (STRONG "mismatch-index") "に" (STRONG "true")
     "を返却し、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "もし" (STRONG "mismatch-index") "が"
     (STRONG "true") "の場合は、" (STRONG "string1") "の開始位置をオフセット値として、"
     "2つの部分文字列が異なっている最初の文字の位置を整数で返却します。" EOL2 "比較は次のように行われます。" EOL2 "- "
     (CODE1 "string=") EOL1 (CODE1 "string=") "は、部分文字列の長さが同じであり、" "対応する位置に同じ文字が含まれているとき"
     (STRONG "true") "を返却します。" "それ以外は" (STRONG "false") "です。" EOL2 "- "
     (CODE1 "string/=") EOL1 (CODE1 "string/=") "は、部分文字列が異なっているときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-equal") EOL1
     (CODE1 "string-equal") "は、" (CODE1 "string=") "と似ていますが、"
     "大文字小文字の違いを無視するところが異なっています。" "2つの文字は" (CODE1 "char-equal") "が" (STRONG "true")
     "であれば同一とみなされます。" EOL2 "- " (CODE1 "string<") EOL1 (CODE1 "string<")
     "は、部分文字列1が部分文字列2よりも小さいときは" (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。"
     EOL2 "- " (CODE1 "string>") EOL1 (CODE1 "string>") "は、部分文字列1が部分文字列2よりも大きいときは"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "- "
     (CODE1 "string-lessp") ", " (CODE1 "string-greaterp") EOL1 (CODE1 "string-lessp")
     ", " (CODE1 "string-greaterp") "は、" "それぞれ" (CODE1 "string<") ", " (CODE1 "string>")
     "と似ていますが、" "大文字小文字を無視するところが異なっています。" EOL2 "- " (CODE1 "string<=") EOL1
     (CODE1 "string<=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは小さいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string>=") EOL1
     (CODE1 "string>=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは大きいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-not-greaterp") ", "
     (CODE1 "string-not-lessp") EOL1 (CODE1 "string-not-greaterp") "と"
     (CODE1 "string-not-lessp") "は、" "それぞれ" (CODE1 "string<=") "と" (CODE1 "string>=")
     "に似ていますが、" "大文字小文字を無視するところが異なっています。" "文字を比較するときに、" (CODE1 "char<") "の代わりに"
     (CODE1 "char-lessp") "が使用されたかのように行われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string= \"foo\" \"foo\") =>  true"
      "(string= \"foo\" \"Foo\") =>  false" "(string= \"foo\" \"bar\") =>  false"
      "(string= \"together\" \"frog\" :start1 1 :end1 3 :start2 2) =>  true"
      "(string-equal \"foo\" \"Foo\") =>  true"
      "(string= \"abcd\" \"01234abcd9012\" :start2 5 :end2 9) =>  true"
      "(string< \"aaaa\" \"aaab\") =>  3" "(string>= \"aaaaa\" \"aaaa\") =>  4"
      "(string-not-greaterp \"Abcde\" \"abcdE\") =>  5"
      "(string-lessp \"012AAAA789\" \"01aaab6\" :start1 3 :end1 7"
      "                                     :start2 2 :end2 6) =>  6"
      "(string-not-equal \"AAAA\" \"aaaA\") =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char="))
    (CHAPTER ("## 備考") 2 (CODE1 "equal") "は、2つの文字列を比較するとき" (CODE1 "string=") "を呼び出します。")))
(setf (gethash '("STRING-NOT-LESSP" . "FUNCTION") *table*) (gethash "STRING-NOT-LESSP" *table*))
(setf (gethash "STRING-RIGHT-TRIM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING-TRIM") ", " (CODE1 "STRING-LEFT-TRIM") ", "
     (CODE1 "STRING-RIGHT-TRIM"))
    (CHAPTER ("## 構文") 2 (CODE1 "string-trim") " " (STRONG "character-bag") " "
     (STRONG "string") " => " (STRONG "trimmed-string") EOL1 (CODE1 "string-left-trim")
     " " (STRONG "character-bag") " " (STRONG "string") " => " (STRONG "trimmed-string")
     EOL1 (CODE1 "string-right-trim") " " (STRONG "character-bag") " " (STRONG "string")
     " => " (STRONG "trimmed-string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character-bag") " - 文字列を含むシーケンス" EOL1
     (STRONG "string") " - string-designator" EOL1 (STRONG "trimmed-string") " - 文字列")
    (CHAPTER ("## 定義") 2 (CODE1 "string-trim") "は、" (STRONG "string") "の先頭と末尾から"
     (STRONG "character-bag") "内のすべての文字を取り除いた文字列を返します。" (CODE1 "string-left-trim")
     "は似た動作をしますが、" "文字列の先頭からのみ文字を取り除きます。" (CODE1 "string-right-trim") "は末尾からのみ取り除きます。"
     EOL2 "もし" (STRONG "string") "から取り除く必要がない場合は、" "処理系の判断により、" (STRONG "string")
     "そのものか、あるいはそのコピーが返却されます。" EOL2 "全ての関数はfill-pointerを考慮します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string-trim \"abc\" \"abcaakaaakabcaaa\") =>  \"kaaak\""
      "(string-trim '(#\\Space #\\Tab #\\Newline) \" garbanzo beans"
      "       \") =>  \"garbanzo beans\"" NIL
      "(string-trim \" (*)\" \" ( *three (silly) words* ) \")"
      "=>  \"three (silly) words\"" NIL
      "(string-left-trim \"abc\" \"labcabcabc\") =>  \"labcabcabc\""
      "(string-left-trim \" (*)\" \" ( *three (silly) words* ) \")"
      "=>  \"three (silly) words* ) \"" NIL
      "(string-right-trim \" (*)\" \" ( *three (silly) words* ) \") "
      "=>  \" ( *three (silly) words\""))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "処理系。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("STRING-RIGHT-TRIM" . "FUNCTION") *table*) (gethash "STRING-RIGHT-TRIM" *table*))
(setf (gethash "STRING-STREAM" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "STRING-STREAM"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "string-stream") "," (CODE1 "stream") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 (CODE1 "string") "ストリームは、" "文字列に関連付けられたものから" "入力として読み込むか、"
     "出力として書き込むかを行うストリームです。" EOL2 (CODE1 "string") "ストリームのストリームの要素の型は、" "常に型"
     (CODE1 "character") "のサブタイプです。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-string-input-stream") ","
     (CODE1 "make-string-output-stream") "," (CODE1 "with-input-from-string") ","
     (CODE1 "with-output-to-string"))))
(setf (gethash '("STRING-STREAM" . "SYSTEM-CLASS") *table*) (gethash "STRING-STREAM" *table*))
(setf (gethash "STRING-TRIM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING-TRIM") ", " (CODE1 "STRING-LEFT-TRIM") ", "
     (CODE1 "STRING-RIGHT-TRIM"))
    (CHAPTER ("## 構文") 2 (CODE1 "string-trim") " " (STRONG "character-bag") " "
     (STRONG "string") " => " (STRONG "trimmed-string") EOL1 (CODE1 "string-left-trim")
     " " (STRONG "character-bag") " " (STRONG "string") " => " (STRONG "trimmed-string")
     EOL1 (CODE1 "string-right-trim") " " (STRONG "character-bag") " " (STRONG "string")
     " => " (STRONG "trimmed-string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character-bag") " - 文字列を含むシーケンス" EOL1
     (STRONG "string") " - string-designator" EOL1 (STRONG "trimmed-string") " - 文字列")
    (CHAPTER ("## 定義") 2 (CODE1 "string-trim") "は、" (STRONG "string") "の先頭と末尾から"
     (STRONG "character-bag") "内のすべての文字を取り除いた文字列を返します。" (CODE1 "string-left-trim")
     "は似た動作をしますが、" "文字列の先頭からのみ文字を取り除きます。" (CODE1 "string-right-trim") "は末尾からのみ取り除きます。"
     EOL2 "もし" (STRONG "string") "から取り除く必要がない場合は、" "処理系の判断により、" (STRONG "string")
     "そのものか、あるいはそのコピーが返却されます。" EOL2 "全ての関数はfill-pointerを考慮します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string-trim \"abc\" \"abcaakaaakabcaaa\") =>  \"kaaak\""
      "(string-trim '(#\\Space #\\Tab #\\Newline) \" garbanzo beans"
      "       \") =>  \"garbanzo beans\"" NIL
      "(string-trim \" (*)\" \" ( *three (silly) words* ) \")"
      "=>  \"three (silly) words\"" NIL
      "(string-left-trim \"abc\" \"labcabcabc\") =>  \"labcabcabc\""
      "(string-left-trim \" (*)\" \" ( *three (silly) words* ) \")"
      "=>  \"three (silly) words* ) \"" NIL
      "(string-right-trim \" (*)\" \" ( *three (silly) words* ) \") "
      "=>  \" ( *three (silly) words\""))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "処理系。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("STRING-TRIM" . "FUNCTION") *table*) (gethash "STRING-TRIM" *table*))
(setf (gethash "STRING-UPCASE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING-UPCASE") ", " (CODE1 "STRING-DOWNCASE")
     ", " (CODE1 "STRING-CAPITALIZE") "," (CODE1 "NSTRING-UPCASE") ", "
     (CODE1 "NSTRING-DOWNCASE") ", " (CODE1 "NSTRING-CAPITALIZE"))
    (CHAPTER ("## 構文") 2 (CODE1 "string-upcase") " " (STRONG "string") " &key "
     (STRONG "start") " " (STRONG "end") " => " (STRONG "cased-string") EOL1
     (CODE1 "string-downcase") " " (STRONG "string") " &key " (STRONG "start") " "
     (STRONG "end") " => " (STRONG "cased-string") EOL1 (CODE1 "string-capitalize") " "
     (STRONG "string") " &key " (STRONG "start") " " (STRONG "end") " => "
     (STRONG "cased-string") EOL1 (CODE1 "nstring-upcase") " " (STRONG "string") " &key "
     (STRONG "start") " " (STRONG "end") " => " (STRONG "string") EOL1
     (CODE1 "string-downcase") " " (STRONG "string") " &key " (STRONG "start") " "
     (STRONG "end") " => " (STRONG "string") EOL1 (CODE1 "string-capitalize") " "
     (STRONG "string") " &key " (STRONG "start") " " (STRONG "end") " => "
     (STRONG "string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string") " - string-designator。ただし、"
     (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") "の場合は、" "文字列出なければならない。" EOL1 (STRONG "start") ", "
     (STRONG "end") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end") "の標準値はそれぞれ"
     (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "cased-string") " - 文字列。")
    (CHAPTER ("## 定義") 2 (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "," (CODE1 "nstring-upcase") ", "
     (CODE1 "nstring-downcase") ", " (CODE1 "nstring-capitalize") "は、" "文字列の"
     (STRONG "start") ", " (STRONG "end") "の境界間の列のケース（大文字小文字）を次のように変更します。" EOL2 "- "
     (CODE1 "string-upcase") EOL1 (CODE1 "string-upcase") "は、" (STRONG "string")
     "の全ての小文字を、" "対応する大文字に全て置き換えた文字列を返却します。" "正確には、返却された文字列の各文字は、" (STRONG "string")
     "の各文字に対して関数" (CODE1 "char-upcase") "の実行によって生成されたものです。" EOL2 "- "
     (CODE1 "string-downcase") EOL1 (CODE1 "string-downcase") "は、"
     (CODE1 "string-upcase") "と似ていますが、" "全ての大文字を小文字に置き換えるところが違っています" "("
     (CODE1 "char-downcase") "を使用します）。" EOL2 "- " (CODE1 "string-capitalize") EOL1
     (CODE1 "string-capitalize") "は、すべての単語" (CODE1 "word") "について、" (CODE1 "word")
     "の最初の文字が大文字であり、" "その他の文字が小文字であるような文字列のコピーを作成します。" (CODE1 "string-capitalize") "では、"
     "英数字からなる連続した文字列の両端を、" "英数字以外の文字か、" "または文字列の終端で区切ったものを単語" (CODE1 "word") "と定義しています。"
     EOL2 "- " (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") EOL1 (CODE1 "nstring-upcase") ", "
     (CODE1 "nstring-downcase") ", " (CODE1 "nstring-capitalize") "は、" "それぞれ"
     (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "と" "同一ですが、" (STRONG "string") "を変更するところが違っています。" EOL2
     (CODE1 "string-upcase") ", " (CODE1 "string-downcase") ", "
     (CODE1 "string-capitalize") "は、" (STRONG "string") "を変更しません。" "しかし文字列に変更する文字がない場合は、"
     "処理系の判断により、返却値は" (STRONG "string") "かあるいはそのコピーのどちらかになります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string-upcase \"abcde\") =>  \"ABCDE\""
      "(string-upcase \"Dr. Livingston, I presume?\")"
      "=>  \"DR. LIVINGSTON, I PRESUME?\""
      "(string-upcase \"Dr. Livingston, I presume?\" :start 6 :end 10)"
      "=>  \"Dr. LiVINGston, I presume?\""
      "(string-downcase \"Dr. Livingston, I presume?\")"
      "=>  \"dr. livingston, i presume?\"" NIL
      "(string-capitalize \"elm 13c arthur;fig don't\") =>  \"Elm 13c Arthur;Fig Don'T\""
      "(string-capitalize \" hello \") =>  \" Hello \""
      "(string-capitalize \"occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION\")"
      "=>   \"Occluded Casements Forestall Inadvertent Defenestration\""
      "(string-capitalize 'kludgy-hash-search) =>  \"Kludgy-Hash-Search\""
      "(string-capitalize \"DON'T!\") =>  \"Don'T!\"    ;not \"Don't!\""
      "(string-capitalize \"pipe 13a, foo16c\") =>  \"Pipe 13a, Foo16c\"" NIL
      "(setq str (copy-seq \"0123ABCD890a\")) =>  \"0123ABCD890a\""
      "(nstring-downcase str :start 5 :end 7) =>  \"0123AbcD890a\""
      "str =>  \"0123AbcD890a\""))
    (CHAPTER ("## 副作用") 2 (CODE1 "nstring-upcase") ", " (CODE1 "nstring-downcase") ", "
     (CODE1 "nstring-capitalize") "は、" "新しい文字列を構築するのではなく、" (STRONG "string") "を変更します。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char-upcase") ", " (CODE1 "char-downcase") ".")
    (CHAPTER ("## 備考") 2 "返却値は常に" (STRONG "string") "と同じ長さです。")))
(setf (gethash '("STRING-UPCASE" . "FUNCTION") *table*) (gethash "STRING-UPCASE" *table*))
(setf (gethash "STRING/=" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING=") ", " (CODE1 "STRING/=") ", "
     (CODE1 "STRING<") ", " (CODE1 "STRING>") ", " (CODE1 "STRING<=") ", "
     (CODE1 "STRING>=") ", " (CODE1 "STRING-EQUAL") ", " (CODE1 "STRING-NOT-EQUAL") ", "
     (CODE1 "STRING-LESSP") ", " (CODE1 "STRING-GREATERP") ", "
     (CODE1 "STRING-NOT-GREATERP") ", " (CODE1 "STRING-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "string=") " " (STRONG "string1") " " (STRONG "string2")
     " &key " (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " "
     (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1 (CODE1 "string/=") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string<") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string<=") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>=") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-equal") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1
     (CODE1 "string-not-equal") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-lessp") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string-greaterp") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-not-greaterp") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string-not-lessp") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string1") " - string-designator" EOL1
     (STRONG "string2") " - string-designator" EOL1 (STRONG "start1") ", "
     (STRONG "end1") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "start2") ", "
     (STRONG "end2") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean" (STRONG "mismatch-index") " - " (STRONG "string1")
     "の境界内インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "string1") "と" (STRONG "string2")
     "の辞書式比較を行います。" (CODE1 "string=") "と" (CODE1 "string-equal") "は等式関数と呼ばれます。"
     "その他の関数は不等式関数です。" "これらの関数が行う比較演算は、" (STRONG "start1") "と" (STRONG "end1") "で囲まれた"
     (STRONG "string1") "の部分文字列と、" (STRONG "start2") "と" (STRONG "end2") "で囲まれた"
     (STRONG "string2") "の部分文字列に限定されます。" EOL2 "文字列" (CODE1 "a") "と文字列" (CODE1 "b")
     "が等しいとは、" "どちらも同じ個数の文字を保有しており、" "各文字が" (CODE1 "char=") "か" (CODE1 "char-equal")
     "の適用において等しい場合です。" EOL2 "文字列" (CODE1 "a") "が文字列" (CODE1 "b") "より小さいとは、"
     "両者の文字が異なる最初の位置で、" (CODE1 "a") "の文字が" (CODE1 "char<") "または" (CODE1 "char-lessp")
     "に従って" (CODE1 "b") "の対応する文字より小さい場合、" "あるいは文字列" (CODE1 "a") "が文字列" (CODE1 "b")
     "のプレフィックス" "（文字の長さが短く、" (CODE1 "a") "のすべての文字に一致する）の場合です。" EOL2 "等式関数は、文字列が等しい場合は"
     (STRONG "generalized-boolean") "に" (STRONG "true") "を返却し、" "それ以外は" (STRONG "false")
     "を返却します。" EOL2 "不等式関数は、文字列が等しくない場合は" (STRONG "mismatch-index") "に" (STRONG "true")
     "を返却し、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "もし" (STRONG "mismatch-index") "が"
     (STRONG "true") "の場合は、" (STRONG "string1") "の開始位置をオフセット値として、"
     "2つの部分文字列が異なっている最初の文字の位置を整数で返却します。" EOL2 "比較は次のように行われます。" EOL2 "- "
     (CODE1 "string=") EOL1 (CODE1 "string=") "は、部分文字列の長さが同じであり、" "対応する位置に同じ文字が含まれているとき"
     (STRONG "true") "を返却します。" "それ以外は" (STRONG "false") "です。" EOL2 "- "
     (CODE1 "string/=") EOL1 (CODE1 "string/=") "は、部分文字列が異なっているときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-equal") EOL1
     (CODE1 "string-equal") "は、" (CODE1 "string=") "と似ていますが、"
     "大文字小文字の違いを無視するところが異なっています。" "2つの文字は" (CODE1 "char-equal") "が" (STRONG "true")
     "であれば同一とみなされます。" EOL2 "- " (CODE1 "string<") EOL1 (CODE1 "string<")
     "は、部分文字列1が部分文字列2よりも小さいときは" (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。"
     EOL2 "- " (CODE1 "string>") EOL1 (CODE1 "string>") "は、部分文字列1が部分文字列2よりも大きいときは"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "- "
     (CODE1 "string-lessp") ", " (CODE1 "string-greaterp") EOL1 (CODE1 "string-lessp")
     ", " (CODE1 "string-greaterp") "は、" "それぞれ" (CODE1 "string<") ", " (CODE1 "string>")
     "と似ていますが、" "大文字小文字を無視するところが異なっています。" EOL2 "- " (CODE1 "string<=") EOL1
     (CODE1 "string<=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは小さいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string>=") EOL1
     (CODE1 "string>=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは大きいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-not-greaterp") ", "
     (CODE1 "string-not-lessp") EOL1 (CODE1 "string-not-greaterp") "と"
     (CODE1 "string-not-lessp") "は、" "それぞれ" (CODE1 "string<=") "と" (CODE1 "string>=")
     "に似ていますが、" "大文字小文字を無視するところが異なっています。" "文字を比較するときに、" (CODE1 "char<") "の代わりに"
     (CODE1 "char-lessp") "が使用されたかのように行われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string= \"foo\" \"foo\") =>  true"
      "(string= \"foo\" \"Foo\") =>  false" "(string= \"foo\" \"bar\") =>  false"
      "(string= \"together\" \"frog\" :start1 1 :end1 3 :start2 2) =>  true"
      "(string-equal \"foo\" \"Foo\") =>  true"
      "(string= \"abcd\" \"01234abcd9012\" :start2 5 :end2 9) =>  true"
      "(string< \"aaaa\" \"aaab\") =>  3" "(string>= \"aaaaa\" \"aaaa\") =>  4"
      "(string-not-greaterp \"Abcde\" \"abcdE\") =>  5"
      "(string-lessp \"012AAAA789\" \"01aaab6\" :start1 3 :end1 7"
      "                                     :start2 2 :end2 6) =>  6"
      "(string-not-equal \"AAAA\" \"aaaA\") =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char="))
    (CHAPTER ("## 備考") 2 (CODE1 "equal") "は、2つの文字列を比較するとき" (CODE1 "string=") "を呼び出します。")))
(setf (gethash '("STRING/=" . "FUNCTION") *table*) (gethash "STRING/=" *table*))
(setf (gethash "STRING<" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING=") ", " (CODE1 "STRING/=") ", "
     (CODE1 "STRING<") ", " (CODE1 "STRING>") ", " (CODE1 "STRING<=") ", "
     (CODE1 "STRING>=") ", " (CODE1 "STRING-EQUAL") ", " (CODE1 "STRING-NOT-EQUAL") ", "
     (CODE1 "STRING-LESSP") ", " (CODE1 "STRING-GREATERP") ", "
     (CODE1 "STRING-NOT-GREATERP") ", " (CODE1 "STRING-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "string=") " " (STRONG "string1") " " (STRONG "string2")
     " &key " (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " "
     (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1 (CODE1 "string/=") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string<") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string<=") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>=") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-equal") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1
     (CODE1 "string-not-equal") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-lessp") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string-greaterp") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-not-greaterp") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string-not-lessp") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string1") " - string-designator" EOL1
     (STRONG "string2") " - string-designator" EOL1 (STRONG "start1") ", "
     (STRONG "end1") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "start2") ", "
     (STRONG "end2") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean" (STRONG "mismatch-index") " - " (STRONG "string1")
     "の境界内インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "string1") "と" (STRONG "string2")
     "の辞書式比較を行います。" (CODE1 "string=") "と" (CODE1 "string-equal") "は等式関数と呼ばれます。"
     "その他の関数は不等式関数です。" "これらの関数が行う比較演算は、" (STRONG "start1") "と" (STRONG "end1") "で囲まれた"
     (STRONG "string1") "の部分文字列と、" (STRONG "start2") "と" (STRONG "end2") "で囲まれた"
     (STRONG "string2") "の部分文字列に限定されます。" EOL2 "文字列" (CODE1 "a") "と文字列" (CODE1 "b")
     "が等しいとは、" "どちらも同じ個数の文字を保有しており、" "各文字が" (CODE1 "char=") "か" (CODE1 "char-equal")
     "の適用において等しい場合です。" EOL2 "文字列" (CODE1 "a") "が文字列" (CODE1 "b") "より小さいとは、"
     "両者の文字が異なる最初の位置で、" (CODE1 "a") "の文字が" (CODE1 "char<") "または" (CODE1 "char-lessp")
     "に従って" (CODE1 "b") "の対応する文字より小さい場合、" "あるいは文字列" (CODE1 "a") "が文字列" (CODE1 "b")
     "のプレフィックス" "（文字の長さが短く、" (CODE1 "a") "のすべての文字に一致する）の場合です。" EOL2 "等式関数は、文字列が等しい場合は"
     (STRONG "generalized-boolean") "に" (STRONG "true") "を返却し、" "それ以外は" (STRONG "false")
     "を返却します。" EOL2 "不等式関数は、文字列が等しくない場合は" (STRONG "mismatch-index") "に" (STRONG "true")
     "を返却し、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "もし" (STRONG "mismatch-index") "が"
     (STRONG "true") "の場合は、" (STRONG "string1") "の開始位置をオフセット値として、"
     "2つの部分文字列が異なっている最初の文字の位置を整数で返却します。" EOL2 "比較は次のように行われます。" EOL2 "- "
     (CODE1 "string=") EOL1 (CODE1 "string=") "は、部分文字列の長さが同じであり、" "対応する位置に同じ文字が含まれているとき"
     (STRONG "true") "を返却します。" "それ以外は" (STRONG "false") "です。" EOL2 "- "
     (CODE1 "string/=") EOL1 (CODE1 "string/=") "は、部分文字列が異なっているときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-equal") EOL1
     (CODE1 "string-equal") "は、" (CODE1 "string=") "と似ていますが、"
     "大文字小文字の違いを無視するところが異なっています。" "2つの文字は" (CODE1 "char-equal") "が" (STRONG "true")
     "であれば同一とみなされます。" EOL2 "- " (CODE1 "string<") EOL1 (CODE1 "string<")
     "は、部分文字列1が部分文字列2よりも小さいときは" (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。"
     EOL2 "- " (CODE1 "string>") EOL1 (CODE1 "string>") "は、部分文字列1が部分文字列2よりも大きいときは"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "- "
     (CODE1 "string-lessp") ", " (CODE1 "string-greaterp") EOL1 (CODE1 "string-lessp")
     ", " (CODE1 "string-greaterp") "は、" "それぞれ" (CODE1 "string<") ", " (CODE1 "string>")
     "と似ていますが、" "大文字小文字を無視するところが異なっています。" EOL2 "- " (CODE1 "string<=") EOL1
     (CODE1 "string<=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは小さいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string>=") EOL1
     (CODE1 "string>=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは大きいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-not-greaterp") ", "
     (CODE1 "string-not-lessp") EOL1 (CODE1 "string-not-greaterp") "と"
     (CODE1 "string-not-lessp") "は、" "それぞれ" (CODE1 "string<=") "と" (CODE1 "string>=")
     "に似ていますが、" "大文字小文字を無視するところが異なっています。" "文字を比較するときに、" (CODE1 "char<") "の代わりに"
     (CODE1 "char-lessp") "が使用されたかのように行われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string= \"foo\" \"foo\") =>  true"
      "(string= \"foo\" \"Foo\") =>  false" "(string= \"foo\" \"bar\") =>  false"
      "(string= \"together\" \"frog\" :start1 1 :end1 3 :start2 2) =>  true"
      "(string-equal \"foo\" \"Foo\") =>  true"
      "(string= \"abcd\" \"01234abcd9012\" :start2 5 :end2 9) =>  true"
      "(string< \"aaaa\" \"aaab\") =>  3" "(string>= \"aaaaa\" \"aaaa\") =>  4"
      "(string-not-greaterp \"Abcde\" \"abcdE\") =>  5"
      "(string-lessp \"012AAAA789\" \"01aaab6\" :start1 3 :end1 7"
      "                                     :start2 2 :end2 6) =>  6"
      "(string-not-equal \"AAAA\" \"aaaA\") =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char="))
    (CHAPTER ("## 備考") 2 (CODE1 "equal") "は、2つの文字列を比較するとき" (CODE1 "string=") "を呼び出します。")))
(setf (gethash '("STRING<" . "FUNCTION") *table*) (gethash "STRING<" *table*))
(setf (gethash "STRING<=" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING=") ", " (CODE1 "STRING/=") ", "
     (CODE1 "STRING<") ", " (CODE1 "STRING>") ", " (CODE1 "STRING<=") ", "
     (CODE1 "STRING>=") ", " (CODE1 "STRING-EQUAL") ", " (CODE1 "STRING-NOT-EQUAL") ", "
     (CODE1 "STRING-LESSP") ", " (CODE1 "STRING-GREATERP") ", "
     (CODE1 "STRING-NOT-GREATERP") ", " (CODE1 "STRING-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "string=") " " (STRONG "string1") " " (STRONG "string2")
     " &key " (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " "
     (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1 (CODE1 "string/=") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string<") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string<=") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>=") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-equal") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1
     (CODE1 "string-not-equal") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-lessp") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string-greaterp") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-not-greaterp") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string-not-lessp") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string1") " - string-designator" EOL1
     (STRONG "string2") " - string-designator" EOL1 (STRONG "start1") ", "
     (STRONG "end1") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "start2") ", "
     (STRONG "end2") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean" (STRONG "mismatch-index") " - " (STRONG "string1")
     "の境界内インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "string1") "と" (STRONG "string2")
     "の辞書式比較を行います。" (CODE1 "string=") "と" (CODE1 "string-equal") "は等式関数と呼ばれます。"
     "その他の関数は不等式関数です。" "これらの関数が行う比較演算は、" (STRONG "start1") "と" (STRONG "end1") "で囲まれた"
     (STRONG "string1") "の部分文字列と、" (STRONG "start2") "と" (STRONG "end2") "で囲まれた"
     (STRONG "string2") "の部分文字列に限定されます。" EOL2 "文字列" (CODE1 "a") "と文字列" (CODE1 "b")
     "が等しいとは、" "どちらも同じ個数の文字を保有しており、" "各文字が" (CODE1 "char=") "か" (CODE1 "char-equal")
     "の適用において等しい場合です。" EOL2 "文字列" (CODE1 "a") "が文字列" (CODE1 "b") "より小さいとは、"
     "両者の文字が異なる最初の位置で、" (CODE1 "a") "の文字が" (CODE1 "char<") "または" (CODE1 "char-lessp")
     "に従って" (CODE1 "b") "の対応する文字より小さい場合、" "あるいは文字列" (CODE1 "a") "が文字列" (CODE1 "b")
     "のプレフィックス" "（文字の長さが短く、" (CODE1 "a") "のすべての文字に一致する）の場合です。" EOL2 "等式関数は、文字列が等しい場合は"
     (STRONG "generalized-boolean") "に" (STRONG "true") "を返却し、" "それ以外は" (STRONG "false")
     "を返却します。" EOL2 "不等式関数は、文字列が等しくない場合は" (STRONG "mismatch-index") "に" (STRONG "true")
     "を返却し、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "もし" (STRONG "mismatch-index") "が"
     (STRONG "true") "の場合は、" (STRONG "string1") "の開始位置をオフセット値として、"
     "2つの部分文字列が異なっている最初の文字の位置を整数で返却します。" EOL2 "比較は次のように行われます。" EOL2 "- "
     (CODE1 "string=") EOL1 (CODE1 "string=") "は、部分文字列の長さが同じであり、" "対応する位置に同じ文字が含まれているとき"
     (STRONG "true") "を返却します。" "それ以外は" (STRONG "false") "です。" EOL2 "- "
     (CODE1 "string/=") EOL1 (CODE1 "string/=") "は、部分文字列が異なっているときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-equal") EOL1
     (CODE1 "string-equal") "は、" (CODE1 "string=") "と似ていますが、"
     "大文字小文字の違いを無視するところが異なっています。" "2つの文字は" (CODE1 "char-equal") "が" (STRONG "true")
     "であれば同一とみなされます。" EOL2 "- " (CODE1 "string<") EOL1 (CODE1 "string<")
     "は、部分文字列1が部分文字列2よりも小さいときは" (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。"
     EOL2 "- " (CODE1 "string>") EOL1 (CODE1 "string>") "は、部分文字列1が部分文字列2よりも大きいときは"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "- "
     (CODE1 "string-lessp") ", " (CODE1 "string-greaterp") EOL1 (CODE1 "string-lessp")
     ", " (CODE1 "string-greaterp") "は、" "それぞれ" (CODE1 "string<") ", " (CODE1 "string>")
     "と似ていますが、" "大文字小文字を無視するところが異なっています。" EOL2 "- " (CODE1 "string<=") EOL1
     (CODE1 "string<=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは小さいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string>=") EOL1
     (CODE1 "string>=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは大きいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-not-greaterp") ", "
     (CODE1 "string-not-lessp") EOL1 (CODE1 "string-not-greaterp") "と"
     (CODE1 "string-not-lessp") "は、" "それぞれ" (CODE1 "string<=") "と" (CODE1 "string>=")
     "に似ていますが、" "大文字小文字を無視するところが異なっています。" "文字を比較するときに、" (CODE1 "char<") "の代わりに"
     (CODE1 "char-lessp") "が使用されたかのように行われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string= \"foo\" \"foo\") =>  true"
      "(string= \"foo\" \"Foo\") =>  false" "(string= \"foo\" \"bar\") =>  false"
      "(string= \"together\" \"frog\" :start1 1 :end1 3 :start2 2) =>  true"
      "(string-equal \"foo\" \"Foo\") =>  true"
      "(string= \"abcd\" \"01234abcd9012\" :start2 5 :end2 9) =>  true"
      "(string< \"aaaa\" \"aaab\") =>  3" "(string>= \"aaaaa\" \"aaaa\") =>  4"
      "(string-not-greaterp \"Abcde\" \"abcdE\") =>  5"
      "(string-lessp \"012AAAA789\" \"01aaab6\" :start1 3 :end1 7"
      "                                     :start2 2 :end2 6) =>  6"
      "(string-not-equal \"AAAA\" \"aaaA\") =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char="))
    (CHAPTER ("## 備考") 2 (CODE1 "equal") "は、2つの文字列を比較するとき" (CODE1 "string=") "を呼び出します。")))
(setf (gethash '("STRING<=" . "FUNCTION") *table*) (gethash "STRING<=" *table*))
(setf (gethash "STRING=" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING=") ", " (CODE1 "STRING/=") ", "
     (CODE1 "STRING<") ", " (CODE1 "STRING>") ", " (CODE1 "STRING<=") ", "
     (CODE1 "STRING>=") ", " (CODE1 "STRING-EQUAL") ", " (CODE1 "STRING-NOT-EQUAL") ", "
     (CODE1 "STRING-LESSP") ", " (CODE1 "STRING-GREATERP") ", "
     (CODE1 "STRING-NOT-GREATERP") ", " (CODE1 "STRING-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "string=") " " (STRONG "string1") " " (STRONG "string2")
     " &key " (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " "
     (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1 (CODE1 "string/=") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string<") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string<=") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>=") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-equal") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1
     (CODE1 "string-not-equal") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-lessp") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string-greaterp") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-not-greaterp") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string-not-lessp") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string1") " - string-designator" EOL1
     (STRONG "string2") " - string-designator" EOL1 (STRONG "start1") ", "
     (STRONG "end1") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "start2") ", "
     (STRONG "end2") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean" (STRONG "mismatch-index") " - " (STRONG "string1")
     "の境界内インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "string1") "と" (STRONG "string2")
     "の辞書式比較を行います。" (CODE1 "string=") "と" (CODE1 "string-equal") "は等式関数と呼ばれます。"
     "その他の関数は不等式関数です。" "これらの関数が行う比較演算は、" (STRONG "start1") "と" (STRONG "end1") "で囲まれた"
     (STRONG "string1") "の部分文字列と、" (STRONG "start2") "と" (STRONG "end2") "で囲まれた"
     (STRONG "string2") "の部分文字列に限定されます。" EOL2 "文字列" (CODE1 "a") "と文字列" (CODE1 "b")
     "が等しいとは、" "どちらも同じ個数の文字を保有しており、" "各文字が" (CODE1 "char=") "か" (CODE1 "char-equal")
     "の適用において等しい場合です。" EOL2 "文字列" (CODE1 "a") "が文字列" (CODE1 "b") "より小さいとは、"
     "両者の文字が異なる最初の位置で、" (CODE1 "a") "の文字が" (CODE1 "char<") "または" (CODE1 "char-lessp")
     "に従って" (CODE1 "b") "の対応する文字より小さい場合、" "あるいは文字列" (CODE1 "a") "が文字列" (CODE1 "b")
     "のプレフィックス" "（文字の長さが短く、" (CODE1 "a") "のすべての文字に一致する）の場合です。" EOL2 "等式関数は、文字列が等しい場合は"
     (STRONG "generalized-boolean") "に" (STRONG "true") "を返却し、" "それ以外は" (STRONG "false")
     "を返却します。" EOL2 "不等式関数は、文字列が等しくない場合は" (STRONG "mismatch-index") "に" (STRONG "true")
     "を返却し、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "もし" (STRONG "mismatch-index") "が"
     (STRONG "true") "の場合は、" (STRONG "string1") "の開始位置をオフセット値として、"
     "2つの部分文字列が異なっている最初の文字の位置を整数で返却します。" EOL2 "比較は次のように行われます。" EOL2 "- "
     (CODE1 "string=") EOL1 (CODE1 "string=") "は、部分文字列の長さが同じであり、" "対応する位置に同じ文字が含まれているとき"
     (STRONG "true") "を返却します。" "それ以外は" (STRONG "false") "です。" EOL2 "- "
     (CODE1 "string/=") EOL1 (CODE1 "string/=") "は、部分文字列が異なっているときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-equal") EOL1
     (CODE1 "string-equal") "は、" (CODE1 "string=") "と似ていますが、"
     "大文字小文字の違いを無視するところが異なっています。" "2つの文字は" (CODE1 "char-equal") "が" (STRONG "true")
     "であれば同一とみなされます。" EOL2 "- " (CODE1 "string<") EOL1 (CODE1 "string<")
     "は、部分文字列1が部分文字列2よりも小さいときは" (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。"
     EOL2 "- " (CODE1 "string>") EOL1 (CODE1 "string>") "は、部分文字列1が部分文字列2よりも大きいときは"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "- "
     (CODE1 "string-lessp") ", " (CODE1 "string-greaterp") EOL1 (CODE1 "string-lessp")
     ", " (CODE1 "string-greaterp") "は、" "それぞれ" (CODE1 "string<") ", " (CODE1 "string>")
     "と似ていますが、" "大文字小文字を無視するところが異なっています。" EOL2 "- " (CODE1 "string<=") EOL1
     (CODE1 "string<=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは小さいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string>=") EOL1
     (CODE1 "string>=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは大きいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-not-greaterp") ", "
     (CODE1 "string-not-lessp") EOL1 (CODE1 "string-not-greaterp") "と"
     (CODE1 "string-not-lessp") "は、" "それぞれ" (CODE1 "string<=") "と" (CODE1 "string>=")
     "に似ていますが、" "大文字小文字を無視するところが異なっています。" "文字を比較するときに、" (CODE1 "char<") "の代わりに"
     (CODE1 "char-lessp") "が使用されたかのように行われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string= \"foo\" \"foo\") =>  true"
      "(string= \"foo\" \"Foo\") =>  false" "(string= \"foo\" \"bar\") =>  false"
      "(string= \"together\" \"frog\" :start1 1 :end1 3 :start2 2) =>  true"
      "(string-equal \"foo\" \"Foo\") =>  true"
      "(string= \"abcd\" \"01234abcd9012\" :start2 5 :end2 9) =>  true"
      "(string< \"aaaa\" \"aaab\") =>  3" "(string>= \"aaaaa\" \"aaaa\") =>  4"
      "(string-not-greaterp \"Abcde\" \"abcdE\") =>  5"
      "(string-lessp \"012AAAA789\" \"01aaab6\" :start1 3 :end1 7"
      "                                     :start2 2 :end2 6) =>  6"
      "(string-not-equal \"AAAA\" \"aaaA\") =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char="))
    (CHAPTER ("## 備考") 2 (CODE1 "equal") "は、2つの文字列を比較するとき" (CODE1 "string=") "を呼び出します。")))
(setf (gethash '("STRING=" . "FUNCTION") *table*) (gethash "STRING=" *table*))
(setf (gethash "STRING>" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING=") ", " (CODE1 "STRING/=") ", "
     (CODE1 "STRING<") ", " (CODE1 "STRING>") ", " (CODE1 "STRING<=") ", "
     (CODE1 "STRING>=") ", " (CODE1 "STRING-EQUAL") ", " (CODE1 "STRING-NOT-EQUAL") ", "
     (CODE1 "STRING-LESSP") ", " (CODE1 "STRING-GREATERP") ", "
     (CODE1 "STRING-NOT-GREATERP") ", " (CODE1 "STRING-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "string=") " " (STRONG "string1") " " (STRONG "string2")
     " &key " (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " "
     (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1 (CODE1 "string/=") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string<") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string<=") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>=") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-equal") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1
     (CODE1 "string-not-equal") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-lessp") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string-greaterp") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-not-greaterp") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string-not-lessp") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string1") " - string-designator" EOL1
     (STRONG "string2") " - string-designator" EOL1 (STRONG "start1") ", "
     (STRONG "end1") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "start2") ", "
     (STRONG "end2") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean" (STRONG "mismatch-index") " - " (STRONG "string1")
     "の境界内インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "string1") "と" (STRONG "string2")
     "の辞書式比較を行います。" (CODE1 "string=") "と" (CODE1 "string-equal") "は等式関数と呼ばれます。"
     "その他の関数は不等式関数です。" "これらの関数が行う比較演算は、" (STRONG "start1") "と" (STRONG "end1") "で囲まれた"
     (STRONG "string1") "の部分文字列と、" (STRONG "start2") "と" (STRONG "end2") "で囲まれた"
     (STRONG "string2") "の部分文字列に限定されます。" EOL2 "文字列" (CODE1 "a") "と文字列" (CODE1 "b")
     "が等しいとは、" "どちらも同じ個数の文字を保有しており、" "各文字が" (CODE1 "char=") "か" (CODE1 "char-equal")
     "の適用において等しい場合です。" EOL2 "文字列" (CODE1 "a") "が文字列" (CODE1 "b") "より小さいとは、"
     "両者の文字が異なる最初の位置で、" (CODE1 "a") "の文字が" (CODE1 "char<") "または" (CODE1 "char-lessp")
     "に従って" (CODE1 "b") "の対応する文字より小さい場合、" "あるいは文字列" (CODE1 "a") "が文字列" (CODE1 "b")
     "のプレフィックス" "（文字の長さが短く、" (CODE1 "a") "のすべての文字に一致する）の場合です。" EOL2 "等式関数は、文字列が等しい場合は"
     (STRONG "generalized-boolean") "に" (STRONG "true") "を返却し、" "それ以外は" (STRONG "false")
     "を返却します。" EOL2 "不等式関数は、文字列が等しくない場合は" (STRONG "mismatch-index") "に" (STRONG "true")
     "を返却し、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "もし" (STRONG "mismatch-index") "が"
     (STRONG "true") "の場合は、" (STRONG "string1") "の開始位置をオフセット値として、"
     "2つの部分文字列が異なっている最初の文字の位置を整数で返却します。" EOL2 "比較は次のように行われます。" EOL2 "- "
     (CODE1 "string=") EOL1 (CODE1 "string=") "は、部分文字列の長さが同じであり、" "対応する位置に同じ文字が含まれているとき"
     (STRONG "true") "を返却します。" "それ以外は" (STRONG "false") "です。" EOL2 "- "
     (CODE1 "string/=") EOL1 (CODE1 "string/=") "は、部分文字列が異なっているときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-equal") EOL1
     (CODE1 "string-equal") "は、" (CODE1 "string=") "と似ていますが、"
     "大文字小文字の違いを無視するところが異なっています。" "2つの文字は" (CODE1 "char-equal") "が" (STRONG "true")
     "であれば同一とみなされます。" EOL2 "- " (CODE1 "string<") EOL1 (CODE1 "string<")
     "は、部分文字列1が部分文字列2よりも小さいときは" (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。"
     EOL2 "- " (CODE1 "string>") EOL1 (CODE1 "string>") "は、部分文字列1が部分文字列2よりも大きいときは"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "- "
     (CODE1 "string-lessp") ", " (CODE1 "string-greaterp") EOL1 (CODE1 "string-lessp")
     ", " (CODE1 "string-greaterp") "は、" "それぞれ" (CODE1 "string<") ", " (CODE1 "string>")
     "と似ていますが、" "大文字小文字を無視するところが異なっています。" EOL2 "- " (CODE1 "string<=") EOL1
     (CODE1 "string<=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは小さいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string>=") EOL1
     (CODE1 "string>=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは大きいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-not-greaterp") ", "
     (CODE1 "string-not-lessp") EOL1 (CODE1 "string-not-greaterp") "と"
     (CODE1 "string-not-lessp") "は、" "それぞれ" (CODE1 "string<=") "と" (CODE1 "string>=")
     "に似ていますが、" "大文字小文字を無視するところが異なっています。" "文字を比較するときに、" (CODE1 "char<") "の代わりに"
     (CODE1 "char-lessp") "が使用されたかのように行われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string= \"foo\" \"foo\") =>  true"
      "(string= \"foo\" \"Foo\") =>  false" "(string= \"foo\" \"bar\") =>  false"
      "(string= \"together\" \"frog\" :start1 1 :end1 3 :start2 2) =>  true"
      "(string-equal \"foo\" \"Foo\") =>  true"
      "(string= \"abcd\" \"01234abcd9012\" :start2 5 :end2 9) =>  true"
      "(string< \"aaaa\" \"aaab\") =>  3" "(string>= \"aaaaa\" \"aaaa\") =>  4"
      "(string-not-greaterp \"Abcde\" \"abcdE\") =>  5"
      "(string-lessp \"012AAAA789\" \"01aaab6\" :start1 3 :end1 7"
      "                                     :start2 2 :end2 6) =>  6"
      "(string-not-equal \"AAAA\" \"aaaA\") =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char="))
    (CHAPTER ("## 備考") 2 (CODE1 "equal") "は、2つの文字列を比較するとき" (CODE1 "string=") "を呼び出します。")))
(setf (gethash '("STRING>" . "FUNCTION") *table*) (gethash "STRING>" *table*))
(setf (gethash "STRING>=" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRING=") ", " (CODE1 "STRING/=") ", "
     (CODE1 "STRING<") ", " (CODE1 "STRING>") ", " (CODE1 "STRING<=") ", "
     (CODE1 "STRING>=") ", " (CODE1 "STRING-EQUAL") ", " (CODE1 "STRING-NOT-EQUAL") ", "
     (CODE1 "STRING-LESSP") ", " (CODE1 "STRING-GREATERP") ", "
     (CODE1 "STRING-NOT-GREATERP") ", " (CODE1 "STRING-NOT-LESSP"))
    (CHAPTER ("## 構文") 2 (CODE1 "string=") " " (STRONG "string1") " " (STRONG "string2")
     " &key " (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " "
     (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1 (CODE1 "string/=") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string<") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string<=") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string>=") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-equal") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "generalized-boolean") EOL1
     (CODE1 "string-not-equal") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-lessp") " " (STRONG "string1")
     " " (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index") EOL1
     (CODE1 "string-greaterp") " " (STRONG "string1") " " (STRONG "string2") " &key "
     (STRONG "start1") " " (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2")
     " => " (STRONG "mismatch-index") EOL1 (CODE1 "string-not-greaterp") " "
     (STRONG "string1") " " (STRONG "string2") " &key " (STRONG "start1") " "
     (STRONG "end1") " " (STRONG "start2") " " (STRONG "end2") " => "
     (STRONG "mismatch-index") EOL1 (CODE1 "string-not-lessp") " " (STRONG "string1") " "
     (STRONG "string2") " &key " (STRONG "start1") " " (STRONG "end1") " "
     (STRONG "start2") " " (STRONG "end2") " => " (STRONG "mismatch-index"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string1") " - string-designator" EOL1
     (STRONG "string2") " - string-designator" EOL1 (STRONG "start1") ", "
     (STRONG "end1") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "start2") ", "
     (STRONG "end2") " - 文字列の境界インデックス指定子。" (STRONG "start") "と" (STRONG "end")
     "の標準値はそれぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean" (STRONG "mismatch-index") " - " (STRONG "string1")
     "の境界内インデックスか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "これらの関数は" (STRONG "string1") "と" (STRONG "string2")
     "の辞書式比較を行います。" (CODE1 "string=") "と" (CODE1 "string-equal") "は等式関数と呼ばれます。"
     "その他の関数は不等式関数です。" "これらの関数が行う比較演算は、" (STRONG "start1") "と" (STRONG "end1") "で囲まれた"
     (STRONG "string1") "の部分文字列と、" (STRONG "start2") "と" (STRONG "end2") "で囲まれた"
     (STRONG "string2") "の部分文字列に限定されます。" EOL2 "文字列" (CODE1 "a") "と文字列" (CODE1 "b")
     "が等しいとは、" "どちらも同じ個数の文字を保有しており、" "各文字が" (CODE1 "char=") "か" (CODE1 "char-equal")
     "の適用において等しい場合です。" EOL2 "文字列" (CODE1 "a") "が文字列" (CODE1 "b") "より小さいとは、"
     "両者の文字が異なる最初の位置で、" (CODE1 "a") "の文字が" (CODE1 "char<") "または" (CODE1 "char-lessp")
     "に従って" (CODE1 "b") "の対応する文字より小さい場合、" "あるいは文字列" (CODE1 "a") "が文字列" (CODE1 "b")
     "のプレフィックス" "（文字の長さが短く、" (CODE1 "a") "のすべての文字に一致する）の場合です。" EOL2 "等式関数は、文字列が等しい場合は"
     (STRONG "generalized-boolean") "に" (STRONG "true") "を返却し、" "それ以外は" (STRONG "false")
     "を返却します。" EOL2 "不等式関数は、文字列が等しくない場合は" (STRONG "mismatch-index") "に" (STRONG "true")
     "を返却し、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "もし" (STRONG "mismatch-index") "が"
     (STRONG "true") "の場合は、" (STRONG "string1") "の開始位置をオフセット値として、"
     "2つの部分文字列が異なっている最初の文字の位置を整数で返却します。" EOL2 "比較は次のように行われます。" EOL2 "- "
     (CODE1 "string=") EOL1 (CODE1 "string=") "は、部分文字列の長さが同じであり、" "対応する位置に同じ文字が含まれているとき"
     (STRONG "true") "を返却します。" "それ以外は" (STRONG "false") "です。" EOL2 "- "
     (CODE1 "string/=") EOL1 (CODE1 "string/=") "は、部分文字列が異なっているときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-equal") EOL1
     (CODE1 "string-equal") "は、" (CODE1 "string=") "と似ていますが、"
     "大文字小文字の違いを無視するところが異なっています。" "2つの文字は" (CODE1 "char-equal") "が" (STRONG "true")
     "であれば同一とみなされます。" EOL2 "- " (CODE1 "string<") EOL1 (CODE1 "string<")
     "は、部分文字列1が部分文字列2よりも小さいときは" (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。"
     EOL2 "- " (CODE1 "string>") EOL1 (CODE1 "string>") "は、部分文字列1が部分文字列2よりも大きいときは"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。" EOL2 "- "
     (CODE1 "string-lessp") ", " (CODE1 "string-greaterp") EOL1 (CODE1 "string-lessp")
     ", " (CODE1 "string-greaterp") "は、" "それぞれ" (CODE1 "string<") ", " (CODE1 "string>")
     "と似ていますが、" "大文字小文字を無視するところが異なっています。" EOL2 "- " (CODE1 "string<=") EOL1
     (CODE1 "string<=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは小さいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string>=") EOL1
     (CODE1 "string>=") "は、部分文字列1が部分文字列2を比べて" "等しいかあるいは大きいときは" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 "- " (CODE1 "string-not-greaterp") ", "
     (CODE1 "string-not-lessp") EOL1 (CODE1 "string-not-greaterp") "と"
     (CODE1 "string-not-lessp") "は、" "それぞれ" (CODE1 "string<=") "と" (CODE1 "string>=")
     "に似ていますが、" "大文字小文字を無視するところが異なっています。" "文字を比較するときに、" (CODE1 "char<") "の代わりに"
     (CODE1 "char-lessp") "が使用されたかのように行われます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(string= \"foo\" \"foo\") =>  true"
      "(string= \"foo\" \"Foo\") =>  false" "(string= \"foo\" \"bar\") =>  false"
      "(string= \"together\" \"frog\" :start1 1 :end1 3 :start2 2) =>  true"
      "(string-equal \"foo\" \"Foo\") =>  true"
      "(string= \"abcd\" \"01234abcd9012\" :start2 5 :end2 9) =>  true"
      "(string< \"aaaa\" \"aaab\") =>  3" "(string>= \"aaaaa\" \"aaaa\") =>  4"
      "(string-not-greaterp \"Abcde\" \"abcdE\") =>  5"
      "(string-lessp \"012AAAA789\" \"01aaab6\" :start1 3 :end1 7"
      "                                     :start2 2 :end2 6) =>  6"
      "(string-not-equal \"AAAA\" \"aaaA\") =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "char="))
    (CHAPTER ("## 備考") 2 (CODE1 "equal") "は、2つの文字列を比較するとき" (CODE1 "string=") "を呼び出します。")))
(setf (gethash '("STRING>=" . "FUNCTION") *table*) (gethash "STRING>=" *table*))
(setf (gethash "STRINGP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "STRINGP"))
    (CHAPTER ("## 構文") 2 (CODE1 "stringp") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が型" (CODE1 "string") "なら" (STRONG "true")
     "を、" "それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(stringp \"aaaaaa\") =>  true" "(stringp #\\a) =>  false"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "typep") ", 型" (CODE1 "string"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(stringp object) ==  (typep object 'string)"))))
(setf (gethash '("STRINGP" . "FUNCTION") *table*) (gethash "STRINGP" *table*))
(setf (gethash "STRUCTURE-CLASS" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "STRUCTURE-CLASS"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "structure-class") "," (CODE1 "class") ","
     (CODE1 "standard-object") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 (CODE1 "defstruct") "によって定義された全てのクラスは、"
     (CODE1 "structure-class") "クラスのインスタンスです。")))
(setf (gethash '("STRUCTURE-CLASS" . "SYSTEM-CLASS") *table*) (gethash "STRUCTURE-CLASS" *table*))
(setf (gethash "STRUCTURE-OBJECT" *table*)
  '((CHAPTER NIL 0 "Class " (CODE1 "STRUCTURE-OBJECT"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "structure-object") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 (CODE1 "structure-object") "クラスは" (CODE1 "structure-class")
     "のインスタンスであり、" "自分以外の" (CODE1 "structure-class") "のインスタンスの" "全てのクラスのスーパークラスであり、"
     (CODE1 "defstruct") "によって定義された" "全てのクラスのスーパークラスです。")
    (CHAPTER ("## 参考") 2 (CODE1 "defstruct") "," "2.4.8.13. シャープサイン S,"
     "22.1.3.12. 構造体の印字")))
(setf (gethash '("STRUCTURE-OBJECT" . "CLASS") *table*) (gethash "STRUCTURE-OBJECT" *table*))
(setf (gethash "STYLE-WARNING" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "STYLE-WARNING"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "style-warning") "," (CODE1 "warning") ","
     (CODE1 "condition") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "style-warning") "は、仕様に適合したコードにおいて"
     "違反しているかあるいは準標準と考えられるコードが発生している状況を" "表しているコンディションを含みます。")
    (CHAPTER ("## 参考") 2 (CODE1 "muffle-warning"))
    (CHAPTER ("## 備考") 2 "実装は、非推奨の機能であったり、" "文法違反や非効率部分があるコードに遭遇したようなときは、"
     "そのようなコンディションを通知するかもしれませんん。" EOL2 "「使用されていない変数」の警告は、" "型" (CODE1 "style-warning")
     "でなければなりません。" EOL2 "一般的に、コードが違反しているか準標準かどうかという質問は、" "そのようなコードを処理している機能によって"
     "主観的に決められます。" "そのような機能が主観的な理由でコードに文句をつけたいときはいつでも、" "この型のコンディションをを使うべきであり、"
     "そうすれば余計な警告をリダイレクトしたり消したりしたいクライアントが、" "他のもっと重大な警告をリダイレクトしたり消したりする"
     "危険を冒すことなく実施することができます。")))
(setf (gethash '("STYLE-WARNING" . "CONDITION-TYPE") *table*) (gethash "STYLE-WARNING" *table*))
(setf (gethash "SUBLIS" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SUBLIS") ", " (CODE1 "NSUBLIS"))
    (CHAPTER ("## 構文") 2 (CODE1 "sublis") " " (STRONG "alist") " " (STRONG "tree")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "new-tree") EOL1 (CODE1 "nsublis") " " (STRONG "alist") " " (STRONG "tree")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "new-tree"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "alist") " - 連想リスト" EOL1 (STRONG "tree") " - ツリー"
     EOL1 (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test-not") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "new-tree") " - ツリー")
    (CHAPTER ("## 定義") 2 (CODE1 "sublis") "は、" (STRONG "tree") "（コンスの構造）をオブジェクトに置換します。"
     (CODE1 "nsublis") "は" (CODE1 "sublis") "と似ていますが、" (STRONG "tree")
     "の関連する部分を破壊的に修正します。" EOL2 (CODE1 "sublis") "は、" (STRONG "tree") "の部分ツリーと葉を全て見ます。"
     "もし部分ツリーか葉が" (STRONG "alist") "のキーとして現れたとき" "（つまりキーと、部分ツリーか葉が" (STRONG "test")
     "を満たすとき）、" "それはキーに連想されているオブジェクトに置き換えられます。" "この操作は非破壊的です。" "実際には、" (CODE1 "sublis")
     "は複数の" (CODE1 "subst") "の操作を同時に" "行うようなものです。" EOL2 (CODE1 "sublis") "が成功すると、"
     "指定された部分ツリーと葉が出現された各部分が、" "関連付けらているオブジェクトで置き換わった" "新しいツリーが返却されます。"
     "もし変更が生じなかったときは、もとの" (STRONG "tree") "が返却されます。" "元の" (STRONG "tree")
     "に変更は生じないとしても、返却値のツリーは" "元のツリーとセルを共有しているかもしれません。" EOL2 (CODE1 "nsublis") "は"
     (STRONG "tree") "の変更を許可されていますが、" "それ以外は" (CODE1 "sublis") "と同じ値を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(sublis '((x . 100) (z . zprime))"
      "        '(plus x (minus g z x p) 4 . x))"
      "=>  (PLUS 100 (MINUS G ZPRIME 100 P) 4 . 100)"
      "(sublis '(((+ x y) . (- x y)) ((- x y) . (+ x y)))"
      "        '(* (/ (+ x y) (+ x p)) (- x y))" "        :test #'equal)"
      "=>  (* (/ (- X Y) (+ X P)) (+ X Y))"
      "(setq tree1 '(1 (1 2) ((1 2 3)) (((1 2 3 4)))))"
      "=>  (1 (1 2) ((1 2 3)) (((1 2 3 4))))" "(sublis '((3 . \"three\")) tree1) "
      "=>  (1 (1 2) ((1 2 \"three\")) (((1 2 \"three\" 4))))"
      "(sublis '((t . \"string\"))" "         (sublis '((1 . \"\") (4 . 44)) tree1)"
      "         :key #'stringp)"
      "=>  (\"string\" (\"string\" 2) ((\"string\" 2 3)) (((\"string\" 2 3 44))))"
      "tree1 =>  (1 (1 2) ((1 2 3)) (((1 2 3 4))))"
      "(setq tree2 '(\"one\" (\"one\" \"two\") ((\"one\" \"Two\" \"three\"))))"
      "=>  (\"one\" (\"one\" \"two\") ((\"one\" \"Two\" \"three\"))) "
      "(sublis '((\"two\" . 2)) tree2) "
      "=>  (\"one\" (\"one\" \"two\") ((\"one\" \"Two\" \"three\"))) "
      "tree2 =>  (\"one\" (\"one\" \"two\") ((\"one\" \"Two\" \"three\"))) "
      "(sublis '((\"two\" . 2)) tree2 :test 'equal) "
      "=>  (\"one\" (\"one\" 2) ((\"one\" \"Two\" \"three\"))) " NIL
      "(nsublis '((t . 'temp))" "          tree1"
      "          :key #'(lambda (x) (or (atom x) (< (list-length x) 3))))"
      "=>  ((QUOTE TEMP) (QUOTE TEMP) QUOTE TEMP) "))
    (CHAPTER ("## 副作用") 2 (CODE1 "nsublis") "は" (STRONG "tree") "を修正します。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "subst") "," "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "副作用による変形（"
     (CODE1 "nsublis") "など）は、" "通過するパスを変更する可能性があるので、" "共有構造や循環構造が現れるものでは、"
     "副作用による修正がないものと比べると、" "驚くべき方法で変化する可能性があります。" "このような挙動を見るために、" "いくつかの実装では見られるかもしれない、"
     "次のような副作用の動作を考えてみましょう。"
     (CODE3 "```lisp" "```" "(defun test-it (fn)" "  (let* ((shared-piece (list 'a 'b))"
      "         (data (list shared-piece shared-piece)))"
      "    (funcall fn '((a . b) (b . a)) data)))" "(test-it #'sublis) =>  ((B A) (B A))"
      "(test-it #'nsublis) =>  ((A B) (A B))"))))
(setf (gethash '("SUBLIS" . "FUNCTION") *table*) (gethash "SUBLIS" *table*))
(setf (gethash "SUBSEQ" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "SUBSEQ"))
    (CHAPTER ("## 構文") 2 (CODE1 "subseq") " " (STRONG "sequence") " " (STRONG "start")
     " &optional " (STRONG "end") " => " (STRONG "subsequence") EOL1 "(" (CODE1 "setf")
     " (" (CODE1 "subseq") " " (STRONG "sequence") " " (STRONG "start") " &optional "
     (STRONG "end") ") " (STRONG "new-subsequence") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "sequence") " - 正常なシーケンス" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1
     (STRONG "subsequence") " - 正常なシーケンス" EOL1 (STRONG "new-subsequence") " - 正常なシーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "subseq") "は、" (STRONG "sequence") "の" (STRONG "start")
     "と" (STRONG "end") "の境界内の" "サブシーケンスのコピーを作成します。" EOL2 (STRONG "start") "は元の"
     (STRONG "sequence") "のオフセットであり、" "サブシーケンスの開始の位置の印であり、" (STRONG "end")
     "は最後の要素に続く位置の印です。" EOL2 (CODE1 "subseq") "は常に結果のシーケンスを新しく確保します。"
     "古いシーケンスのストレージを共有することはありません。" "返却値のサブシーケンスは、常に" (STRONG "sequence") "と同じ型です。" EOL2
     "もし" (STRONG "sequence") "が" (CODE1 "vector") "のとき、" "返却値は一次元の新しいsimple-arrayであり、"
     (STRONG "sequence") "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence")
     "がリストのときは、返却値は新しいリストです。" EOL2 (CODE1 "setf") "の" (CODE1 "subseq") "は、"
     "サブシーケンスの要素を新しい値として受け取ったシーケンスの要素に、" "破壊的に置き換えを行います。"
     "もしサブシーケンスと新しいシーケンスが同じ長さではないとき、" "短い方の長さが置換の要素数になります。" "長い方のシーケンスの終わりの位置にある残りの要素は、"
     "この操作では修正されません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq str \"012345\") =>  \"012345\""
      "(subseq str 2) =>  \"2345\"" "(subseq str 3 5) =>  \"34\""
      "(setf (subseq str 4) \"abc\") =>  \"abc\"" "str =>  \"0123ab\""
      "(setf (subseq str 0 2) \"A\") =>  \"A\"" "str =>  \"A123ab\""))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。" (STRONG "new-sequence") "が正常なシーケンスでないとき、" "型"
     (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "replace")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("SUBSEQ" . "ACCESSOR") *table*) (gethash "SUBSEQ" *table*))
(setf (gethash "SUBSETP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SUBSETP"))
    (CHAPTER ("## 構文") 2 (CODE1 "subsetp") " " (STRONG "list-1") " " (STRONG "list-2")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list-1") " - 通常のリスト" EOL1 (STRONG "list-2")
     " - 通常のリスト" EOL1 (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test-not") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "subsetp") "は、" (STRONG "list-1") "の全ての要素が、"
     (STRONG "list-2") "のどれかの要素にマッチしたら" (STRONG "true") "を、" "それ以外は" (STRONG "false")
     "を返却します。" EOL2 "あるリストの要素が、他のリスト要素と同じかどうかは、" "キーワード引数で指定された関数によって決定されます。"
     (CODE1 ":test") "か" (CODE1 ":test-not") "の関数の最初の要素は通常は" (STRONG "list-1") "の要素であり、"
     (CODE1 ":key") "関数によって返却されたものです。" "二番目の引数は通常は" (STRONG "list-2") "の要素であり、"
     (CODE1 ":key") "関数によって返却されたものです。" EOL2 (CODE1 ":key") "関数の引数は、" (STRONG "list-1")
     "か" (STRONG "list-2") "の要素です。" "返却値は、引数で与えられたリスト要素からなる、" "判定に使われる要素の部分です。" "もし"
     (CODE1 ":key") "が与えられないか、あるいは" (CODE1 "nil") "が指定されたとき、" (STRONG "list-1") "と"
     (STRONG "list-2") "の要素自身がが使われ、" (CODE1 ":test") "か" (CODE1 ":test-not")
     "関数に供給されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq cosmos '(1 \"a\" (1 2))) =>  (1 \"a\" (1 2))"
      "(subsetp '(1) cosmos) =>  true" "(subsetp '((1 2)) cosmos) =>  false"
      "(subsetp '((1 2)) cosmos :test 'equal) =>  true"
      "(subsetp '(1 \"A\") cosmos :test #'equalp) =>  true"
      "(subsetp '((1) (2)) '((1) (2))) =>  false"
      "(subsetp '((1) (2)) '((1) (2)) :key #'car) =>  true"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list-1") "と" (STRONG "list-2") "が通常のリストではないとき、" "型"
     (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。")))
(setf (gethash '("SUBSETP" . "FUNCTION") *table*) (gethash "SUBSETP" *table*))
(setf (gethash "SUBST" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SUBST") ", " (CODE1 "SUBST-IF") ", "
     (CODE1 "SUBST-IF-NOT") "," (CODE1 "NSUBST") ", " (CODE1 "NSUBST-IF") ", "
     (CODE1 "NSUBST-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "subst") " " (STRONG "new") " " (STRONG "old") " "
     (STRONG "tree") " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not")
     " => " (STRONG "new-tree") EOL1 (CODE1 "subst-if") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "subst-if-not") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "nsubst") " " (STRONG "new") " " (STRONG "old") " "
     (STRONG "tree") " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not")
     " => " (STRONG "new-tree") EOL1 (CODE1 "nsubst-if") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "nsubst-if-not") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "new") " - オブジェクト" EOL1 (STRONG "old") " - オブジェクト"
     EOL1 (STRONG "predicate") " - 関数名のシンボルか、" "1つの引数をとりgeneralized-booleanを返却する関数" EOL1
     (STRONG "tree") " - ツリー" EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "new-tree") " - ツリー")
    (CHAPTER ("## 定義") 2 (CODE1 "subst") ", " (CODE1 "subst-if") ", "
     (CODE1 "subst-if-not") "は、" (STRONG "tree") "の置換操作を行います。" "各関数は" (STRONG "tree")
     "に対して" (STRONG "test") "を満たすような特定の" (STRONG "old") "要素か、" "あるいは部分式を満たすものを検索します。"
     EOL2 (CODE1 "nsubst") ", " (CODE1 "nsubst-if") ", " (CODE1 "nsubst-if-not") "はそれぞれ"
     (CODE1 "subst") ", " (CODE1 "subst-if") ", " (CODE1 "subst-if-not") "と似ていますが、" "元の"
     (STRONG "tree") "を修正するところが違っています。" EOL2 (CODE1 "subst") "は" (STRONG "tree")
     "のコピーを作成し、" "全てのサブツリー、葉、親の" (CODE1 "car") "部、" (CODE1 "cdr") "部、すべてに対して"
     (STRONG "old") "と" (STRONG "test") "が満たされる部分を" (STRONG "new") "に置換します。" EOL2
     (CODE1 "nsubst") "は、" (CODE1 "subst") "の破壊的バージョンです。" (STRONG "tree") "のリスト構造は、それぞれの"
     (STRONG "tree") "の葉に対して、" (STRONG "old") "と" (STRONG "test") "が満たされる葉の部分を"
     (STRONG "new") "で破壊的に置換することによって変更されます" EOL2 (CODE1 "subst") ", " (CODE1 "subst-if")
     ", " (CODE1 "subst-if-not") "は、" "もし関数が成功すると、" "指定された要素のそれぞれの出現を" (STRONG "new")
     "要素で置き換えられたものか、" "あるいは部分式で置き換えられたものの新たなコピーが返却されます。" "もし変更が生じなかったときは、元の"
     (STRONG "tree") "が返却されるかもしれません。" "元の" (STRONG "tree") "が変更されないとしても、"
     "返却値のツリーは元のツリーと" "ストレージを共有しているかもしれません。" EOL2 (CODE1 "nsubst") ", "
     (CODE1 "nsubst-if") ", " (CODE1 "nsubst-if-not") "は、" "元の" (STRONG "tree")
     "を修正し返却します。" "しかし関数の結果は、" (STRONG "tree") "と" (CODE1 "eq") "で等しくないかもしれません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq tree1 '(1 (1 2) (1 2 3) (1 2 3 4))) =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(subst \"two\" 2 tree1) =>  (1 (1 \"two\") (1 \"two\" 3) (1 \"two\" 3 4))"
      "(subst \"five\" 5 tree1) =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(eq tree1 (subst \"five\" 5 tree1)) =>  implementation-dependent"
      "(subst 'tempest 'hurricane" "       '(shakespeare wrote (the hurricane)))"
      "=>  (SHAKESPEARE WROTE (THE TEMPEST))"
      "(subst 'foo 'nil '(shakespeare wrote (twelfth night)))"
      "=>  (SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO)"
      "(subst '(a . cons) '(old . pair)"
      "       '((old . spice) ((old . shoes) old . pair) (old . pair))"
      "       :test #'equal)" "=>  ((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS))"
      NIL "(subst-if 5 #'listp tree1) =>  5" "(subst-if-not '(x) #'consp tree1) "
      "=>  (1 X)" NIL "tree1 =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(nsubst 'x 3 tree1 :key #'(lambda (y) (and (listp y) (third y)))) "
      "=>  (1 (1 2) X X)" "tree1 =>  (1 (1 2) X X)"))
    (CHAPTER ("## 副作用") 2 (CODE1 "nsubst") ", " (CODE1 "nsubst-if") ", "
     (CODE1 "nsubst-if-not") "は、" (STRONG "tree") "のツリー構造を変更するかもしれません。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "substitute") "," (CODE1 "nsubstitute") ","
     "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "subst-if-not") "と" (CODE1 "nsubst-if-not") "は非推奨です。" EOL2 (CODE1 "subst")
     "は一例として次のように定義できます。"
     (CODE3 "```lisp" "```" "(defun subst (old new tree &rest x &key test test-not key)"
      "  (cond ((satisfies-the-test old tree :test test"
      "                             :test-not test-not :key key)" "         new)"
      "        ((atom tree) tree)"
      "        (t (let ((a (apply #'subst old new (car tree) x))"
      "                 (d (apply #'subst old new (cdr tree) x)))"
      "             (if (and (eql a (car tree))"
      "                      (eql d (cdr tree)))" "                 tree"
      "                 (cons a d))))))"))))
(setf (gethash '("SUBST" . "FUNCTION") *table*) (gethash "SUBST" *table*))
(setf (gethash "SUBST-IF" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SUBST") ", " (CODE1 "SUBST-IF") ", "
     (CODE1 "SUBST-IF-NOT") "," (CODE1 "NSUBST") ", " (CODE1 "NSUBST-IF") ", "
     (CODE1 "NSUBST-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "subst") " " (STRONG "new") " " (STRONG "old") " "
     (STRONG "tree") " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not")
     " => " (STRONG "new-tree") EOL1 (CODE1 "subst-if") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "subst-if-not") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "nsubst") " " (STRONG "new") " " (STRONG "old") " "
     (STRONG "tree") " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not")
     " => " (STRONG "new-tree") EOL1 (CODE1 "nsubst-if") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "nsubst-if-not") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "new") " - オブジェクト" EOL1 (STRONG "old") " - オブジェクト"
     EOL1 (STRONG "predicate") " - 関数名のシンボルか、" "1つの引数をとりgeneralized-booleanを返却する関数" EOL1
     (STRONG "tree") " - ツリー" EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "new-tree") " - ツリー")
    (CHAPTER ("## 定義") 2 (CODE1 "subst") ", " (CODE1 "subst-if") ", "
     (CODE1 "subst-if-not") "は、" (STRONG "tree") "の置換操作を行います。" "各関数は" (STRONG "tree")
     "に対して" (STRONG "test") "を満たすような特定の" (STRONG "old") "要素か、" "あるいは部分式を満たすものを検索します。"
     EOL2 (CODE1 "nsubst") ", " (CODE1 "nsubst-if") ", " (CODE1 "nsubst-if-not") "はそれぞれ"
     (CODE1 "subst") ", " (CODE1 "subst-if") ", " (CODE1 "subst-if-not") "と似ていますが、" "元の"
     (STRONG "tree") "を修正するところが違っています。" EOL2 (CODE1 "subst") "は" (STRONG "tree")
     "のコピーを作成し、" "全てのサブツリー、葉、親の" (CODE1 "car") "部、" (CODE1 "cdr") "部、すべてに対して"
     (STRONG "old") "と" (STRONG "test") "が満たされる部分を" (STRONG "new") "に置換します。" EOL2
     (CODE1 "nsubst") "は、" (CODE1 "subst") "の破壊的バージョンです。" (STRONG "tree") "のリスト構造は、それぞれの"
     (STRONG "tree") "の葉に対して、" (STRONG "old") "と" (STRONG "test") "が満たされる葉の部分を"
     (STRONG "new") "で破壊的に置換することによって変更されます" EOL2 (CODE1 "subst") ", " (CODE1 "subst-if")
     ", " (CODE1 "subst-if-not") "は、" "もし関数が成功すると、" "指定された要素のそれぞれの出現を" (STRONG "new")
     "要素で置き換えられたものか、" "あるいは部分式で置き換えられたものの新たなコピーが返却されます。" "もし変更が生じなかったときは、元の"
     (STRONG "tree") "が返却されるかもしれません。" "元の" (STRONG "tree") "が変更されないとしても、"
     "返却値のツリーは元のツリーと" "ストレージを共有しているかもしれません。" EOL2 (CODE1 "nsubst") ", "
     (CODE1 "nsubst-if") ", " (CODE1 "nsubst-if-not") "は、" "元の" (STRONG "tree")
     "を修正し返却します。" "しかし関数の結果は、" (STRONG "tree") "と" (CODE1 "eq") "で等しくないかもしれません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq tree1 '(1 (1 2) (1 2 3) (1 2 3 4))) =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(subst \"two\" 2 tree1) =>  (1 (1 \"two\") (1 \"two\" 3) (1 \"two\" 3 4))"
      "(subst \"five\" 5 tree1) =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(eq tree1 (subst \"five\" 5 tree1)) =>  implementation-dependent"
      "(subst 'tempest 'hurricane" "       '(shakespeare wrote (the hurricane)))"
      "=>  (SHAKESPEARE WROTE (THE TEMPEST))"
      "(subst 'foo 'nil '(shakespeare wrote (twelfth night)))"
      "=>  (SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO)"
      "(subst '(a . cons) '(old . pair)"
      "       '((old . spice) ((old . shoes) old . pair) (old . pair))"
      "       :test #'equal)" "=>  ((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS))"
      NIL "(subst-if 5 #'listp tree1) =>  5" "(subst-if-not '(x) #'consp tree1) "
      "=>  (1 X)" NIL "tree1 =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(nsubst 'x 3 tree1 :key #'(lambda (y) (and (listp y) (third y)))) "
      "=>  (1 (1 2) X X)" "tree1 =>  (1 (1 2) X X)"))
    (CHAPTER ("## 副作用") 2 (CODE1 "nsubst") ", " (CODE1 "nsubst-if") ", "
     (CODE1 "nsubst-if-not") "は、" (STRONG "tree") "のツリー構造を変更するかもしれません。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "substitute") "," (CODE1 "nsubstitute") ","
     "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "subst-if-not") "と" (CODE1 "nsubst-if-not") "は非推奨です。" EOL2 (CODE1 "subst")
     "は一例として次のように定義できます。"
     (CODE3 "```lisp" "```" "(defun subst (old new tree &rest x &key test test-not key)"
      "  (cond ((satisfies-the-test old tree :test test"
      "                             :test-not test-not :key key)" "         new)"
      "        ((atom tree) tree)"
      "        (t (let ((a (apply #'subst old new (car tree) x))"
      "                 (d (apply #'subst old new (cdr tree) x)))"
      "             (if (and (eql a (car tree))"
      "                      (eql d (cdr tree)))" "                 tree"
      "                 (cons a d))))))"))))
(setf (gethash '("SUBST-IF" . "FUNCTION") *table*) (gethash "SUBST-IF" *table*))
(setf (gethash "SUBST-IF-NOT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SUBST") ", " (CODE1 "SUBST-IF") ", "
     (CODE1 "SUBST-IF-NOT") "," (CODE1 "NSUBST") ", " (CODE1 "NSUBST-IF") ", "
     (CODE1 "NSUBST-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "subst") " " (STRONG "new") " " (STRONG "old") " "
     (STRONG "tree") " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not")
     " => " (STRONG "new-tree") EOL1 (CODE1 "subst-if") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "subst-if-not") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "nsubst") " " (STRONG "new") " " (STRONG "old") " "
     (STRONG "tree") " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not")
     " => " (STRONG "new-tree") EOL1 (CODE1 "nsubst-if") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree") EOL1 (CODE1 "nsubst-if-not") " " (STRONG "new") " "
     (STRONG "predicate") " " (STRONG "tree") " &key " (STRONG "key") " => "
     (STRONG "new-tree"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "new") " - オブジェクト" EOL1 (STRONG "old") " - オブジェクト"
     EOL1 (STRONG "predicate") " - 関数名のシンボルか、" "1つの引数をとりgeneralized-booleanを返却する関数" EOL1
     (STRONG "tree") " - ツリー" EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "new-tree") " - ツリー")
    (CHAPTER ("## 定義") 2 (CODE1 "subst") ", " (CODE1 "subst-if") ", "
     (CODE1 "subst-if-not") "は、" (STRONG "tree") "の置換操作を行います。" "各関数は" (STRONG "tree")
     "に対して" (STRONG "test") "を満たすような特定の" (STRONG "old") "要素か、" "あるいは部分式を満たすものを検索します。"
     EOL2 (CODE1 "nsubst") ", " (CODE1 "nsubst-if") ", " (CODE1 "nsubst-if-not") "はそれぞれ"
     (CODE1 "subst") ", " (CODE1 "subst-if") ", " (CODE1 "subst-if-not") "と似ていますが、" "元の"
     (STRONG "tree") "を修正するところが違っています。" EOL2 (CODE1 "subst") "は" (STRONG "tree")
     "のコピーを作成し、" "全てのサブツリー、葉、親の" (CODE1 "car") "部、" (CODE1 "cdr") "部、すべてに対して"
     (STRONG "old") "と" (STRONG "test") "が満たされる部分を" (STRONG "new") "に置換します。" EOL2
     (CODE1 "nsubst") "は、" (CODE1 "subst") "の破壊的バージョンです。" (STRONG "tree") "のリスト構造は、それぞれの"
     (STRONG "tree") "の葉に対して、" (STRONG "old") "と" (STRONG "test") "が満たされる葉の部分を"
     (STRONG "new") "で破壊的に置換することによって変更されます" EOL2 (CODE1 "subst") ", " (CODE1 "subst-if")
     ", " (CODE1 "subst-if-not") "は、" "もし関数が成功すると、" "指定された要素のそれぞれの出現を" (STRONG "new")
     "要素で置き換えられたものか、" "あるいは部分式で置き換えられたものの新たなコピーが返却されます。" "もし変更が生じなかったときは、元の"
     (STRONG "tree") "が返却されるかもしれません。" "元の" (STRONG "tree") "が変更されないとしても、"
     "返却値のツリーは元のツリーと" "ストレージを共有しているかもしれません。" EOL2 (CODE1 "nsubst") ", "
     (CODE1 "nsubst-if") ", " (CODE1 "nsubst-if-not") "は、" "元の" (STRONG "tree")
     "を修正し返却します。" "しかし関数の結果は、" (STRONG "tree") "と" (CODE1 "eq") "で等しくないかもしれません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(setq tree1 '(1 (1 2) (1 2 3) (1 2 3 4))) =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(subst \"two\" 2 tree1) =>  (1 (1 \"two\") (1 \"two\" 3) (1 \"two\" 3 4))"
      "(subst \"five\" 5 tree1) =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(eq tree1 (subst \"five\" 5 tree1)) =>  implementation-dependent"
      "(subst 'tempest 'hurricane" "       '(shakespeare wrote (the hurricane)))"
      "=>  (SHAKESPEARE WROTE (THE TEMPEST))"
      "(subst 'foo 'nil '(shakespeare wrote (twelfth night)))"
      "=>  (SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO)"
      "(subst '(a . cons) '(old . pair)"
      "       '((old . spice) ((old . shoes) old . pair) (old . pair))"
      "       :test #'equal)" "=>  ((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS))"
      NIL "(subst-if 5 #'listp tree1) =>  5" "(subst-if-not '(x) #'consp tree1) "
      "=>  (1 X)" NIL "tree1 =>  (1 (1 2) (1 2 3) (1 2 3 4))"
      "(nsubst 'x 3 tree1 :key #'(lambda (y) (and (listp y) (third y)))) "
      "=>  (1 (1 2) X X)" "tree1 =>  (1 (1 2) X X)"))
    (CHAPTER ("## 副作用") 2 (CODE1 "nsubst") ", " (CODE1 "nsubst-if") ", "
     (CODE1 "nsubst-if-not") "は、" (STRONG "tree") "のツリー構造を変更するかもしれません。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "substitute") "," (CODE1 "nsubstitute") ","
     "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "subst-if-not") "と" (CODE1 "nsubst-if-not") "は非推奨です。" EOL2 (CODE1 "subst")
     "は一例として次のように定義できます。"
     (CODE3 "```lisp" "```" "(defun subst (old new tree &rest x &key test test-not key)"
      "  (cond ((satisfies-the-test old tree :test test"
      "                             :test-not test-not :key key)" "         new)"
      "        ((atom tree) tree)"
      "        (t (let ((a (apply #'subst old new (car tree) x))"
      "                 (d (apply #'subst old new (cdr tree) x)))"
      "             (if (and (eql a (car tree))"
      "                      (eql d (cdr tree)))" "                 tree"
      "                 (cons a d))))))"))))
(setf (gethash '("SUBST-IF-NOT" . "FUNCTION") *table*) (gethash "SUBST-IF-NOT" *table*))
(setf (gethash "SUBSTITUTE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SUBSTITUTE") ", " (CODE1 "SUBSTITUTE-IF") ", "
     (CODE1 "SUBSTITUTE-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "substitute") " " (STRONG "newitem") " "
     (STRONG "olditem") " " (STRONG "sequence") " &key " (STRONG "from-end") " "
     (STRONG "test") " " (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " "
     (STRONG "count") " " (STRONG "key") EOL1 "=> " (STRONG "result-sequence") EOL2
     (CODE1 "substitute-if") " " (STRONG "newitem") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") EOL1 "=> result-sequence"
     EOL2 (CODE1 "substitute-if-not") " " (STRONG "newitem") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") EOL1 "=> result-sequence"
     EOL2 (CODE1 "nsubstitute") " " (STRONG "newitem") " " (STRONG "olditem") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "test") " "
     (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> " (STRONG "result-sequence") EOL2 (CODE1 "nsubstitute-if")
     " " (STRONG "newitem") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> result-sequence" EOL2 (CODE1 "nsubstitute-if-not") " "
     (STRONG "newitem") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> result-sequence")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "newitem") " - オブジェクト" EOL1 (STRONG "olditem")
     " - オブジェクト" EOL1 (STRONG "sequence") " - 正常なシーケンス" EOL1 (STRONG "predicate")
     " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "from-end")
     " - generalized-boolean、デフォルトは" (STRONG "false") EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "count")
     " - 整数か" (CODE1 "nil") "。デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "result-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "substitute") "、" (CODE1 "substitute-if") "、"
     (CODE1 "substitute-if-not") "は、" "テストを満たす各要素が" (STRONG "newitem") "に置き換えられた、"
     (STRONG "sequence") "のコピーを返却します。" EOL2 (CODE1 "nsubstitute") "、"
     (CODE1 "nsubstitute-if") "、" (CODE1 "nsubstitute-if-not") "は、" "それぞれ"
     (CODE1 "substitute") "、" (CODE1 "substitute-if") "、" (CODE1 "substitute-if-not")
     "と似ていますが、" "しかし" (STRONG "sequence") "を修正するでしょう。" EOL2 "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のとき、返却値は" (CODE1 "vector") "であり、" (STRONG "sequence")
     "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence") "がリストなら、返却値はリストです。" EOL2
     (STRONG "count") "が与えられたとき、変更する要素数を制限できます。" "もしテストを満たす要素が" (STRONG "count")
     "を越えていたときは、" "それらの要素は左端か右端（" (STRONG "from-end") "の値による）から、" "ただ" (STRONG "count")
     "で指定された数だけ置き換えられます。" "もし" (STRONG "count") "負の値が指定されたときは、" (CODE1 "0")
     "が指定されたかのようにふるまいます。" "もし" (STRONG "count") "が" (CODE1 "nil") "のときは、" (STRONG "item")
     "にマッチした全てに影響します。" EOL2 (STRONG "from-end") "が" (STRONG "true") "のときは、" "ただ"
     (STRONG "count") "が指定されたとき（" (CODE1 "nil") "以外）が" "重要になります。"
     "このような場合、右端から（左端ではなく）テストを満たす" (STRONG "count") "の要素だけが置き換えられます。" EOL2
     (STRONG "predicate") ", " (STRONG "test") ", " (STRONG "test-not") "は、"
     "各シーケンスの要素に対して一回以上呼び出されるかもしれず、" "それらの副作用はどんな順番でも生じます。" EOL2 "これらすべての関数の返却値は、"
     (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start") ", " (STRONG "end")
     "に囲まれたサブシーケンスのテストを満たし" (STRONG "newitem") "に置き換えが生じたもの以外は、" "同じ要素を持ちます。" EOL2
     (CODE1 "substitute") "、" (CODE1 "substitute-if") "、" (CODE1 "substitute-if-not")
     "は、" "もし要素に変更が生じなかったときは、" (STRONG "sequence") "と共有されたシーケンスか、" "あるいは入力の"
     (STRONG "sequence") "と同一のものが返却されます。" EOL2 (CODE1 "nsubstitute") "、"
     (CODE1 "nsubstitute-if") "、" (CODE1 "nsubstitute-if-not") "は、" "もし"
     (STRONG "sequence") "がリストのときは" (CODE1 "setf") "の" (CODE1 "car") "を、" "もし"
     (STRONG "sequence") "が" (CODE1 "vector") "のときは" (CODE1 "aref") "を"
     (STRONG "sequence") "に対して行い、" (STRONG "newitem") "に置き換えます。" "もし" (STRONG "sequence")
     "がリストのときは、" "トップレベルのリストのどの" (CODE1 "cdr") "も変更できません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(substitute #\\. #\\SPACE \"0 2 4 6\") =>  \"0.2.4.6\""
      "(substitute 9 4 '(1 2 4 1 3 4 5)) =>  (1 2 9 1 3 9 5)"
      "(substitute 9 4 '(1 2 4 1 3 4 5) :count 1) =>  (1 2 9 1 3 4 5)"
      "(substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t)" "=>  (1 2 4 1 3 9 5)"
      "(substitute 9 3 '(1 2 4 1 3 4 5) :test #'>) =>  (9 9 4 9 3 4 5)" NIL
      "(substitute-if 0 #'evenp '((1) (2) (3) (4)) :start 2 :key #'car)"
      "=>  ((1) (2) (3) 0)"
      "(substitute-if 9 #'oddp '(1 2 4 1 3 4 5)) =>  (9 2 4 9 9 4 9)"
      "(substitute-if 9 #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)"
      "=>  (1 2 4 1 3 9 5)" NIL
      "(setq some-things (list 'a 'car 'b 'cdr 'c)) =>  (A CAR B CDR C)"
      "(nsubstitute-if \"function was here\" #'fboundp some-things"
      "                :count 1 :from-end t) =>  (A CAR B \"function was here\" C)"
      "some-things =>  (A CAR B \"function was here\" C)"
      "(setq alpha-tester (copy-seq \"ab \")) =>  \"ab \""
      "(nsubstitute-if-not #\\z #'alpha-char-p alpha-tester) =>  \"abz\""
      "alpha-tester =>  \"abz\""))
    (CHAPTER ("## 副作用") 2 (CODE1 "nsubstitute") "、" (CODE1 "nsubstitute-if") "、"
     (CODE1 "nsubstitute-if-not") "は、" (STRONG "sequence") "を修正します。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "subst") "," (CODE1 "nsubst") "," "3.2.1. コンパイラーの用語,"
     "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "返却値は"
     (CODE1 "simple") "かもしれませんし、そうでないかもしれません。" "また、返却値は" (STRONG "sequence")
     "と同一かもしれませんし、" "そうでないかもしれません。" EOL2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "substitute-if-not") "と" (CODE1 "nsubstitute-if-not") "は非推奨です。" EOL2
     "副作用による変形（" (CODE1 "nsubstitute") "など）は、" "通過するパスを変更する可能性があるので、"
     "共有構造や循環構造が現れるものでは、" "副作用による修正がないものと比べると、" "驚くべき方法で変化する可能性があります。" "このような挙動を見るために、"
     "いくつかの実装では見られるかもしれない、" "次のような副作用の動作を考えてみましょう。"
     (CODE3 "```lisp" "```" "(defun test-it (fn)" "  (let ((x (cons 'b nil)))"
      "    (rplacd x x)" "    (funcall fn 'a 'b x :count 1)))"
      "(test-it #'substitute) =>  (A . #1=(B . #1#))"
      "(test-it #'nsubstitute) =>  (A . #1#)"))))
(setf (gethash '("SUBSTITUTE" . "FUNCTION") *table*) (gethash "SUBSTITUTE" *table*))
(setf (gethash "SUBSTITUTE-IF" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SUBSTITUTE") ", " (CODE1 "SUBSTITUTE-IF") ", "
     (CODE1 "SUBSTITUTE-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "substitute") " " (STRONG "newitem") " "
     (STRONG "olditem") " " (STRONG "sequence") " &key " (STRONG "from-end") " "
     (STRONG "test") " " (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " "
     (STRONG "count") " " (STRONG "key") EOL1 "=> " (STRONG "result-sequence") EOL2
     (CODE1 "substitute-if") " " (STRONG "newitem") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") EOL1 "=> result-sequence"
     EOL2 (CODE1 "substitute-if-not") " " (STRONG "newitem") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") EOL1 "=> result-sequence"
     EOL2 (CODE1 "nsubstitute") " " (STRONG "newitem") " " (STRONG "olditem") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "test") " "
     (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> " (STRONG "result-sequence") EOL2 (CODE1 "nsubstitute-if")
     " " (STRONG "newitem") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> result-sequence" EOL2 (CODE1 "nsubstitute-if-not") " "
     (STRONG "newitem") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> result-sequence")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "newitem") " - オブジェクト" EOL1 (STRONG "olditem")
     " - オブジェクト" EOL1 (STRONG "sequence") " - 正常なシーケンス" EOL1 (STRONG "predicate")
     " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "from-end")
     " - generalized-boolean、デフォルトは" (STRONG "false") EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "count")
     " - 整数か" (CODE1 "nil") "。デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "result-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "substitute") "、" (CODE1 "substitute-if") "、"
     (CODE1 "substitute-if-not") "は、" "テストを満たす各要素が" (STRONG "newitem") "に置き換えられた、"
     (STRONG "sequence") "のコピーを返却します。" EOL2 (CODE1 "nsubstitute") "、"
     (CODE1 "nsubstitute-if") "、" (CODE1 "nsubstitute-if-not") "は、" "それぞれ"
     (CODE1 "substitute") "、" (CODE1 "substitute-if") "、" (CODE1 "substitute-if-not")
     "と似ていますが、" "しかし" (STRONG "sequence") "を修正するでしょう。" EOL2 "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のとき、返却値は" (CODE1 "vector") "であり、" (STRONG "sequence")
     "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence") "がリストなら、返却値はリストです。" EOL2
     (STRONG "count") "が与えられたとき、変更する要素数を制限できます。" "もしテストを満たす要素が" (STRONG "count")
     "を越えていたときは、" "それらの要素は左端か右端（" (STRONG "from-end") "の値による）から、" "ただ" (STRONG "count")
     "で指定された数だけ置き換えられます。" "もし" (STRONG "count") "負の値が指定されたときは、" (CODE1 "0")
     "が指定されたかのようにふるまいます。" "もし" (STRONG "count") "が" (CODE1 "nil") "のときは、" (STRONG "item")
     "にマッチした全てに影響します。" EOL2 (STRONG "from-end") "が" (STRONG "true") "のときは、" "ただ"
     (STRONG "count") "が指定されたとき（" (CODE1 "nil") "以外）が" "重要になります。"
     "このような場合、右端から（左端ではなく）テストを満たす" (STRONG "count") "の要素だけが置き換えられます。" EOL2
     (STRONG "predicate") ", " (STRONG "test") ", " (STRONG "test-not") "は、"
     "各シーケンスの要素に対して一回以上呼び出されるかもしれず、" "それらの副作用はどんな順番でも生じます。" EOL2 "これらすべての関数の返却値は、"
     (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start") ", " (STRONG "end")
     "に囲まれたサブシーケンスのテストを満たし" (STRONG "newitem") "に置き換えが生じたもの以外は、" "同じ要素を持ちます。" EOL2
     (CODE1 "substitute") "、" (CODE1 "substitute-if") "、" (CODE1 "substitute-if-not")
     "は、" "もし要素に変更が生じなかったときは、" (STRONG "sequence") "と共有されたシーケンスか、" "あるいは入力の"
     (STRONG "sequence") "と同一のものが返却されます。" EOL2 (CODE1 "nsubstitute") "、"
     (CODE1 "nsubstitute-if") "、" (CODE1 "nsubstitute-if-not") "は、" "もし"
     (STRONG "sequence") "がリストのときは" (CODE1 "setf") "の" (CODE1 "car") "を、" "もし"
     (STRONG "sequence") "が" (CODE1 "vector") "のときは" (CODE1 "aref") "を"
     (STRONG "sequence") "に対して行い、" (STRONG "newitem") "に置き換えます。" "もし" (STRONG "sequence")
     "がリストのときは、" "トップレベルのリストのどの" (CODE1 "cdr") "も変更できません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(substitute #\\. #\\SPACE \"0 2 4 6\") =>  \"0.2.4.6\""
      "(substitute 9 4 '(1 2 4 1 3 4 5)) =>  (1 2 9 1 3 9 5)"
      "(substitute 9 4 '(1 2 4 1 3 4 5) :count 1) =>  (1 2 9 1 3 4 5)"
      "(substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t)" "=>  (1 2 4 1 3 9 5)"
      "(substitute 9 3 '(1 2 4 1 3 4 5) :test #'>) =>  (9 9 4 9 3 4 5)" NIL
      "(substitute-if 0 #'evenp '((1) (2) (3) (4)) :start 2 :key #'car)"
      "=>  ((1) (2) (3) 0)"
      "(substitute-if 9 #'oddp '(1 2 4 1 3 4 5)) =>  (9 2 4 9 9 4 9)"
      "(substitute-if 9 #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)"
      "=>  (1 2 4 1 3 9 5)" NIL
      "(setq some-things (list 'a 'car 'b 'cdr 'c)) =>  (A CAR B CDR C)"
      "(nsubstitute-if \"function was here\" #'fboundp some-things"
      "                :count 1 :from-end t) =>  (A CAR B \"function was here\" C)"
      "some-things =>  (A CAR B \"function was here\" C)"
      "(setq alpha-tester (copy-seq \"ab \")) =>  \"ab \""
      "(nsubstitute-if-not #\\z #'alpha-char-p alpha-tester) =>  \"abz\""
      "alpha-tester =>  \"abz\""))
    (CHAPTER ("## 副作用") 2 (CODE1 "nsubstitute") "、" (CODE1 "nsubstitute-if") "、"
     (CODE1 "nsubstitute-if-not") "は、" (STRONG "sequence") "を修正します。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "subst") "," (CODE1 "nsubst") "," "3.2.1. コンパイラーの用語,"
     "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "返却値は"
     (CODE1 "simple") "かもしれませんし、そうでないかもしれません。" "また、返却値は" (STRONG "sequence")
     "と同一かもしれませんし、" "そうでないかもしれません。" EOL2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "substitute-if-not") "と" (CODE1 "nsubstitute-if-not") "は非推奨です。" EOL2
     "副作用による変形（" (CODE1 "nsubstitute") "など）は、" "通過するパスを変更する可能性があるので、"
     "共有構造や循環構造が現れるものでは、" "副作用による修正がないものと比べると、" "驚くべき方法で変化する可能性があります。" "このような挙動を見るために、"
     "いくつかの実装では見られるかもしれない、" "次のような副作用の動作を考えてみましょう。"
     (CODE3 "```lisp" "```" "(defun test-it (fn)" "  (let ((x (cons 'b nil)))"
      "    (rplacd x x)" "    (funcall fn 'a 'b x :count 1)))"
      "(test-it #'substitute) =>  (A . #1=(B . #1#))"
      "(test-it #'nsubstitute) =>  (A . #1#)"))))
(setf (gethash '("SUBSTITUTE-IF" . "FUNCTION") *table*) (gethash "SUBSTITUTE-IF" *table*))
(setf (gethash "SUBSTITUTE-IF-NOT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SUBSTITUTE") ", " (CODE1 "SUBSTITUTE-IF") ", "
     (CODE1 "SUBSTITUTE-IF-NOT"))
    (CHAPTER ("## 構文") 2 (CODE1 "substitute") " " (STRONG "newitem") " "
     (STRONG "olditem") " " (STRONG "sequence") " &key " (STRONG "from-end") " "
     (STRONG "test") " " (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " "
     (STRONG "count") " " (STRONG "key") EOL1 "=> " (STRONG "result-sequence") EOL2
     (CODE1 "substitute-if") " " (STRONG "newitem") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") EOL1 "=> result-sequence"
     EOL2 (CODE1 "substitute-if-not") " " (STRONG "newitem") " " (STRONG "predicate") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "start") " "
     (STRONG "end") " " (STRONG "count") " " (STRONG "key") EOL1 "=> result-sequence"
     EOL2 (CODE1 "nsubstitute") " " (STRONG "newitem") " " (STRONG "olditem") " "
     (STRONG "sequence") " &key " (STRONG "from-end") " " (STRONG "test") " "
     (STRONG "test-not") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> " (STRONG "result-sequence") EOL2 (CODE1 "nsubstitute-if")
     " " (STRONG "newitem") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> result-sequence" EOL2 (CODE1 "nsubstitute-if-not") " "
     (STRONG "newitem") " " (STRONG "predicate") " " (STRONG "sequence") " &key "
     (STRONG "from-end") " " (STRONG "start") " " (STRONG "end") " " (STRONG "count") " "
     (STRONG "key") EOL1 "=> result-sequence")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "newitem") " - オブジェクト" EOL1 (STRONG "olditem")
     " - オブジェクト" EOL1 (STRONG "sequence") " - 正常なシーケンス" EOL1 (STRONG "predicate")
     " - 1つの引数をとりgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "from-end")
     " - generalized-boolean、デフォルトは" (STRONG "false") EOL1 (STRONG "test")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "test-not")
     " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "start") ", "
     (STRONG "end") " - " (STRONG "sequence") "の境界インデックス指定子。" "デフォルトは" (STRONG "start")
     ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。" EOL1 (STRONG "count")
     " - 整数か" (CODE1 "nil") "。デフォルトは" (CODE1 "nil") "。" EOL1 (STRONG "key")
     " - 1つの引数を取る関数の指定子、または" (CODE1 "nil") EOL1 (STRONG "result-sequence") " - シーケンス")
    (CHAPTER ("## 定義") 2 (CODE1 "substitute") "、" (CODE1 "substitute-if") "、"
     (CODE1 "substitute-if-not") "は、" "テストを満たす各要素が" (STRONG "newitem") "に置き換えられた、"
     (STRONG "sequence") "のコピーを返却します。" EOL2 (CODE1 "nsubstitute") "、"
     (CODE1 "nsubstitute-if") "、" (CODE1 "nsubstitute-if-not") "は、" "それぞれ"
     (CODE1 "substitute") "、" (CODE1 "substitute-if") "、" (CODE1 "substitute-if-not")
     "と似ていますが、" "しかし" (STRONG "sequence") "を修正するでしょう。" EOL2 "もし" (STRONG "sequence") "が"
     (CODE1 "vector") "のとき、返却値は" (CODE1 "vector") "であり、" (STRONG "sequence")
     "と同じ実際の配列の要素の型を持ちます。" "もし" (STRONG "sequence") "がリストなら、返却値はリストです。" EOL2
     (STRONG "count") "が与えられたとき、変更する要素数を制限できます。" "もしテストを満たす要素が" (STRONG "count")
     "を越えていたときは、" "それらの要素は左端か右端（" (STRONG "from-end") "の値による）から、" "ただ" (STRONG "count")
     "で指定された数だけ置き換えられます。" "もし" (STRONG "count") "負の値が指定されたときは、" (CODE1 "0")
     "が指定されたかのようにふるまいます。" "もし" (STRONG "count") "が" (CODE1 "nil") "のときは、" (STRONG "item")
     "にマッチした全てに影響します。" EOL2 (STRONG "from-end") "が" (STRONG "true") "のときは、" "ただ"
     (STRONG "count") "が指定されたとき（" (CODE1 "nil") "以外）が" "重要になります。"
     "このような場合、右端から（左端ではなく）テストを満たす" (STRONG "count") "の要素だけが置き換えられます。" EOL2
     (STRONG "predicate") ", " (STRONG "test") ", " (STRONG "test-not") "は、"
     "各シーケンスの要素に対して一回以上呼び出されるかもしれず、" "それらの副作用はどんな順番でも生じます。" EOL2 "これらすべての関数の返却値は、"
     (STRONG "sequence") "と同じ型をもつシーケンスであり、" (STRONG "start") ", " (STRONG "end")
     "に囲まれたサブシーケンスのテストを満たし" (STRONG "newitem") "に置き換えが生じたもの以外は、" "同じ要素を持ちます。" EOL2
     (CODE1 "substitute") "、" (CODE1 "substitute-if") "、" (CODE1 "substitute-if-not")
     "は、" "もし要素に変更が生じなかったときは、" (STRONG "sequence") "と共有されたシーケンスか、" "あるいは入力の"
     (STRONG "sequence") "と同一のものが返却されます。" EOL2 (CODE1 "nsubstitute") "、"
     (CODE1 "nsubstitute-if") "、" (CODE1 "nsubstitute-if-not") "は、" "もし"
     (STRONG "sequence") "がリストのときは" (CODE1 "setf") "の" (CODE1 "car") "を、" "もし"
     (STRONG "sequence") "が" (CODE1 "vector") "のときは" (CODE1 "aref") "を"
     (STRONG "sequence") "に対して行い、" (STRONG "newitem") "に置き換えます。" "もし" (STRONG "sequence")
     "がリストのときは、" "トップレベルのリストのどの" (CODE1 "cdr") "も変更できません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(substitute #\\. #\\SPACE \"0 2 4 6\") =>  \"0.2.4.6\""
      "(substitute 9 4 '(1 2 4 1 3 4 5)) =>  (1 2 9 1 3 9 5)"
      "(substitute 9 4 '(1 2 4 1 3 4 5) :count 1) =>  (1 2 9 1 3 4 5)"
      "(substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t)" "=>  (1 2 4 1 3 9 5)"
      "(substitute 9 3 '(1 2 4 1 3 4 5) :test #'>) =>  (9 9 4 9 3 4 5)" NIL
      "(substitute-if 0 #'evenp '((1) (2) (3) (4)) :start 2 :key #'car)"
      "=>  ((1) (2) (3) 0)"
      "(substitute-if 9 #'oddp '(1 2 4 1 3 4 5)) =>  (9 2 4 9 9 4 9)"
      "(substitute-if 9 #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)"
      "=>  (1 2 4 1 3 9 5)" NIL
      "(setq some-things (list 'a 'car 'b 'cdr 'c)) =>  (A CAR B CDR C)"
      "(nsubstitute-if \"function was here\" #'fboundp some-things"
      "                :count 1 :from-end t) =>  (A CAR B \"function was here\" C)"
      "some-things =>  (A CAR B \"function was here\" C)"
      "(setq alpha-tester (copy-seq \"ab \")) =>  \"ab \""
      "(nsubstitute-if-not #\\z #'alpha-char-p alpha-tester) =>  \"abz\""
      "alpha-tester =>  \"abz\""))
    (CHAPTER ("## 副作用") 2 (CODE1 "nsubstitute") "、" (CODE1 "nsubstitute-if") "、"
     (CODE1 "nsubstitute-if-not") "は、" (STRONG "sequence") "を修正します。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスでないとき、" "型" (CODE1 "type-error")
     "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "subst") "," (CODE1 "nsubst") "," "3.2.1. コンパイラーの用語,"
     "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "もし" (STRONG "sequence") "が" (CODE1 "vector") "なら、" "返却値は"
     (CODE1 "simple") "かもしれませんし、そうでないかもしれません。" "また、返却値は" (STRONG "sequence")
     "と同一かもしれませんし、" "そうでないかもしれません。" EOL2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 "関数"
     (CODE1 "substitute-if-not") "と" (CODE1 "nsubstitute-if-not") "は非推奨です。" EOL2
     "副作用による変形（" (CODE1 "nsubstitute") "など）は、" "通過するパスを変更する可能性があるので、"
     "共有構造や循環構造が現れるものでは、" "副作用による修正がないものと比べると、" "驚くべき方法で変化する可能性があります。" "このような挙動を見るために、"
     "いくつかの実装では見られるかもしれない、" "次のような副作用の動作を考えてみましょう。"
     (CODE3 "```lisp" "```" "(defun test-it (fn)" "  (let ((x (cons 'b nil)))"
      "    (rplacd x x)" "    (funcall fn 'a 'b x :count 1)))"
      "(test-it #'substitute) =>  (A . #1=(B . #1#))"
      "(test-it #'nsubstitute) =>  (A . #1#)"))))
(setf (gethash '("SUBSTITUTE-IF-NOT" . "FUNCTION") *table*) (gethash "SUBSTITUTE-IF-NOT" *table*))
(setf (gethash "SUBTYPEP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SUBTYPEP"))
    (CHAPTER ("## 構文") 2 (CODE1 "subtypep") " " (STRONG "type-1") " " (STRONG "type-2")
     " " (CODE1 "&optional") " " (STRONG "environment") " => " (STRONG "subtype-p") ", "
     (STRONG "valid-p"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "type-1") " - 型指定子" EOL1 (STRONG "type-2") " - 型指定子"
     EOL1 (STRONG "environment") " - " "環境オブジェクト。デフォルトは" (CODE1 "nil") "であり、" "これは"
     (CODE1 "null") "のレキシカルな環境と現在のグローバルな環境を示します。" EOL1 (STRONG "subtype-p")
     " - generalized-boolean" EOL1 (STRONG "valid-p") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "もし" (STRONG "type-1") "が" (STRONG "type-2")
     "の認識可能なサブタイプであれば最初の値は" (STRONG "true") "です。" "そうではないときは最初の値は" (STRONG "false")
     "であり、" "これは" (STRONG "type-1") "が" (STRONG "type-2") "のサブタイプではないか、" "あるいは"
     (STRONG "type-1") "が" (STRONG "type-2") "がサブタイプではあるが" "認識可能なサブタイプではないことを意味します。" EOL2
     "第二返却値は、最初の値が確実であるかを示します。" "もしこの値が" (STRONG "true") "なら、"
     "最初の値はサブタイプの関係が正確であることを示します" "（最初の値が" (STRONG "true") "であれば第二返却値は常に" (STRONG "true")
     "です）。" EOL2 "次の表は、可能性のある返却値の組み合わせを要約したものです。" EOL2 "|Value 1|Value 2|意味|"
     "|-------|-------|----|" "|" (STRONG "true") " |" (STRONG "true") " |"
     (STRONG "type-1") "は確実に" (STRONG "type-2") "のサブタイプ|" "|" (STRONG "false") "|"
     (STRONG "true") " |" (STRONG "type-2") "は確実に" (STRONG "type-2") "のサブタイプではない|" "|"
     (STRONG "false") "|" (STRONG "false") "|" (CODE1 "subtypep") "はこの関係を決定できないので、"
     (STRONG "type-1") "は" (STRONG "type-2") "のサブタイプかもしれないしそうではないかもしれない|" EOL2
     "Figure 4-9. " (CODE1 "subtypep") "の返却値の可能性" EOL2 (CODE1 "subtypep") "は、"
     "次に示す型指定子のうち、少なくとものひとつを引数に含んでいたときのみ" "多値である" (STRONG "false") "、" (STRONG "false")
     "を返却します。" "その型指定子は、" (CODE1 "and") "," (CODE1 "eql") "," "リストフォームの"
     (CODE1 "function") "," (CODE1 "member") "," (CODE1 "not") "," (CODE1 "or") ","
     (CODE1 "satisfies") "," (CODE1 "values") "です" "（型指定子は、型展開後にそれらのシンボルが含まれる位置で"
     "型指定子が意味のある使われ方をして呼び出されているときは、" "そのようなシンボルを含むことになります）。" "このような結果のひとつとして" "もし"
     (STRONG "type-1") "も" (STRONG "type-2") "もそれらの型指定子を含まないときは、" (CODE1 "subtypep")
     "は正確な関係を決定する義務があります。" "とくに" (CODE1 "subtypep") "は" "もしそれらの引数が" (CODE1 "equal")
     "で一致しており" "それらの型指定子を含まないときは、" "多値の" (STRONG "true") "、" (STRONG "true") "を返却します。"
     EOL2 "もし" (STRONG "type-1") "と" (STRONG "type-2") "の両方が" (CODE1 "figure_4-2")
     "で表される名前のみ含まれているときか、" "または型の名前が" (CODE1 "defstruct") "か" (CODE1 "define-condition")
     "か" (CODE1 "defclass") "か" "これらの名前の展開による派生型であるときは、" (CODE1 "subtypep") "は決して第二返却値が"
     (CODE1 "nil") "になりません。" (CODE1 "figure_4-2") "のリスト内の型指定子や" (CODE1 "defclass") "と"
     (CODE1 "defstruct") "による名前は、" "派生された型として実装される場合もありますが、" (CODE1 "subtypep")
     "はそれらの型を原始的なものとみなします。" EOL2 (CODE1 "subtypep") "によって反映される型と型との関係は、"
     "特定の実装によって指定されます。" "例えば、もし実装が浮動小数の型を" (CODE1 "single") "ただひとつサポートしていた場合、" "その実装は"
     (CODE1 "(subtypep 'float 'long-float)") "を" (STRONG "true") ", " (STRONG "true")
     "で返却します（2つの型が同一の場合）。" EOL2 (CODE1 "*") "以外の全てを" (CODE1 "T1") "と" (CODE1 "T2")
     "としたとき、" (CODE1 "(array T1)") "と" (CODE1 "(array T2)") "は違う型指定子ですが、"
     "もしそれらを参照する配列が正確に同じ" (CODE1 "specialized") "の表現のときは、" "常に同じものの集合を参照します。" "例えば、もし"
     (CODE1 "(upgraded-array-element-type 'T1)") "と"
     (CODE1 "(upgraded-array-element-type 'T2)") "が" "常に同じオブジェクトの集合を参照する"
     "違う型指定子を返却するようなときです。" "別の言い方をすると、" (CODE3 "```lisp" "```" "`(array type-specifier)")
     EOL2 "と"
     (CODE3 "```lisp" "```" "`(array ,(upgraded-array-element-type 'type-specifier))")
     EOL2 "はどちらも同じ" (CODE1 "specialized") "配列で表現された" "集合を参照しています。" (CODE1 "*") "以外の全ての"
     (CODE1 "T1") "と" (CODE1 "T2") "において、" (CODE1 "(array T1)") "と" (CODE1 "(array T2)")
     "が" "それぞれ区別できる" (CODE1 "specialized") "な表現により違った配列を参照しているときは、" "2つの型の共通部分は空の集合です。"
     EOL2 "つまり、" (CODE3 "```lisp" "```" "(subtypep '(array T1) '(array T2)) =>  true")
     EOL2 "であるというのは、"
     (CODE3 "```lisp" "```" "(upgraded-array-element-type 'T1)"
      "(upgraded-array-element-type 'T2) ")
     EOL2 "上記の返却値は、" "常に同じオブジェクトの集合を参照しているような" "違った2つの型指定子が返却されます。" EOL2 (CODE1 "*")
     "以外の全てを" (CODE1 "T1") "と" (CODE1 "T2") "としたとき、"
     (CODE3 "```lisp" "```" "(subtypep '(complex T1) '(complex T2)) =>  true, true") EOL2
     "という結果が得られるのは、下記の2つのどちらかの条件のときです。" EOL2 "1. " (CODE1 "T1") "は" (CODE1 "T2")
     "のサブタイプであるか、" EOL2 "2.  " (CODE1 "(upgraded-array-element-type 'T1)") "と"
     (CODE1 "(upgraded-array-element-type 'T2)") "が" "常に同じオブジェクトの集合を参照する"
     "違う型指定子を返却するようなときです。" "このような場合、" (CODE1 "(complex T1)") "と" (CODE1 "(complex T2)")
     "の両方は、" "どちらも同じ" (CODE1 "specialized") "な表現を参照します。" EOL2 "それ以外のときは、"
     (STRONG "false") ", " (STRONG "false") "を返却します。" EOL2 "下記のフォームについて、"
     (CODE3 "```lisp" "```" "(subtypep '(complex single-float) '(complex float))") EOL2
     "これはすべｔの実装において" (STRONG "true") "を返却しなければなりません。" "しかし下記のフォーム"
     (CODE3 "```lisp" "```" "(subtypep '(array single-float) '(array float))") EOL2
     "こちらについては、" "配列の" (CODE1 "specialized") "な表現で" (CODE1 "single-float") "と他の浮動小数を"
     "区別できない処理系でのみ" (STRONG "true") "が返却されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(subtypep 'compiled-function 'function) =>  true, true"
      "(subtypep 'null 'list) =>  true, true" "(subtypep 'null 'symbol) =>  true, true"
      "(subtypep 'integer 'string) =>  false, true"
      "(subtypep '(satisfies dummy) nil) =>  false, implementation-dependent"
      "(subtypep '(integer 1 3) '(integer 1 4)) =>  true, true"
      "(subtypep '(integer (0) (0)) 'nil) =>  true, true"
      "(subtypep 'nil '(integer (0) (0))) =>  true, true"
      "(subtypep '(integer (0) (0)) '(member)) =>  true, true ;or false, false"
      "(subtypep '(member) 'nil) =>  true, true ;or false, false"
      "(subtypep 'nil '(member)) =>  true, true ;or false, false")
     EOL2 (CODE1 "<aet-x>") "と" (CODE1 "<aet-y>") "は" "その実装において常に同じオブジェクトの集合を参照していない"
     "2つの違った型指定子であるとします。" "しかし" (CODE1 "make-array") "関数は、" "同じ配列の型としてオブジェクトを返却します。" EOL2
     "したがって、次のようになります。"
     (CODE3 "```lisp" "```"
      " (subtypep (array-element-type (make-array 0 :element-type '<aet-x>))"
      "           (array-element-type (make-array 0 :element-type '<aet-y>)))"
      "=>  true, true" NIL
      " (subtypep (array-element-type (make-array 0 :element-type '<aet-y>))"
      "           (array-element-type (make-array 0 :element-type '<aet-x>)))"
      "=>  true, true")
     EOL2 "もし" (CODE1 "(array <aet-x>)") "と" (CODE1 "(array <aet-y>)") "が"
     "正確に同じオブジェクトの集合のための違う名前であるとき、" "それらの名前は常に同じオブジェクトの集合を参照しなければなりません。"
     "これの意味することは、次のテストの集合もまた" (STRONG "true") "ということです。"
     (CODE3 "```lisp" "```" "(subtypep '(array <aet-x>) '(array <aet-y>)) =>  true, true"
      "(subtypep '(array <aet-y>) '(array <aet-x>)) =>  true, true"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "4.2. 型")
    (CHAPTER ("## 備考") 2 (CODE1 "subtypep") "の仕様の" (CODE1 "array") "と" (CODE1 "complex")
     "の型の間にある" "小さな違いは重要です。" "なぜなら、実際の部分の型と独立して" "返却値の部分の型を指定できるような"
     "複素数を作成する関数が存在しないからです。" "したがって、複素数の型の場合は、" "実際の部分の型はひとつ以上の型はあるものの、"
     "その数を参照して決定されます。" "例えば、" (CODE1 "17") "は" (CODE1 "(mod 18)") "の型ですし、" "同様に"
     (CODE1 "(mod 256)") "の型であり、" (CODE1 "integer") "の型です。" "そして、" (CODE1 "2.3f5") "は"
     (CODE1 "single-float") "の型であり、" (CODE1 "float") "の型でもあります。")))
(setf (gethash '("SUBTYPEP" . "FUNCTION") *table*) (gethash "SUBTYPEP" *table*))
(setf (gethash "SVREF" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "SVREF"))
    (CHAPTER ("## 構文") 2 (CODE1 "svref") " " (STRONG "simple-vector") " "
     (STRONG "index") " => " (STRONG "element") EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "svref") " " (STRONG "simple-vector") " " (STRONG "index") ") "
     (STRONG "new-element") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "simple-vector") " - " (CODE1 "simple-vector") EOL1
     (STRONG "index") " - " (STRONG "simple-vector") "に対する有効な配列のインデックス" EOL1
     (STRONG "element") ", " (STRONG "new-element") " - オブジェクト" "（この型は、"
     (STRONG "simple-vector") "の配列の要素の型のサブタイプです）。")
    (CHAPTER ("## 定義") 2 (STRONG "index") "によって指定された" (STRONG "simple-vector")
     "の要素にアクセスします。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(simple-vector-p (setq v (vector 1 2 'sirens))) =>  true"
      "(svref v 0) =>  1" "(svref v 2) =>  SIRENS"
      "(setf (svref v 1) 'newcomer) =>  NEWCOMER               "
      "v =>  #(1 NEWCOMER SIRENS)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "aref") "," (CODE1 "sbit") "," (CODE1 "schar") ","
     (CODE1 "vector") "," "3.2.1. コンパイラーの用語")
    (CHAPTER ("## 備考") 2 (CODE1 "svref") "は、" "最初の引数が" (CODE1 "simple-vector")
     "を要求するところを除けば、" (CODE1 "aref") "と同じです。"
     (CODE3 "```lisp" "```" "(svref v i) == (aref (the simple-vector v) i)"))))
(setf (gethash '("SVREF" . "ACCESSOR") *table*) (gethash "SVREF" *table*))
(setf (gethash "SXHASH" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SXHASH"))
    (CHAPTER ("## 構文") 2 (CODE1 "sxhash") " " (STRONG "object") " => "
     (STRONG "hash-code"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "hash-code")
     " - 非負の整数")
    (CHAPTER ("## 定義") 2 (CODE1 "sxhash") "は、" (STRONG "object") "のハッシュコードを返却します。" EOL2
     "ハッシュコードを計算する方法は実装依存ですが、" "次のような明確な制約に従う必要があります。" EOL2 "1. " (CODE1 "(equal x y)")
     "は" (CODE1 "(= (sxhash x) (sxhash y))") "を意味します。" EOL2 "2. 2つのオブジェクト" (CODE1 "x")
     "と" (CODE1 "y") "が、両方とも" (CODE1 "bit-vector") ", 文字列, コンス," " 数, "
     (CODE1 "pathname") ", 文字列, シンボルのどれかであり、" "それらが似ているとき、" "さらに" (CODE1 "x") "と"
     (CODE1 "y") "が同じ実装の違うLispイメージ上に存在するときであっても、" (CODE1 "(sxhash x)") "と"
     (CODE1 "(sxhash y)") "は数学的に同じ値になります。" "3.2.4. ファイルコンパイル時のリテラルオブジェクトをご確認ください。" EOL2
     "3. オブジェクトの" (STRONG "hash-code") "は、" "そのオブジェクトが等価のテスト" (CODE1 "equal") "で確認できるような"
     "目に見える変更でもされない限り、" "ひとつのセッション内で常に同じ値になります。" EOL2 "4. " (STRONG "hash-code")
     "はハッシュに使用されます。" "これは仕様に適合した実装に検証可能な制約はしませんが、" "実装は非負の" (CODE1 "fixnum") "の範囲内で"
     "うまく分散された" (STRONG "hash-code") "を生成するために" "誠実に努力すべきであるという意図があります。" EOL2 "5. "
     (STRONG "hash-code") "の計算は、" (STRONG "object") "が循環構造を含んでいるときでも" "終了しなければなりません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(= (sxhash (list 'list \"ab\")) (sxhash (list 'list \"ab\"))) =>  true"
      "(= (sxhash \"a\") (sxhash (make-string 1 :initial-element #\\a))) =>  true"
      "(let ((r (make-random-state)))" "  (= (sxhash r) (sxhash (make-random-state r))))"
      "=>  implementation-dependent"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "実装。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 "多くのハッシュについての一般的なの要求は、" (CODE1 "make-hash-table")
     "とハッシュテーブルに関連する関数によって満たされます。" (CODE1 "sxhash") "は、あらかじめ定義された抽象化では"
     "不十分な場合に使うことを意図しています。" (CODE1 "sxhash") "の主な目的は、" "ハッシュテーブルで提供されるよりも複雑なハッシュの例を、"
     "ユーザが簡単に実装できるようにすることです。" EOL2 (CODE1 "sxhash") "が返すハッシュコードは、"
     "Common Lisp内の他の関数で使われているハッシュの手順とは" "必ずしも関係する必要がありません。" EOL2 (CODE1 "equal") "が"
     (CODE1 "eq") "として比較する型のオブジェクトのとき、" "3番目の項目は" (STRONG "hash-code") "がオブジェクトの"
     "同一性の不変の性質に基づくことを要求しています。" "もうひとつの正当な実装手法は、" "類似しているものの" (CODE1 "eq") "ではないオブジェクトが"
     "同じハッシュコードを持たなければいけないという要求がないので、" (CODE1 "sxhash") "はこれらのオブジェクトに対して"
     "ランダムなハッシュコードを割り当てる" "（そしてキャッシュする）ようにすることです。" EOL2 "シンボルの類似性は、シンボル名とそのシンボルがアクセス可能な"
     "パッケージの両方で定義されますが、" "あるシンボルのパッケージの状態は変更されてもイコールで見えないため、"
     "項目3ではパッケージ情報を使ってハッシュコードを計算することを禁止しています。")))
(setf (gethash '("SXHASH" . "FUNCTION") *table*) (gethash "SXHASH" *table*))
(setf (gethash "SYMBOL" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "SYMBOL"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "symbol") ", " (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "シンボルは、オブジェクトの同一性のために、"
     "Common Lispでは、変数や関数といった（しかし限定はしない）言語的な実体を含む、" "様々な実体に名前を付けるために使用されます。" EOL2
     "シンボルはパッケージの中に集めることができます。" "もしシンボルがパッケージからアクセス可能な時、" "シンボルはパッケージに" (CODE1 "intern")
     "されたと言います。" "同じシンボルは、複数のパッケージに" (CODE1 "intern") "することができます。" "もしシンボルがどのパッケージにも"
     (CODE1 "intern") "されていないとき、" "それは" (CODE1 "unintern") "と呼ばれます。" EOL2
     (CODE1 "intern") "されたシンボルは、" "アクセス可能などのパッケージからもその名前によって" "一意に識別することができます。" EOL2
     "歴史的な理由からこれを" (CODE1 "cell") "と呼ぶことがありますが、" "実際のシンボルの内部表現とそれらの属性は実装依存です。" EOL2
     "- 名前" "  - シンボルの名前は文字列であり、シンボルの同一性のために使われます。" "    全てのシンボルは名前を持っており、"
     "    もし名前が変更されたときの結果は未定義です。" "    名前は、外部の機能であるシンボルの印字表現に使われます。"
     "    2.1. 文字の構文をご確認ください。" "    関数" (CODE1 "symbol-name") "は、引数のシンボルの名前を返却します。"
     "    シンボルはその名前にどのような文字も保有します。" "	<br><br>" EOL2 "- パッケージ"
     "  - オブジェクトのこの領域は、シンボルのホームパッケージと呼ばれます。" "    もしホームパッケージが" (CODE1 "nil") "のときは、"
     "    シンボルはホームパッケージを持たないと言われることがあります。" "    <br><br>"
     "    パッケージが最初に作成されたときは、ホームパッケージを持ちません。" "    それが最初に" (CODE1 "intern") "されたとき、"
     "    その最初に" (CODE1 "intern") "されたパッケージがホームパッケージになります。" "    シンボルのホームパッケージは、"
     "    関数" (CODE1 "symbol-package") "を使うことでアクセスできます。" "    <br><br>"
     "    もしシンボルがホームパッケージから" (CODE1 "unintern") "されたとき、" "    そのホームパッケージには" (CODE1 "nil")
     "が設定されます。" "    そのシンボルが他に" (CODE1 "intern") "されているパッケージがあるかどうかによって、" "    シンボルが本当に"
     (CODE1 "unintern") "されたシンボルかもしれませんし、" "    そうでないかもしれません。"
     "    したがって、ホームパッケージがないシンボルは、" "    見かけ上は" (CODE1 "unintern") "されたと呼ばれます。"
     "    <br><br>" "    もし" (CODE1 "COMMON-LISP") "パッケージか、" (CODE1 "KEYWORD") "パッケージの"
     "    外部シンボルのホームパッケージを変更しようとしたときの" "    結果は未定義です。" "	<br><br>" EOL2 "- プロパティリスト"
     "  - シンボルのプロパティリストは、" "    そのシンボルに名前付きの属性を関連付けるための仕組みです。"
     "    要素の追加と削除の操作は、プロパティリストに対して破壊的に行われます。"
     "    Common Lispはプロパティリストのオブジェクトを直接操作するものと" "    （" (CODE1 "getf") ", "
     (CODE1 "remf") ", " (CODE1 "symbol-plist") "など）、" "    シンボルのプロパティリストを参照し暗黙に操作するもの"
     "    （" (CODE1 "get") ", " (CODE1 "remprop") "など）の両方を提供しています。"
     "    新しいシンボルに関連付けられるプロパティリストは、" "    初期状態では" (CODE1 "null") "です。" "	<br><br>" EOL2
     "- 値" "  - シンボルが値の属性を持つ場合、それは束縛" (CODE1 "bound") "されていると言われ、" "    そのことは関数"
     (CODE1 "boundp") "によって検出できます。" "    " (CODE1 "bound") "シンボルの値のセルに含まれるオブジェクトは"
     "    そのシンボルによって名付けられたグローバル変数の値あり、" "    関数" (CODE1 "symbol-value") "によってアクセスできます。"
     "    シンボルは、関数" (CODE1 "makunbound") "によって" (CODE1 "unbound") "にできます。" "    <br><br>"
     "    もし定数の変数の名前のシンボル値を変更しようとしたり、" "    そのようなシンボルを" (CODE1 "unbound")
     "にしようとしたときの結果は未定義です。" "	<br><br>" EOL2 "- 関数" "  - シンボルが関数の属性を持つ場合、それは"
     (CODE1 "fbound") "されていると言われ、" "    そのことは関数" (CODE1 "fboundp") "によって検出できます。"
     "    もしシンボルがグローバル環境下の関数の名前である場合は、" "    関数のセルにはその関数が含まれ、" "    関数"
     (CODE1 "symbol-function") "によってアクセスできます。" "    もしシンボルがグローバル環境下のマクロ名か（"
     (CODE1 "macro-function") "を参照）、" "    あるいは特殊オペレーター名（" (CODE1 "special-operator-p")
     "を参照）であるときは" "    シンボルは" (CODE1 "fbound") "であり、関数" (CODE1 "symbol-function")
     "でアクセス可能です。" "    しかしその関数のセルに含まれるオブジェクトは実装依存の型と意味なります。" "    シンボルは、関数"
     (CODE1 "fmakunbound") "によって" (CODE1 "funbound") "にすることができます。" "    <br><br>"
     "    スペシャルフォームと名前付けられたシンボルの" "    関数の値を変更しようとした結果は未定義です。" "	<br><br>" EOL2
     "シンボルの値のセルや関数のセルに対する操作は、" "シンボル自身に対する影響という観点から説明されることがありますが、"
     "ユーザーは、これらのセルの内容とグローバル変数やグローバル関数定義との間に" "密接な関係があることを心に留めておく必要があります。" EOL2
     "シンボルはレキシカル変数やレキシカル関数の定義の識別子として使用されますが、" "その役割においては、ただオブジェクトの同一性のみが重要です。"
     "Common Lispはシンボルに対して、レキシカル変数やレキシカル関数の定義に" "影響を与えるような操作は提供されません。")
    (CHAPTER ("## 参考") 2 "2.3.4. トークンとしてのシンボル," "2.3.1.1. トークンとしての潜在的数,"
     "22.1.3.3. シンボルの印字")))
(setf (gethash '("SYMBOL" . "SYSTEM-CLASS") *table*) (gethash "SYMBOL" *table*))
(setf (gethash "SYMBOL-FUNCTION" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "SYMBOL-FUNCTION"))
    (CHAPTER ("## 構文") 2 (CODE1 "symbol-function") " " (STRONG "symbol") " => "
     (STRONG "contents") EOL1 "(" (CODE1 "setf") " (" (CODE1 "symbol-function") " "
     (STRONG "symbol") ") " (STRONG "new-contents") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - シンボル" EOL1 (STRONG "contents") " - もし"
     (STRONG "symbol") "がマクロか特殊オペレーターとして" "グローバルに宣言されているものならば、"
     "実装依存の性質と固有値であるオブジェクトが返却されます。" "もし" (STRONG "symbol") "がマクロか特殊オペレーターとしてグローバルに"
     "宣言されていないのであれば、" "その" (STRONG "symbol") "は" (CODE1 "fbound") "であり、関数オブジェクトが返却されます。"
     EOL1 (STRONG "new-contents") " - 関数")
    (CHAPTER ("## 定義") 2 (STRONG "symbol") "の関数セルにアクセスします。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(symbol-function 'car) =>  #<FUNCTION CAR>"
      "(symbol-function 'twice) はエラー   ;なぜならTWICEは定義されていない"
      "(defun twice (n) (* n 2)) =>  TWICE"
      "(symbol-function 'twice) =>  #<FUNCTION TWICE>" "(list (twice 3)"
      "      (funcall (function twice) 3)" "      (funcall (symbol-function 'twice) 3))"
      "=>  (6 6 6)" "(flet ((twice (x) (list x x)))" "  (list (twice 3)"
      "        (funcall (function twice) 3)"
      "        (funcall (symbol-function 'twice) 3)))" "=>  ((3 3) (3 3) 6)   "
      "(setf (symbol-function 'twice) #'(lambda (x) (list x x)))"
      "=>  #<FUNCTION anonymous>" "(list (twice 3)" "      (funcall (function twice) 3)"
      "      (funcall (symbol-function 'twice) 3))" "=>  ((3 3) (3 3) (3 3))"
      "(fboundp 'defun) =>  true" "(symbol-function 'defun)"
      "=>  implementation-dependent" "(functionp (symbol-function 'defun))"
      "=>  implementation-dependent" "(defun symbol-function-or-nil (symbol)"
      "  (if (and (fboundp symbol) " "           (not (macro-function symbol))"
      "           (not (special-operator-p symbol)))" "      (symbol-function symbol)"
      "      nil)) =>  SYMBOL-FUNCTION-OR-NIL"
      "(symbol-function-or-nil 'car) =>  #<FUNCTION CAR>"
      "(symbol-function-or-nil 'defun) =>  NIL"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 (CODE1 "defun"))
    (CHAPTER ("## 例外") 2 (STRONG "symbol") "がシンボルではないとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。" EOL2 "もし" (STRONG "symbol") "が" (CODE1 "fbound") "ではなく、"
     "その定義を読み込もうとしたとき、" (CODE1 "undefined-function") "が通知されます。"
     "（その定義を書き込もうとしたときに発生するエラーはありません）")
    (CHAPTER ("## 参考") 2 (CODE1 "fboundp") "," (CODE1 "fmakunbound") ","
     (CODE1 "macro-function") "," (CODE1 "special-operator-p"))
    (CHAPTER ("## 備考") 2 (CODE1 "symbol-function") "は、" (CODE1 "flet") "か"
     (CODE1 "labels") "によって生成された" "レキシカルな関数の値にアクセスできません。" "それはただグローバルな関数の値にのみアクセスできます。"
     EOL2 (CODE1 "setf") "は、" (CODE1 "symbol-function") "とともに使用することで、" (STRONG "symbol")
     "の関数定義が特殊オペレーターとして表現されていない場合は、" "グローバルな関数定義を置き換えます。"
     (CODE3 "```lisp" "```" "(symbol-function symbol) ==  (fdefinition symbol)") EOL2
     "しかし、" (CODE1 "fdefinition") "は、引数にシンボル以外を受け付けます。")))
(setf (gethash '("SYMBOL-FUNCTION" . "ACCESSOR") *table*) (gethash "SYMBOL-FUNCTION" *table*))
(setf (gethash "SYMBOL-MACROLET" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "SYMBOL-MACROLET"))
    (CHAPTER ("## 構文") 2 (CODE1 "symbol-macrolet") " ((" (STRONG "symbol") " "
     (STRONG "expansion") ")\\*) " (STRONG "declaration\\*") " " (STRONG "form\\*") EOL1
     "=> " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - シンボル" EOL1 (STRONG "expansion")
     " - フォーム" EOL1 (STRONG "declaration") " - 宣言式。評価されません。" EOL1 (STRONG "form")
     " - 暗黙のprogn" EOL1 (STRONG "result") " - " (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "symbol-macrolet") "は、シンボル" (STRONG "symbol") "に影響を与える"
     "マクロ展開環境の仕組みを提供します。" EOL2 (CODE1 "symbol-macrolet") "は、" (STRONG "symbol")
     "という名前の各シンボルマクロの" "展開関数をレキシカルに確立します。" EOL2 "シンボルマクロの展開関数は、" "ただフォームと環境が適用されたときに"
     "正しい展開を返すことが保証されています。" "（特に展開が概念的に、展開関数か環境かその両方かの、" "どこに保存されるのかは実装依存です）" EOL2
     (CODE1 "symbol-macrolet") "のキシカルスコープ内で、" "変数として参照される各" (STRONG "symbol") "は、"
     "通常のマクロ展開処理が行われます。" "3.1.2.1.1. フォームとしてのシンボルをご確認ください。" "シンボルマクロの展開は、通常のマクロと同様に、"
     "シンボルマクロの参照先と同じレキシカル環境において、" "さらにマクロ展開が行われます。" EOL2 (STRONG "declaration")
     "は、ひとつの例外を除いて" "正確に" (CODE1 "let") "と同じものが許されます。" "例外は、" (CODE1 "symbol-macrolet")
     "のシンボルの定義に" (CODE1 "special") "宣言があったときはエラーが発生します。" EOL2 (CODE1 "symbol-macrolet")
     "の" (STRONG "form") "内で展開が行われるとき、" (CODE1 "setq") "を使って" (STRONG "symbol")
     "に値をセットしたときは、" "それは" (CODE1 "setf") "を使ったかのように扱われます。" (CODE1 "psetq") "での"
     (STRONG "symbol") "は、" (CODE1 "psetf") "のように扱われ、" (CODE1 "multiple-value-setq") "は"
     (CODE1 "setf") "の" (CODE1 "values") "のように扱われます。" EOL2 (CODE1 "symbol-macrolet")
     "の使用は、" (CODE1 "let") "によってシャドウされます。" "言い換えると、" (CODE1 "symbol-macrolet") "は、"
     (STRONG "symbol") "がレキシカルスコープの束縛で囲まれている" (STRONG "form") "においてのみ、" (STRONG "symbol")
     "の出現が置き換えられます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";;; 例文は下記と等しいのであり、" ";;;   (list 'foo (let ((x 'bar)) x)),"
      ";;; 次と等しいのではありません。" ";;;   (list 'foo (let (('foo 'bar)) 'foo))"
      "(symbol-macrolet ((x 'foo))" "  (list x (let ((x 'bar)) x))) " "=>  (foo bar)"
      "NOT=>  (foo foo) " " " "(symbol-macrolet ((x '(foo x)))" "  (list x))"
      "=>  ((FOO X))"))
    (CHAPTER ("## 影響o") 2 "なし。")
    (CHAPTER ("## 例外") 2 "グローバル変数として定義されているシンボルに束縛をしようとしたときは、" "型"
     (CODE1 "program-error") "のエラーが発生します。" EOL2 (STRONG "declaration") "に"
     (CODE1 "symbol-macrolet") "で束縛するシンボル名の" (CODE1 "special") "宣言が含まれていたときは、" "型"
     (CODE1 "program-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "with-slots") "," (CODE1 "macroexpand"))
    (CHAPTER ("## 備考") 2 "特殊フォームである" (CODE1 "symbol-macrolet") "の基本的な仕組みは、"
     (CODE1 "with-slots") "の実装に使用されています。" EOL2 (CODE1 "symbol-macrolet")
     "フォームがトップレベルフォームであるとき、" (STRONG "form") "もまたトップレベルフォームとして処理されます。"
     "3.2.3. ファイルのコンパイルをご確認ください。")))
(setf (gethash '("SYMBOL-MACROLET" . "SPECIAL-OPERATOR") *table*) (gethash "SYMBOL-MACROLET" *table*))
(setf (gethash "SYMBOL-NAME" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SYMBOL-NAME"))
    (CHAPTER ("## 構文") 2 (CODE1 "symbol-name") " " (STRONG "symbol") " => "
     (STRONG "name"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - シンボル" EOL1 (STRONG "name") " - 文字列")
    (CHAPTER ("## 定義") 2 (CODE1 "symbol-name") "は、" (STRONG "symbol") "の名前を返却します。"
     "もしこれまで" (STRONG "name") "が修正された場合の結果は未定義です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(symbol-name 'temp) =>  \"TEMP\" "
      "(symbol-name :start) =>  \"START\"" "(symbol-name (gensym)) =>  \"G1234\" ;一例"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "symbol") "がシンボルでないときは、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("SYMBOL-NAME" . "FUNCTION") *table*) (gethash "SYMBOL-NAME" *table*))
(setf (gethash "SYMBOL-PACKAGE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SYMBOL-PACKAGE"))
    (CHAPTER ("## 構文") 2 (CODE1 "symbol-package") " " (STRONG "symbol") " => "
     (STRONG "contents"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - シンボル" EOL1 (STRONG "contents")
     " - パッケージオブジェクトか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "シンボルのホームパッケージを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(in-package \"CL-USER\") =>  #<PACKAGE \"COMMON-LISP-USER\">"
      "(symbol-package 'car) =>  #<PACKAGE \"COMMON-LISP\">"
      "(symbol-package 'bus) =>  #<PACKAGE \"COMMON-LISP-USER\">"
      "(symbol-package :optional) =>  #<PACKAGE \"KEYWORD\">"
      ";; Gensyms are uninterned, so have no home package."
      "(symbol-package (gensym)) =>  NIL" "(make-package 'pk1) =>  #<PACKAGE \"PK1\">"
      "(intern \"SAMPLE1\" \"PK1\") =>  PK1::SAMPLE1, NIL"
      "(export (find-symbol \"SAMPLE1\" \"PK1\") \"PK1\") =>  T"
      "(make-package 'pk2 :use '(pk1)) =>  #<PACKAGE \"PK2\">"
      "(find-symbol \"SAMPLE1\" \"PK2\") =>  PK1:SAMPLE1, :INHERITED"
      "(symbol-package 'pk1::sample1) =>  #<PACKAGE \"PK1\">"
      "(symbol-package 'pk2::sample1) =>  #<PACKAGE \"PK1\">"
      "(symbol-package 'pk1::sample2) =>  #<PACKAGE \"PK1\">"
      "(symbol-package 'pk2::sample2) =>  #<PACKAGE \"PK2\">"
      ";; 次に続くフォームは、シンボルが本当にはuninternされておらず、" ";; 「uninternされているらしい」状態で、"
      ";; SYMBOL-PACKAGEがNILを返却するというシナリオです。" "(setq s3 'pk1::sample3) =>  PK1::SAMPLE3"
      "(import s3 'pk2) =>  T" "(unintern s3 'pk1) =>  T" "(symbol-package s3) =>  NIL"
      "(eq s3 'pk2::sample3) =>  T"))
    (CHAPTER ("## 副作用") 2 "なし。")
    (CHAPTER ("## 影響") 2 (CODE1 "import") "," (CODE1 "intern") "," (CODE1 "unintern"))
    (CHAPTER ("## 例外") 2 "もし" (STRONG "symbol") "がシンボルでないとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "intern")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("SYMBOL-PACKAGE" . "FUNCTION") *table*) (gethash "SYMBOL-PACKAGE" *table*))
(setf (gethash "SYMBOL-PLIST" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "SYMBOL-PLIST"))
    (CHAPTER ("## 構文") 2 (CODE1 "symbol-plist") " " (STRONG "symbol") " => "
     (STRONG "plist") EOL1 "(" (CODE1 "setf") " (" (CODE1 "symbol-plist") " "
     (STRONG "symbol") ") " (STRONG "new-plist") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - シンボル" EOL1 (STRONG "plist") ", "
     (STRONG "new-plist") " - プロパティリスト")
    (CHAPTER ("## 定義") 2 (STRONG "symbol") "のプロパティリストにアクセスします。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq sym (gensym)) =>  #:G9723" "(symbol-plist sym) =>  ()"
      "(setf (get sym 'prop1) 'val1) =>  VAL1" "(symbol-plist sym) =>  (PROP1 VAL1)"
      "(setf (get sym 'prop2) 'val2) =>  VAL2"
      "(symbol-plist sym) =>  (PROP2 VAL2 PROP1 VAL1)"
      "(setf (symbol-plist sym) (list 'prop3 'val3)) =>  (PROP3 VAL3)"
      "(symbol-plist sym) =>  (PROP3 VAL3)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "symbol") "がシンボルではないとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "get") "," (CODE1 "remprop"))
    (CHAPTER ("## 備考") 2 "シンボルのプロパティリストはグローバルな資源であり、" "同じLispイメージ内の無関係なプログラムが"
     "操作し依存する情報を含む可能性があるため、" (CODE1 "setf") "の使用は避けるべきです。")))
(setf (gethash '("SYMBOL-PLIST" . "ACCESSOR") *table*) (gethash "SYMBOL-PLIST" *table*))
(setf (gethash "SYMBOL-VALUE" *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "SYMBOL-VALUE"))
    (CHAPTER ("## 構文") 2 (CODE1 "symbol-value") " " (STRONG "symbol") " => "
     (STRONG "value") EOL1 "(" (CODE1 "setf") " (" (CODE1 "symbol-value") " "
     (STRONG "symbol") ") " (STRONG "new-value") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - 値を持っているシンボル" EOL1 (STRONG "value")
     ", " (STRONG "new-value") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "シンボルの値のセルにアクセスします。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setf (symbol-value 'a) 1) =>  1" "(symbol-value 'a) =>  1"
      ";; SYMBOL-VALUEはレキシカル変数を見れない" "(let ((a 2)) (symbol-value 'a)) =>  1"
      "(let ((a 2)) (setq a 3) (symbol-value 'a)) =>  1" ";; SYMBOL-VALUEは動的変数を見れる"
      "(let ((a 2)) " "  (declare (special a)) " "  (symbol-value 'a)) =>  2"
      "(let ((a 2)) " "  (declare (special a)) " "  (setq a 3)"
      "  (symbol-value 'a)) =>  3" "(let ((a 2))" "  (setf (symbol-value 'a) 3)"
      "  a) =>  2" "a =>  3" "(symbol-value 'a) =>  3" "(let ((a 4))"
      "  (declare (special a))" "  (let ((b (symbol-value 'a)))"
      "    (setf (symbol-value 'a) 5)" "    (values a b))) =>  5, 4" "a =>  3"
      "(symbol-value :any-keyword) =>  :ANY-KEYWORD" "(symbol-value 'nil) =>  NIL"
      "(symbol-value '()) =>  NIL" ";; 次の値の精度は実装依存"
      "(symbol-value 'pi) =>  3.141592653589793d0" EOL1))
    (CHAPTER ("## 副作用") 2 "なし。")
    (CHAPTER ("## 影響") 2 (CODE1 "makunbound") "," (CODE1 "set") "," (CODE1 "setq"))
    (CHAPTER ("## 例外") 2 (STRONG "symbol") "がシンボルではないとき、" "型" (CODE1 "type-error")
     "のエラーが発生します。" EOL2 "もし" (STRONG "symbol") "が" (CODE1 "unbound") "で、"
     "その値を読み込もうとしたとき、" (CODE1 "unbound-variable") "が通知されます。"
     "（その値を書き込もうとしたときに発生するエラーはありません）")
    (CHAPTER ("## 参考") 2 (CODE1 "boundp") "," (CODE1 "makunbound") "," (CODE1 "set") ","
     (CODE1 "setq"))
    (CHAPTER ("## 備考") 2 (CODE1 "symbol-value") "は、定数の値を取得できます。" (CODE1 "symbol-value")
     "は、レキシカルな変数の値にアクセスできません。")))
(setf (gethash '("SYMBOL-VALUE" . "ACCESSOR") *table*) (gethash "SYMBOL-VALUE" *table*))
(setf (gethash "SYMBOLP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SYMBOLP"))
    (CHAPTER ("## 構文") 2 (CODE1 "symbolp") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "もし" (STRONG "object") "が型" (CODE1 "symbol") "なら"
     (STRONG "true") "を、" "それ以外なら" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(symbolp 'elephant) =>  true" "(symbolp 12) =>  false"
      "(symbolp nil) =>  true" "(symbolp '()) =>  true" "(symbolp :test) =>  true"
      "(symbolp \"hello\") =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "keywordp") "," (CODE1 "symbol") "," (CODE1 "typep"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(symbolp object) ==  (typep object 'symbol)"))))
(setf (gethash '("SYMBOLP" . "FUNCTION") *table*) (gethash "SYMBOLP" *table*))
(setf (gethash "SYNONYM-STREAM" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "SYNONYM-STREAM"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "synonym-stream") "," (CODE1 "stream") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "このストリームは、他のストリームの別名であり、" (CODE1 "synonym")
     "ストリームが保有するシンボルの名前の動的変数の値が" "別名のストリームを示します。" EOL2 (CODE1 "synonym")
     "ストリームのどのような操作も、" (CODE1 "synonym") "ストリームのシンボルによって名前付けられた"
     "動的変数の値のストリームに対して実行されます。" "もし変数の値が変更されたか、" "あるいは変数に対して束縛が生じたときは、"
     "ストリームは変数の新しい値に対して処理を行います。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-synonym-stream") ","
     (CODE1 "synonym-stream-symbol"))))
(setf (gethash '("SYNONYM-STREAM" . "SYSTEM-CLASS") *table*) (gethash "SYNONYM-STREAM" *table*))
(setf (gethash "SYNONYM-STREAM-SYMBOL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "SYNONYM-STREAM-SYMBOL"))
    (CHAPTER ("## 構文") 2 (CODE1 "synonym-stream-symbol") " " (STRONG "synonym-stream")
     " => " (STRONG "symbol"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "synonym-stream") " - " (CODE1 "synonym") "ストリーム"
     EOL1 (STRONG "symbol") " - シンボル")
    (CHAPTER ("## 定義") 2 (STRONG "synonym-stream") "の" (CODE1 "symbol-value")
     "で使用されているシンボルを返却します。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "make-synonym-stream"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("SYNONYM-STREAM-SYMBOL" . "FUNCTION") *table*) (gethash "SYNONYM-STREAM-SYMBOL" *table*))
(setf (gethash "T" *table*)
  '("T CONSTANT-VARIABLE" EOL1 "T SYSTEM-CLASS" EOL1))
(setf (gethash '("T" . "CONSTANT-VARIABLE") *table*)
  '((CHAPTER NIL 0 "Constant Variable " (CODE1 "T")) (CHAPTER ("## 定数値") 2 (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "ブール値の真を表現しており、" "また標準的なgeneralized-booleanの真を表しています。"
     (CODE1 "nil") "ではないどんなオブジェクトも" (STRONG "true") "であると考えられますが、" (CODE1 "t") "は一般的に、"
     "そのようなオブジェクトを他のものより" "優先する特別な理由がない場合に使用されます。" EOL2 "また、シンボル" (CODE1 "t") "は、"
     "他の目的でも使われることがあります。" "例えば、クラスの名前として。" "指示子として（例えばストリーム指示子）。" "あるいは構文的な理由による特別な記号として"
     "（例えば" (CODE1 "case") "と" (CODE1 "typecase") "の" (CODE1 "otherwise") "句のラベル）。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "t =>  T " "(eq t 't) =>  true"
      "(find-class 't) =>  #<CLASS T 610703333>" "(case 'a (a 1) (t 2)) =>  1"
      "(case 'b (a 1) (t 2)) =>  2" "(prin1 'hello t)" ">>  HELLO" "=>  HELLO"))
    (CHAPTER ("## 参考") 2 (CODE1 "nil")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("T" . "SYSTEM-CLASS") *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "T")) (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "全てのオブジェクトの集合を表します。" "型" (CODE1 "t") "は、自分自身を含む全ての方のスーパータイプです。"
     "全てのオブジェクトは、型" (CODE1 "t") "です。")))
(setf (gethash "TAGBODY" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "TAGBODY"))
    (CHAPTER ("## 構文") 2 (CODE1 "tagbody") " " (CODE1 "{") (STRONG "tag") " " (CODE1 "|")
     " " (STRONG "statement") (CODE1 "}") "\\* => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "tag") " - " (CODE1 "go") "のタグ、評価されません。" EOL1
     (STRONG "statement") " - compound-form、下記の説明通り評価されます。")
    (CHAPTER ("## 定義") 2 (STRONG "tag") "によってラベル付けされた場所へ制御を移す機能を提供するための"
     "レキシカル環境下において、0個か複数の" (STRONG "statement") "を実行します。" EOL2 (CODE1 "tagbody") "の"
     (STRONG "statement") "は、左から右の順番で評価され、" "それらの値は捨てられます。" "もしどんなときでも、残りの"
     (STRONG "statement") "がない場合は、" (CODE1 "tagbody") "は" (CODE1 "nil") "を返却します。"
     "しかし、もし" (CODE1 "(go tag)") "が評価されたときは、" "制御が" (STRONG "tag")
     "でラベル付けされたボディ部の部分にジャンプします" "（タグは" (CODE1 "eql") "によって比較されます）。" EOL2
     (CODE1 "tagbody") "で確立した" (STRONG "tag") "は、レキシカルスコープと動的エクステントを持ちます。" "いったん"
     (CODE1 "tagbody") "を終えると、" "そのボディの" (STRONG "tag") "に対する" (CODE1 "go")
     "はもはや有効ではありません。" (CODE1 "go") "のジャンプは、" "その" (CODE1 "go") "が含まれるもっとも内側の"
     (CODE1 "tagbody") "以外への" "ものも許されます。" (CODE1 "tagbody") "の" (STRONG "tag") "の確立は、"
     "ただ同じ名前の他のタグをシャドウします。" EOL2 "ボディのどの要素が" (STRONG "tag") "でどの要素が" (STRONG "statement")
     "であるかの判断は、" "その要素のマクロ展開の前に行われます。" "もし" (STRONG "statement") "がマクロフォームで、"
     "そのマクロ展開がアトムである場合、" "そのアトムは" (STRONG "tag") "ではなく" (STRONG "statement") "として扱われます。"
     EOL2 "Examples:"
     (CODE3 "```lisp" "```" "(let (val)" "   (tagbody" "     (setq val 1)"
      "     (go point-a)" "     (incf val 16)" "    point-c" "     (incf val 04)"
      "     (go point-b)" "     (incf val 32)" "    point-a" "     (incf val 02)"
      "     (go point-c)" "     (incf val 64)" "    point-b" "     (incf val 08))"
      "   val)" "=>  15" "(defun f1 (flag)" "  (let ((n 1))" "    (tagbody "
      "      (setq n (f2 flag #'(lambda () (go out))))" "     out" "      (prin1 n))))"
      "=>  F1" "(defun f2 (flag escape)" "  (if flag (funcall escape) 2))" "=>  F2"
      "(f1 nil)" ">>  2" "=>  NIL" "(f1 t)" ">>  1" "=>  NIL"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "go"))
    (CHAPTER ("## 備考") 2 "次の図のマクロは、暗黙の" (CODE1 "tagbody") "を持ちます。" EOL2
     "|                     |                           |               |"
     "|---------------------|---------------------------|---------------|" (CODE1 "do")
     "             |" (CODE1 "do-external-symbols") " |" (CODE1 "dotimes") " |"
     (CODE1 "do*") "            |" (CODE1 "do-symbols") "          |" (CODE1 "prog")
     "    |" (CODE1 "do-all-symbols") " |" (CODE1 "dolist") "              |"
     (CODE1 "prog*") "   |" EOL2 "Figure 5-10. 暗黙の" (CODE1 "tagbody") "をもつマクロ")))
(setf (gethash '("TAGBODY" . "SPECIAL-OPERATOR") *table*) (gethash "TAGBODY" *table*))
(setf (gethash "TAILP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "LDIFF") ", " (CODE1 "TAILP"))
    (CHAPTER ("## 構文") 2 (CODE1 "ldiff") " " (STRONG "list") " " (STRONG "object") " => "
     (STRONG "result-list") EOL1 (CODE1 "tailp") " " (STRONG "object") " "
     (STRONG "list") " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト。ドットリストを受け付けます。" EOL1
     (STRONG "object") " - オブジェクト" EOL1 (STRONG "result-list") " - リスト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が" (STRONG "list") "のどれかの末尾と等しいとき、"
     (CODE1 "tailp") "は" (STRONG "true") "を返却し、それ以外は" (STRONG "false") "を返却します。" EOL2
     (STRONG "object") "が" (STRONG "list") "のどれかの末尾と等しいとき、" (CODE1 "ldiff") "は、"
     (STRONG "list") "のリスト構造の中で、" (STRONG "object") "より前にある要素を" "新しいリストとして返却します。"
     "それ以外のときは、" (STRONG "list") "のコピーを返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(let ((lists '#((a b c) (a b c . d))))"
      "  (dotimes (i (length lists)) ()" "    (let ((list (aref lists i)))"
      "      (format t \"~2&list=~S ~21T(tailp object list)~"
      "                 ~44T(ldiff list object)~%\" list)"
      "        (let ((objects (vector list (cddr list) (copy-list (cddr list))"
      "                               '(f g h) '() 'd 'x)))"
      "          (dotimes (j (length objects)) ()"
      "            (let ((object (aref objects j)))"
      "              (format t \"~& object=~S ~21T~S ~44T~S\""
      "                      object (tailp object list) (ldiff list object))))))))"
      ">>  " ">>  list=(A B C)         (tailp object list)    (ldiff list object)"
      ">>   object=(A B C)      T                      NIL"
      ">>   object=(C)          T                      (A B)"
      ">>   object=(C)          NIL                    (A B C)"
      ">>   object=(F G H)      NIL                    (A B C)"
      ">>   object=NIL          T                      (A B C)"
      ">>   object=D            NIL                    (A B C)"
      ">>   object=X            NIL                    (A B C)" ">>  "
      ">>  list=(A B C . D)     (tailp object list)    (ldiff list object)"
      ">>   object=(A B C . D)  T                      NIL"
      ">>   object=(C . D)      T                      (A B)"
      ">>   object=(C . D)      NIL                    (A B C . D)"
      ">>   object=(F G H)      NIL                    (A B C . D)"
      ">>   object=NIL          NIL                    (A B C . D)"
      ">>   object=D            T                      (A B C)"
      ">>   object=X            NIL                    (A B C . D)" "=>  NIL"))
    (CHAPTER ("## 副作用") 2 (CODE1 "ldiff") "と" (CODE1 "tailp") "は、どちらも引数を修正しません。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list") "が通常のリストでもドットリストでもないときは、" "型"
     (CODE1 "type-error") "のエラーを発生させる準備をする必要があります。")
    (CHAPTER ("## 参考") 2 (CODE1 "set-difference"))
    (CHAPTER ("## 備考") 2 "もし" (STRONG "list") "が循環リストのとき、" (STRONG "object") "が実際に"
     (STRONG "list") "の末尾である場合にのみ、" (CODE1 "tailp") "は確実に値を返却します。" "その他の結果は未定義であり、"
     "ある実装では循環を検出して" (STRONG "false") "を返却しますが、" "ある実装ではそのような状況を検出しませんので、" "このような場合、"
     (CODE1 "tailp") "は値を返却することなく、" "ただ無限にループするかもしれません。" EOL2 (CODE1 "tailp")
     "は次のように定義できます。"
     (CODE3 "```lisp" "```" "(defun tailp (object list)" "  (do ((list list (cdr list)))"
      "      ((atom list) (eql list object))" "     (if (eql object list)"
      "         (return t))))")
     EOL2 "そして" (CODE1 "ldiff") "は次のようになります。"
     (CODE3 "```lisp" "```" "(defun ldiff (list object)" "  (do ((list list (cdr list))"
      "       (r '() (cons (car list) r)))" "      ((atom list)"
      "       (if (eql list object) (nreverse r) (nreconc r list)))"
      "    (when (eql object list)" "      (return (nreverse r)))))"))))
(setf (gethash '("TAILP" . "FUNCTION") *table*) (gethash "TAILP" *table*))
(setf (gethash "TENTH" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "FIRST") ", " (CODE1 "SECOND") ", " (CODE1 "THIRD")
     ", " (CODE1 "FOURTH") ", " (CODE1 "FIFTH") "," (CODE1 "SIXTH") ", "
     (CODE1 "SEVENTH") ", " (CODE1 "EIGHTH") ", " (CODE1 "NINTH") ", " (CODE1 "TENTH"))
    (CHAPTER ("## 構文") 2 (CODE1 "first") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "second") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "third") " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fourth")
     " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fifth") " "
     (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "sixth") " " (STRONG "list")
     " => " (STRONG "object") EOL1 (CODE1 "seventh") " " (STRONG "list") " => "
     (STRONG "object") EOL1 (CODE1 "eighth") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "ninth") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "tenth") " " (STRONG "list") " => " (STRONG "object") EOL1 "(" (CODE1 "setf")
     " (" (CODE1 "first") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "second") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "third") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "fourth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "fifth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "sixth") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "seventh") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "eighth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "ninth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "tenth") " " (STRONG "list") ") " (STRONG "new-object")
     ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト、ドットリストと循環リストも受け付けます。" EOL1
     (STRONG "object") ", " (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "関数" (CODE1 "first") ", " (CODE1 "second") ", " (CODE1 "third")
     ", " (CODE1 "fourth") ", " (CODE1 "fifth") "," (CODE1 "sixth") ", "
     (CODE1 "seventh") ", " (CODE1 "eighth") ", " (CODE1 "ninth") ", " (CODE1 "tenth")
     "は、" "それぞれリストの1番目、2番目、3番目、4番目、5番目、" "6番目、7番目、8番目、9番目、10番目の要素にアクセスします。"
     "具体的には次のようになります。"
     (CODE3 "```lisp" "```" "(first list)    ==   (car list)"
      "(second list)   ==   (car (cdr list))" "(third list)    ==   (car (cddr list))"
      "(fourth list)   ==   (car (cdddr list))"
      "(fifth list)    ==   (car (cddddr list))"
      "(sixth list)    ==   (car (cdr (cddddr list)))"
      "(seventh list)  ==   (car (cddr (cddddr list)))"
      "(eighth list)   ==   (car (cdddr (cddddr list)))"
      "(ninth list)    ==   (car (cddddr (cddddr list)))"
      "(tenth list)    ==   (car (cdr (cddddr (cddddr list))))")
     EOL2 (CODE1 "setf") "は、これらの関数を使うことによって" "既存の構成要素を変更することもできます。"
     "上記の等価な関係を用いて同じように適用できます。" "例えば次のようになります。"
     (CODE3 "```lisp" "```"
      "(setf (fifth list) new-object) == (setf (car (cddddr list)) new-object)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst '(1 2 3 (4 5 6) ((V)) vi 7 8 9 10)) "
      "=>  (1 2 3 (4 5 6) ((V)) VI 7 8 9 10)" "(first lst) =>  1" "(tenth lst) =>  10"
      "(fifth lst) =>  ((V))" "(second (fourth lst)) =>  5" "(sixth '(1 2 3)) =>  NIL"
      "(setf (fourth lst) \"four\") =>  \"four\""
      "lst =>  (1 2 3 \"four\" ((V)) VI 7 8 9 10)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "car") "," (CODE1 "nth"))
    (CHAPTER ("## 備考") 2 (CODE1 "first") "は機能的には" (CODE1 "car") "と同じです。" (CODE1 "second")
     "は機能的には" (CODE1 "cadr") "と同じです。" (CODE1 "third") "は機能的には" (CODE1 "caddr") "と同じです。"
     (CODE1 "fourth") "は機能的には" (CODE1 "cadddr") "と同じです。" EOL2 "通常の番号付けは1から開始しますが、"
     (CODE1 "nth") "によって使われる採番は0開始であり、" "次の関係が成り立ちます。"
     (CODE3 "```lisp" "```" "(fifth x) == (nth 4 x)"))))
(setf (gethash '("TENTH" . "ACCESSOR") *table*) (gethash "TENTH" *table*))
(setf (gethash "TERPRI" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "TERPRI") ", " (CODE1 "FRESH-LINE"))
    (CHAPTER ("## 構文") 2 (CODE1 "terpri") " " (CODE1 "&optional") " "
     (STRONG "output-stream") " => " (CODE1 "nil") EOL1 (CODE1 "fresh-line") " "
     (CODE1 "&optional") " " (STRONG "output-stream") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "output-stream") " - 出力ストリーム指定子。標準は標準出力。" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "terpri") "は、" (STRONG "output-stream") "に改行"
     (CODE1 "newline") "を出力します。" EOL2 (CODE1 "fresh-line") "は" (CODE1 "terpri")
     "と似ていますが、" "もし" (STRONG "output-stream") "が行の始まりに位置していないときのみ" "改行" (CODE1 "newline")
     "を出力します。" "何らかの理由でこのような状況が決定できないときは、" "改行" (CODE1 "newline") "は常に出力します。"
     (CODE1 "fresh-line") "は、改行" (CODE1 "newline") "が出力されたとき" (STRONG "true") "を返却し、"
     "それ以外のときは" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-output-to-string (s)"
      "   (write-string \"some text\" s)" "   (terpri s)" "   (terpri s)"
      "   (write-string \"more text\" s))" "=>  \"some text" NIL "more text\""
      "(with-output-to-string (s)" "   (write-string \"some text\" s)"
      "   (fresh-line s)" "   (fresh-line s)" "   (write-string \"more text\" s))"
      "=>  \"some text" "more text\""))
    (CHAPTER ("## 副作用") 2 (STRONG "output-stream") "は修正されます。")
    (CHAPTER ("## 影響") 2 (CODE1 "*standard-output*") "," (CODE1 "*terminal-io*"))
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2 (CODE1 "terpri") "の効果は下記の同等です。"
     (CODE3 "```lisp" "```" "(write-char #\\Newline output-stream)"))))
(setf (gethash '("TERPRI" . "FUNCTION") *table*) (gethash "TERPRI" *table*))
(setf (gethash "THE" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "THE"))
    (CHAPTER ("## 構文") 2 (CODE1 "the") " " (STRONG "value-type") " " (STRONG "form")
     " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "value-type") " - 型指定子。評価されません。" EOL1
     (STRONG "form") " - フォーム。評価されます。" EOL1 (STRONG "result") " - " (STRONG "form")
     "を評価した結果の返却値。" "これらの返却値は" (STRONG "value-type") "によって指定した型に一致しなければなりません。"
     "詳細は下記を参照。")
    (CHAPTER ("## 定義") 2 (CODE1 "the") "は" (STRONG "form") "によって返却された値が"
     (STRONG "value-type") "の型であることを指定します。" (STRONG "result") "が宣言の型ではないときの結果は未定義です。"
     EOL2 "型が宣言されている値が実際にその型である限り、" (STRONG "form") "が" (STRONG "value-type")
     "で指定されている値とは" "異なる数の値を生成することは許されます。" "欠落している値は、その型を確認するために" (CODE1 "nil")
     "として扱われます。" EOL2 (STRONG "value-type") "で宣言された値の数に関係なく、" (STRONG "form") "が返す値の数は、"
     (CODE1 "the") " 特殊フォームが返す値の数と同じになります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(the symbol (car (list (gensym)))) =>  #:G9876"
      "(the fixnum (+ 5 7)) =>  12" "(the (values) (truncate 3.2 2)) =>  1, 1.2"
      "(the integer (truncate 3.2 2)) =>  1, 1.2"
      "(the (values integer) (truncate 3.2 2)) =>  1, 1.2"
      "(the (values integer float) (truncate 3.2 2))   =>  1, 1.2"
      "(the (values integer float symbol) (truncate 3.2 2)) =>  1, 1.2"
      "(the (values integer float symbol t null list) "
      "     (truncate 3.2 2)) =>  1, 1.2" "(let ((i 100))" "   (declare (fixnum i))"
      "   (the fixnum (1+ i))) =>  101" "(let* ((x (list 'a 'b 'c))" "       (y 5))"
      "   (setf (the fixnum (car x)) y)" "   x) =>  (5 B C)"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "form") "が生成した返却値が指定した" (STRONG "value-type") "では"
     "なかったときの結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "values"))
    (CHAPTER ("## 備考") 2 (CODE1 "values") "型指定子は、多値の型を示すのに使われます。"
     (CODE3 "```lisp" "```" "(the (values integer integer) (floor x y))"
      "(the (values string t)" "     (gethash the-key the-string-table))")
     EOL2 (CODE1 "setf") "は、" (CODE1 "the") "の型指定子を使用できます。"
     "この場合、宣言は新しい値を指定したフォームへ変換されます。" "その" (CODE1 "setf") "の結果が解析されます。")))
(setf (gethash '("THE" . "SPECIAL-OPERATOR") *table*) (gethash "THE" *table*))
(setf (gethash "THIRD" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "FIRST") ", " (CODE1 "SECOND") ", " (CODE1 "THIRD")
     ", " (CODE1 "FOURTH") ", " (CODE1 "FIFTH") "," (CODE1 "SIXTH") ", "
     (CODE1 "SEVENTH") ", " (CODE1 "EIGHTH") ", " (CODE1 "NINTH") ", " (CODE1 "TENTH"))
    (CHAPTER ("## 構文") 2 (CODE1 "first") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "second") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "third") " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fourth")
     " " (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "fifth") " "
     (STRONG "list") " => " (STRONG "object") EOL1 (CODE1 "sixth") " " (STRONG "list")
     " => " (STRONG "object") EOL1 (CODE1 "seventh") " " (STRONG "list") " => "
     (STRONG "object") EOL1 (CODE1 "eighth") " " (STRONG "list") " => " (STRONG "object")
     EOL1 (CODE1 "ninth") " " (STRONG "list") " => " (STRONG "object") EOL1
     (CODE1 "tenth") " " (STRONG "list") " => " (STRONG "object") EOL1 "(" (CODE1 "setf")
     " (" (CODE1 "first") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "second") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "third") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "fourth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "fifth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "sixth") " " (STRONG "list") ") " (STRONG "new-object")
     ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "seventh") " " (STRONG "list") ") "
     (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " (" (CODE1 "eighth") " "
     (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "(" (CODE1 "setf") " ("
     (CODE1 "ninth") " " (STRONG "list") ") " (STRONG "new-object") ")" EOL1 "("
     (CODE1 "setf") " (" (CODE1 "tenth") " " (STRONG "list") ") " (STRONG "new-object")
     ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト、ドットリストと循環リストも受け付けます。" EOL1
     (STRONG "object") ", " (STRONG "new-object") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "関数" (CODE1 "first") ", " (CODE1 "second") ", " (CODE1 "third")
     ", " (CODE1 "fourth") ", " (CODE1 "fifth") "," (CODE1 "sixth") ", "
     (CODE1 "seventh") ", " (CODE1 "eighth") ", " (CODE1 "ninth") ", " (CODE1 "tenth")
     "は、" "それぞれリストの1番目、2番目、3番目、4番目、5番目、" "6番目、7番目、8番目、9番目、10番目の要素にアクセスします。"
     "具体的には次のようになります。"
     (CODE3 "```lisp" "```" "(first list)    ==   (car list)"
      "(second list)   ==   (car (cdr list))" "(third list)    ==   (car (cddr list))"
      "(fourth list)   ==   (car (cdddr list))"
      "(fifth list)    ==   (car (cddddr list))"
      "(sixth list)    ==   (car (cdr (cddddr list)))"
      "(seventh list)  ==   (car (cddr (cddddr list)))"
      "(eighth list)   ==   (car (cdddr (cddddr list)))"
      "(ninth list)    ==   (car (cddddr (cddddr list)))"
      "(tenth list)    ==   (car (cdr (cddddr (cddddr list))))")
     EOL2 (CODE1 "setf") "は、これらの関数を使うことによって" "既存の構成要素を変更することもできます。"
     "上記の等価な関係を用いて同じように適用できます。" "例えば次のようになります。"
     (CODE3 "```lisp" "```"
      "(setf (fifth list) new-object) == (setf (car (cddddr list)) new-object)"))
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq lst '(1 2 3 (4 5 6) ((V)) vi 7 8 9 10)) "
      "=>  (1 2 3 (4 5 6) ((V)) VI 7 8 9 10)" "(first lst) =>  1" "(tenth lst) =>  10"
      "(fifth lst) =>  ((V))" "(second (fourth lst)) =>  5" "(sixth '(1 2 3)) =>  NIL"
      "(setf (fourth lst) \"four\") =>  \"four\""
      "lst =>  (1 2 3 \"four\" ((V)) VI 7 8 9 10)"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "car") "," (CODE1 "nth"))
    (CHAPTER ("## 備考") 2 (CODE1 "first") "は機能的には" (CODE1 "car") "と同じです。" (CODE1 "second")
     "は機能的には" (CODE1 "cadr") "と同じです。" (CODE1 "third") "は機能的には" (CODE1 "caddr") "と同じです。"
     (CODE1 "fourth") "は機能的には" (CODE1 "cadddr") "と同じです。" EOL2 "通常の番号付けは1から開始しますが、"
     (CODE1 "nth") "によって使われる採番は0開始であり、" "次の関係が成り立ちます。"
     (CODE3 "```lisp" "```" "(fifth x) == (nth 4 x)"))))
(setf (gethash '("THIRD" . "ACCESSOR") *table*) (gethash "THIRD" *table*))
(setf (gethash "THROW" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "THROW"))
    (CHAPTER ("## 構文") 2 (CODE1 "throw") " " (STRONG "tag") " " (STRONG "result-form")
     " =>" (CODE1 "|"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "tag") " - " (CODE1 "catch") "のタグ、評価されます。" EOL1
     (STRONG "result-form") " - フォーム、下記の説明どおり評価されます。")
    (CHAPTER ("## 定義") 2 (CODE1 "throw") "は、" (STRONG "tag") "と" (CODE1 "eq") "で等しいタグの"
     (CODE1 "catch") "へ、" "非局所的な制御の遷移を行います。" EOL2 "最初に" (STRONG "tag") "が評価され、"
     (CODE1 "throw") "タグと呼ばれるオブジェクトを生成します。" "そのあと" (STRONG "result-form")
     "が評価され、その値は保存されます。" "もし" (STRONG "result-form") "が多値を生成したときは、その全ての値が保存されます。"
     "もっとも近くにある" (STRONG "tag") "と" (CODE1 "eq") "で等しい" (CODE1 "throw") "タグを持つ有効な"
     (CODE1 "catch") "に対して退出が行われます。" "そのとき保存された値は、" (CODE1 "catch") "の返却値か多値として返されます。"
     EOL2 (CODE1 "throw") "によって開始される制御の遷移の実行についての説明は、" "5.2. 終了地点への制御の遷移をご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(catch 'result" "   (setq i 0 j 0)"
      "   (loop (incf j 3) (incf i)"
      "         (if (= i 3) (throw 'result (values i j))))) =>  3, 9" NIL "(catch nil "
      "  (unwind-protect (throw nil 1)" "    (throw nil 2))) =>  2")
     EOL2 "下記の例では" (CODE1 "b") "の" (CODE1 "catch") "の上を最初の" (CODE1 "throw")
     "によって通過しているため、" "結果は未定義であり、したがって移植可能なプログラムは" "動的エクステントが終了していると仮定してください。"
     (CODE1 "catch") "タグの束縛はまだ解除されていないので、" "これは2番目の" (CODE1 "throw") "のターゲットです。"
     (CODE3 "```lisp" "```" "(catch 'a" "  (catch 'b" "    (unwind-protect (throw 'a 1)"
      "      (throw 'b 2))))")
     EOL2 "下記の例は「" (CODE1 "The inner catch returns :SECOND-THROW") "」が出力され、"
     (CODE1 ":outer-catch") "が返却されます。"
     (CODE3 "```lisp" "```" "(catch 'foo"
      "        (format t \"The inner catch returns ~s.~%\"" "                (catch 'foo"
      "                    (unwind-protect (throw 'foo :first-throw)"
      "                        (throw 'foo :second-throw))))" "        :outer-catch)"
      ">>  The inner catch returns :SECOND-THROW" "=>  :OUTER-CATCH"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (CODE1 "throw") "タグにマッチする有効な" (CODE1 "catch") "タグがないときは、"
     (CODE1 "unwind") "のスタックが実行され、" "型" (CODE1 "control-error") "のエラーが発生します。"
     "もしエラーが発生した時は、" "動的環境は" (CODE1 "throw") "の地点で有効なものになります。")
    (CHAPTER ("## 参考") 2 (CODE1 "block") "," (CODE1 "catch") "," (CODE1 "return-from")
     "," (CODE1 "unwind-protect") "," "3.1. 評価")
    (CHAPTER ("## 備考") 2 (CODE1 "catch") "と" (CODE1 "throw") "は通常、" "退出点が動的スコープのとき（例えば、"
     (CODE1 "throw") "がレキシカルな" (CODE1 "catch") "に囲まれていないとき）に使われ、" "それに対して"
     (CODE1 "block") "と" (CODE1 "return-from") "は、" "レキシカルスコープで十分のときに使用されます。")))
(setf (gethash '("THROW" . "SPECIAL-OPERATOR") *table*) (gethash "THROW" *table*))
(setf (gethash "TRANSLATE-LOGICAL-PATHNAME" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "TRANSLATE-LOGICAL-PATHNAME"))
    (CHAPTER ("## 構文") 2 (CODE1 "translate-logical-pathname") " " (STRONG "pathname") " "
     (CODE1 "&key") " => " (STRONG "physical-pathname"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathname") " - パス名指定子か、論理パス名の名前文字列。" EOL1
     (STRONG "physical-pathname") " - 物理パス名")
    (CHAPTER ("## 定義") 2 (STRONG "pathname") "を物理パス名に変換し返却します。" EOL2 "もし"
     (STRONG "pathname") "がストリームのとき、" "そのストリームは開いているものか閉じているものを指定できます。"
     (CODE1 "translate-logical-pathname") "は" "ファイルがクローズされたあとのものについては、"
     "ファイルが開いているときに実行されたものと同じ論理パス名を返却します。" "もし" (STRONG "pathname") "がストリームであり、"
     (CODE1 "make-two-way-stream") "," (CODE1 "make-echo-stream") ","
     (CODE1 "make-broadcast-stream") "," (CODE1 "make-concatenated-stream") ","
     (CODE1 "make-string-input-stream") "," (CODE1 "make-string-output-stream")
     "によって作成されたもののときはエラーが発生します。" EOL2 "もし" (STRONG "pathname") "が論理パス名の名前文字列であるときは、"
     "それはホストの要素と合わせてコロンが続くものを含まなければなりません。" EOL2 (STRONG "pathname") "は、最初にパス名に変換されます。"
     "もし変換された" (STRONG "pathname") "が物理パス名のときは、それが返却されます。" "もし変換された" (STRONG "pathname")
     "が論理パス名のときは、" (CODE1 "translate-pathname") "が呼び出されたかのように、" "論理パス名のホストの最初にマッチした変換"
     "（" (CODE1 "pathname-match-p") "に従って）が適用されます。" "もし結果が論理パス名のとき、この処理は繰り返し行われます。"
     "結果が最終的に物理パス名になったとき、それが返却されます。" "もしどの変換にもマッチしなかったとき、エラーが通知されます。" EOL2
     (CODE1 "translate-logical-pathname") "は追加の変換を行うことがあり、"
     "典型的にはローカルな命名規則に合わせてファイルのタイプを変換したり、" "物理ファイルシステムの名前の長さに制限がある場合に対応したり、"
     "ハイフンをアンダースコアに、" "大文字を小文字に変換するような" "特殊文字の要件に対応するなどを行います。" "このような追加の変換は実装定義のものです。"
     "実装によっては追加の変換を行いません。" EOL2 (CODE1 "translate-logical-pathname") "にはキーワード引数はありませんが、"
     "しかし実装は追加のキーワード引数による拡張が許されます。")
    (CHAPTER ("## 例文") 2 "See " (CODE1 "logical-pathname-translations"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "pathname") "に不正なものが与えられたとき、" "型"
     (CODE1 "type-error") "のエラーが発生します。" EOL2 "もしどの返還にもマッチしないとき、" "型" (CODE1 "file-error")
     "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "logical-pathname") ","
     (CODE1 "logical-pathname-translations") "," (CODE1 "logical-pathname") ","
     "20.1. ファイルシステムの説明," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("TRANSLATE-LOGICAL-PATHNAME" . "FUNCTION") *table*) (gethash "TRANSLATE-LOGICAL-PATHNAME" *table*))
(setf (gethash "TRANSLATE-PATHNAME" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "TRANSLATE-PATHNAME"))
    (CHAPTER ("## 構文") 2 (CODE1 "translate-pathname") " " (STRONG "source") " "
     (STRONG "from-wildcard") " " (STRONG "to-wildcard") " " (CODE1 "&key") " => "
     (STRONG "translated-pathname"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "source") " - パス名指定子" EOL1 (STRONG "from-wildcard")
     " - パス名指定子" EOL1 (STRONG "to-wildcard") " - パス名指定子" EOL1
     (STRONG "translated-pathname") " - パス名")
    (CHAPTER ("## 定義") 2 (CODE1 "translate-pathname") "は" (STRONG "source") "（"
     (STRONG "from-wildcard") "にマッチしたもの）を、" (STRONG "to-wildcard") "にマッチした対応したパス名に変換し、"
     "その対応したパス名を返却します。" EOL2 "パス名の結果は" (STRONG "to-wildcard") "の各ワイルドカードか欠落した要素が"
     (STRONG "source") "の部分に置き換えられたものになります。" "「ワイルドカードの要素」とは、" "パス名の要素の値が"
     (CODE1 ":wild") "であるか、" "ディレクトリの要素のリストの要素が" (CODE1 ":wild") "であるか、"
     "あるいは要素の実装定義の部分である" "例えばいくつかの実装でサポートされている、" "文字列" (CODE1 "\"foo*bar\"")
     "のような複雑なワイルドカードである" (CODE1 "\"*\"") "のような文字のことです。"
     "実装は例えば正規表現のようなその他のワイルドカードの機能を追加することができ、" "そのような機能をどのようにして"
     (CODE1 "translate-pathname") "に拡張するのか" "定義しなければなりません。" "「欠落した要素」はパス名の要素が"
     (CODE1 "nil") "のものです。" EOL2 "結果のパス名からコピーされた" (STRONG "source") "の部分は実装定義です。"
     "典型的にはそれはファイルシステムに関与する" "ユーザーインターフェイスの慣習によって決定されます。" "通常それは" (STRONG "source")
     "の部分が" (STRONG "from-wildcard") "のワイルドカードの要素と" (STRONG "to-wildcard")
     "のワイルドカードか欠落した要素の同じ部分が" "マッチした部分です。" "もし" (STRONG "from-wildcard")
     "のある位置がワイルドカードの要素ではなかったとき、" "通常はそれは対応する" (STRONG "source") "のパス名の要素全体であるか、"
     "あるいはディレクトリ要素のリストの要素の場合であるか、" "あるいは対応するリストの要素全体になります。" EOL2 (STRONG "source")
     "の部分を結果のパス名へコピーするとき、" "追加の実装定義の大文字小文字の変換や、" "ファイル名の慣習の変換が生じるかもしれません。" "とくに"
     (STRONG "from-wildcard") "と" (STRONG "to-wildcard") "が違うホストのときに生じます。" EOL2
     (STRONG "source") "がワイルドカードのパス名であることは正当であり、" "一般的にこれはワイルドカードを含む結果が生成されるでしょう。"
     (STRONG "from-wildcard") "と" (STRONG "to-wildcard") "の片方かあるいは両方に"
     "ワイルドカードを含まれないパス名であることは正当です。" EOL2 (CODE1 "translate-pathname") "にはキーワード引数はありませんが、"
     "しかし実装は追加のキーワード引数による拡張が許されます。" EOL2 (CODE1 "translate-pathname") "は"
     (STRONG "source") "の慣習的な大文字小文字と" "出力パス名の慣習的な大文字小文字を対応付けします。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; 下記の5つのフォームの結果は、全て実装依存です。"
      ";; とくに2つ目については一般的に生じるであろう多くのもののうち" ";; 強調したものをいくつか示しています。"
      "(pathname-name (translate-pathname \"foobar\" \"foo*\" \"*baz\")) =>  \"barbaz\""
      "(pathname-name (translate-pathname \"foobar\" \"foo*\" \"*\"))" "=>  \"foobar\""
      "OR=>  \"bar\""
      "(pathname-name (translate-pathname \"foobar\" \"*\"    \"foo*\")) =>  \"foofoobar\""
      "(pathname-name (translate-pathname \"bar\"    \"*\"    \"foo*\")) =>  \"foobar\""
      "(pathname-name (translate-pathname \"foobar\" \"foo*\" \"baz*\")) =>  \"bazbar\""
      NIL "(defun translate-logical-pathname-1 (pathname rules)"
      "  (let ((rule (assoc pathname rules :test #'pathname-match-p)))"
      "    (unless rule (error \"No translation rule for ~A\" pathname))"
      "    (translate-pathname pathname (first rule) (second rule))))"
      "(translate-logical-pathname-1 \"FOO:CODE;BASIC.LISP\""
      "                      '((\"FOO:DOCUMENTATION;\" \"MY-UNIX:/doc/foo/\")"
      "                        (\"FOO:CODE;\"          \"MY-UNIX:/lib/foo/\")"
      "                        (\"FOO:PATCHES;*;\"     \"MY-UNIX:/lib/foo/patch/*/\")))"
      "=>  #P\"MY-UNIX:/lib/foo/basic.l\"" NIL ";;; この例はワイルドカードを認識できることを仮定しています。"
      ";;; 全てのファイルシステムがこの例のように正確に実行されません。" "(defun rename-files (from to)"
      "  (dolist (file (directory from))"
      "    (rename-file file (translate-pathname file from to))))"
      "(rename-files \"/usr/me/*.lisp\" \"/dev/her/*.l\")"
      "  ;Renames /usr/me/init.lisp to /dev/her/init.l"
      "(rename-files \"/usr/me/pcl*/*\" \"/sys/pcl/*/\")"
      "  ;Renames /usr/me/pcl-5-may/low.lisp to /sys/pcl/pcl-5-may/low.lisp"
      "  ;In some file systems the result might be /sys/pcl/5-may/low.lisp"
      "(rename-files \"/usr/me/pcl*/*\" \"/sys/library/*/\")"
      "  ;Renames /usr/me/pcl-5-may/low.lisp to /sys/library/pcl-5-may/low.lisp"
      "  ;In some file systems the result might be /sys/library/5-may/low.lisp"
      "(rename-files \"/usr/me/foo.bar\" \"/usr/me2/\")"
      "  ;Renames /usr/me/foo.bar to /usr/me2/foo.bar"
      "(rename-files \"/usr/joe/*-recipes.text\" \"/usr/jim/cookbook/joe's-*-rec.text\")"
      "  ;Renames /usr/joe/lamb-recipes.text to /usr/jim/cookbook/joe's-lamb-rec.text"
      "  ;Renames /usr/joe/pork-recipes.text to /usr/jim/cookbook/joe's-pork-rec.text"
      "  ;Renames /usr/joe/veg-recipes.text to /usr/jim/cookbook/joe's-veg-rec.text"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "source") "か" (STRONG "from-wildcard") "か"
     (STRONG "to-wildcard") "のいずれかが、" "パス名、文字列、ファイルに関連づいたストリームのどれでもない場合は、" "型"
     (CODE1 "type-error") "のエラーが発生します。" EOL2
     (CODE1 "(pathname-match-p source from-wildcard)") "は" (STRONG "true") "でなければならず、"
     "あるいは型" (CODE1 "type-error") "のエラーが派生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "namestring") "," (CODE1 "pathname-host") ","
     (CODE1 "pathname") "," (CODE1 "logical-pathname") "," "20.1. ファイルシステムの説明,"
     "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 (CODE1 "translate-pathname") "の正確なふるまいは、"
     "Common Lisp言語では決めることができず、" "ファイルシステムの慣習に従ったユーザーインターフェイスに"
     "依存するように変化できるようにする必要があります。" EOL2 "これ以降の文章は実装のガイドラインです。" "あるファイルシステムでは、"
     "この操作行うためにパス名の3つの各部分を順番に調べます。" "ここで、各部分とはパス名のコンポーネントか、"
     "または階層型ディレクトリのような構造化された要素を表すリストの要素です。" (STRONG "from-wildcard") "と"
     (STRONG "to-wildcard") "の階層ディレクトリ要素は、" "ディレクトリ階層内の深さではなく、" "ワイルドカードであるかどうかでマッチされます。"
     "もし" (STRONG "to-wildcard") "に含まれる部分が存在し、" "それがワイルドカードでないときは結果にコピーされます。"
     (STRONG "to-wildcard") "の部分が" (CODE1 ":wild") "または" (CODE1 "nil") "のときは、"
     (STRONG "source") "の部分が結果にコピーされます。" "それ以外のときは、" (STRONG "to-wildcard") "の部分は"
     (CODE1 "\"foo*bar\"") "のような複雑なワイルドカードであり、" (STRONG "from-wildcard")
     "の部分はワイルドカードでなければなりません。" (STRONG "source") "の部分のうち、" (STRONG "from-wildcard")
     "の部分のワイルドカードにマッチする部分は、" (STRONG "to-wildcard") "のワイルドカードの部分を置き換え、"
     "その生成された値が結果として使われます。")))
(setf (gethash '("TRANSLATE-PATHNAME" . "FUNCTION") *table*) (gethash "TRANSLATE-PATHNAME" *table*))
(setf (gethash "TREE-EQUAL" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "TREE-EQUAL"))
    (CHAPTER ("## 構文") 2 (CODE1 "tree-equal") " " (STRONG "tree-1") " " (STRONG "tree-2")
     " &key " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "tree-1") " - ツリー" EOL1 (STRONG "tree-2") " - ツリー"
     EOL1 (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test-not") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     "generalized-boolean - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "tree-equal") "は、2つのツリーが" "同じ形であり同じ葉を持っているかどうかをテストします。"
     (CODE1 "tree-equal") "は、" (STRONG "tree-1") "と" (STRONG "tree-2") "がどちらもアトムでかつ"
     (STRONG "test") "を満たすときは" (STRONG "true") "を返却し、" "また、どちらもコンスであり、" (STRONG "tree-1")
     "の" (CODE1 "car") "と" (STRONG "tree-2") "の" (CODE1 "car") "が" (CODE1 "tree-equal")
     "で等しく、" (STRONG "tree-1") "の" (CODE1 "cdr") "と" (STRONG "tree-2") "の" (CODE1 "cdr")
     "が" (CODE1 "tree-equal") "で等しいとき、" (STRONG "true") "を返却を返却します。" "その他の場合は、"
     (CODE1 "tree-equal") "は" (STRONG "false") "を返却します。" EOL2 (CODE1 "tree-equal")
     "はコンスを再帰的に比較しますが、" "要素を持つ他のオブジェクトは比較しません。" EOL2 (CODE1 ":test:") "と"
     (CODE1 ":test-not") "の関数の" "最初の引数は、" (STRONG "tree-1") "か、" (STRONG "tree-1") "の"
     (CODE1 "car") "か" (CODE1 "cdr") "です。" "二番目の引数は、" (STRONG "tree-2") "か、"
     (STRONG "tree-2") "の" (CODE1 "car") "か" (CODE1 "cdr") "です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq tree1 '(1 (1 2))"
      "      tree2 '(1 (1 2))) =>  (1 (1 2))" "(tree-equal tree1 tree2) =>  true"
      "(eql tree1 tree2) =>  false" "(setq tree1 '('a ('b 'c))"
      "      tree2 '('a ('b 'c))) =>  ('a ('b 'c)) "
      "=>  ((QUOTE A) ((QUOTE B) (QUOTE C)))"
      "(tree-equal tree1 tree2 :test 'eq) =>  true"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "tree-1") "と" (STRONG "tree-2")
     "がどちらも循環しているときの結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "equal") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。")))
(setf (gethash '("TREE-EQUAL" . "FUNCTION") *table*) (gethash "TREE-EQUAL" *table*))
(setf (gethash "TRUENAME" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "TRUENAME"))
    (CHAPTER ("## 構文") 2 (CODE1 "truename") " " (STRONG "filespec") " => "
     (STRONG "truename"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "filespec") " - パス名指定子" EOL1 (STRONG "truename")
     " - 物理パス名")
    (CHAPTER ("## 定義") 2 (CODE1 "truename") "は、" (STRONG "filespec") "によって指し示している"
     "ファイルを見つけようと試行し、" "それを実際の名前として返却します。" "もし" (STRONG "filespec") "の指定子が開いたストリームのとき、"
     "それに関連付けられたファイルが使用されます。" "もし" (STRONG "filespec") "がストリームのとき、" (CODE1 "truename")
     "はストリームが開いているか閉じられているかに関わらず" "使用することができます。" (CODE1 "truename") "はストリームが開いているときよりも、"
     "ストリームが閉じられた後の方が" "より多くの特定的な情報を返却することが許されています。" "もし" (STRONG "filespec") "がパス名のとき、"
     "それはファイルを開くときに使用される名前の表現になります。" "これはおそらく、必須ではありませんが、" "実際のファイル名になります。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";; この例ではバージョンの数に注目します。"
      ";; まだファイルが開いているものに対してtruenameが返却する内容は" ";; 実装依存であることに注意してください。"
      "(with-open-file (stream \">vistor>test.text.newest\")"
      "  (values (pathname stream)" "          (truename stream)))"
      "=>  #P\"S:>vistor>test.text.newest\", #P\"S:>vistor>test.text.1\""
      "OR=>  #P\"S:>vistor>test.text.newest\", #P\"S:>vistor>test.text.newest\""
      "OR=>  #P\"S:>vistor>test.text.newest\", #P\"S:>vistor>_temp_._temp_.1\"" NIL
      ";; この例では閉じられたファイルに対してtruenameを試行しているので" ";; truenameの情報は確かなものになります。"
      "(with-open-file (stream \">vistor>test.text.newest\")" "  (close stream)"
      "  (values (pathname stream)" "          (truename stream)))"
      "=>  #P\"S:>vistor>test.text.newest\", #P\"S:>vistor>test.text.1\"" NIL
      ";; この例ではTOP-20の論理デバイスに基づく処理系実装であり、"
      ";; この場合、\"DOC:\"は\"PS:<DOCUMENTATION>\" ...の省略形になります。"
      "(with-open-file (stream \"CMUC::DOC:DUMPER.HLP\")" "  (values (pathname stream)"
      "          (truename stream)))"
      "=>  #P\"CMUC::DOC:DUMPER.HLP\", #P\"CMUC::PS:<DOCUMENTATION>DUMPER.HLP.13\""))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし引数の" (STRONG "filespec") "がファイルシステム内において"
     "適切なファイルの位置を特定できなかったときか、" "あるいはファイルシステムが要求された処理を実行できなかったときは、" "型"
     (CODE1 "file-error") "のエラーが発生します。" EOL2 "もし" (STRONG "filespec") "がワイルドカードを含むとき、"
     "型" (CODE1 "file-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "pathname") "," (CODE1 "logical-pathname") ","
     "20.1. ファイルシステムの説明," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 (CODE1 "truename") "はファイルシステムによって実行できるような"
     "ファイル名に変換するときに使用されます。")))
(setf (gethash '("TRUENAME" . "FUNCTION") *table*) (gethash "TRUENAME" *table*))
(setf (gethash "TWO-WAY-STREAM" *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "TWO-WAY-STREAM"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "two-way-stream") "," (CODE1 "stream") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "双方向の合成されたストリームであり、" "関連付けられた入力ストリームから入力の取得と、"
     "関連付けられた出力ストリームへ出力を送信をします。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-two-way-stream") ","
     (CODE1 "two-way-stream-input-stream") "," (CODE1 "two-way-stream-output-stream"))))
(setf (gethash '("TWO-WAY-STREAM" . "SYSTEM-CLASS") *table*) (gethash "TWO-WAY-STREAM" *table*))
(setf (gethash "TWO-WAY-STREAM-INPUT-STREAM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "TWO-WAY-STREAM-INPUT-STREAM") ", "
     (CODE1 "TWO-WAY-STREAM-OUTPUT-STREAM"))
    (CHAPTER ("## 構文") 2 (CODE1 "two-way-stream-input-stream") " "
     (STRONG "two-way-stream") " => " (STRONG "input-stream") EOL1
     (CODE1 "two-way-stream-output-stream") " " (STRONG "two-way-stream") " => "
     (STRONG "output-stream"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "two-way-stream") " - " (CODE1 "two-way") "ストリーム"
     EOL1 (STRONG "input-stream") " - 入力ストリーム" EOL1 (STRONG "output-stream")
     " - 出力ストリーム")
    (CHAPTER ("## 定義") 2 (CODE1 "two-way-stream-input-stream") "は、"
     (STRONG "two-way-stream") "が入力を受け取るストリームを返却します。" EOL2
     (CODE1 "two-way-stream-output-stream") "は、" (STRONG "two-way-stream")
     "が出力を送信するストリームを返却します。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("TWO-WAY-STREAM-INPUT-STREAM" . "FUNCTION") *table*) (gethash "TWO-WAY-STREAM-INPUT-STREAM" *table*))
(setf (gethash "TWO-WAY-STREAM-OUTPUT-STREAM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "TWO-WAY-STREAM-INPUT-STREAM") ", "
     (CODE1 "TWO-WAY-STREAM-OUTPUT-STREAM"))
    (CHAPTER ("## 構文") 2 (CODE1 "two-way-stream-input-stream") " "
     (STRONG "two-way-stream") " => " (STRONG "input-stream") EOL1
     (CODE1 "two-way-stream-output-stream") " " (STRONG "two-way-stream") " => "
     (STRONG "output-stream"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "two-way-stream") " - " (CODE1 "two-way") "ストリーム"
     EOL1 (STRONG "input-stream") " - 入力ストリーム" EOL1 (STRONG "output-stream")
     " - 出力ストリーム")
    (CHAPTER ("## 定義") 2 (CODE1 "two-way-stream-input-stream") "は、"
     (STRONG "two-way-stream") "が入力を受け取るストリームを返却します。" EOL2
     (CODE1 "two-way-stream-output-stream") "は、" (STRONG "two-way-stream")
     "が出力を送信するストリームを返却します。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 "なし。") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("TWO-WAY-STREAM-OUTPUT-STREAM" . "FUNCTION") *table*) (gethash "TWO-WAY-STREAM-OUTPUT-STREAM" *table*))
(setf (gethash "TYPE" *table*)
  '((CHAPTER NIL 0 "Declaration " (CODE1 "TYPE"))
    (CHAPTER ("## 構文") 2 "(" (CODE1 "type") " " (STRONG "typespec") " " (STRONG "var\\*")
     ")" EOL1 "(" (STRONG "typespec") " " (STRONG "var\\*") ")")
    (CHAPTER ("## 引数") 2 (STRONG "typespec") " - 型指定子" EOL1 (STRONG "var") " - 変数名")
    (CHAPTER ("## 有効な文脈") 2 (CODE1 "declare") "と" (CODE1 "proclaim"))
    (CHAPTER ("## 影響する束縛の型") 2 "変数")
    (CHAPTER ("## 定義") 2 "変数の束縛にのみ影響し、" (STRONG "var") "がただ指定した" (STRONG "typespec")
     "の値のみ受け取ることを宣言します。" "とくに" (CODE1 "setq") "によって値を変数に代入するときは、" (STRONG "var")
     "の初期値が指定した" (STRONG "typespec") "になるようにするのと" "同様の効果があります。" (CODE1 "type")
     "宣言は関数束縛には適用しません" "（" (CODE1 "ftype") "をご確認ください）。" EOL2 (CODE1 "symbol-macrolet")
     "によって定義されたシンボルの型宣言は、" (CODE1 "the") "式でそのシンボルの展開の周りを囲むことと同等です。"
     "しかし実際のシンボルの展開結果には影響を与えません。" EOL2 "型宣言の意味は、宣言のスコープ内にある" "各変数" (STRONG "var") "の参照を"
     (CODE1 "(the typespec var)") "に変更すること、" "またスコープ内の各変数へ代入される値" (STRONG "new-value")
     "を" (CODE1 "(the typespec new-value)") "に変更すること、" "そして宣言のスコープに入った時点で"
     (CODE1 "(the typespec var)") "を実行すること、" "という意味と同じです。" EOL2 "型宣言は、全ての宣言で有効です。"
     "型宣言の解釈については下記をご確認ください。" EOL2 "1. 宣言スコープ内で宣言された変数の参照が実行されたとき、"
     "その変数の値が指定した型と一致してないときの結果は未定義です。" EOL2 "2. 宣言スコープ内で宣言された変数が" (CODE1 "setq")
     "を実行したとき、" "その変数へ代入される新しい値が指定した型と" "一致していないときの結果は未定義です。" EOL2
     "3. 宣言スコープに入った時点で、宣言された変数の値が" "指定した型と一致していないときの結果は未定義です。" EOL2
     "4. 型宣言は、ただスコープ内の変数の参照のみに影響します。" EOL2 "もし同じ変数に型宣言がネストされていたときは、" "変数の値は宣言された複数の型の"
     "共通部分の型でなければなりません。" EOL2 "もしローカル宣言で" (CODE1 "type") "が動的変数に対して行われており、" "同じ変数のグローバルな"
     (CODE1 "proclamation") "もまた存在しているときは、" "ローカル宣言のスコープ内の変数の値は、"
     "宣言された2つの型の共通部分の型でなければなりません。" EOL2 (CODE1 "type") "宣言は、自由宣言と境界宣言のどちらでも行えます。" EOL2
     "シンボルは型の名前と宣言の名前を両方同時にはなれません。" "あるシンボルがクラスか、構造体か、コンディションか、あるいは型の名前であり、"
     "そのシンボルが宣言の名前として宣言されたときか、" "あるいはその反対であったときはエラーが発生します。" EOL2 (CODE1 "array")
     "の型宣言があるレキシカルスコープ内では、" "配列の要素への参照全ては表現された配列の要素の型を満たします" "（アップグレードされた配列の要素の型とは対称的に）。"
     "コンパイラーは" (CODE1 "array") "の型宣言があるスコープ内では" "各配列の要素へのアクセスを" (CODE1 "the")
     "フォームを適用したかのように" "囲まれたコードとして扱うことができます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun f (x y)" "  (declare (type fixnum x y))"
      "  (let ((z (+ x y)))" "    (declare (type fixnum z))" "    z)) =>  F"
      "(f 1 2) =>  3" ";; 前の定義Fは次の定義と同等です。" "(defun f (x y)" "  ;; この宣言はTYPE宣言の短縮フォームです。"
      "  (declare (fixnum x y))" "  ;; 返却値の型を宣言するときは名前付き変数を作成する必要はありません。"
      "  ;; かわりにTHE特殊フォームを使用できます。" "  (the fixnum (+ x y))) =>  F" "(f 1 2) =>  3"
      "(defvar *one-array* (make-array 10 :element-type '(signed-byte 5)))"
      "(defvar *another-array* (make-array 10 :element-type '(signed-byte 8)))" " "
      "(defun frob (an-array)" "  (declare (type (array (signed-byte 5) 1) an-array))"
      "  (setf (aref an-array 1) 31)" "  (setf (aref an-array 2) 127)"
      "  (setf (aref an-array 3) (* 2 (aref an-array 3)))" "  (let ((foo 0))"
      "    (declare (type (signed-byte 5) foo))" "    (setf foo (aref an-array 0))))" " "
      "(frob *one-array*)" "(frob *another-array*)")
     EOL2 "上記の" (CODE1 "frob") "の定義は下記と同等です。"
     (CODE3 "```lisp" "```" "(defun frob (an-array)"
      "  (setf (the (signed-byte 5) (aref an-array 1)) 31)"
      "  (setf (the (signed-byte 5) (aref an-array 2)) 127)"
      "  (setf (the (signed-byte 5) (aref an-array 3))"
      "        (* 2 (the (signed-byte 5) (aref an-array 3))))" "  (let ((foo 0))"
      "    (declare (type (signed-byte 5) foo))"
      "    (setf foo (the (signed-byte 5) (aref an-array 0)))))")
     EOL2 "ある実装では、" (CODE1 "fixnum") "が29-bitであり" "しかし" (CODE1 "fixnum")
     "の配列が符号付き32-bitへ格上げされるものであるとき、" "下記の例は全て" (CODE1 "fixnum") "で計算されるようにコンパイルされます。"
     (CODE3 "```lisp" "```" "(defun bump-counters (counters)"
      "  (declare (type (array fixnum *) bump-counters))"
      "  (dotimes (i (length counters))" "    (incf (aref counters i))))"))
    (CHAPTER ("## 参考") 2 (CODE1 "declare") "," (CODE1 "declaim") "," (CODE1 "proclaim"))
    (CHAPTER ("## 備考") 2 (CODE1 "(typespec var*)") "は、" (CODE1 "(type typespec var*)")
     "の省略形です。" EOL2 "関数の引数の" (CODE1 "type") "宣言は、" "結果の型について暗に何かを意味しているわけではありません。"
     "下記の関数は、コンパイルされる際に" "実装依存の" (CODE1 "fixnum") "のみでの演算を" "許可してはいません。"
     (CODE3 "```lisp" "```" "(defun f (x y) (declare (fixnum x y)) (+ x y))") EOL2
     "なぜかというと、" (CODE1 "(f most-positive-fixnum 1)") "を考えてみます。" "Common Lispは"
     (CODE1 "F") "の結果を、" "数学的に正しくない返却としてエラーを発生させるのではなく、" "ここでは" (CODE1 "bignum")
     "が返却するように定義します。" "もし" (CODE1 "fixnum") "のオーバーフローが生じないような特別な知識があるならば、" "返却値が"
     (CODE1 "fixnum") "の範囲であることを宣言することで、" "一部のコンパイラがより効率的な演算を行うようにすることができます。" "例えば下記の通り。"
     (CODE3 "```lisp" "```" "(defun f (x y)" "  (declare (fixnum x y))"
      "  (the fixnum (+ x y)))")
     EOL2 "しかし、注意点として3つの引数の場合は、" "暗黙的な中間値が非常に大きくなる可能性があるため、" "下記の例文は実装依存の"
     (CODE1 "fixnum") "のみの演算は" "実行されないかもしれません。"
     (CODE3 "```lisp" "```" "(defun f (x y)" "  (declare (fixnum x y z))"
      "  (the fixnum (+ x y z)))")
     EOL2 "なぜなら、" (CODE1 "(f most-positive-fixnum 1 -1)") "を考えてみましょう。" "引数とその結果は全て"
     (CODE1 "fixnum") "ですが、中間の値は" (CODE1 "fixnum") "ではありません。" "もし、その実装が提供する実装依存の"
     (CODE1 "fixnum") "のみの演算が重要なのであれば、" "かわりに次のような記載を考えてみて下さい。"
     (CODE3 "```lisp" "```" "(defun f (x y)" "  (declare (fixnum x y z))"
      "  (the fixnum (+ (the fixnum (+ x y)) z)))"))))
(setf (gethash '("TYPE" . "DECLARATION") *table*) (gethash "TYPE" *table*))
(setf (gethash "TYPE-ERROR" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "TYPE-ERROR"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "type-error") "," (CODE1 "error") ","
     (CODE1 "serious-condition") "," (CODE1 "condition") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "type-error") "は、オブジェクトが期待した型ではないという" "状況を表現しています。"
     "「問題のデータ」と「期待した型」が、" (CODE1 "make-condition") "の初期化引数によって" "それぞれ" (CODE1 ":datum")
     "と" (CODE1 ":expected-type") "で指定されて生成され、" (CODE1 "type-error-datum") "と"
     (CODE1 "type-error-expected-type") "という" "関数によってアクセスできます。")
    (CHAPTER ("## 参考") 2 (CODE1 "type-error-datum") ","
     (CODE1 "type-error-expected-type"))))
(setf (gethash '("TYPE-ERROR" . "CONDITION-TYPE") *table*) (gethash "TYPE-ERROR" *table*))
(setf (gethash "TYPE-ERROR-DATUM" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "TYPE-ERROR-DATUM") ", "
     (CODE1 "TYPE-ERROR-EXPECTED-TYPE"))
    (CHAPTER ("## 構文") 2 (CODE1 "type-error-datum") " " (STRONG "condition") " => "
     (STRONG "datum") EOL1 (CODE1 "type-error-expected-type") " " (STRONG "condition")
     " => " (STRONG "expected-type"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "condition") " - " (CODE1 "type-error") "型のコンディション"
     EOL1 (STRONG "datum") " - オブジェクト" EOL1 (STRONG "expected-type") " - 型指定子")
    (CHAPTER ("## 定義") 2 (CODE1 "type-error-datum") "は、" (STRONG "condition")
     "によって表現された状況の" "問題のデータを返却します。" EOL2 (CODE1 "type-error-expected-type") "は、"
     (STRONG "condition") "によって表現された状況の、" "問題のデータに対する期待した型を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun fix-digits (condition)"
      "  (check-type condition type-error)" "  (let* ((digits '(zero one two three four"
      "                  five six seven eight nine))"
      "        (val (position (type-error-datum condition) digits)))"
      "    (if (and val (subtypep 'fixnum (type-error-expected-type condition)))"
      "        (store-value 7))))" NIL "(defun foo (x)"
      "  (handler-bind ((type-error #'fix-digits))" "    (check-type x number)"
      "    (+ x 3)))" NIL "(foo 'seven)" "=>  10"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "type-error") "," "9. コンディション")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("TYPE-ERROR-DATUM" . "FUNCTION") *table*) (gethash "TYPE-ERROR-DATUM" *table*))
(setf (gethash "TYPE-ERROR-EXPECTED-TYPE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "TYPE-ERROR-DATUM") ", "
     (CODE1 "TYPE-ERROR-EXPECTED-TYPE"))
    (CHAPTER ("## 構文") 2 (CODE1 "type-error-datum") " " (STRONG "condition") " => "
     (STRONG "datum") EOL1 (CODE1 "type-error-expected-type") " " (STRONG "condition")
     " => " (STRONG "expected-type"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "condition") " - " (CODE1 "type-error") "型のコンディション"
     EOL1 (STRONG "datum") " - オブジェクト" EOL1 (STRONG "expected-type") " - 型指定子")
    (CHAPTER ("## 定義") 2 (CODE1 "type-error-datum") "は、" (STRONG "condition")
     "によって表現された状況の" "問題のデータを返却します。" EOL2 (CODE1 "type-error-expected-type") "は、"
     (STRONG "condition") "によって表現された状況の、" "問題のデータに対する期待した型を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun fix-digits (condition)"
      "  (check-type condition type-error)" "  (let* ((digits '(zero one two three four"
      "                  five six seven eight nine))"
      "        (val (position (type-error-datum condition) digits)))"
      "    (if (and val (subtypep 'fixnum (type-error-expected-type condition)))"
      "        (store-value 7))))" NIL "(defun foo (x)"
      "  (handler-bind ((type-error #'fix-digits))" "    (check-type x number)"
      "    (+ x 3)))" NIL "(foo 'seven)" "=>  10"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "type-error") "," "9. コンディション")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("TYPE-ERROR-EXPECTED-TYPE" . "FUNCTION") *table*) (gethash "TYPE-ERROR-EXPECTED-TYPE" *table*))
(setf (gethash "TYPE-OF" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "TYPE-OF"))
    (CHAPTER ("## 構文") 2 (CODE1 "type-of") " " (STRONG "object") " => "
     (STRONG "typespec"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "typespec")
     " - 型指定子")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が要素という立場で保有されている型の" "型指定子"
     (STRONG "typespec") "を返却します。" "返却値である" (STRONG "typespec") "は下記の条件を満たします。" EOL2
     "1. " (STRONG "object") "が組み込み型の要素であるとき" "  a. その組み込み型が認識可能なサブタイプであるならその型を返却"
     "  b. その型が" "     " (CODE1 "and") "," "     " (CODE1 "eql") "," "     "
     (CODE1 "member") "," "     " (CODE1 "not") "," "     " (CODE1 "or") "," "     "
     (CODE1 "satisfies") "," "     " (CODE1 "values") "," "     を含んでいないときは、その型自身を返却" EOL2
     "2. 全てのオブジェクト" (STRONG "object") "について、" (CODE1 "(typep object (type-of object))")
     "は" (STRONG "true") "を返却します。" "これは暗に、例えばリストフォームの" (CODE1 "function") "型指定子のように、"
     (CODE1 "typep") "で有効ではない型指定子は" (CODE1 "type-of") "から" "決して返却しないことを意味しています。" EOL2
     "3. " (CODE1 "type-of") "の返却値の型は、" "常に" (CODE1 "class-of") "による返却値のクラスの"
     "認識可能なサブタイプです。" "つまり、下記のようになります。"
     (CODE3 "```lisp" "```"
      "(subtypep (type-of object) (class-of object)) =>  true, true")
     EOL2 "4. メタクラスが" (CODE1 "structure-class") "," (CODE1 "standard-class") ","
     "またはコンディションの" (STRONG "object") "について、" (CODE1 "class-of")
     "によって返却されるクラスがが正しい名前を持つとき、" (CODE1 "type-of") "は、その名前を返却します。"
     "それ以外のときは、クラス自身が返却されます。" "特に、" (CODE1 ":type") "オプションなしで" (CODE1 "defstruct")
     "によって定義された" "構造体の構築関数で作られた" (STRONG "object") "は、" (CODE1 "type-of")
     "関数は構造体の名前を返却します。" "また、" (CODE1 "make-condition") "によって作られた" (STRONG "object") "は、"
     "返却値" (STRONG "typespec") "はコンディション型の名前です。" EOL2 "5. 次の型" (CODE1 "short-float") ", "
     (CODE1 "single-float") "," (CODE1 "double-float") ", " (CODE1 "long-float") "の"
     (STRONG "object") "の返却値" (STRONG "typespec") "は、" "その型の認識可能なサブタイプです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(type-of 'a) =>  SYMBOL          " "(type-of '(1 . 2))"
      "=>  CONS" "OR=>  (CONS FIXNUM FIXNUM)" "(type-of #c(0 1))" "=>  COMPLEX"
      "OR=>  (COMPLEX INTEGER)" "(defstruct temp-struct x y z) =>  TEMP-STRUCT"
      "(type-of (make-temp-struct)) =>  TEMP-STRUCT" "(type-of \"abc\")" "=>  STRING"
      "OR=>  (STRING 3)" "(subtypep (type-of \"abc\") 'string) =>  true, true"
      "(type-of (expt 2 40))" "=>  BIGNUM" "OR=>  INTEGER"
      "OR=>  (INTEGER 1099511627776 1099511627776)" "OR=>  SYSTEM::TWO-WORD-BIGNUM"
      "OR=>  FIXNUM" "(subtypep (type-of 112312) 'integer) =>  true, true"
      "(defvar *foo* (make-array 5 :element-type t)) =>  *FOO*"
      "(class-name (class-of *foo*)) =>  VECTOR" "(type-of *foo*)" "=>  VECTOR"
      "OR=>  (VECTOR T 5)"))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "array-element-type") "," (CODE1 "class-of") ","
     (CODE1 "defstruct") "," (CODE1 "typecase") "," (CODE1 "typep") "," "4.2. 型")
    (CHAPTER ("## 備考") 2 "実装は" (CODE1 "type-of") "が移植可能な値を返却するように" "改良することを勧められます。")))
(setf (gethash '("TYPE-OF" . "FUNCTION") *table*) (gethash "TYPE-OF" *table*))
(setf (gethash "TYPECASE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "TYPECASE") ", " (CODE1 "CTYPECASE") ", "
     (CODE1 "ETYPECASE"))
    (CHAPTER ("## 構文") 2 (CODE1 "typecase") " " (STRONG "keyform") " " (CODE1 "{")
     (STRONG "normal-clause") (CODE1 "}") "\\* [" (STRONG "otherwise-clause") "] => "
     (STRONG "result\\*") EOL1 (CODE1 "ctypecase") " " (STRONG "keyplace") " "
     (CODE1 "{") (STRONG "normal-clause") (CODE1 "}") "\\* => " (STRONG "result\\*") EOL1
     (CODE1 "etypecase") " " (STRONG "keyform") " " (CODE1 "{") (STRONG "normal-clause")
     (CODE1 "}") "\\* => " (STRONG "result\\*")
     (CODE3 "```" "```" "normal-clause ::= (type form*) "
      "otherwise-clause ::= ({otherwise | t} form*) "
      "clause ::= normal-clause | otherwise-clause "))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "keyform") " - フォーム。評価され" (STRONG "test-key")
     "を返却します。" EOL1 (STRONG "keyplace") " - フォーム。評価されて最初に" (STRONG "test-key") "を返却します。"
     EOL1 (STRONG "test-key") " - " (STRONG "keyform") "か" (STRONG "keyplace")
     "が評価されることによって返却されるオブジェクト。" EOL1 (STRONG "type") " - 型指定子" EOL1 (STRONG "form")
     " - 暗黙のprogn" EOL1 (STRONG "result") " - マッチした" (STRONG "clause") "の"
     (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 "これらのマクロは、" (STRONG "test-key") "の型のマッチによって選択された"
     (STRONG "clause") "内の" (STRONG "form") "のボディを条件付きで実行します。" EOL2 (STRONG "keyform")
     "と" (STRONG "keyplace") "が評価されて、" (STRONG "test-key") "が生成されます。" EOL2 "そのあと各"
     (STRONG "normal-clause") "が順番に考慮されます。" "もし" (STRONG "test-key") "が"
     (STRONG "clause") "のどれかの型と同じであれば、" "その" (STRONG "clause") "内の" (STRONG "form")
     "が暗黙のprognとして評価され、" (CODE1 "typecase") "、" (CODE1 "ctypecase") "、"
     (CODE1 "etypecase") "フォームの返却値として" "その多値が返却されます。" EOL2 "これらのマクロは、もし"
     (STRONG "normal-clause") "がマッチしなかったときにだけ、" "動作が違っています。" "違いを下記に示します。" EOL2 "- "
     (CODE1 "typecase") "  - もしマッチする" (STRONG "normal-clause") "が存在せず"
     (STRONG "otherwise-clause") "があるときは、" "    自動的に" (STRONG "otherwise-clause")
     "がマッチします。" "    その" (STRONG "clause") "にある" (STRONG "form") "は暗黙のprognとして評価され、"
     "    その" (STRONG "clause") "内の" (STRONG "form") "は暗黙のprognとして評価され、" "    "
     (CODE1 "typecase") "フォームの返却値としてその多値が返却されます。" "    <br><br>" "    もし"
     (STRONG "otherwise-clause") "がないときは、" "    " (CODE1 "typecase") "は" (CODE1 "nil")
     "を返却します。" "    <br><br>" EOL2 "- " (CODE1 "ctypecase") "  - もしマッチする"
     (STRONG "normal-clause") "が存在しないときは、" "    型" (CODE1 "type-error")
     "の修正可能なエラーが発生します。" "    問題の" (CODE1 "datum") "は" (STRONG "test-key") "であり、" "    "
     (CODE1 "expected type") "は" (CODE1 "(member key1 key2 ...)") "と同等の型です。" "    "
     (CODE1 "store-value") " " (CODE1 "restart") "をエラーの修正に使うことができます。" "    <br><br>"
     "    もし" (CODE1 "store-value") " " (CODE1 "restart") "が起動されたら、" "    その引数は新しい"
     (STRONG "test-key") "であり、" "    " (STRONG "keyplace") "への保存は"
     (CODE1 "(setf keyplace test-key)") "のように行われます。" "    それから" (CODE1 "ctypecase")
     "は最初から始められ、" "    各" (STRONG "clause") "が新しく評価されます。" "    <br><br>" "    もし"
     (CODE1 "store-value") " " (CODE1 "restart") "が対話形式で起動されたら、" "    ユーザーは新しい"
     (STRONG "test-key") "を使用できるような" "    プロンプトが表示されます。" "    <br><br>"
     "    いずれのケースも成立しない場合、" "    " (STRONG "keyplace") "のサブフォームは再度評価されるかもしれません。"
     "    <br><br>" EOL2 "- " (CODE1 "etypecase") "  - もしマッチする" (STRONG "normal-clause")
     "が存在しないときは、" "    型" (CODE1 "type-error") "の修正不可能なエラーが発生します。" "    問題の"
     (CODE1 "datum") "は" (STRONG "test-key") "であり、" "    " (CODE1 "expected type") "は"
     (CODE1 "(member key1 key2 ...)") "と同等の型です。" "    <br><br>" "    "
     (CODE1 "ctypecase") "とは対照的に" (CODE1 "etypecase") "の使用者は、" "    もし"
     (STRONG "normal-clause") "がマッチしなかったら" "    " (CODE1 "etypecase")
     "は戻ってこないという事実に頼っています。" "    <br><br>" EOL2 "3つの全ての場合において、" "指定した型にマッチする"
     (STRONG "clause") "が複数あっても許されます。" "特にその型が何かのサブタイプになっているような場合も同様です。"
     "そのような場合は、もっとも早い適切な" (STRONG "clause") "が選ばれます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";;; (この例で使われているTYPE-OFの部分は" ";;;  実装依存であることに注意して下さい)"
      "(defun what-is-it (x)" "  (format t \"~&~S is ~A.~%\"" "          x (typecase x"
      "              (float \"a float\")"
      "              (null \"a symbol, boolean false, or the empty list\")"
      "              (list \"a list\")"
      "              (t (format nil \"a(n) ~(~A~)\" (type-of x))))))" "=>  WHAT-IS-IT"
      "(map 'nil #'what-is-it '(nil (a b) 7.0 7 box))"
      ">>  NIL is a symbol, boolean false, or the empty list." ">>  (A B) is a list."
      ">>  7.0 is a float." ">>  7 is a(n) integer." ">>  BOX is a(n) symbol." "=>  NIL"
      "(setq x 1/3)" "=>  1/3" "(ctypecase x" "    (integer (* x 4))"
      "    (symbol  (symbol-value x)))"
      ">>  Error: The value of X, 1/3, is neither an integer nor a symbol."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Specify a value to use instead." ">>   2: Return to Lisp Toplevel."
      ">>  Debug> :CONTINUE 1" ">>  Use value: 3.7"
      ">>  Error: The value of X, 3.7, is neither an integer nor a symbol."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Specify a value to use instead." ">>   2: Return to Lisp Toplevel."
      ">>  Debug> :CONTINUE 1" ">>  Use value: 12" "=>  48" "x =>  12"))
    (CHAPTER ("## 影響") 2 (CODE1 "ctypecase") "と" (CODE1 "etypecase") "がエラーを通知したときは、"
     "既存の" (CODE1 "handler") "と" (CODE1 "*debug-io*") "に影響を及ぼす可能性があります。")
    (CHAPTER ("## 例外") 2 (STRONG "normal-clause") "にマッチしなかったときは、" (CODE1 "ccase") "と"
     (CODE1 "ecase") "は" "型" (CODE1 "type-error") "のエラーが発生します。" EOL2 "もしある"
     (STRONG "clause") "がそれより早い" (STRONG "clause") "によって完全にシャドウされ、"
     "決して選択されないような状況であったとき、" "コンパイラーは、型" (CODE1 "style-warning") "の警告を出すかどうか"
     "選択することができます。")
    (CHAPTER ("## 参考") 2 (CODE1 "case") "," (CODE1 "cond") "," (CODE1 "setf") ","
     "5.1. 一般化された参照")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(typecase test-key" "  {(type form*)}*)" "== "
      "(let ((#1=#:g0001 test-key))" "  (cond {((typep #1# 'type) form*)}*))")
     EOL2 (CODE1 "etypecase") "と" (CODE1 "ctypecase") "によって使われる特定のエラーメッセージは、"
     "実装によって変わります。" "そんな中で、エラーメッセージの特定の単語の制御が必要なときは、" (CODE1 "typecase") "の"
     (STRONG "otherwise-clause") "で" "明示的に適切なエラーメッセージを発生させるのが良いでしょう。")))
(setf (gethash '("TYPECASE" . "MACRO") *table*) (gethash "TYPECASE" *table*))
(setf (gethash "TYPEP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "TYPEP"))
    (CHAPTER ("## 構文") 2 (CODE1 "typep") " " (STRONG "object") " "
     (STRONG "type-specifier") " " (CODE1 "&optional") " " (STRONG "environment") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "type-specifier")
     " - 型指定子ですが、 " (CODE1 "values") "と" "最初の要素が" (CODE1 "function") "か" (CODE1 "values")
     "の" "リストは除きます。" EOL1 (STRONG "environment") " - 環境オブジェクト。" "デフォルトは" (CODE1 "nil")
     "であり、" "これは" (CODE1 "null") "のレキシカルな環境の現在のグローバルな環境を示します。" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "もし" (STRONG "object") "が" (STRONG "type-specifier")
     "によって指定された型のときは" (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。" EOL2
     (STRONG "type-specifier") "が" (CODE1 "(satisfies fn)") "フォームのときは、" "関数" (CODE1 "fn")
     "を" (STRONG "object") "で適用することで返却します。" EOL2 "式"
     (CODE1 "(typep object '(array type-specifier))") "の" (STRONG "type-specifier") "が"
     (CODE1 "*") "ではないときは、" (STRONG "object") "が" (CODE1 "make-array") "関数の"
     (CODE1 ":element-type") "の引数に" (STRONG "type-specifier") "が指定されて" "生成された配列であるときに"
     (STRONG "true") "を返却します。" (CODE1 "(array *)") "は要素の型に関係せず全ての配列を意味し、"
     (CODE1 "(array type-specifier)") "はただ" (CODE1 "make-array") "関数の"
     (CODE1 ":element-type") "の引数に" (STRONG "type-specifier") "が指定されて" "生成された配列のみを意味します。"
     "似たような解釈として、" (CODE1 "(simple-array type-specifier)") "と"
     (CODE1 "(vector type-specifier)") "にも" "適用されます。" "詳しくは15.1.2.1. 配列のアップグレードをご確認ください。"
     EOL2 "式" (CODE1 "(typep object '(complex type-specifier)") "は、" (CODE1 "complex")
     "関数に" (STRONG "type-specifier") "型の数を与えた返却値による複素数か、" "加えて同じ" (CODE1 "specialized")
     "の表現の数を持った" "複素数のときに" (STRONG "true") "を返却します。"
     "そのような複素数は、実部と虚部の両方で次の式が満たされなければなりません。"
     (CODE3 "```lisp" "```" "(typep realpart 'type-specifier)"
      "(typep imagpart 'type-specifier)")
     EOL2 (CODE1 "upgraded-complex-part-type") "関数をご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(typep 12 'integer) =>  true"
      "(typep (1+ most-positive-fixnum) 'fixnum) =>  false" "(typep nil t) =>  true"
      "(typep nil nil) =>  false" "(typep 1 '(mod 2)) =>  true"
      "(typep #c(1 1) '(complex (eql 1))) =>  true")
     EOL2 "次の例を理解するには12.1.5.3. " (CODE1 "rational") "型の複素数の標準的な表現のルールを参照してください。"
     (CODE3 "```lisp" "```" NIL "(typep #c(0 0) '(complex (eql 0))) =>  false") EOL2
     (CODE1 "Ax") "と" (CODE1 "Ay") "の2つの型指定子は違う型ですが、"
     (CODE3 "```lisp" "```" "(upgraded-array-element-type 'Ax)") EOL2 "と"
     (CODE3 "```lisp" "```" "(upgraded-array-element-type 'Ay)") EOL2
     "はどちらも同じ型を示しているものとします。" "このとき、下記のようになることに注意してください。"
     (CODE3 "```lisp" "```"
      "(typep (make-array 0 :element-type 'Ax) '(array Ax)) =>  true"
      "(typep (make-array 0 :element-type 'Ay) '(array Ay)) =>  true"
      "(typep (make-array 0 :element-type 'Ax) '(array Ay)) =>  true"
      "(typep (make-array 0 :element-type 'Ay) '(array Ax)) =>  true"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "type-specifier") "が" (CODE1 "values") "か、"
     "あるいは最初の要素が" (CODE1 "function") "か" (CODE1 "values") "のリストのときは、" "型" (CODE1 "error")
     "のエラーが発生します。" EOL2 (STRONG "type-specifier") "が型指定子ではないときの結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "type-of") "," (CODE1 "upgraded-array-element-type") ","
     (CODE1 "upgraded-complex-part-type") "," "4.2.3. 型指定子")
    (CHAPTER ("## 備考") 2 "実装は、" (CODE1 "(typep x (the class y))") "のような式の場合は、" "実行時に"
     (CODE1 "deftype") "による展開の実行が必要無いように" "最適化を行うよう推奨されます。")))
(setf (gethash '("TYPEP" . "FUNCTION") *table*) (gethash "TYPEP" *table*))
(setf (gethash "UNBOUND-SLOT" *table*)
  '((CHAPTER NIL 0 "Contition Type " (CODE1 "UNBOUND-SLOT"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "unbound-slot") "," (CODE1 "cell-error") ","
     (CODE1 "error") "," (CODE1 "serious-condition") "," (CODE1 "condition") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 (CODE1 "make-condition") "の初期化引数である" (CODE1 ":instance") "が、"
     (CODE1 "unbound") "スロットを持つオブジェクトに初期化されます。" "このスロットは、"
     (CODE1 "unbound-slot-instance") "関数によってアクセスできます。" EOL2 (CODE1 "cell") "の名前（"
     (CODE1 "cell-error") "を参照）は、スロットの名前です。")
    (CHAPTER ("## 参考") 2 (CODE1 "cell-error-name") "," "9.1. コンディションシステムの説明")))
(setf (gethash '("UNBOUND-SLOT" . "CONDITION-TYPE") *table*) (gethash "UNBOUND-SLOT" *table*))
(setf (gethash "UNBOUND-SLOT-INSTANCE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "UNBOUND-SLOT-INSTANCE"))
    (CHAPTER ("## 構文") 2 (CODE1 "unbound-slot-instance") " " (STRONG "condition") " => "
     (STRONG "instance"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "condition") " - " (CODE1 "unbound-slot")
     "型のコンディション" EOL1 (STRONG "instance") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "condition") "によって表現される状況においての" (CODE1 "unbound")
     "スロットを持つインスタンスを返却します。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "cell-error-name") "," (CODE1 "unbound-slot") ","
     "9.1. コンディションシステムの説明")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("UNBOUND-SLOT-INSTANCE" . "FUNCTION") *table*) (gethash "UNBOUND-SLOT-INSTANCE" *table*))
(setf (gethash "UNBOUND-VARIABLE" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "UNBOUND-VARIABLE"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "unbound-variable") "," (CODE1 "cell-error") ","
     (CODE1 "error") "," (CODE1 "serious-condition") "," (CODE1 "condition") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "unbound-variable") "は、" (CODE1 "unbound")
     "の変数から値を読み込もうとしたときの" "エラーコンディションを表します。" EOL2 "セルの名前（" (CODE1 "cell-error") "を参照）は、"
     (CODE1 "unbound") "であった変数名です。")
    (CHAPTER ("## 参考") 2 (CODE1 "cell-error-name"))))
(setf (gethash '("UNBOUND-VARIABLE" . "CONDITION-TYPE") *table*) (gethash "UNBOUND-VARIABLE" *table*))
(setf (gethash "UNDEFINED-FUNCTION" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "UNDEFINED-FUNCTION"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "undefined-function") "," (CODE1 "cell-error")
     "," (CODE1 "error") "," (CODE1 "serious-condition") "," (CODE1 "condition") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "undefined-function") "は、"
     "定義されていない関数への読み込みを実施しようとしたときを表現する" "エラーの状態で構成されています。" EOL2 "セルの名前（"
     (CODE1 "cell-error") "を参照）は" (CODE1 "funbound") "の関数名です。")
    (CHAPTER ("## 参考") 2 (CODE1 "cell-error-name"))))
(setf (gethash '("UNDEFINED-FUNCTION" . "CONDITION-TYPE") *table*) (gethash "UNDEFINED-FUNCTION" *table*))
(setf (gethash "UNEXPORT" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "UNEXPORT"))
    (CHAPTER ("## 構文") 2 (CODE1 "unexport") " " (STRONG "symbols") " "
     (CODE1 "&optional") " " (STRONG "package") " => " (CODE1 "t"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbols") " - シンボルのリストの指定子" EOL1 (STRONG "package")
     " - パッケージ指定子。デフォルトは現在のパッケージ。")
    (CHAPTER ("## 定義") 2 (CODE1 "unexport") "は、" (STRONG "package") "の外部シンボルを内部状態に戻します。"
     "それは" (CODE1 "export") "の効果を取り消します。" EOL2 (CODE1 "unexport") "は、" (STRONG "package")
     "に現れるシンボルのみに動作し、" "それらを内部状態へと戻します。" "もし" (CODE1 "unexport") "に与えられたシンボルが" "すでに"
     (STRONG "package") "の内部シンボルとしてアクセス可能であれば、" "何もしません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(in-package \"COMMON-LISP-USER\") =>  #<PACKAGE \"COMMON-LISP-USER\">"
      "(export (intern \"CONTRABAND\" (make-package 'temp)) 'temp) =>  T"
      "(find-symbol \"CONTRABAND\") =>  NIL, NIL " "(use-package 'temp) =>  T "
      "(find-symbol \"CONTRABAND\") =>  CONTRABAND, :INHERITED"
      "(unexport 'contraband 'temp) =>  T" "(find-symbol \"CONTRABAND\") =>  NIL, NIL"))
    (CHAPTER ("## 副作用") 2 "パッケージシステムは修正されます。") (CHAPTER ("## 影響") 2 "パッケージシステムの現在の状態。")
    (CHAPTER ("## 例外") 2 (CODE1 "unexport") "に与えられたシンボルが" (STRONG "package")
     "で全くアクセスできないものであったら、" "型" (CODE1 "package-error") "のエラーが発生します。" EOL2
     (STRONG "package") "が" (CODE1 "KEYWORD") "パッケージか、" (CODE1 "COMMON-LISP")
     "パッケージのときの結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "export") "," "11.1. パッケージの説明")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("UNEXPORT" . "FUNCTION") *table*) (gethash "UNEXPORT" *table*))
(setf (gethash "UNINTERN" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "UNINTERN"))
    (CHAPTER ("## 構文") 2 (CODE1 "unintern") " " (STRONG "symbol") " " (CODE1 "&optional")
     " " (STRONG "package") " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "symbol") " - シンボル" EOL1 (STRONG "package")
     " - パッケージ指定子。デフォルトは現在のパッケージ。" EOL1 (STRONG "generalized-boolean")
     " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "unintern") "は、" (STRONG "package") "から"
     (STRONG "symbol") "を取り除きます。" "もし" (STRONG "symbol") "が" (STRONG "package")
     "に存在するとき、" "それは" (STRONG "package") "から取り除かれ、" (STRONG "package") "の"
     (CODE1 "shadowing") "シンボルリストに存在するなら" "それも削除されます。" "もし" (STRONG "package") "が"
     (STRONG "symbol") "のホームパッケージであったときは、" (STRONG "symbol") "はホームパッケージを持たない状態になります。"
     (STRONG "symbol") "は継承によって" (STRONG "package") "からアクセスし続けることができるかもしれません。" EOL2
     (CODE1 "unintern") "の使用すると、" "シンボルが記録されているホームパッケージを持たなくなりますが、"
     "しかし実際にはいくつかのパッケージからはアクセスできます。" "Common Lispはこのような病的なケースをチェックしないので、" "そのようなシンボルは常に"
     (CODE1 "#:") "が先頭に印刷されます。" EOL2 "もし" (STRONG "symbol") "が取り除かれたら" (CODE1 "unintern")
     "は" (STRONG "true") "を返却し、" "それ以外の場合は" (CODE1 "nil") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(in-package \"COMMON-LISP-USER\") =>  #<PACKAGE \"COMMON-LISP-USER\">"
      "(setq temps-unpack (intern \"UNPACK\" (make-package 'temp))) =>  TEMP::UNPACK "
      "(unintern temps-unpack 'temp) =>  T"
      "(find-symbol \"UNPACK\" 'temp) =>  NIL, NIL " "temps-unpack =>  #:UNPACK "))
    (CHAPTER ("## 副作用") 2 (CODE1 "unintern") "は、パッケージの一貫したルールが" "その変更によって保持されないような方法で、"
     "パッケージシステムの状態を変更します。")
    (CHAPTER ("## 影響") 2 "パッケージシステムの現在の状態。")
    (CHAPTER ("## 例外") 2 (CODE1 "unintern") "に" (CODE1 "shadowing") "シンボルが与えられたとき、" "以前"
     (CODE1 "shadowing") "によって解決していた名前の衝突が出てきます。" "もしパッケージ" (CODE1 "A") "が、パッケージ"
     (CODE1 "B") "と" (CODE1 "C") "を" (CODE1 "use") "しており、" (CODE1 "A") "には"
     (CODE1 "shadowing") "シンボル" (CODE1 "x") "が、" (CODE1 "B") "と" (CODE1 "C")
     "にはそれぞれ外部シンボル" (CODE1 "x") "があるとき、" (CODE1 "A") "から" (CODE1 "shadowing") "シンボル"
     (CODE1 "x") "を取り除くような状況で、" "もし" (CODE1 "b:x") "と" (CODE1 "c:x") "がそれぞれ別物であるときには"
     "名前の衝突が表に出てきます。" "このような状況では、" (CODE1 "unintern") "はエラーが発生します。")
    (CHAPTER ("## 参考") 2 "11.1. パッケージの説明") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("UNINTERN" . "FUNCTION") *table*) (gethash "UNINTERN" *table*))
(setf (gethash "UNION" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "UNION") ", " (CODE1 "NUNION"))
    (CHAPTER ("## 構文") 2 (CODE1 "union") " " (STRONG "list-1") " " (STRONG "list-2")
     " &key " (STRONG "key") " " (STRONG "test") " " (STRONG "test-not") " => "
     (STRONG "result-list") EOL1 (CODE1 "nunion") " " (STRONG "list-1") " "
     (STRONG "list-2") " &key " (STRONG "key") " " (STRONG "test") " "
     (STRONG "test-not") " => " (STRONG "result-list"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list-1") " - 通常のリスト" EOL1 (STRONG "list-2")
     " - 通常のリスト" EOL1 (STRONG "test") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1
     (STRONG "test-not") " - 2つの引数を取りgeneralized-booleanを返却する関数の指定子" EOL1 (STRONG "key")
     " - 1つの引数を取りgeneralized-booleanを返却する関数の指定子、" "または" (CODE1 "nil") EOL1
     (STRONG "result-list") " - リスト")
    (CHAPTER ("## 定義") 2 (CODE1 "union") "と" (CODE1 "nunion") "は、" (STRONG "list-1") "か"
     (STRONG "list-2") "のどちらかに生じたすべての要素を含むリストを返却します。" EOL2 (STRONG "list-1") "のひとつの要素と、"
     (STRONG "list-2") "のひとつの要素からなる、" "全ての順序付けされたペアに対して、" (CODE1 ":test") "か"
     (CODE1 ":test-not") "を使ってテストが満たされるかどうかを決定します。" (CODE1 ":test") "か"
     (CODE1 ":test-not") "の関数の最初の要素は" (STRONG "list-1") "の要素であり、" (CODE1 ":key")
     "関数によって返却されたものです（もし" (CODE1 ":key") "が指定されたなら）。" "二番目の引数は" (STRONG "list-2")
     "の要素であり、" (CODE1 ":key") "関数によって返却されたものです（もし" (CODE1 ":key") "が指定されたなら）。" EOL2
     (CODE1 ":key") "関数の引数は、" (STRONG "list-1") "か" (STRONG "list-2") "の要素です。"
     "返却値は、引数で与えられたリスト要素からなる、" "判定に使われる要素の部分です。" "もし" (CODE1 ":key") "が与えられないか、あるいは"
     (CODE1 "nil") "が指定されたとき、" (STRONG "list-1") "と" (STRONG "list-2") "の要素自身がが使われ、"
     (CODE1 ":test") "か" (CODE1 ":test-not") "関数に供給されます。" EOL2 "全てのマッチしたペアに対して、"
     "そのペアの2つの要素のうちのひとつが結果に含まれます。" (STRONG "list-1") "か" (STRONG "list-2") "のどちらかの要素が、"
     "もう一方の要素にマッチしないものがあれば、それが結果に含まれます。" EOL2 (STRONG "list-1") "と" (STRONG "list-2")
     "に重複があるとき、" "重複している要素のうちひとつだけが結果に含まれます。" (STRONG "list-1") "か" (STRONG "list-2")
     "のどちらかの中に重複するものがあるときは、" "その冗長な要素は結果に現れるかもしれませんし、" "現れないかもしれません。" EOL2 "結果の要素の順番は、"
     (STRONG "list-1") "と" (STRONG "list-2") "の順番を反映する必要はありません。" "適切に評価されたのであれば、"
     (STRONG "list-1") "と" (STRONG "list-2") "は、" "結果のリストに対して" (CODE1 "eq")
     "で一致するかもしれません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(union '(a b c) '(f a d))" "=>  (A B C F D)"
      "OR=>  (B C F A D)" "OR=>  (D F A B C)"
      "(union '((x 5) (y 6)) '((z 2) (x 4)) :key #'car)" "=>  ((X 5) (Y 6) (Z 2))"
      "OR=>  ((X 4) (Y 6) (Z 2))" NIL "(setq lst1 (list 1 2 '(1 2) \"a\" \"b\")"
      "      lst2 (list 2 3 '(2 3) \"B\" \"C\"))" "=>  (2 3 (2 3) \"B\" \"C\")"
      "(nunion lst1 lst2)" "=>  (1 (1 2) \"a\" \"b\" 2 3 (2 3) \"B\" \"C\") "
      "OR=>  (1 2 (1 2) \"a\" \"b\" \"C\" \"B\" (2 3) 3)"))
    (CHAPTER ("## 副作用") 2 (CODE1 "nunion") "は、" (STRONG "list-1") "か" (STRONG "list-2")
     "のリスト構造の" (CODE1 "car") ", " (CODE1 "cdr") "の" "どの部分も修正することが許されています。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "list-1") "と" (STRONG "list-2") "が通常のリストではないとき、" "型"
     (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。")
    (CHAPTER ("## 参考") 2 (CODE1 "intersection") "," "3.2.1. コンパイラーの用語," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 (CODE1 ":test-not") "パラメーターは非推奨です。" EOL2 (CODE1 "nunion")
     "の副作用は必要ないため、" "移植可能なコードにおいては副作用のみを期待した姿勢で使うべきではありません。")))
(setf (gethash '("UNION" . "FUNCTION") *table*) (gethash "UNION" *table*))
(setf (gethash "UNLESS" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "WHEN") ", " (CODE1 "UNLESS"))
    (CHAPTER ("## 構文") 2 (CODE1 "when") " " (STRONG "test-form") " " (STRONG "form\\*")
     " => " (STRONG "result\\*") EOL1 (CODE1 "unless") " " (STRONG "test-form") " "
     (STRONG "form\\*") " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "test-form") " - フォーム" EOL1 (STRONG "form")
     " - 暗黙のprogn" EOL1 (STRONG "result") " - " (STRONG "test-form") "が" (STRONG "true")
     "のときは" (CODE1 "when") "フォーム内の" (STRONG "form") "の多値。" (STRONG "test-form") "が"
     (STRONG "false") "のときは" (CODE1 "unless") "フォーム内の" (STRONG "form") "の多値。" "それ以外は"
     (CODE1 "nil") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "when") "と" (CODE1 "unless") "は、" (STRONG "test-form")
     "単体に依存したフォームの実行を行います。" EOL2 (CODE1 "when") "のフォーム内において、" (STRONG "test-form") "が"
     (STRONG "true") "のときは、" (STRONG "form") "が左から右の順番で評価され、" "その" (STRONG "form") "の多値が"
     (CODE1 "when") "フォームからの返却値になります。" "一方、" (STRONG "test-form") "が" (STRONG "false")
     "のときは、" (STRONG "form") "は評価されず" (CODE1 "when") "フォームは" (CODE1 "nil") "を返却します。" EOL2
     (CODE1 "unless") "のフォーム内において、" (STRONG "test-form") "が" (STRONG "false") "のときは、"
     (STRONG "form") "が左から右の順番で評価され、" "その" (STRONG "form") "の多値が" (CODE1 "unless")
     "フォームからの返却値になります。" "一方、" (STRONG "test-form") "が" (STRONG "true") "のときは、"
     (STRONG "form") "は評価されず" (CODE1 "unless") "フォームは" (CODE1 "nil") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(when t 'hello) =>  HELLO" "(unless t 'hello) =>  NIL"
      "(when nil 'hello) =>  NIL" "(unless nil 'hello) =>  HELLO" "(when t) =>  NIL"
      "(unless nil) =>  NIL" "(when t (prin1 1) (prin1 2) (prin1 3))" ">>  123" "=>  3"
      "(unless t (prin1 1) (prin1 2) (prin1 3)) =>  NIL"
      "(when nil (prin1 1) (prin1 2) (prin1 3)) =>  NIL"
      "(unless nil (prin1 1) (prin1 2) (prin1 3))" ">>  123" "=>  3" "(let ((x 3))"
      "  (list (when (oddp x) (incf x) (list x))"
      "        (when (oddp x) (incf x) (list x))"
      "        (unless (oddp x) (incf x) (list x))"
      "        (unless (oddp x) (incf x) (list x))"
      "        (if (oddp x) (incf x) (list x)) "
      "        (if (oddp x) (incf x) (list x)) "
      "        (if (not (oddp x)) (incf x) (list x)) "
      "        (if (not (oddp x)) (incf x) (list x))))"
      "=>  ((4) NIL (5) NIL 6 (6) 7 (7))"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "and") "," (CODE1 "cond") "," (CODE1 "if") ","
     (CODE1 "or"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(when test {form}+) == (and test (progn {form}+))"
      "(when test {form}+) == (cond (test {form}+))"
      "(when test {form}+) == (if test (progn {form}+) nil)"
      "(when test {form}+) == (unless (not test) {form}+)"
      "(unless test {form}+) == (cond ((not test) {form}+))"
      "(unless test {form}+) == (if test nil (progn {form}+))"
      "(unless test {form}+) == (when (not test) {form}+)"))))
(setf (gethash '("UNLESS" . "MACRO") *table*) (gethash "UNLESS" *table*))
(setf (gethash "UNREAD-CHAR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "UNREAD-CHAR"))
    (CHAPTER ("## 構文") 2 (CODE1 "unread-char") " " (STRONG "character") " "
     (CODE1 "&optional") " " (STRONG "input-stream") " => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " - 文字。" (STRONG "input-stream")
     "から読み込んだ最後の文字でなければなりません。" EOL1 (STRONG "input-stream") " - 入力ストリーム指定子。デフォルトは標準入力。")
    (CHAPTER ("## 定義") 2 (CODE1 "unread-char") "は、" (STRONG "character") "を"
     (STRONG "input-stream") "の前に戻し、" "ふたたび" (STRONG "input-stream") "の次の文字になるようにします。"
     EOL2 (STRONG "input-stream") "が" (CODE1 "echo") "ストリームのとき、" (STRONG "input-stream")
     "上ですでに実施された文字のエコーの取り消しは行いません。" "しかし" (CODE1 "unread-char") "による"
     (STRONG "input-stream") "上で置き換えられた文字は、" "あとで" (CODE1 "read-char")
     "によって再びエコーされ内容にするために" "印がつけられます。" EOL2 "同じストリームに対して" (CODE1 "unread-char") "を二度続けて、"
     (CODE1 "read-char") "（または暗黙的に文字の読み込みを行う他の入力操作）を" "介入させることなく実行したときはエラーです。" EOL2
     (CODE1 "peek-char") "か" (CODE1 "read-char") "の呼び出しは、前の文字を渡します。" (CODE1 "peek-char")
     "によって返却されたものの前のどんな文字について" (CODE1 "unread-char") "を実行した結果は指定されていません" "（"
     (CODE1 "peek-char") "の" (STRONG "peek-type") "が" (CODE1 "nil") "では"
     "なかったときに渡された場合を含む）。" "とくに、" (CODE1 "peek-char") "のあとの" (CODE1 "unread-char") "の"
     "呼び出しの結果は指定されていません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-input-from-string (is \"0123\")" "   (dotimes (i 6)"
      "     (let ((c (read-char is)))"
      "       (if (evenp i) (format t \"~&~S ~S~%\" i c) (unread-char c is)))))"
      ">>  0 #\\0" ">>  2 #\\1" ">>  4 #\\2" "=>  NIL"))
    (CHAPTER ("## 影響") 2 (CODE1 "*standard-input*") "," (CODE1 "*terminal-io*"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "peek-char") "," (CODE1 "read-char") ","
     "21.1. ストリームの説明")
    (CHAPTER ("## 備考") 2 (CODE1 "unread-char") "は、" "Lispリーダーやその他の構文解析を実行するときに"
     (STRONG "input-stream") "からひとつの文字を先読みできるような" "効率的な仕組みの提供を目的としています。")))
(setf (gethash '("UNREAD-CHAR" . "FUNCTION") *table*) (gethash "UNREAD-CHAR" *table*))
(setf (gethash "UNUSE-PACKAGE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "UNUSE-PACKAGE"))
    (CHAPTER ("## 構文") 2 (CODE1 "unuse-package") " " (STRONG "packages-to-unuse") " "
     (CODE1 "&optional") " " (STRONG "package") " => " (CODE1 "t"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "packages-to-unuse") " - パッケージ指定子のリストの指定子" EOL1
     (STRONG "package") " - パッケージ指定子。デフォルトは現在のパッケージ")
    (CHAPTER ("## 定義") 2 (CODE1 "unuse-package") "は、" (STRONG "package") "に対して、"
     (STRONG "packages-to-unuse") "の全ての外部シンボルの継承をやめます。" (CODE1 "unuse-package") "は、"
     (CODE1 "use-package") "の効果を取り消します。" (STRONG "packages-to-unuse") "は、"
     (STRONG "package") "の" (CODE1 "use") "リストから取り除かれます。" EOL2 (STRONG "package") "内部に"
     (CODE1 "import") "されているどんなシンボルも" (STRONG "package") "内に存在し続けます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(in-package \"COMMON-LISP-USER\") =>  #<PACKAGE \"COMMON-LISP-USER\">"
      "(export (intern \"SHOES\" (make-package 'temp)) 'temp) =>  T"
      "(find-symbol \"SHOES\") =>  NIL, NIL" "(use-package 'temp) =>  T"
      "(find-symbol \"SHOES\") =>  SHOES, :INHERITED"
      "(find (find-package 'temp) (package-use-list 'common-lisp-user)) =>  #<PACKAGE \"TEMP\">"
      "(unuse-package 'temp) =>  T" "(find-symbol \"SHOES\") =>  NIL, NIL"))
    (CHAPTER ("## 副作用") 2 (STRONG "package") "の" (CODE1 "use") "リストが修正されます。")
    (CHAPTER ("## 影響") 2 "パッケージシステムの現在の状態。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "use-package") "," (CODE1 "package-use-list"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("UNUSE-PACKAGE" . "FUNCTION") *table*) (gethash "UNUSE-PACKAGE" *table*))
(setf (gethash "UNWIND-PROTECT" *table*)
  '((CHAPTER NIL 0 "Special Operator " (CODE1 "UNWIND-PROTECT"))
    (CHAPTER ("## 構文") 2 (CODE1 "unwind-protect") " " (STRONG "protected-form") " "
     (STRONG "cleanup-form\\* => ") "result\\*")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "protected-form") " - フォーム" EOL1
     (STRONG "cleanup-form") " - フォーム" EOL1 (STRONG "result") " - "
     (STRONG "protected-form") "の返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "unwind-protect") "は、" (STRONG "protected-form") "を評価し、"
     (CODE1 "unwind-protect") "を退出したあとで" "それが通常の終了か、何かの種類の制御遷移による中断かに関わらず、"
     (STRONG "cleanup-form") "を実行することを保証します。" (CODE1 "unwind-protect") "は、"
     (STRONG "protected-form") "評価後に" "確実に特定の副作用を実行することを意図しています。" EOL2 "もし非ローカル退出が"
     (STRONG "cleanup-form") "実行中にで生じたときは、" "何の特殊なアクションも行いません。" (CODE1 "unwind-protect")
     "の" (STRONG "cleanup-form") "は、" (CODE1 "unwind-protect") "によって保護されているわけではありません。"
     EOL2 (CODE1 "unwind-protect") "は、" (STRONG "protected-form") "から"
     "全ての退出の実行に対して保護されます。" "退出は、" (CODE1 "go") "、" (CODE1 "ignore-errors") "、"
     (CODE1 "restart-case") "、" (CODE1 "return-from") "、" (CODE1 "throw") "、"
     (CODE1 "with-simple-restart") "が含まれます。" EOL2 "退出による" (CODE1 "handler") "と"
     (CODE1 "restart") "の束縛の解除は、" "動的変数と" (CODE1 "catch") "タグの束縛の解除と並行して、"
     "それらの確立とは逆順に行われます。" "この効果は、" (CODE1 "unwind-protect") "に入ったときに、"
     (STRONG "cleanup-form") "を" (CODE1 "handler") "と" (CODE1 "restart") "の束縛や"
     "動的変数の束縛および" (CODE1 "catch") "タグと" "同じように見ることができるというものです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(tagbody" "  (let ((x 3))" "    (unwind-protect"
      "      (if (numberp x) (go out))" "      (print x)))" " out" "  ...)")
     EOL2 (CODE1 "go") "が実行されたとき、" "最初に" (CODE1 "print") "が実行され、" "そのあとにタグ" (CODE1 "out")
     "の制御の遷移が完了します。"
     (CODE3 "```lisp" "```" "(defun dummy-function (x)" "   (setq state 'running)"
      "   (unless (numberp x) (throw 'abort 'not-a-number))"
      "   (setq state (1+ x))) =>  DUMMY-FUNCTION"
      "(catch 'abort (dummy-function 1)) =>  2" "state =>  2"
      "(catch 'abort (dummy-function 'trash)) =>  NOT-A-NUMBER" "state =>  RUNNING"
      "(catch 'abort (unwind-protect (dummy-function 'trash) "
      "                 (setq state 'aborted))) =>  NOT-A-NUMBER" "state =>  ABORTED")
     EOL2 "下記のコードは正しくありません。"
     (CODE3 "```lisp" "```" "(unwind-protect" "  (progn (incf *access-count*)"
      "         (perform-access))" "  (decf *access-count*))")
     EOL2 "もし" (CODE1 "incf") "完了前に退出が生じたとき、" (CODE1 "decf") "フォームはやはり実行されるので、" "その結果"
     (CODE1 "*access-count*") "は正しくない値になります。"
     (CODE3 "```lisp" "```" "(let ((old-count *access-count*))" "  (unwind-protect"
      "    (progn (incf *access-count*)" "           (perform-access))"
      "    (setq *access-count* old-count)))" ";;; 下記は2が返却されます。" "(block nil   "
      "  (unwind-protect (return 1)" "    (return 2)))" " " ";;; 下記は未定義です。"
      "(block a    " "  (block b" "    (unwind-protect (return-from a 1)"
      "      (return-from b 2))))" " " ";;; 下記は2が返却されます。" "(catch nil "
      "  (unwind-protect (throw nil 1)" "    (throw nil 2)))" NIL ";;;"
      ";;;  下記の例ではBのcatchの上を最初のTHROWによって通過しているため" ";;;  結果は未定義であり、したがって移植可能なプログラムは"
      ";;;  動的エクステントが終了していると仮定してください。" ";;;  catchタグの束縛はまだ解除されていないので、"
      ";;;  これは2番目のthrowのターゲットです。" "(catch 'a" "  (catch 'b"
      "    (unwind-protect (throw 'a 1)" "      (throw 'b 2))))" NIL ";;;"
      ";;; 下記の例は \"The inner catch returns :SECOND-THROW\" が出力され、"
      ";;; :OUTER-CATCHが返却されます。" "(catch 'foo"
      "        (format t \"The inner catch returns ~s.~%\"" "                (catch 'foo"
      "                    (unwind-protect (throw 'foo :first-throw)"
      "                        (throw 'foo :second-throw))))" "        :outer-catch)" NIL
      " " ";;; 下記の例は10が返却されます。内側のAのCATCHは素通りされますが"
      ";;; なぜならそのAのCATCHはAへのTHROW実行前に解除されるため" ";;; 見ることができません。" "(catch 'a" "  (catch 'b"
      "    (unwind-protect (1+ (catch 'a (throw 'b 1)))" "      (throw 'a 10))))" NIL " "
      ";;; 下記の例は未定義です。なぜなら(THROW 'FOO ...)が開始されたとき"
      ";;; (CATCH 'BAR ...)の退出の範囲は終わっているため。" "(catch 'foo" "  (catch 'bar"
      "      (unwind-protect (throw 'foo 3)" "        (throw 'bar 4)"
      "        (print 'xxx))))" NIL NIL ";;; 下記の例は4を返却します。XXXは出力されません。"
      ";;; BARのcatchのスコープ上では(THROW 'FOO ...)に効果はありません。"
      ";;; そして(CATCH 'BAR ...)により退出します。" "(catch 'bar" "  (catch 'foo"
      "      (unwind-protect (throw 'foo 3)" "        (throw 'bar 4)"
      "        (print 'xxx))))" NIL NIL ";;; 下記の例では5を出力します。" "(block nil"
      "  (let ((x 5))" "    (declare (special x))" "    (unwind-protect (return)"
      "      (print x))))  " EOL1))
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "catch") "," (CODE1 "go") "," (CODE1 "handler-case") ","
     (CODE1 "restart-case") "," (CODE1 "return") "," (CODE1 "return-from") ","
     (CODE1 "throw") "," "3.1. 評価")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("UNWIND-PROTECT" . "SPECIAL-OPERATOR") *table*) (gethash "UNWIND-PROTECT" *table*))
(setf (gethash "UPDATE-INSTANCE-FOR-DIFFERENT-CLASS" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function "
     (CODE1 "UPDATE-INSTANCE-FOR-DIFFERENT-CLASS"))
    (CHAPTER ("## 構文") 2 (CODE1 "update-instance-for-different-class") " "
     (STRONG "previous") " " (STRONG "current") "&rest " (STRONG "initargs")
     " &key &allow-other-keys => 処理系依存")
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "update-instance-for-different-class") "("
     (STRONG "previous") " " (CODE1 "standard-object") ")" "(" (STRONG "current") " "
     (CODE1 "standard-object") ") &rest " (STRONG "initargs"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "previous") " - 元の" (STRONG "instance") "のコピー" EOL1
     (STRONG "current") " - 元の" (STRONG "instance") " (変更された)" EOL1 (STRONG "initargs")
     " - 初期化引数リスト")
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "update-instance-for-different-class") "は、"
     "プログラマーによって呼び出されることを意図していません。" "プログラマーはこの関数のメソッドを作成できます。" "関数"
     (CODE1 "update-instance-for-different-class") "は、" "ただ関数" (CODE1 "change-class")
     "によってのみ呼ばれます。" EOL2 "システムが提供する" (CODE1 "update-instance-for-different-class") "の"
     "プライマリメソッドは、" (STRONG "initargs") "の有効性を確認し、" "もし" (STRONG "initargs")
     "に有効として宣言されていないものが与えられていた場合は" "エラーが通知されます。" "このメソッドは、" (STRONG "initargs")
     "に対応する値でスロットを初期化します。" "そして新たに追加されたスロットには" (CODE1 ":initform") "フォーム対応した値で初期化します。"
     "このような動作は、ジェネリック関数" (CODE1 "shared-initialize") "を" "次のような引数で呼び出すことで行います。"
     "引数は、インスタンス（" (STRONG "current") "）、" "新しく追加されたスロットの名前のリスト、" "そして受け取った"
     (STRONG "initargs") "。" "新しく追加されたスロットとは、" "以前のクラスに同じ名前のスロットが存在しない局所スロットのことです。" EOL2
     (CODE1 "update-instance-for-different-class") "のメソッドを定義することで、"
     "インスタンス更新時の動作を指定することができます。" (CODE1 "update-instance-for-different-class") "の"
     (CODE1 "after") "メソッドのみが定義されている場合は、" "それらはシステムが提供している初期化の" "プライマリメソッドの後に実行されるため、"
     (CODE1 "update-instance-for-different-class") "の" "デフォルトの動作に干渉することはありません。" EOL2
     (CODE1 "update-instance-for-different-class") "のメソッドは、" (CODE1 "change-class")
     "とは違うスロットの初期化を定義できます。" (CODE1 "change-class")
     "のデフォルトの動作は、7.2. インスタンスのクラスの変更に定義されています。" EOL2
     (CODE1 "update-instance-for-different-class") "の引数は、" (CODE1 "change-class")
     "によって計算されます。" (CODE1 "change-class") "がインスタンスとともに起動されると" "そのインスタンスのコピーが生成され、" "そのとき"
     (CODE1 "change-class") "は元のインスタンスを破壊的に変更します。"
     (CODE1 "update-instance-for-different-class") "の最初の引数である" (STRONG "previous")
     "はコピーであり、古いスロットの値が一時的に保存されます。" "この引数は" (CODE1 "change-class") "内で動的生存期間を持ちます。" "もし"
     (CODE1 "update-instance-for-different-class") "から戻った後に、" "何らかの方法で参照された場合、結果は未定義です。"
     (CODE1 "update-instance-for-different-class") "の二番目の引数である" (STRONG "current")
     "は変更された元のインスタンスです。" (STRONG "previous") "の使用目的は、" (CODE1 "slot-value") "か、"
     (CODE1 "with-slots") "か、リーダーのジェネリック関数によって、" "古いスロットの値を読みだしたり、"
     "あるいは元のクラスのインスタンスとして適用できる" "他のメソッドを実行したりすることです。")
    (CHAPTER ("## 例文") 2 (CODE1 "change-class") "の例をご確認ください。")
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "システムが提供する" (CODE1 "update-instance-for-different-class") "の"
     "プライマリメソッドは、" "初期化引数に有効として宣言されていないものが" "与えられていた場合はエラーが通知されます。")
    (CHAPTER ("## 参考") 2 (CODE1 "change-class") "," (CODE1 "shared-initialize") ","
     "7.2. インスタンスのクラスの変更," "7.1.4. 初期化引数の規則," "7.1.2. 初期化引数の有効性の宣言")
    (CHAPTER ("## 備考") 2 (STRONG "initargs") "は、" (CODE1 "defclass") "の"
     (CODE1 ":initarg") "引数によって、" "あるいは" (CODE1 "update-instance-for-different-class")
     "か" (CODE1 "shared-initialize") "のメソッドの宣言によって、" "有効であると宣言されます。"
     (CODE1 "update-instance-for-different-class") "か" (CODE1 "shared-initialize")
     "の各メソッドの宣言のラムダリストにある、" "各キーワードパラメーター指定子のキーワード名は、" "それらのメソッドが適用されるすべてのクラスに対して、"
     "有効な初期化引数の名前として宣言されます。" EOL2 (CODE1 "update-instance-for-different-class") "の返却値は、"
     (CODE1 "change-class") "によって無視されます。")))
(setf (gethash '("UPDATE-INSTANCE-FOR-DIFFERENT-CLASS" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "UPDATE-INSTANCE-FOR-DIFFERENT-CLASS" *table*))
(setf (gethash "UPDATE-INSTANCE-FOR-REDEFINED-CLASS" *table*)
  '((CHAPTER NIL 0 "Standard Generic Function "
     (CODE1 "UPDATE-INSTANCE-FOR-REDEFINED-CLASS"))
    (CHAPTER ("## 構文") 2 (CODE1 "update-instance-for-redefined-class")
     (STRONG "instance") " " (STRONG "add-slots") " " (STRONG "discarded-slots") " "
     (STRONG "property-list") "&rest " (STRONG "initargs") " &key &allow-other-keys => "
     (STRONG "result\\*"))
    (CHAPTER ("## メソッド宣言") 2 (CODE1 "update-instance-for-redefined-class") "("
     (STRONG "instance") " " (CODE1 "standard-object") ")" (STRONG "added-slots") " "
     (STRONG "discarded-slots") " " (STRONG "property-list") " &rest "
     (STRONG "initargs"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "instance") " - オブジェクト" EOL1 (STRONG "added-slots")
     " - リスト" EOL1 (STRONG "discarded-slots") " - リスト" EOL1 (STRONG "property-list")
     " - リスト" EOL1 (STRONG "initargs") " - 初期化引数リスト" EOL1 (STRONG "result") " - オブジェクト")
    (CHAPTER ("## 定義") 2 "ジェネリック関数" (CODE1 "update-instance-for-redefined-class") "は、"
     "プログラマーによって呼び出されることを意図していません。" "プログラマーはこの関数のメソッドを作成できます。" "関数"
     (CODE1 "update-instance-for-redefined-class") "は、" "関数"
     (CODE1 "make-instances-obsolete") "によって" "有効化される仕組みによって呼び出されます。" EOL2 "システムが提供する"
     (CODE1 "update-instance-for-redefined-class") "の" "プライマリメソッドは、" (STRONG "initargs")
     "の有効性を確認し、" "もし" (STRONG "initargs") "に有効として宣言されていないものが与えられていた場合は" "エラーが通知されます。"
     "このメソッドは、" (STRONG "initargs") "に対応する値でスロットを初期化します。" "そして新たに追加されたスロット"
     (STRONG "added-slots") "には" (CODE1 ":initform") "フォーム対応した値で初期化します。"
     "このような動作は、ジェネリック関数" (CODE1 "shared-initialize") "を" "次のような引数で呼び出すことで行います。" "引数は、"
     (STRONG "instance") "、" (STRONG "instance") "に新しく追加されたスロットの名前のリスト"
     (STRONG "added-slots") "、" "そして受け取った" (STRONG "initargs") "です。" "新しく追加されたスロット"
     (STRONG "added-slots") "とは、" "以前のクラスに同じ名前のスロットが存在しない局所スロットのことです。" EOL2
     (CODE1 "make-instances-obsolete") "が起動されるときか、" "クラスが再定義されて" (STRONG "instance")
     "が更新されるときは、" "元のインスタンスの全ての削除されるスロット" (STRONG "discarded-slots") "とその値が、"
     "スロットの名前と値とともに取り出され" (STRONG "property-list") "が作成されます。" (STRONG "instance")
     "の構造は、現在のクラスの定義に合うように変換されます。" (CODE1 "update-instance-for-redefined-class") "の引数は、"
     "変換された" (STRONG "instance") "、" "インスタンスへ追加されたスロットのリスト" (STRONG "added-slots") "、"
     "インスタンスから削除されるスロットのリスト" (STRONG "discarded-slots") "、" "削除されるスロットで値を持っているの"
     "スロットの名前と値が含まれるリスト" (STRONG "property-list") "です。"
     "削除されるスロットのリストは、古いクラスでは局所スロットだったものから、" "新しいクラスでは共有スロットになったものが含まれます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defclass position () ())" " "
      "(defclass x-y-position (position)" "    ((x :initform 0 :accessor position-x)"
      "     (y :initform 0 :accessor position-y)))" " "
      ";;; 極座標は直交座標よりも多く使用されることが判明したため、" ";;; 表現を変更し、いくつかの新しいaccessorメソッドを追加しました。" " "
      "(defmethod update-instance-for-redefined-class :before"
      "   ((pos x-y-position) added deleted plist &key)"
      "  ;; x-y座標を極座標に変換し新しいスロットに保存します" "  (let ((x (getf plist 'x))"
      "        (y (getf plist 'y)))"
      "    (setf (position-rho pos) (sqrt (+ (* x x) (* y y)))"
      "          (position-theta pos) (atan y x))))" "  "
      "(defclass x-y-position (position)" "    ((rho :initform 0 :accessor position-rho)"
      "     (theta :initform 0 :accessor position-theta)))" "  "
      ";;; 全ての古いx-y-positionインスタンスは、" ";;; 自動的にアップデートされるでしょう。" NIL
      ";;; 新しい表現は、旧来の表現と同じような見た目が与えられています。" NIL
      "(defmethod position-x ((pos x-y-position))  "
      "   (with-slots (rho theta) pos (* rho (cos theta))))" NIL
      "(defmethod (setf position-x) (new-x (pos x-y-position))"
      "   (with-slots (rho theta) pos" "     (let ((y (position-y pos)))"
      "       (setq rho (sqrt (+ (* new-x new-x) (* y y)))"
      "             theta (atan y new-x))" "       new-x)))" NIL
      "(defmethod position-y ((pos x-y-position))"
      "   (with-slots (rho theta) pos (* rho (sin theta))))" NIL
      "(defmethod (setf position-y) (new-y (pos x-y-position))"
      "   (with-slots (rho theta) pos" "     (let ((x (position-x pos)))"
      "       (setq rho (sqrt (+ (* x x) (* new-y new-y)))"
      "             theta (atan new-y x))" "       new-y)))"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "システムが提供する" (CODE1 "update-instance-for-redefined-class") "の"
     "プライマリメソッドは、" (STRONG "initargs") "に有効として宣言されていないものが与えられていた場合は" "エラーが通知されます。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-instances-obsolete") ","
     (CODE1 "shared-initialize") "," "4.3.6. クラスの再定義," "7.1.4. 初期化引数の規則,"
     "7.1.2. 初期化引数の有効性の宣言")
    (CHAPTER ("## 備考") 2 (STRONG "initargs") "は、" (CODE1 "defclass") "の"
     (CODE1 ":initarg") "引数によって、" "あるいは" (CODE1 "update-instance-for-redefined-class")
     "か" (CODE1 "shared-initialize") "のメソッドの宣言によって、" "有効であると宣言されます。"
     (CODE1 "update-instance-for-redefined-class") "か" (CODE1 "shared-initialize")
     "の各メソッドの宣言のラムダリストにある、" "各キーワードパラメーター指定子のキーワード名は、" "それらのメソッドが適用されるすべてのクラスに対して、"
     "有効な初期化引数の名前として宣言されます。")))
(setf (gethash '("UPDATE-INSTANCE-FOR-REDEFINED-CLASS" . "STANDARD-GENERIC-FUNCTION") *table*) (gethash "UPDATE-INSTANCE-FOR-REDEFINED-CLASS" *table*))
(setf (gethash "UPGRADED-ARRAY-ELEMENT-TYPE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "UPGRADED-ARRAY-ELEMENT-TYPE"))
    (CHAPTER ("## 構文") 2 (CODE1 "upgraded-array-element-type") " " (STRONG "typespec")
     " " (CODE1 "&optional") " " (STRONG "environment") " => "
     (STRONG "upgraded-typespec"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "typespec") " - 型指定子" EOL1 (STRONG "environment")
     " - 環境オブジェクト。" "デフォルトは" (CODE1 "nil") "であり、" (CODE1 "null")
     "のレキシカルな環境と現在のグローバル環境を示します。" EOL1 (STRONG "upgraded-typespec") " - 型指定子")
    (CHAPTER ("## 定義") 2 (STRONG "typespec") "で指定された型の要素を格納するような能力のある"
     "もっとも特定化された配列の表現の要素の型を返却します。" EOL2 (STRONG "typespec") "は"
     (STRONG "upgraded-typespec") "のサブタイプであり、" "可能であれば同等の型です。" EOL2 "もし"
     (STRONG "typespec") "が" (CODE1 "bit") "のとき、返却値は" (CODE1 "bit") "と同等の型です。" "もし"
     (STRONG "typespec") "が" (CODE1 "base-char") "のとき、返却値は" (CODE1 "base-char")
     "と同等の型です。" "もし" (STRONG "typespec") "が" (CODE1 "character") "のとき、" "返却値は"
     (CODE1 "character") "と同等の型です。" EOL2 (CODE1 "upgraded-array-element-type") "の目的は、"
     "実装がそのアップグレードをどのようなものにするか明らかにすることです。" EOL2 (STRONG "environment") "は"
     (STRONG "typespec") "に含まれる" "どんな派生された型指定子も展開するときに使用されます。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "array-element-type") "," (CODE1 "make-array"))
    (CHAPTER ("## 備考") 2 "ストレージの確保の結果と、オプションの" (STRONG "environment") "引数の正しい扱いを除けば、"
     (CODE1 "upgraded-array-element-type") "は次のように定義できます。"
     (CODE3 "```lisp" "```"
      "(defun upgraded-array-element-type (type &optional environment)"
      "  (array-element-type (make-array 0 :element-type type)))"))))
(setf (gethash '("UPGRADED-ARRAY-ELEMENT-TYPE" . "FUNCTION") *table*) (gethash "UPGRADED-ARRAY-ELEMENT-TYPE" *table*))
(setf (gethash "UPPER-CASE-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "UPPER-CASE-P") ", " (CODE1 "LOWER-CASE-P") ", "
     (CODE1 "BOTH-CASE-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "upper-case-p") " " (STRONG "character") " => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "lower-case-p") " " (STRONG "character")
     " => " (STRONG "generalized-boolean") EOL1 (CODE1 "both-case-p") " "
     (STRONG "character") " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " - 文字" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は、" (STRONG "character") "のケースをテストします。" EOL2
     (CODE1 "upper-case-p") "は、" (STRONG "character") "が大文字の場合は" (STRONG "true") "を、"
     "それ以外は" (STRONG "false") "を返却します。" EOL2 (CODE1 "lower-case-p") "は、"
     (STRONG "character") "が小文字の場合は" (STRONG "true") "を、" "それ以外は" (STRONG "false")
     "を返却します。" EOL2 (CODE1 "both-case-p") "は、" (STRONG "character") "にケースがある場合は"
     (STRONG "true") "を、" "それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(upper-case-p #\\A) =>  true"
      "(upper-case-p #\\a) =>  false" "(both-case-p #\\a) =>  true"
      "(both-case-p #\\5) =>  false" "(lower-case-p #\\5) =>  false"
      "(upper-case-p #\\5) =>  false" ";; 次の例では、#\\Bellという文字が定義されている処理系を前提にしている。"
      "(lower-case-p #\\Bell) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "character") "が文字ではなかったら、型" (CODE1 "type-error")
     "のエラーが生じます。")
    (CHAPTER ("## 参考") 2 (CODE1 "char-upcase") ", " (CODE1 "char-downcase")
     ", 13.1.4.3. 文字のケース, 13.1.10. 処理系実装のスクリプトの説明")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("UPPER-CASE-P" . "FUNCTION") *table*) (gethash "UPPER-CASE-P" *table*))
(setf (gethash "USE-PACKAGE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "USE-PACKAGE"))
    (CHAPTER ("## 構文") 2 (CODE1 "use-package") " " (STRONG "packages-to-use") " "
     (CODE1 "&optional") " " (STRONG "package") " => " (CODE1 "t"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "packages-to-use") " - パッケージ指定子のリストの指定子。"
     (CODE1 "KEYWORD") "パッケージは指定されません。" EOL1 (STRONG "package")
     " - パッケージ指定子。デフォルトは現在のパッケージ。" (STRONG "package") "には" (CODE1 "KEYWORD")
     "パッケージは指定できません。")
    (CHAPTER ("## 定義") 2 (CODE1 "use-package") "は、" (STRONG "package") "に対して、"
     (STRONG "packages-to-use") "の全ての外部シンボルを継承します。" "継承されたシンボルは、" (STRONG "package")
     "の内部シンボルとして" "アクセスできるようになります。" EOL2 (STRONG "packages-to-use") "は、"
     (STRONG "package") "の" (CODE1 "use") "リストに、" "もしそれらが現れていないときは追加されます。"
     (STRONG "packages-to-use") "の全ての外部シンボルは、" (STRONG "package")
     "の内部シンボルとしてアクセスできるようになります。" (CODE1 "use-package") "は" (STRONG "package")
     "に新しいシンボルが現れるようなことはせず、" "ただそれらを継承によってアクセス可能にするだけです。" EOL2 (CODE1 "use-package")
     "は、新しく入ってくるシンボルと、" "それらが" (STRONG "package") "内ですでにアクセス可能なものとの間で" "名前の衝突のチェックを行います。"
     (STRONG "packages-to-use") "から" (STRONG "package") "によって継承される" "2つの外部シンボル間に生じた"
     (CODE1 "use-package") "の名前衝突は、" "それらの" (STRONG "package") "内に入ってくるどちらかのシンボルを選び、"
     "それを" (CODE1 "shadowing") "シンボルにすることで解決できます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(export (intern \"LAND-FILL\" (make-package 'trash)) 'trash) =>  T"
      "(find-symbol \"LAND-FILL\" (make-package 'temp)) =>  NIL, NIL"
      "(package-use-list 'temp) =>  (#<PACKAGE \"TEMP\">)"
      "(use-package 'trash 'temp) =>  T"
      "(package-use-list 'temp) =>  (#<PACKAGE \"TEMP\"> #<PACKAGE \"TRASH\">)"
      "(find-symbol \"LAND-FILL\" 'temp) =>  TRASH:LAND-FILL, :INHERITED"))
    (CHAPTER ("## 副作用") 2 (STRONG "package") "の" (CODE1 "use") "リストは修正されます。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "unuse-package") "," (CODE1 "package-use-list") ","
     "11.1. パッケージの説明")
    (CHAPTER ("## 備考") 2 "パッケージ" (CODE1 "P2") "がすでにパッケージ" (CODE1 "P1") "を使用していたときでさえ、"
     (CODE1 "P1") "が" (CODE1 "P2") "を使用することは許されます。" "パッケージの" (CODE1 "use") "は推移的ではないので、"
     "循環構造が現れても問題がありません。")))
(setf (gethash '("USE-PACKAGE" . "FUNCTION") *table*) (gethash "USE-PACKAGE" *table*))
(setf (gethash "USE-VALUE" *table*)
  '("USE-VALUE FUNCTION" EOL1 "USE-VALUE RESTART" EOL1))
(setf (gethash '("USE-VALUE" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "ABORT") ", " (CODE1 "CONTINUE") ", "
     (CODE1 "MUFFLE-WARNING") ", " (CODE1 "STORE-VALUE") ", " (CODE1 "USE-VALUE"))
    (CHAPTER ("## 構文") 2 (CODE1 "abort") " " (CODE1 "&optional") " " (STRONG "condition")
     " => " (CODE1 "|") EOL1 (CODE1 "continue") " " (CODE1 "&optional") " "
     (STRONG "condition") " => " (CODE1 "nil") EOL1 (CODE1 "muffle-warning") " "
     (CODE1 "&optional") " " (STRONG "condition") " => " (CODE1 "|") EOL1
     (CODE1 "store-value") " " (STRONG "value") " " (CODE1 "&optional") " "
     (STRONG "condition") " => " (CODE1 "nil") EOL1 (CODE1 "use-value") " "
     (STRONG "value") " " (CODE1 "&optional") " " (STRONG "condition") " => "
     (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "value") " - オブジェクト" EOL1 (STRONG "condition")
     " - コンディションオブジェクトか、" (CODE1 "nil"))
    (CHAPTER ("## 定義") 2 "もっとも最近確立された適用可能な" (CODE1 "restart") "のうち、"
     "関数と同じ名前を持つものへ制御が遷移されます。" "つまり、" (CODE1 "abort") "関数は" "適用可能な" (CODE1 "abort") " "
     (CODE1 "restart") "を探し、" (CODE1 "continue") "関数は" "適用可能な" (CODE1 "continue") " "
     (CODE1 "restart") "を探し、" "他も同様です。" EOL2 "もしそのような" (CODE1 "restart") "が存在しないときは、"
     (CODE1 "continue") ", " (CODE1 "store-value") "," (CODE1 "use-value") "は"
     (CODE1 "nil") "を返却し、" (CODE1 "abort") "と" (CODE1 "muffle-warning") "は" "型"
     (CODE1 "control-error") "のエラーを発生します。" EOL2 "もし" (STRONG "condition") "が"
     (CODE1 "nil") "ではないときは、" "それらの" (CODE1 "restart") "は、明に" (STRONG "condition")
     "と関連付けられているものか、" "あるいはどのコンディションにも関連付けられてないものかの" "どちらかのみが集められます。" "これは、排他された"
     (CODE1 "restart") "というのは、" "関連付けられたコンディションの集合が空ではなく、" "その要素に指定した"
     (STRONG "condition") "が含まれていないということです。" "もし" (STRONG "condition") "が" (CODE1 "nil")
     "のときは、" "全ての" (CODE1 "restart") "が集められます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";;; ABORT restartの例" NIL
      "(defmacro abort-on-error (&body forms)" "  `(handler-bind ((error #'abort))"
      "     ,@forms)) =>  ABORT-ON-ERROR" "(abort-on-error (+ 3 5)) =>  8"
      "(abort-on-error (error \"You lose.\"))" ">>  Returned to Lisp Top Level." NIL
      ";;; CONTINUE restartの例" NIL "(defun real-sqrt (n)" "  (when (minusp n)"
      "    (setq n (- n))"
      "    (cerror \"Return sqrt(~D) instead.\" \"Tried to take sqrt(-~D).\" n))"
      "  (sqrt n))" NIL "(real-sqrt 4) =>  2" "(real-sqrt -9)"
      ">>  Error: Tried to take sqrt(-9)."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Return sqrt(9) instead." ">>   2: Return to Lisp Toplevel."
      ">>  Debug> (continue)" ">>  Return sqrt(9) instead." "=>  3" " "
      " (handler-bind ((error #'(lambda (c) (continue))))" "   (real-sqrt -9)) =>  3" NIL
      ";;; MUFFLE-WARNING restartの例" NIL "(defun count-down (x)"
      "  (do ((counter x (1- counter)))" "      ((= counter 0) 'done)"
      "    (when (= counter 1)" "      (warn \"Almost done\"))"
      "    (format t \"~&~D~%\" counter)))" "=>  COUNT-DOWN" "(count-down 3)" ">>  3"
      ">>  2" ">>  Warning: Almost done" ">>  1" "=>  DONE"
      "(defun ignore-warnings-while-counting (x)"
      "  (handler-bind ((warning #'ignore-warning))" "    (count-down x)))"
      "=>  IGNORE-WARNINGS-WHILE-COUNTING" "(defun ignore-warning (condition)"
      "  (declare (ignore condition))" "  (muffle-warning))" "=>  IGNORE-WARNING"
      " (ignore-warnings-while-counting 3)" ">>  3" ">>  2" ">>  1" "=>  DONE" NIL
      ";;; STORE-VALUE restartとUSE-VALUE restartの例" NIL
      "(defun careful-symbol-value (symbol)" "  (check-type symbol symbol)"
      "  (restart-case (if (boundp symbol)"
      "                    (return-from careful-symbol-value "
      "                                 (symbol-value symbol))"
      "                    (error 'unbound-variable"
      "                           :name symbol))" "    (use-value (value)"
      "      :report \"Specify a value to use this time.\"" "      value)"
      "    (store-value (value)"
      "      :report \"Specify a value to store and use in the future.\""
      "      (setf (symbol-value symbol) value))))" "(setq a 1234) =>  1234"
      "(careful-symbol-value 'a) =>  1234" "(makunbound 'a) =>  A"
      "(careful-symbol-value 'a)" ">>  Error: A is not bound."
      ">>  To continue, type :CONTINUE followed by an option number."
      ">>   1: Specify a value to use this time."
      ">>   2: Specify a value to store and use in the future."
      ">>   3: Return to Lisp Toplevel." ">>  Debug> (use-value 12)" "=>  12"
      "(careful-symbol-value 'a)" ">>  Error: A is not bound."
      ">>  To continue, type :CONTINUE followed by an option number."
      ">>    1: Specify a value to use this time."
      ">>    2: Specify a value to store and use in the future."
      ">>    3: Return to Lisp Toplevel." ">>  Debug> (store-value 24)" "=>  24"
      " (careful-symbol-value 'a)" "=>  24" NIL ";;; USE-VALUE restartの例" NIL
      "(defun add-symbols-with-default (default &rest symbols)"
      "  (handler-bind ((sys:unbound-symbol" "                   #'(lambda (c)"
      "                       (declare (ignore c)) "
      "                       (use-value default))))"
      "    (apply #'+ (mapcar #'careful-symbol-value symbols))))"
      "=>  ADD-SYMBOLS-WITH-DEFAULT" "(setq x 1 y 2) =>  2"
      "(add-symbols-with-default 3 'x 'y 'z) =>  6"))
    (CHAPTER ("## 副作用") 2 "適用可能な" (CODE1 "restart") "が使用可能なときに" "制御の遷移が起こるかもしれませんし、"
     "あるいは（" (CODE1 "abort") "関数か" (CODE1 "muffle-warning") "関数の場合は）" "実行が停止するかもしれません。")
    (CHAPTER ("## 影響") 2 "もし適用可能な" (CODE1 "abort") " " (CODE1 "restart") "が" "利用不可の状態で"
     (CODE1 "abort") "関数が実行されれたときか、" "適用可能な" (CODE1 "muffle-warning") " "
     (CODE1 "restart") "が" "利用不可の状態で" (CODE1 "muffle-warning") "関数が実行されれたときは、" "型"
     (CODE1 "control-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "invoke-restart") "," "9.1.4.2. " (CODE1 "restart") ","
     "9.1.4.2.2. " (CODE1 "restart") "のインターフェイス," (CODE1 "assert") "," (CODE1 "ccase")
     "," (CODE1 "cerror") "," (CODE1 "check-type") "," (CODE1 "ctypecase") ","
     (CODE1 "use-value") "," (CODE1 "warn"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(abort condition) ==  (invoke-restart 'abort)"
      "(muffle-warning)  ==  (invoke-restart 'muffle-warning)"
      "(continue)        ==  (let ((r (find-restart 'continue))) (if r (invoke-restart r)))"
      "(use-value x) ==  (let ((r (find-restart 'use-value))) (if r (invoke-restart r x)))"
      "(store-value x) ==  (let ((r (find-restart 'store-value))) (if r (invoke-restart r x)))")
     EOL2 "この仕様書で" (CODE1 "use-value") " " (CODE1 "restart") "の提供に" "要求される関数定義はありません。")))
(setf (gethash '("USE-VALUE" . "RESTART") *table*)
  '((CHAPTER NIL 0 "Restart " (CODE1 "USE-VALUE"))
    (CHAPTER ("## 要求される引数のデータ") 2 "かわりに使う値（一度だけ）")
    (CHAPTER ("## 定義") 2 (CODE1 "use-value") " " (CODE1 "restart") "は、" "一般的には"
     (CODE1 "cell-error") "か" (CODE1 "type-error") "のような" "エラーの型から回復を試みるハンドラーによって使用されます。"
     "回復はハンドラーが置き換えるデータの希望を指定して" "その値を一度だけ使用することによって行います。" EOL2 "See Also:" EOL2
     "9.1.4.2. " (CODE1 "restart") "," "9.1.4.2.2. " (CODE1 "restart") "のインターフェイス,"
     (CODE1 "invoke-restart") "," (CODE1 "use-value") "（関数）," (CODE1 "store-value")
     "（関数）," (CODE1 "store-value") "（" (CODE1 "restart") "）")))
(setf (gethash "VALUES" *table*)
  '("VALUES ACCESSOR" EOL1 "VALUES TYPE-SPECIFIER" EOL1))
(setf (gethash '("VALUES" . "ACCESSOR") *table*)
  '((CHAPTER NIL 0 "Accessor " (CODE1 "VALUES"))
    (CHAPTER ("## 構文") 2 (CODE1 "values") " &rest " (STRONG "object") " => "
     (STRONG "object\\*") EOL1 "(" (CODE1 "setf") " (" (CODE1 "values") " &rest "
     (STRONG "place") ") " (STRONG "new-values") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "place") " - "
     (CODE1 "place") EOL1 (STRONG "new-value") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (CODE1 "values") "は多値として" (STRONG "object") "を返却します。" EOL2
     (CODE1 "setf") "の" (CODE1 "values") "は、" (STRONG "new-values") "の多値を"
     (CODE1 "place") "に格納するときに使います。" "5.1.2.3. " (CODE1 "place")
     "としてのVALUESフォームをご確認ください。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(values) =>  <no values>" "(values 1) =>  1"
      "(values 1 2) =>  1, 2" "(values 1 2 3) =>  1, 2, 3"
      "(values (values 1 2 3) 4 5) =>  1, 4, 5" "(defun polar (x y)"
      "  (values (sqrt (+ (* x x) (* y y))) (atan y x))) =>  POLAR"
      "(multiple-value-bind (r theta) (polar 3.0 4.0)" "  (vector r theta))"
      "=>  #(5.0 0.927295)")
     EOL2 "よく関数の返却値を正確にひとつだけと" "明に示したいことがあるかもしれません。" "例えば、次の関数は" (CODE1 "floor")
     "が2つの値を返却するので、" "関数の返却値も2つです。"
     (CODE3 "```lisp" "```" "(defun foo (x y)" "  (floor (+ x y) y)) =>  FOO") EOL2
     "これは2番目の返却値が意味をなさないときもあるかもしれませんし、" "あるいは効率という理由で2番目の値を算出してほしくないときもあると思います。"
     (CODE1 "values") "は、返却値がただひとつだけであることを示す標準的な記載方法です。"
     (CODE3 "```lisp" "```" "(defun foo (x y)" "  (values (floor (+ x y) y))) =>  FOO")
     EOL2 "これは、" (CODE1 "values") "がどんな関数呼び出しでも、" "どんな引数が複数の値を返却しても、"
     "最初以外の全ては切り捨てられて各引数の値を正確にひとつ返却するので、" "うまく動作します。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "values-list") "," (CODE1 "multiple-value-bind") ","
     (CODE1 "multiple-values-limit") "," "3.1. 評価")
    (CHAPTER ("## 備考") 2 (CODE1 "values") "は関数であり、マクロや特殊フォームでもないので、"
     "その引数のフォームはただ主値のみ引数として受け取ります。")))
(setf (gethash '("VALUES" . "TYPE-SPECIFIER") *table*)
  '((CHAPTER NIL 0 "Type Specifier " (CODE1 "VALUES")) (CHAPTER ("## 型指定子の種類") 2 "特定化")
    (CHAPTER ("## 型指定子の構文") 2
     (CODE3 "```" "```"
      "value-typespec::= typespec* [&optional typespec*] [&rest typespec] [&allow-other-keys] "))
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "typespec") " - 型指定子")
    (CHAPTER ("## 型指定子の定義") 2 "この型指定子は" (CODE1 "function") "型指定子か、" (CODE1 "the")
     " 特殊フォームの" (STRONG "value-type") "としてのみ使用することができます。"
     "これは多値が関係するときに独立した型を指定するときに使われます。" (CODE1 "&optional") "と" (CODE1 "&rest") "の印を"
     (STRONG "value-type") "のリストに配置することができます。" "それらの値は" (CODE1 "multiple-value-call")
     "に関数と共に与えられれたとき、" "正しく受け取れるようなパラメーターを意味しています。" EOL2 "シンボル" (CODE1 "*") "は"
     (STRONG "value-type") "の中に含まれないかもしれません。" EOL2 "シンボルとしての" (CODE1 "values")
     "は、有効な型指定子ではありませんし、" "とくに" (CODE1 "(values)") "の省略形ではありません。")))
(setf (gethash "VALUES-LIST" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "VALUES-LIST"))
    (CHAPTER ("## 構文") 2 (CODE1 "values-list") " " (STRONG "list") " => "
     (STRONG "element\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "list") " - リスト" EOL1 (STRONG "element") " - "
     (STRONG "list") "の要素")
    (CHAPTER ("## 定義") 2 (STRONG "list") "の要素を多値として返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(values-list nil) =>  <no values>"
      "(values-list '(1)) =>  1" "(values-list '(1 2)) =>  1, 2"
      "(values-list '(1 2 3)) =>  1, 2, 3"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "引数が通常のリストではないとき、" "型" (CODE1 "type-error") "が発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "multiple-value-bind") "," (CODE1 "multiple-value-list")
     "," (CODE1 "multiple-values-limit") "," (CODE1 "values"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" " (values-list list) ==  (apply #'values list)") EOL2
     (CODE1 "(equal x (multiple-value-list (values-list x)))") "は、" "全てのリスト" (CODE1 "x")
     "において" (STRONG "true") "を返却します。")))
(setf (gethash '("VALUES-LIST" . "FUNCTION") *table*) (gethash "VALUES-LIST" *table*))
(setf (gethash "VECTOR" *table*)
  '("VECTOR FUNCTION" EOL1 "VECTOR SYSTEM-CLASS" EOL1))
(setf (gethash '("VECTOR" . "FUNCTION") *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "VECTOR"))
    (CHAPTER ("## 構文") 2 (CODE1 "vector") " " (CODE1 "&rest") " " (STRONG "objects")
     " => " (STRONG "vector"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "vector") " - 型"
     (CODE1 "(vector t *)") "の" (CODE1 "vector"))
    (CHAPTER ("## 定義") 2 (STRONG "objects") "の数に対応したサイズの" "新しい一般的な"
     (CODE1 "simple-vector") "を生成します。" EOL2 (CODE1 "vector") "は" (STRONG "objects")
     "の内容で初期化されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(arrayp (setq v (vector 1 2 'sirens))) =>  true"
      "(vectorp v) =>  true" "(simple-vector-p v) =>  true         " "(length v) =>  3"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-array"))
    (CHAPTER ("## 備考") 2 (CODE1 "vector") "は" (CODE1 "list") "に似ています。"
     (CODE3 "```lisp" "```" "(vector a1 a2 ... an)"
      " ==  (make-array (list n) :element-type t"
      "                         :initial-contents "
      "                           (list a1 a2 ... an))"))))
(setf (gethash '("VECTOR" . "SYSTEM-CLASS") *table*)
  '((CHAPTER NIL 0 "System Class " (CODE1 "VECTOR"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "vector") "," (CODE1 "array") ","
     (CODE1 "sequence") "," (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "一次元の配列は" (CODE1 "vector") "です。" EOL2 "型" (CODE1 "vector") "は、型"
     (CODE1 "array") "のサブタイプです。" "全ての型" (CODE1 "x") "に対して、" (CODE1 "(vector x)") "は"
     (CODE1 "(array x (*))") "と同じです。" EOL2 "型" (CODE1 "(vector t)") "と、型"
     (CODE1 "string") "と、" "型" (CODE1 "bit-vector") "は、型" (CODE1 "vector") "のサブタイプであり、"
     "それぞれが互いに素です。")
    (CHAPTER ("## 型指定子の種類") 2 "特定化")
    (CHAPTER ("## 型指定子の構文") 2 (CODE1 "vector") " [" (CODE1 "{") (STRONG "element-type")
     " " (CODE1 "|") " \\*" (CODE1 "}") " [" (CODE1 "{") (STRONG "size") " " (CODE1 "|")
     " \\*" (CODE1 "}") "]]")
    (CHAPTER ("## 型指定子の引数") 2 (STRONG "size") " - 非負の" (CODE1 "fixnum") EOL1
     (STRONG "element-type") " - 型指定子")
    (CHAPTER ("## 型指定子の定義") 2 "これは要素の型" (STRONG "element-type") "と大きさ"
     (STRONG "dimension") "が" "指定された値を取った" (CODE1 "vector") "の特定型の集合を示します。"
     "特に下記のようになります。" EOL2 "もし" (STRONG "element-type") "がシンボル" (CODE1 "*") "のときは、"
     (CODE1 "vector") "は要素の型を元にして排他しません。" "その他の場合は、" (CODE1 "vector") "は"
     (STRONG "element-type") "をアップグレードした結果の" "実際の配列の要素の型のみを含みます。"
     "15.1.2.1. 配列のアップグレードをご確認ください。" EOL2 "もし" (STRONG "size") "が指定されたとき、" "その集合は、大きさが"
     (STRONG "size") "であるもののみの" (CODE1 "vector") "を含んだものになります。" "もし" (STRONG "size")
     "のかわりにシンボル" (CODE1 "*") "が指定されたときは、" "その集合には大きさをもとに制限されることはありません。")
    (CHAPTER ("## 参考") 2 "15.1.2.2. 特定化された配列の種類の要求," "2.4.8.3. シャープサイン 左かっこ,"
     "22.1.3.7. 他の" (CODE1 "vector") "の印字," "2.4.8.12. シャープサイン A")
    (CHAPTER ("## 備考") 2 "型" (CODE1 "(vector e s)") "は、型" (CODE1 "(array e (s))")
     "と同じです。" EOL2 "型" (CODE1 "(vector bit)") "は、" (CODE1 "bit-vector") "という名前です。" EOL2
     (CODE1 "C") "を" (CODE1 "character") "のサブタイプとしたときの" "型" (CODE1 "(vector C)")
     "の全ての和集合は、" (CODE1 "string") "という名前です。" EOL2 (CODE1 "(vector *)") "は要素の型に関わらず全ての"
     (CODE1 "vector") "を示し、" (CODE1 "(vector type-specifier)") "は" (CODE1 "make-array")
     "の引数の" (CODE1 ":element-type") "として指定された" (STRONG "type-specifier") "の結果の"
     (CODE1 "vector") "のみを示します。")))
(setf (gethash "VECTOR-POP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "VECTOR-POP"))
    (CHAPTER ("## 構文") 2 (CODE1 "vector-pop") " " (STRONG "vector") " => "
     (STRONG "element"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "vector") " - fill-pointerを持つ" (CODE1 "vector") EOL1
     (STRONG "element") " - オブジェクト")
    (CHAPTER ("## 定義") 2 (STRONG "vector") "からfill-pointerをひとつ減らし、"
     "新しいfill-pointerによって指定された" (CODE1 "vector") "の要素を取得します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(vector-push (setq fable (list 'fable))"
      "             (setq fa (make-array 8"
      "                                  :fill-pointer 2"
      "                                  :initial-element 'sisyphus))) =>  2 "
      "(fill-pointer fa) =>  3 " "(eq (vector-pop fa) fable) =>  true"
      "(vector-pop fa) =>  SISYPHUS " "(fill-pointer fa) =>  1 "))
    (CHAPTER ("## 副作用") 2 "fill-pointerはひとつ減ります。")
    (CHAPTER ("## 影響") 2 "fill-pointerの値。")
    (CHAPTER ("## 例外") 2 (STRONG "vector") "がfill-pointerを持っていないときは、" "型"
     (CODE1 "type-error") "が発生します。" EOL2 "もしfill-pointerがゼロのとき、" (CODE1 "vector-pop")
     "は型" (CODE1 "error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "vector-push") "," (CODE1 "vector-push-extend") ","
     (CODE1 "fill-pointer"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("VECTOR-POP" . "FUNCTION") *table*) (gethash "VECTOR-POP" *table*))
(setf (gethash "VECTOR-PUSH" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "VECTOR-PUSH") ", " (CODE1 "VECTOR-PUSH-EXTEND"))
    (CHAPTER ("## 構文") 2 (CODE1 "vector-push") " " (STRONG "new-element") " "
     (STRONG "vector") " => " (STRONG "new-index-p") EOL1 (CODE1 "vector-push-extend")
     " " (STRONG "new-element") " " (STRONG "vector") " " (CODE1 "&optional") " "
     (STRONG "extension") " => " (STRONG "new-index"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "new-element") " - オブジェクト" EOL1 (STRONG "vector")
     " - fill-pointerを持つ" (CODE1 "vector") EOL1 (STRONG "extension")
     " - 正の整数。デフォルトは実装依存。" EOL1 (STRONG "new-index-p") " - " (CODE1 "vector")
     "の有効な配列のインデックスか、" (CODE1 "nil") "。" EOL1 (STRONG "new-index") " - " (CODE1 "vector")
     "の有効な配列のインデックス")
    (CHAPTER ("## 定義") 2 (CODE1 "vector-push") "と" (CODE1 "vector-push-extend") "は、"
     (STRONG "vector") "内に" (STRONG "new-element") "を格納します。" (CODE1 "vector-push") "は、"
     (STRONG "new-element") "を" "fill-pointerによって指定された" (STRONG "vector") "の要素に格納しようと試み、"
     "そしてfill-pointerをひとつ増加させます。" "もし"
     (CODE1 "(>= (fill-pointer vector) (array-dimension vector 0))") "のときは、"
     (STRONG "vector") "にもfill-pointerにも影響を与えません。" "その他の場合は、格納と増加をしてから、"
     (CODE1 "vector-push") "は" (STRONG "vector") "に残る値よりひとつ小さい、"
     "以前のfill-pointerの値を返します。" EOL2 (CODE1 "vector-push-extend") "は"
     (CODE1 "vector-push") "と似ていますが、" "もしfill-pointerが大きすぎるときに、" (STRONG "vector") "を"
     (CODE1 "adjust-array") "を用いて拡張し、" "多くの要素を含めることができるようになることが違っています。"
     (STRONG "extension") "は、もし拡張が必要になったときに" (STRONG "vector") "に追加する最小の要素数です。" EOL2
     (CODE1 "vector-push-extend") "と" (CODE1 "vector-push") "は、" (STRONG "vector") "内の"
     (STRONG "new-element") "のインデックスを返却します。" "もし"
     (CODE1 "(>= (fill-pointer vector) (array-dimension vector 0))") "のとき、"
     (CODE1 "vector-push") "は" (CODE1 "nil") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(vector-push (setq fable (list 'fable))"
      "             (setq fa (make-array 8 "
      "                                  :fill-pointer 2"
      "                                  :initial-element 'first-one))) =>  2 "
      "(fill-pointer fa) =>  3 " "(eq (aref fa 2) fable) =>  true"
      "(vector-push-extend #\\X" "                   (setq aa "
      "                         (make-array 5"
      "                                     :element-type 'character"
      "                                     :adjustable t"
      "                                     :fill-pointer 3))) =>  3 "
      "(fill-pointer aa) =>  4 " "(vector-push-extend #\\Y aa 4) =>  4 "
      "(array-total-size aa) =>  at least 5 " "(vector-push-extend #\\Z aa 4) =>  5 "
      "(array-total-size aa) =>  9 ;(or more)"))
    (CHAPTER ("## 影響") 2 "fill-pointerの値。" EOL2 "どのように" (CODE1 "vector") "が生成されたか。")
    (CHAPTER ("## 例外") 2 (STRONG "vector") "を拡張しようとしたときに" (STRONG "vector") "が実際に"
     (CODE1 "adjustable") "ではなかったとき、" (CODE1 "vector-push-extend") "によって型"
     (CODE1 "error") "のエラーが発生します。" EOL2 (STRONG "vector") "がfill-pointerを持たなかったとき、" "型"
     (CODE1 "error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "adjustable-array-p") "," (CODE1 "fill-pointer") ","
     (CODE1 "vector-pop"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("VECTOR-PUSH" . "FUNCTION") *table*) (gethash "VECTOR-PUSH" *table*))
(setf (gethash "VECTOR-PUSH-EXTEND" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "VECTOR-PUSH") ", " (CODE1 "VECTOR-PUSH-EXTEND"))
    (CHAPTER ("## 構文") 2 (CODE1 "vector-push") " " (STRONG "new-element") " "
     (STRONG "vector") " => " (STRONG "new-index-p") EOL1 (CODE1 "vector-push-extend")
     " " (STRONG "new-element") " " (STRONG "vector") " " (CODE1 "&optional") " "
     (STRONG "extension") " => " (STRONG "new-index"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "new-element") " - オブジェクト" EOL1 (STRONG "vector")
     " - fill-pointerを持つ" (CODE1 "vector") EOL1 (STRONG "extension")
     " - 正の整数。デフォルトは実装依存。" EOL1 (STRONG "new-index-p") " - " (CODE1 "vector")
     "の有効な配列のインデックスか、" (CODE1 "nil") "。" EOL1 (STRONG "new-index") " - " (CODE1 "vector")
     "の有効な配列のインデックス")
    (CHAPTER ("## 定義") 2 (CODE1 "vector-push") "と" (CODE1 "vector-push-extend") "は、"
     (STRONG "vector") "内に" (STRONG "new-element") "を格納します。" (CODE1 "vector-push") "は、"
     (STRONG "new-element") "を" "fill-pointerによって指定された" (STRONG "vector") "の要素に格納しようと試み、"
     "そしてfill-pointerをひとつ増加させます。" "もし"
     (CODE1 "(>= (fill-pointer vector) (array-dimension vector 0))") "のときは、"
     (STRONG "vector") "にもfill-pointerにも影響を与えません。" "その他の場合は、格納と増加をしてから、"
     (CODE1 "vector-push") "は" (STRONG "vector") "に残る値よりひとつ小さい、"
     "以前のfill-pointerの値を返します。" EOL2 (CODE1 "vector-push-extend") "は"
     (CODE1 "vector-push") "と似ていますが、" "もしfill-pointerが大きすぎるときに、" (STRONG "vector") "を"
     (CODE1 "adjust-array") "を用いて拡張し、" "多くの要素を含めることができるようになることが違っています。"
     (STRONG "extension") "は、もし拡張が必要になったときに" (STRONG "vector") "に追加する最小の要素数です。" EOL2
     (CODE1 "vector-push-extend") "と" (CODE1 "vector-push") "は、" (STRONG "vector") "内の"
     (STRONG "new-element") "のインデックスを返却します。" "もし"
     (CODE1 "(>= (fill-pointer vector) (array-dimension vector 0))") "のとき、"
     (CODE1 "vector-push") "は" (CODE1 "nil") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(vector-push (setq fable (list 'fable))"
      "             (setq fa (make-array 8 "
      "                                  :fill-pointer 2"
      "                                  :initial-element 'first-one))) =>  2 "
      "(fill-pointer fa) =>  3 " "(eq (aref fa 2) fable) =>  true"
      "(vector-push-extend #\\X" "                   (setq aa "
      "                         (make-array 5"
      "                                     :element-type 'character"
      "                                     :adjustable t"
      "                                     :fill-pointer 3))) =>  3 "
      "(fill-pointer aa) =>  4 " "(vector-push-extend #\\Y aa 4) =>  4 "
      "(array-total-size aa) =>  at least 5 " "(vector-push-extend #\\Z aa 4) =>  5 "
      "(array-total-size aa) =>  9 ;(or more)"))
    (CHAPTER ("## 影響") 2 "fill-pointerの値。" EOL2 "どのように" (CODE1 "vector") "が生成されたか。")
    (CHAPTER ("## 例外") 2 (STRONG "vector") "を拡張しようとしたときに" (STRONG "vector") "が実際に"
     (CODE1 "adjustable") "ではなかったとき、" (CODE1 "vector-push-extend") "によって型"
     (CODE1 "error") "のエラーが発生します。" EOL2 (STRONG "vector") "がfill-pointerを持たなかったとき、" "型"
     (CODE1 "error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "adjustable-array-p") "," (CODE1 "fill-pointer") ","
     (CODE1 "vector-pop"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("VECTOR-PUSH-EXTEND" . "FUNCTION") *table*) (gethash "VECTOR-PUSH-EXTEND" *table*))
(setf (gethash "VECTORP" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "VECTORP"))
    (CHAPTER ("## 構文") 2 (CODE1 "vectorp") " " (STRONG "object") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (STRONG "object") "が型" (CODE1 "simple-vector") "のときは"
     (STRONG "true") "を、それ以外は" (STRONG "false") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(vectorp \"aaaaaa\") =>  true"
      "(vectorp (make-array 6 :fill-pointer t)) =>  true"
      "(vectorp (make-array '(2 3 4))) =>  false" "(vectorp #*11) =>  true"
      "(vectorp #b11) =>  false"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 "なし。")
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(vectorp object) == (typep object 'vector)"))))
(setf (gethash '("VECTORP" . "FUNCTION") *table*) (gethash "VECTORP" *table*))
(setf (gethash "WARN" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "WARN"))
    (CHAPTER ("## 構文") 2 (CODE1 "warn") " " (STRONG "datum") " " (CODE1 "&rest") " "
     (STRONG "arguments") " => " (CODE1 "nil"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "datum") ", " (STRONG "arguments")
     " - コンディション指定子であり、標準の型は" (CODE1 "simple-error") "。")
    (CHAPTER ("## 定義") 2 "型" (CODE1 "warning") "のコンディションを通知します。" "もしコンディションが捕捉されなかったときは、"
     (CODE1 "error-output") "にコンディションを報告します。" EOL2 "警告の正確な仕組みは下記の通り。" EOL2 "- "
     (CODE1 "warning") "コンディションを通知" "  - " (CODE1 "warning") "コンディションの通知を始めるとき、" "    "
     (CODE1 "muffle-warning") " " (CODE1 "restart") "がハンドラーとして確立します。" "    もし起動されたら、この"
     (CODE1 "restart") "は" (CODE1 "warn") "によるアクションを素通りして、" "    その次に" (CODE1 "warn")
     "を即座に" (CODE1 "nil") "で返却させます。" "    <br><br>" EOL2 "- もし" (CODE1 "warning")
     "コンディションのハンドラーが見つからなかったとき" "  - もし" (CODE1 "warning") "コンディションのハンドラーが見つからなかったか、"
     "    あるいはそのようなハンドラーが全て却下されたときは、" "    そのコンディションは" (CODE1 "warn") "によって、"
     "    実装依存のフォーマットで" "    " (CODE1 "error-output") "に報告が出力されます。" "    <br><br>" EOL2
     "- " (CODE1 "nil") "が返却される" "  - " (CODE1 "warn") "が戻った時の返却値は" (CODE1 "nil") "です。"
     "    <br><br>")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" " (defun foo (x)" "   (let ((result (* x 2)))"
      "     (if (not (typep result 'fixnum))"
      "         (warn \"You're using very big numbers.\"))" "     result))" "=>  FOO" NIL
      " (foo 3)" "=>  6" NIL " (foo most-positive-fixnum)"
      ">>  Warning: You're using very big numbers." "=>  4294967294" NIL
      " (setq *break-on-signals* t)" "=>  T" NIL " (foo most-positive-fixnum)"
      ">>  Break: Caveat emptor."
      ">>  To continue, type :CONTINUE followed by an option number."
      ">>   1: Return from Break." ">>   2: Abort to Lisp Toplevel."
      ">>  Debug> :continue 1" ">>  Warning: You're using very big numbers."
      "=>  4294967294"))
    (CHAPTER ("## 副作用") 2 "警告が表示されます。" "デバッガーに入るかもしれません。")
    (CHAPTER ("## 影響") 2 "存在するハンドラーの束縛" EOL2 (CODE1 "*break-on-signals*") ","
     (CODE1 "*error-output*"))
    (CHAPTER ("## 例外") 2 (STRONG "datum") "がコンディションのとき、" "そのコンディションが型" (CODE1 "warning")
     "ではなかったか、" "あるいは（" (STRONG "datum") "がコンディションでありかつ）" (STRONG "arguments") "が"
     (CODE1 "nil") "でなかったときは、" "型" (CODE1 "type-error") "のエラーが通知されます。" EOL2
     (STRONG "datum") "がコンディションの型のときは、"
     (CODE1 "(apply #'make-condition datum arguments)") "の結果は" "型" (CODE1 "warning")
     "でなければならず、" "そうでないときは型" (CODE1 "type-error") "おエラーが通知されます。")
    (CHAPTER ("## 参考") 2 (CODE1 "*break-on-signals*") "," (CODE1 "muffle-warning") ","
     (CODE1 "signal") ",")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("WARN" . "FUNCTION") *table*) (gethash "WARN" *table*))
(setf (gethash "WARNING" *table*)
  '((CHAPTER NIL 0 "Condition Type " (CODE1 "WARNING"))
    (CHAPTER ("## クラス優先順位リスト") 2 (CODE1 "warning") "," (CODE1 "condition") ","
     (CODE1 "t"))
    (CHAPTER ("## 定義") 2 "型" (CODE1 "warning") "は全ての警告の型を含みます。")
    (CHAPTER ("## 参考") 2 (CODE1 "style-warning"))))
(setf (gethash '("WARNING" . "CONDITION-TYPE") *table*) (gethash "WARNING" *table*))
(setf (gethash "WHEN" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "WHEN") ", " (CODE1 "UNLESS"))
    (CHAPTER ("## 構文") 2 (CODE1 "when") " " (STRONG "test-form") " " (STRONG "form\\*")
     " => " (STRONG "result\\*") EOL1 (CODE1 "unless") " " (STRONG "test-form") " "
     (STRONG "form\\*") " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "test-form") " - フォーム" EOL1 (STRONG "form")
     " - 暗黙のprogn" EOL1 (STRONG "result") " - " (STRONG "test-form") "が" (STRONG "true")
     "のときは" (CODE1 "when") "フォーム内の" (STRONG "form") "の多値。" (STRONG "test-form") "が"
     (STRONG "false") "のときは" (CODE1 "unless") "フォーム内の" (STRONG "form") "の多値。" "それ以外は"
     (CODE1 "nil") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "when") "と" (CODE1 "unless") "は、" (STRONG "test-form")
     "単体に依存したフォームの実行を行います。" EOL2 (CODE1 "when") "のフォーム内において、" (STRONG "test-form") "が"
     (STRONG "true") "のときは、" (STRONG "form") "が左から右の順番で評価され、" "その" (STRONG "form") "の多値が"
     (CODE1 "when") "フォームからの返却値になります。" "一方、" (STRONG "test-form") "が" (STRONG "false")
     "のときは、" (STRONG "form") "は評価されず" (CODE1 "when") "フォームは" (CODE1 "nil") "を返却します。" EOL2
     (CODE1 "unless") "のフォーム内において、" (STRONG "test-form") "が" (STRONG "false") "のときは、"
     (STRONG "form") "が左から右の順番で評価され、" "その" (STRONG "form") "の多値が" (CODE1 "unless")
     "フォームからの返却値になります。" "一方、" (STRONG "test-form") "が" (STRONG "true") "のときは、"
     (STRONG "form") "は評価されず" (CODE1 "unless") "フォームは" (CODE1 "nil") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(when t 'hello) =>  HELLO" "(unless t 'hello) =>  NIL"
      "(when nil 'hello) =>  NIL" "(unless nil 'hello) =>  HELLO" "(when t) =>  NIL"
      "(unless nil) =>  NIL" "(when t (prin1 1) (prin1 2) (prin1 3))" ">>  123" "=>  3"
      "(unless t (prin1 1) (prin1 2) (prin1 3)) =>  NIL"
      "(when nil (prin1 1) (prin1 2) (prin1 3)) =>  NIL"
      "(unless nil (prin1 1) (prin1 2) (prin1 3))" ">>  123" "=>  3" "(let ((x 3))"
      "  (list (when (oddp x) (incf x) (list x))"
      "        (when (oddp x) (incf x) (list x))"
      "        (unless (oddp x) (incf x) (list x))"
      "        (unless (oddp x) (incf x) (list x))"
      "        (if (oddp x) (incf x) (list x)) "
      "        (if (oddp x) (incf x) (list x)) "
      "        (if (not (oddp x)) (incf x) (list x)) "
      "        (if (not (oddp x)) (incf x) (list x))))"
      "=>  ((4) NIL (5) NIL 6 (6) 7 (7))"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "and") "," (CODE1 "cond") "," (CODE1 "if") ","
     (CODE1 "or"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(when test {form}+) == (and test (progn {form}+))"
      "(when test {form}+) == (cond (test {form}+))"
      "(when test {form}+) == (if test (progn {form}+) nil)"
      "(when test {form}+) == (unless (not test) {form}+)"
      "(unless test {form}+) == (cond ((not test) {form}+))"
      "(unless test {form}+) == (if test nil (progn {form}+))"
      "(unless test {form}+) == (when (not test) {form}+)"))))
(setf (gethash '("WHEN" . "MACRO") *table*) (gethash "WHEN" *table*))
(setf (gethash "WILD-PATHNAME-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "WILD-PATHNAME-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "wild-pathname-p") " " (STRONG "pathname") " "
     (CODE1 "&optional") " " (STRONG "field-key") " => " (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "pathname") " - パス名指定子" EOL1 (STRONG "field-key")
     " - 次のうちのどれか。" (CODE1 ":host") ", " (CODE1 ":device") ", " (CODE1 ":directory") ", "
     (CODE1 ":name") ", " (CODE1 ":type") ", " (CODE1 ":version") "," "そして" (CODE1 "nil")
     EOL1 (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 (CODE1 "wild-pathname-p") "は、" (STRONG "pathname")
     "にワイルドカードの要素が現れるかどうかをテストします。" EOL2 "もし" (STRONG "pathname") "がパス名" "（"
     (CODE1 "pathname") "によって返却されたものとして）であり" "それがファイルのオープンに使用された名前であるとき、"
     "おそらくそれは、必須ではありませんが、実際のファイルの名前です。" EOL2 "もし" (STRONG "field-key") "が指定されないか、あるいは"
     (CODE1 "nil") "のとき、" (CODE1 "wild-pathname-p") "は" (STRONG "pathname")
     "にワイルドカードの要素が" "含まれているときは" (STRONG "true") "を返却し、" (STRONG "pathname")
     "にそれらが含まれていないときは" (CODE1 "nil") "を返却します。" "もし" (STRONG "field-key") "が"
     (CODE1 "nil") "ではないとき、" (CODE1 "wild-pathname-p") "は" (STRONG "pathname")
     "の指定された要素が" "ワイルドカードのときは" (STRONG "true") "を返却し、" "その要素にワイルドカードが含まれていないときは"
     (CODE1 "nil") "を返却します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" ";;; 下記の例は移植性がありません。これらは特定のファイルシステムの"
      ";;; 特定のワイルドカード表記で動作するように記述されています。" ";;; 他の実装では違った動作になるかもしれません。これらの例は"
      ";;; 説明のためのものであり、規範的なものではありません。" NIL
      "(wild-pathname-p (make-pathname :name :wild)) =>  true"
      "(wild-pathname-p (make-pathname :name :wild) :name) =>  true"
      "(wild-pathname-p (make-pathname :name :wild) :type) =>  false"
      "(wild-pathname-p (pathname \"s:>foo>**>\")) =>  true ;Lispm"
      "(wild-pathname-p (pathname :name \"F*O\")) =>  true ;Most places"))
    (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "もし" (STRONG "pathname") "がパス名、文字列、" "ファイルに関連付けられたストリームの、"
     "いずれの場合でもないときは、" "型" (CODE1 "type-error") "のエラーが発生します。")
    (CHAPTER ("## 参考") 2 (CODE1 "pathname") "," (CODE1 "logical-pathname") ","
     "20.1. ファイルシステムの説明," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "全ての実装が全ての要素にワイルドカードをサポートしているわけではありません。"
     "19.2.2.2.2. 要素の値としての:WILDと19.2.2.3. ワイルドカードのパス名の制限をご確認ください。")))
(setf (gethash '("WILD-PATHNAME-P" . "FUNCTION") *table*) (gethash "WILD-PATHNAME-P" *table*))
(setf (gethash "WITH-ACCESSORS" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "WITH-ACCESSORS"))
    (CHAPTER ("## 構文") 2 (CODE1 "with-accessors") " (" (STRONG "slot-entry\\*") ") "
     (STRONG "instance-form") " " (STRONG "declaration\\*") " " (STRONG "form\\*") "=> "
     (STRONG "result\\*") EOL1 (STRONG "slot-entry") " ::= (" (STRONG "variable-name")
     " " (STRONG "accessor-name") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "variable-name") " - 変数名、評価はされない" EOL1
     (STRONG "accessor-name") " - 関数名、評価はされない" EOL1 (STRONG "instance-form")
     " - フォーム、評価される" EOL1 (STRONG "declaration") " - 宣言式、評価はされない" EOL1 (STRONG "form")
     " - フォーム、暗黙のprogn" EOL1 (STRONG "result") " - フォームの返却値")
    (CHAPTER ("## 定義") 2 (STRONG "slot-entry") "によって指定されたスロットが、"
     "アクセッサを通して変数のように使用できるような" "レキシカルな環境が作成されます。" "マクロ" (CODE1 "with-accessors") "は"
     (STRONG "slot-entry") "で指定された" "スロットにアクセスするための適切なアクセッサを呼び出します。" "スロットの値を設定するために"
     (CODE1 "setf") "と" (CODE1 "setq") "の両方を使用することができます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defclass thing ()"
      "          ((x :initarg :x :accessor thing-x)"
      "           (y :initarg :y :accessor thing-y)))"
      "=>  #<STANDARD-CLASS THING 250020173>"
      "(defmethod (setf thing-x) :before (new-x (thing thing))"
      "  (format t \"~&Changing X from ~D to ~D in ~S.~%\""
      "          (thing-x thing) new-x thing))"
      "(setq thing1 (make-instance 'thing :x 1 :y 2)) =>  #<THING 43135676>"
      "(setq thing2 (make-instance 'thing :x 7 :y 8)) =>  #<THING 43147374>"
      "(with-accessors ((x1 thing-x) (y1 thing-y))" "                thing1"
      "  (with-accessors ((x2 thing-x) (y2 thing-y))" "                  thing2"
      "    (list (list x1 (thing-x thing1) y1 (thing-y thing1)"
      "                x2 (thing-x thing2) y2 (thing-y thing2))"
      "          (setq x1 (+ y1 x2))"
      "          (list x1 (thing-x thing1) y1 (thing-y thing1)"
      "                x2 (thing-x thing2) y2 (thing-y thing2))"
      "          (setf (thing-x thing2) (list x1))"
      "          (list x1 (thing-x thing1) y1 (thing-y thing1)"
      "                x2 (thing-x thing2) y2 (thing-y thing2)))))"
      ">>  Changing X from 1 to 9 in #<THING 43135676>."
      ">>  Changing X from 7 to (9) in #<THING 43147374>." "=>  ((1 1 2 2 7 7 8 8)"
      "    9" "    (9 9 2 2 7 7 8 8) " "    (9)" "    (9 9 2 2 (9) (9) 8 8))"))
    (CHAPTER ("## 影響") 2 (CODE1 "defclass"))
    (CHAPTER ("## 例外") 2 "もし" (STRONG "accessor-name") "がインスタンスのアクセッサの名前ではない場合は、"
     "結果は定義されていません。")
    (CHAPTER ("## 参考") 2 (CODE1 "with-slots") "," (CODE1 "symbol-macrolet"))
    (CHAPTER ("## 備考") 2 (CODE1 "with-accessors") "の下記のフォームについて、"
     (CODE3 "```lisp" "```"
      "(with-accessors (slot-entry1 ... slot-entryn) instance-form form1 ... formk)")
     EOL2 "これは、下記の展開と同等です。"
     (CODE3 "```lisp" "```" "(let ((in instance-form))"
      "  (symbol-macrolet (Q1 ... Qn) form1 ... formk))")
     EOL2 "ただし、" (CODE1 "Qi") "は下記のようになります。"
     (CODE3 "```lisp" "```" "(variable-namei () (accessor-namei in))"))))
(setf (gethash '("WITH-ACCESSORS" . "MACRO") *table*) (gethash "WITH-ACCESSORS" *table*))
(setf (gethash "WITH-CONDITION-RESTARTS" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "WITH-CONDITION-RESTARTS"))
    (CHAPTER ("## 構文") 2 (CODE1 "with-condition-restarts") " " (STRONG "condition-form")
     " " (STRONG "restarts-form") " " (STRONG "form\\*") EOL1 "=> " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "condition-form") " - フォーム。評価されて"
     (STRONG "condition") "を生成します。" EOL1 (STRONG "condition") " - "
     (STRONG "condition-form") "の評価結果のコンディションオブジェクト" EOL1 (STRONG "restart-form")
     " - フォーム。評価されて" (STRONG "restart-list") "を生成します。" EOL1 (STRONG "restart-list") " - "
     (STRONG "restart-form") "の評価結果の" (CODE1 "restart") "オブジェクトのリスト" EOL1 (STRONG "form")
     " - 暗黙のprogn。評価されます。" EOL1 (STRONG "result") " - " (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 "最初に" (STRONG "condition-form") "と" (STRONG "restart-form") "が"
     "通常の左から右の順に評価され、" "それらの評価の主値がそれぞれ" (STRONG "condition") "と" (STRONG "restart-list")
     "に対応します。" EOL2 "次に" (STRONG "condition") "に対応する" (STRONG "restart-list") "内の各"
     (CODE1 "restart") "がある" "動的環境下で" (STRONG "form") "が評価されます。" "9.1.4.2.4. コンディションと"
     (CODE1 "restart") "の関連付けをご確認ください。")
    (CHAPTER ("## 例文") 2 "なし。") (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "restart-case"))
    (CHAPTER ("## 備考") 2 (CODE1 "restart-case") "の捕捉が" "この機能を文法的により簡潔にあらわす"
     "もっとも一般的な場合であり、" "通常このマクロはコードに明確に使用されません。")))
(setf (gethash '("WITH-CONDITION-RESTARTS" . "MACRO") *table*) (gethash "WITH-CONDITION-RESTARTS" *table*))
(setf (gethash "WITH-HASH-TABLE-ITERATOR" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "WITH-HASH-TABLE-ITERATOR"))
    (CHAPTER ("## 構文") 2 (CODE1 "with-hash-table-iterator") " (" (STRONG "name") " "
     (STRONG "hash-table") ") " (STRONG "declaration\\*") " " (STRONG "form\\*") " => "
     (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - " (CODE1 "macrolet") "の最初の引数として適切な名前"
     EOL1 (STRONG "hash-table") " - フォーム。" "一度だけ評価され、ハッシュテーブルを生成しなければなりません。" EOL1
     (STRONG "declaration") " - 宣言式。評価されません。" EOL1 (STRONG "form") " - 暗黙のprogn" EOL1
     (STRONG "result") " - " (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 "ボディ部のレキシカルスコープ内で" (STRONG "name") "が" (CODE1 "macrolet")
     "によって定義され、" "連続した" (CODE1 "(name)") "の実行は、" "ハッシュテーブルからの要素がひとつひとつ返却されます。"
     "ハッシュテーブルは" (STRONG "hash-table") "が一度だけ評価されることによって得られます。" EOL2 (CODE1 "(name)")
     "の実行は、下記に示す3つの値が返却されます。" EOL2 "1. エントリーが返却されたときに" (STRONG "true")
     "を返すgeneralized-boolean" "2. " (STRONG "hash-table") "のエントリーのキー" "3. "
     (STRONG "hash-table") "のエントリーの値" EOL2 "連続した" (CODE1 "(name)") "の実行によって"
     "全てのエントリーが返却された後は、" "ただひとつだけの値" (CODE1 "nil") "が返却されます。" EOL2 "もし繰り返しの何らかの暗黙的な内部状態が"
     "クロージャーで起動フォームを囲んだ返却値などによって" (CODE1 "with-hash-table-iterator") "フォームの"
     "動的エクステントの外側で返却されたときに" "何が起こるかは指定されていません。" EOL2 (CODE1 "with-hash-table-iterator")
     "はいくつでもネストすることが可能であり、" "もっとも内側のボディ部は、" "これら全てのマクロが違う名前を持っているようなときは、"
     "確立されたローカルマクロの全てを起動することができます。")
    (CHAPTER ("## 例文") 2 "下記の関数はどんなハッシュテーブルでも" (CODE1 "t") "を返却し、" "もし"
     (CODE1 "with-hash-table-iterator") "の使用が、" "対応する" (CODE1 "maphash")
     "の使用に合っていないときはエラーが発生します。"
     (CODE3 "```lisp" "```" "(defun test-hash-table-iterator (hash-table)"
      "  (let ((all-entries '())" "        (generated-entries '())"
      "        (unique (list nil)))"
      "    (maphash #'(lambda (key value) (push (list key value) all-entries))"
      "             hash-table)"
      "    (with-hash-table-iterator (generator-fn hash-table)" "      (loop     "
      "        (multiple-value-bind (more? key value) (generator-fn)"
      "          (unless more? (return))"
      "          (unless (eql value (gethash key hash-table unique))"
      "            (error \"Key ~S not found for value ~S\" key value))"
      "          (push (list key value) generated-entries))))"
      "    (unless (= (length all-entries)" "               (length generated-entries)"
      "               (length (union all-entries generated-entries"
      "                              :key #'car :test (hash-table-test hash-table))))"
      "      (error \"Generated entries and Maphash entries don't correspond\"))"
      "    t))")
     EOL2 "下記のものは" (CODE1 "with-hash-table-iterator") "によって実装された、" "適切な"
     (CODE1 "maphash") "の定義です。"
     (CODE3 "```lisp" "```" "(defun maphash (function hash-table)"
      "  (with-hash-table-iterator (next-entry hash-table)"
      "    (loop (multiple-value-bind (more key value) (next-entry)"
      "            (unless more (return nil))"
      "            (funcall function key value)))))"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (CODE1 "with-hash-table-iterator") "によって確立された" (STRONG "name")
     "というローカル関数は、" "それが第一返却値として" (STRONG "false") "を返却したあとに" "呼び出された結果は未定義です。")
    (CHAPTER ("## 参考") 2 "3.6. 横断の規則と副作用") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("WITH-HASH-TABLE-ITERATOR" . "MACRO") *table*) (gethash "WITH-HASH-TABLE-ITERATOR" *table*))
(setf (gethash "WITH-INPUT-FROM-STRING" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "WITH-INPUT-FROM-STRING"))
    (CHAPTER ("## 構文") 2 (CODE1 "with-input-from-string") " " (CODE1 "(") (STRONG "var")
     " " (STRONG "string") " " (CODE1 "&key") " " (STRONG "index") " " (STRONG "start")
     " " (STRONG "end") (CODE1 ")") " " (STRONG "declaration\\*") " " (STRONG "form\\*")
     " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - 変数名" EOL1 (STRONG "string")
     " - フォーム。評価され文字列を生成します。" EOL1 (STRONG "index") " - " (CODE1 "place") EOL1
     (STRONG "start") ", " (STRONG "end") " - " (STRONG "string") "の境界インデックス指定子。"
     "デフォルトは" (STRONG "start") ", " (STRONG "end") "それぞれ" (CODE1 "0") "と" (CODE1 "nil")
     "。" EOL1 (STRONG "declaration") " - 宣言式。評価されません。" EOL1 (STRONG "form") " - 暗黙のprogn"
     EOL1 (STRONG "result") " - " (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 "入力の文字列ストリームを作成し、" "ストリーム上の操作を実行する機会を提供し" "（ゼロか複数の値を返却します）、"
     "そして文字列ストリームをクローズします。" EOL2 (STRONG "string") "は最初に評価され、" "結果の文字列を" (STRONG "start")
     "と" (STRONG "end") "で囲った部分文字列から、" "文字を提供する文字型の入力の文字列ストリームを" (STRONG "var") "に束縛します。"
     EOL2 "入力の文字列ストリームは" (CODE1 "with-input-from-string") "から"
     "退出したときに通常時と非通常時に関わらず自動的にクローズされます。" "変数" (STRONG "var")
     "に束縛された入力の文字列ストリームは動的エクステントを持ち、" "フォームから退出されたときにエクステントは終了します。" EOL2 (STRONG "index")
     "は" (STRONG "string") "内で前進したポインターです。" "もし" (CODE1 "with-input-from-string")
     "が通常の退出をしたとき、" (STRONG "index") "には" (STRONG "string")
     "の最初に読まなくなった文字を示すインデックスの値を持っており" "もし全ての文字が使用されたときは" (CODE1 "(length string)")
     "になります。" (STRONG "index") "によって指定された" (CODE1 "place") "は"
     "読み込み進行時だけではなく操作の終わりにも更新されます。" EOL2 (STRONG "start") "と" (STRONG "index")
     "はおそらくどちらも同じ変数であり、" "これは" (STRONG "string") "内の前進を行うポインターを示しており、"
     "おそらくは何らかのループに含まれて繰り返されます。" EOL2 "変数" (STRONG "var") "に代入しようとしたときの結果は未定義です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-input-from-string (s \"XXX1 2 3 4xxx\""
      "                            :index ind"
      "                            :start 3 :end 10)"
      "   (+ (read s) (read s) (read s))) =>  6" "ind =>  9"
      "(with-input-from-string (s \"Animal Crackers\" :index j :start 6)"
      "  (read s)) =>  CRACKERS")
     EOL2 "変数" (CODE1 "j") "は" (CODE1 "15") "が設定されます。")
    (CHAPTER ("## 副作用") 2 (STRONG "index") "によって名前付けられた" (CODE1 "place") "の値は、"
     "必要なら修正されます。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-string-input-stream") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("WITH-INPUT-FROM-STRING" . "MACRO") *table*) (gethash "WITH-INPUT-FROM-STRING" *table*))
(setf (gethash "WITH-OPEN-FILE" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "WITH-OPEN-FILE"))
    (CHAPTER ("## 構文") 2 (CODE1 "with-open-file") " " (CODE1 "(") " " (STRONG "stream")
     "  " (STRONG "filespec") " " (STRONG "options\\*") " " (CODE1 ")") " "
     (STRONG "declaration\\*") " " (STRONG "form\\*") " => " (STRONG "result"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "stream") " - 変数" EOL1 (STRONG "filespec")
     " - パス名指定子" EOL1 (STRONG "options") " -- フォーム。評価されます。" EOL1 (STRONG "declaration")
     " - 宣言式。評価されません。" EOL1 (STRONG "form") " - 暗黙のprogn" EOL1 (STRONG "result") " - "
     (STRONG "form") "による返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "with-open-file") "は、" (CODE1 "open") "を使い"
     (STRONG "filespec") "によって名前付けられたファイルの" "ファイルストリームを作成します。" (STRONG "filespec")
     "は開かれるファイルの名前です。" (STRONG "options") "は" (CODE1 "open") "のキーワード引数として使われます。" EOL2
     (STRONG "stream") "変数に束縛されるストリームオブジェクトは" "動的エクステントを持っており、"
     "その範囲はフォームから退出が行われたときに終了します。" EOL2 (CODE1 "with-open-file") "は、" (CODE1 "open")
     "の返却値を" (STRONG "stream") "に束縛して、" (STRONG "form") "を暗黙のprognとして評価します。" EOL2
     "通常の場合か普通ではない方法（例えば" (CODE1 "throw") "の使用によるもの）のどちらかで" "ボディ部から制御が出るとき、"
     "ファイルは自動的にクローズされます。" "もし新しい出力ファイルが書き込みを始めてから" "制御が普通ではない方法で退出したとき、" "そのファイルは中断され、"
     "ファイルシステムを可能な限り" "そのファイルがオープンされていなかったかのようにします。" EOL2 (CODE1 ":if-exists nil") "か"
     (CODE1 ":if-does-not-exist nil") "を使用することで、" (STRONG "stream") "に" (CODE1 "nil")
     "を束縛することができます。" "ユーザーが" (CODE1 ":if-does-not-exist nil") "を使うときは、"
     "ストリームが有効かどうかチェックする必要があります。" EOL2 (STRONG "stream") "変数に代入を仕様とした結果は定義されていません。"
     "もしそのような試行を検出したとき、" "コンパイラーは警告を出力するかもしれません。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq p (merge-pathnames \"test\"))"
      "=>  #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY directory-name"
      "   :NAME \"test\" :TYPE NIL :VERSION :NEWEST>"
      "(with-open-file (s p :direction :output :if-exists :supersede)"
      "   (format s \"Here are a couple~%of test data lines~%\")) =>  NIL"
      "(with-open-file (s p)" "   (do ((l (read-line s) (read-line s nil 'eof)))"
      "       ((eq l 'eof) \"Reached end of file.\")" "    (format t \"~&*** ~A~%\" l)))"
      ">>  *** Here are a couple" ">>  *** of test data lines"
      "=>  \"Reached end of file.\"" ";; 通常はこのように不明瞭なことを意図的には実行しません。"
      ";; しかし例の通り:IF-DOES-NOT-EXIST NILをうっかり" ";; 使ってしまうことがないように注意してください。"
      "(with-open-file (foo \"no-such-file\" :if-does-not-exist nil)" "  (read foo))"
      ">>  hello?" "=>  HELLO? ;この値はterminalからreadしたもので、ファイルではない！" NIL
      ";; ここにも避けるべきバグがあります。"
      "(with-open-file (foo \"no-such-file\" :direction :output :if-does-not-exist nil)"
      "  (format foo \"Hello\"))" "=>  \"Hello\" ;FORMATは引数にNILを受け取る！"))
    (CHAPTER ("## 副作用") 2 (STRONG "filespec") "による名前のファイルへのストリームを作成し（入るとき）、"
     "そのストリームをクローズします（退出するとき）。" "ある実装では、ファイルを開いている間に" "何らかの方法でロックするかもしれません。"
     "もしストリームが出力ストリームのとき、ファイルは作成されます。")
    (CHAPTER ("## 影響") 2 "ホストコンピューターのファイルシステム")
    (CHAPTER ("## 例外") 2 (CODE1 "open") "関数をご確認ください。")
    (CHAPTER ("## 参考") 2 (CODE1 "open") "," (CODE1 "close") "," (CODE1 "pathname") ","
     (CODE1 "logical-pathname") "," "19.1.2. ファイル名としてのパス名")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("WITH-OPEN-FILE" . "MACRO") *table*) (gethash "WITH-OPEN-FILE" *table*))
(setf (gethash "WITH-OPEN-STREAM" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "WITH-OPEN-STREAM"))
    (CHAPTER ("## 構文") 2 (CODE1 "with-open-stream") " " (CODE1 "(") (STRONG "var") " "
     (STRONG "stream") (CODE1 ")") " " (STRONG "declaration\\*") " " (STRONG "form\\*")
     EOL1 " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - 変数名" EOL1 (STRONG "stream")
     " - フォーム。評価されストリームが生成されます。" EOL1 (STRONG "declaration") " - 宣言式。評価されません。" EOL1
     (STRONG "form") " - 暗黙のprogn" EOL1 (STRONG "result") " - " (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "with-open-stream") "は、" (STRONG "stream") "の一連の操作を実行し、"
     "値を返却し、そして" (STRONG "stream") "をクローズします。" EOL2 (STRONG "var") "は" (STRONG "stream")
     "の値を束縛し、" "それから" (STRONG "form") "が暗黙のprognとして実行されます。" (STRONG "stream") "は"
     (CODE1 "with-open-stream") "から退出するときに、" "退出が通常時か非通常時に関わらず" "どんな時でも自動的に閉じられます。"
     (STRONG "stream") "は動的エクステントであり、" (STRONG "form") "から退出されたときに" "そのエクステントは終了します。"
     EOL2 (STRONG "form") "内で変数" (STRONG "var") "に代入を施行したときの結果は未定義です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(with-open-stream (s (make-string-input-stream \"1 2 3 4\"))"
      "   (+ (read s) (read s) (read s))) =>  6"))
    (CHAPTER ("## 副作用") 2 (STRONG "stream") "は（退出時に）クローズされます。")
    (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "close")) (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("WITH-OPEN-STREAM" . "MACRO") *table*) (gethash "WITH-OPEN-STREAM" *table*))
(setf (gethash "WITH-OUTPUT-TO-STRING" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "WITH-OUTPUT-TO-STRING"))
    (CHAPTER ("## 構文") 2 (CODE1 "with-output-to-string") " " (CODE1 "(") (STRONG "var")
     " " (CODE1 "&optional") " " (STRONG "string-form") " " (CODE1 "&key") " "
     (STRONG "element-type") (CODE1 ")") " " (STRONG "declaration\\*") " "
     (STRONG "form\\*") " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "var") " - 変数名" EOL1 (STRONG "string-form")
     " - フォームか" (CODE1 "nil") "。" "もし" (CODE1 "nil") "ではないとき、" "評価されて" (STRONG "string")
     "が生成されます。" EOL1 (STRONG "string") " - fill-pointerを持つ文字列" EOL1
     (STRONG "element-type") " - 型指定子。デフォルトは" (CODE1 "character") "。" EOL1
     (STRONG "declaration") " - 宣言式。評価されません。" EOL1 (STRONG "form") " - 暗黙のprogn" EOL1
     (STRONG "result") " - もし" (STRONG "string-form") "が指定されていないか" (CODE1 "nil")
     "のときは文字列、" "それ以外のときは" (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 (CODE1 "with-output-to-string") "は文字列の出力ストリームを作成し、"
     "一連のストリームに結果を送信するであろう操作を実行し、" "そしてそのストリームをクローズします。" EOL2 (STRONG "element-type")
     "はストリームの要素の型を示す名前であり、" "ストリームは指定された型の要素を収容できるような" "特定化した型で構築されなければなりません。" EOL2
     "暗黙のprognとして実行されるボディ部は、" "出力の文字列ストリームを" (STRONG "var") "に束縛します。"
     "文字列ストリームへの全ての出力は文字列内に保存されます。" EOL2 "もし" (STRONG "string") "が指定されたとき、"
     (STRONG "element-type") "は無視され、" "そして出力は" (STRONG "string") "に対して"
     (CODE1 "vector-push-extend") "を使用したかのように" "蓄積するように追加されていきます。" EOL2 "出力の文字列ストリームは"
     (CODE1 "with-output-to-string") "から" "退出したときに通常時と非通常時に関わらず自動的にクローズされます。" "変数"
     (STRONG "var") "に束縛された出力の文字列ストリームは動的エクステントを持ち、" "フォームから退出されたときにエクステントは終了します。" EOL2
     "もし" (STRONG "string") "が指定されなかったとき、" (CODE1 "with-output-to-string")
     "は文字列を受け付けるストリームを提供し、" (STRONG "element-type") "で示された文字列を返却します。" "もし"
     (STRONG "string") "が指定されたとき、" (CODE1 "with-output-to-string") "は最後の" (STRONG "form")
     "が" "評価された結果を返却します。" EOL2 "変数" (STRONG "var") "に代入しようとしたときの結果は未定義です。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(setq fstr (make-array '(0) :element-type 'base-char"
      "                            :fill-pointer 0 :adjustable t)) =>  \"\""
      "(with-output-to-string (s fstr)" "   (format s \"here's some output\")"
      "   (input-stream-p s)) =>  false" "fstr =>  \"here's some output\""))
    (CHAPTER ("## 副作用") 2 (STRONG "string") "は修正されます。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 "この呼び出しの動的エクステント内で" "直接" (STRONG "string")
     "に対して破壊的修正を行ったときの結果は未定義です。")
    (CHAPTER ("## 参考") 2 (CODE1 "make-string-output-stream") ","
     (CODE1 "vector-push-extend") "," "3.6. 横断の規則と副作用")
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("WITH-OUTPUT-TO-STRING" . "MACRO") *table*) (gethash "WITH-OUTPUT-TO-STRING" *table*))
(setf (gethash "WITH-PACKAGE-ITERATOR" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "WITH-PACKAGE-ITERATOR"))
    (CHAPTER ("## 構文") 2 (CODE1 "with-package-iterator") " (" (STRONG "name") " "
     (STRONG "package-list-form") " " (CODE1 "&rest") " " (STRONG "symbol-types") ") "
     (STRONG "declaration\\*") " " (STRONG "form\\*") EOL1 " => " (STRONG "result\\*"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - シンボル" EOL1 (STRONG "package-list-form")
     " - フォーム。いちど評価されて" (STRONG "package-list") "を生成します。" EOL1 (STRONG "package-list")
     " - パッケージ指定子のリストの指定子" EOL1 (STRONG "symbol-types") " - 次のシンボルのうちの一つ、"
     (CODE1 ":internal") ", " (CODE1 ":external") ", " (CODE1 ":inherited") "。" EOL1
     (STRONG "declaration") " - 宣言式。評価されません。" EOL1 (STRONG "form") " - 暗黙のprogn" EOL1
     (STRONG "result") " - " (STRONG "form") "の返却値")
    (CHAPTER ("## 定義") 2 (STRONG "form") "のボディ部のレキシカルスコープ内で" (STRONG "name") "が"
     (CODE1 "macrolet") "によって定義され、" (CODE1 "(name)") "が連続して呼び出されたときに、"
     (STRONG "package-list") "のパッケージからシンボルがひとつずつ返却されます。" EOL2 "パッケージが複数継承されていたもののシンボルが"
     "一度ではなく複数にわたって返却されるかどうかは指定されていません。" "返却されるシンボルの順番は、" (STRONG "package-list")
     "のパッケージの順番を反映する必要はありません。" "もし" (STRONG "package-list") "に複数の要素があったときは、"
     "シンボルがひとつ返却されるか複数回返却されるかは指定されていません。" EOL2 (STRONG "symbol-types")
     "はパッケージのアクセス可能なシンボルに対して、" "次のような返却の制御を行います。" EOL2 "- " (CODE1 ":internal")
     "  - シンボルはパッケージに現れるものですが、" (CODE1 "export") "ではありません。" "- " (CODE1 ":external")
     "  - シンボルはパッケージに現れるものと、" (CODE1 "export") "の両方です。" "- " (CODE1 ":inherited")
     "  - シンボルは" (CODE1 "use") "されているパッケージの外部シンボルですが、" "    " (CODE1 "shadow")
     "はされていないものです。" EOL2 (STRONG "symbol-types") "にひとつ以上の引数が指定されたときは、" "シンボルのアクセスが指定された"
     (STRONG "symbol-types") "のうちのどれかにマッチするものが返却されます。" "実装はこの構文に追加で認識可能なシンボルのアクセス型を"
     "拡張するかもしれません。" EOL2 (CODE1 "(name)") "の起動は、下記のような4つの値を返却します。" EOL2
     "1. シンボルが返却されたかどうかを示すフラグ（" (STRONG "true") "ならシンボルが返却された）。"
     "2. シンボルであり指定したパッケージのひとつからアクセスしたもの。" "3. シンボルのアクセスの型である次のどれか" (CODE1 ":internal")
     ", " (CODE1 ":external") ", " (CODE1 ":inherited") "。" "4. パッケージであり、シンボルが得られた場所。"
     "パッケージは" (STRONG "package-list") "内にパッケージとして現れたものか" "あるいはその名前のひとつ。" EOL2
     (CODE1 "(name)") "の連続の呼び出しによって" "全てのシンボルが返却されたあとは、" "ただひとつの値である" (CODE1 "nil")
     "のみが返却されます。" EOL2 "返却値の第2、第3、第4の意味は、" "以下で示される第2返却値の内容で、"
     "返却されたシンボルが返却されたパッケージでアクセス可能ということです。" EOL2 "- " (CODE1 ":internal") "  - 現れたシンボルは"
     (CODE1 "export") "ではない。" "- " (CODE1 ":external") "  - 現れたシンボルは" (CODE1 "export")
     "されている。" "- " (CODE1 ":inherited") "  - シンボルは現れてない（したがって" (CODE1 "shadow") "でもない）が、"
     "    " (CODE1 "use") "されたいくつかのパッケージから継承されている。" EOL2 "呼び出しフォームを囲った何かのクロージャーを返すなどして、"
     (CODE1 "with-package-iterator") "フォームの動的エクステントの外で" "繰り返しの暗黙の内部状態の何かが返却された場合には、"
     "何が起こるは規定されていません。" EOL2 (CODE1 "with-package-iterator") "はいくつでもネストすることができ、"
     "それらの全てのマクロが違う名前を持つ場合は、" "もっとも内側のボディ部では" "確立されたすべてのローカルマクロを起動することができます。")
    (CHAPTER ("## 例文") 2 "下記の関数はどんなパッケージでも" (CODE1 "t") "を返却し、" "もし"
     (CODE1 "with-package-iterator") "の使用で" "対応する" (CODE1 "do-symbols") "の使用が合意されなかったときは"
     "エラーが発生します。"
     (CODE3 "```lisp" "```" "(defun test-package-iterator (package)"
      "  (unless (packagep package)" "    (setq package (find-package package)))"
      "  (let ((all-entries '())" "        (generated-entries '()))"
      "    (do-symbols (x package) " "      (multiple-value-bind (symbol accessibility) "
      "          (find-symbol (symbol-name x) package)"
      "        (push (list symbol accessibility) all-entries)))"
      "    (with-package-iterator (generator-fn package "
      "                            :internal :external :inherited)" "      (loop     "
      "        (multiple-value-bind (more? symbol accessibility pkg)"
      "            (generator-fn)" "          (unless more? (return))"
      "          (let ((l (multiple-value-list (find-symbol (symbol-name symbol) "
      "                                                     package))))"
      "            (unless (equal l (list symbol accessibility))"
      "              (error \"Symbol ~S not found as ~S in package ~A [~S]\""
      "                     symbol accessibility (package-name package) l))"
      "            (push l generated-entries)))))"
      "    (unless (and (subsetp all-entries generated-entries :test #'equal)"
      "                 (subsetp generated-entries all-entries :test #'equal))"
      "     (error \"Generated entries and Do-Symbols entries don't correspond\"))"
      "    t))")
     EOL2 "下記の関数は全ての現れるシンボルを印刷します（複数回の可能性があります）。"
     (CODE3 "```lisp" "```" "(defun print-all-symbols () "
      "  (with-package-iterator (next-symbol (list-all-packages)"
      "                          :internal :external)" "    (loop"
      "      (multiple-value-bind (more? symbol) (next-symbol)" "        (if more? "
      "           (print symbol)" "           (return))))))"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "symbol-types") "が指定されなかったか、" (STRONG "symbol-types")
     "のどれかが実装では認識できないものが指定されたときは、" (CODE1 "with-package-iterator") "は型"
     (CODE1 "program-error") "のエラーを通知します。" EOL2 (CODE1 "with-package-iterator")
     "によって確立された" (STRONG "name") "という名前のローカル関数が、" "その主値が" (STRONG "false") "を返却したあとで"
     "呼び出されたときの結果は未定義です")
    (CHAPTER ("## 参考") 2 "3.6. 横断の規則と副作用") (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("WITH-PACKAGE-ITERATOR" . "MACRO") *table*) (gethash "WITH-PACKAGE-ITERATOR" *table*))
(setf (gethash "WITH-SIMPLE-RESTART" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "WITH-SIMPLE-RESTART"))
    (CHAPTER ("## 構文") 2 (CODE1 "with-simple-restart") " (" (STRONG "name") " "
     (STRONG "format-control") " " (STRONG "format-argument\\*") ") " (STRONG "form\\*")
     EOL1 "=> " (STRONG "result"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "name") " - シンボル" EOL1 (STRONG "format-control")
     " - format-control" EOL1 (STRONG "format-argument") " - オブジェクト（これはformat-arguments）"
     EOL1 (STRONG "form") " - 暗黙のprogn" EOL1 (STRONG "result") " - 通常の状況では"
     (STRONG "form") "による返却値であり、" (STRONG "name") "という" (CODE1 "restart")
     "が起動されたことによる例外的な状況では、" "2つの値" (CODE1 "nil") "と" (CODE1 "t") "が返却されます。")
    (CHAPTER ("## 定義") 2 (CODE1 "with-simple-restart") "は" (CODE1 "restart") "を確立します。"
     EOL2 "もし" (STRONG "name") "で指定された" (CODE1 "restart") "が" (STRONG "form")
     "実行中に起動されなかったら、" (STRONG "form") "の最後から返却される全ての値が返却されます。" "もし" (STRONG "name")
     "で指定された" (CODE1 "restart") "が" (STRONG "form") "実行中に起動されたら、" "制御は"
     (CODE1 "with-simple-restart") "へ遷移し、" "2つの値" (CODE1 "nil") "と" (CODE1 "t")
     "が返却されます。" EOL2 "もし" (STRONG "name") "が" (CODE1 "nil") "のとき、" "匿名の"
     (CODE1 "restart") "が確立されます。" EOL2 (STRONG "format-control") "と"
     (STRONG "format-argument") "は、" (CODE1 "restart") "の報告のときに使用されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defun read-eval-print-loop (level)"
      "  (with-simple-restart (abort \"Exit command level ~D.\" level)" "    (loop"
      "      (with-simple-restart (abort \"Return to command level ~D.\" level)"
      "        (let ((form (prog2 (fresh-line) (read) (fresh-line))))"
      "          (prin1 (eval form)))))))" "=>  READ-EVAL-PRINT-LOOP"
      "(read-eval-print-loop 1)" "(+ 'a 3)"
      ">>  Error: The argument, A, to the function + was of the wrong type."
      ">>         The function expected a number."
      ">>  To continue, type :CONTINUE followed by an option number:"
      ">>   1: Specify a value to use this time." ">>   2: Return to command level 1."
      ">>   3: Exit command level 1." ">>   4: Return to Lisp Toplevel."
      "(defun compute-fixnum-power-of-2 (x)"
      "  (with-simple-restart (nil \"Give up on computing 2^~D.\" x)"
      "    (let ((result 1))" "      (dotimes (i x result)"
      "        (setq result (* 2 result))" "        (unless (fixnump result)"
      "          (error \"Power of 2 is too large.\"))))))" "COMPUTE-FIXNUM-POWER-OF-2"
      "(defun compute-power-of-2 (x)"
      "  (or (compute-fixnum-power-of-2 x) 'something big))" "COMPUTE-POWER-OF-2"
      "(compute-power-of-2 10)" "1024" "(compute-power-of-2 10000)"
      ">>  Error: Power of 2 is too large."
      ">>  To continue, type :CONTINUE followed by an option number."
      ">>   1: Give up on computing 2^10000." ">>   2: Return to Lisp Toplevel"
      ">>  Debug> :continue 1" "=>  SOMETHING-BIG"))
    (CHAPTER ("## 副作用") 2 "なし。") (CHAPTER ("## 影響") 2 "なし。") (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "restart-case"))
    (CHAPTER ("## 備考") 2 (CODE1 "with-simple-restart") "は、" "もっとも一般的に使用される"
     (CODE1 "restart-case") "の" "短縮形のひとつです。" EOL2 (CODE1 "with-simple-restart")
     "は次のように定義できます。"
     (CODE3 "```lisp" "```" "(defmacro with-simple-restart ((restart-name format-control"
      "                                             &rest format-arguments)"
      "                               &body forms)" "  `(restart-case (progn ,@forms)"
      "     (,restart-name ()" "         :report (lambda (stream)"
      "                   (format stream ,format-control ,@format-arguments))"
      "        (values nil t))))")
     EOL2 "例外的な状況では第二返却値が" (CODE1 "t") "になるため、" "通常の場合は第二返却値を省略するか" (CODE1 "nil") "にして、"
     "2つの状況を区別できるようにするのが一般的です（ただし必須ではありません）。")))
(setf (gethash '("WITH-SIMPLE-RESTART" . "MACRO") *table*) (gethash "WITH-SIMPLE-RESTART" *table*))
(setf (gethash "WITH-SLOTS" *table*)
  '((CHAPTER NIL 0 "Macro " (CODE1 "WITH-SLOTS"))
    (CHAPTER ("## 構文") 2 (CODE1 "with-slots") " (" (STRONG "slot-entry\\*") ") "
     (STRONG "instance-form") " " (STRONG "declaration\\*") " " (STRONG "form\\*") "=> "
     (STRONG "result\\*") EOL1 (STRONG "slot-entry") " ::= " (STRONG "slot-name") " "
     (CODE1 "|") " (" (STRONG "variable-name") " " (STRONG "slot-name") ")")
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "slot-name") " - スロット名、評価はされない" EOL1
     (STRONG "variable-name") " - 変数名、評価はされない" EOL1 (STRONG "instance-form")
     " - フォーム、評価されて" (STRONG "instance") "が生成される" EOL1 (STRONG "instance") " - オブジェクト"
     EOL1 (STRONG "declaration") " - 宣言式、評価はされない" EOL1 (STRONG "form") " - フォーム、暗黙のprogn"
     EOL1 (STRONG "result") " - フォームの返却値")
    (CHAPTER ("## 定義") 2 "マクロ" (CODE1 "with-slots") "は、" (STRONG "slot-name") "で指定された"
     (STRONG "instance") "のスロットを、" "変数のように参照するためのレキシカルな環境が作成されます。" "このような文脈では、スロットの値は、"
     "レキシカルに束縛された変数のように、" "そのスロット名を使用して使うことができます。" "スロットの値を設定するために" (CODE1 "setf") "と"
     (CODE1 "setq") "の両方を使用することができます。" EOL2 "マクロ" (CODE1 "with-slots")
     "は、スロット名が変数として現れるところを、" (CODE1 "slot-value") "の呼び出しに変換します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(defclass thing ()"
      "          ((x :initarg :x :accessor thing-x)"
      "           (y :initarg :y :accessor thing-y)))"
      "=>  #<STANDARD-CLASS THING 250020173>"
      "(defmethod (setf thing-x) :before (new-x (thing thing))"
      "  (format t \"~&Changing X from ~D to ~D in ~S.~%\""
      "          (thing-x thing) new-x thing))"
      "(setq thing (make-instance 'thing :x 0 :y 1)) =>  #<THING 62310540>"
      "(with-slots (x y) thing (incf x) (incf y)) =>  2"
      "(values (thing-x thing) (thing-y thing)) =>  1, 2"
      "(setq thing1 (make-instance 'thing :x 1 :y 2)) =>  #<THING 43135676>"
      "(setq thing2 (make-instance 'thing :x 7 :y 8)) =>  #<THING 43147374>"
      "(with-slots ((x1 x) (y1 y))" "            thing1" "  (with-slots ((x2 x) (y2 y))"
      "              thing2" "    (list (list x1 (thing-x thing1) y1 (thing-y thing1)"
      "                x2 (thing-x thing2) y2 (thing-y thing2))"
      "          (setq x1 (+ y1 x2))"
      "          (list x1 (thing-x thing1) y1 (thing-y thing1)"
      "                x2 (thing-x thing2) y2 (thing-y thing2))"
      "          (setf (thing-x thing2) (list x1))"
      "          (list x1 (thing-x thing1) y1 (thing-y thing1)"
      "                x2 (thing-x thing2) y2 (thing-y thing2)))))"
      ">>  Changing X from 7 to (9) in #<THING 43147374>." "=>  ((1 1 2 2 7 7 8 8)"
      "     9" "     (9 9 2 2 7 7 8 8) " "     (9)" "     (9 9 2 2 (9) (9) 8 8))"))
    (CHAPTER ("## 影響") 2 (CODE1 "defclass"))
    (CHAPTER ("## 例外") 2 "もし" (STRONG "slot-name") "が" (STRONG "instance")
     "のスロット名ではない場合は、" "結果は定義されていません。")
    (CHAPTER ("## 参考") 2 (CODE1 "with-accessors") "," (CODE1 "slot-value") ","
     (CODE1 "symbol-macrolet"))
    (CHAPTER ("## 備考") 2 (CODE1 "with-slots") "の下記のフォームについて、"
     (CODE3 "```lisp" "```"
      "(with-slots (slot-entry1 ... slot-entryn) instance-form form1 ... formk)")
     EOL2 "これは、下記の展開と同等です。"
     (CODE3 "```lisp" "```" "(let ((in instance-form))"
      "  (symbol-macrolet (Q1 ... Qn) form1 ... formk))")
     EOL2 "ただし、" (CODE1 "Qi") "は下記のようになります。"
     (CODE3 "```lisp" "```" "(slot-entryi () (slot-value in 'slot-entryi))") EOL2 "もし"
     (STRONG "slot-entry_i") "がシンボルなら次のようになります。"
     (CODE3 "```lisp" "```" "(variable-namei () (slot-value in 'slot-namei))") EOL2 "もし"
     (STRONG "slot-entry_i") "がフォームなら次のようになります。"
     (CODE3 "```lisp" "```" "(variable-namei 'slot-namei)"))))
(setf (gethash '("WITH-SLOTS" . "MACRO") *table*) (gethash "WITH-SLOTS" *table*))
(setf (gethash "WRITE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "WRITE") ", " (CODE1 "PRIN1") ", " (CODE1 "PRINT")
     ", " (CODE1 "PPRINT") ", " (CODE1 "PRINC"))
    (CHAPTER ("## 構文") 2 (CODE1 "write") " " (STRONG "object") " " (CODE1 "&key") " "
     (STRONG "array") " " (STRONG "base") " " (STRONG "case") " " (STRONG "circle") " "
     (STRONG "escape") " " (STRONG "gensym") " " (STRONG "length") " " (STRONG "level")
     " " (STRONG "lines") " " (STRONG "miser-width") " " (STRONG "pprint-dispatch") " "
     (STRONG "pretty") " " (STRONG "radix") " " (STRONG "readably") " "
     (STRONG "right-margin") " " (STRONG "stream") " => " (STRONG "object") EOL1
     (CODE1 "prin1") " " (STRONG "object") " " (CODE1 "&optional") " "
     (STRONG "output-stream") " => " (STRONG "object") EOL1 (CODE1 "princ") " "
     (STRONG "object") " " (CODE1 "&optional") " " (STRONG "output-stream") " => "
     (STRONG "object") EOL1 (CODE1 "print") " " (STRONG "object") " " (CODE1 "&optional")
     " " (STRONG "output-stream") " => " (STRONG "object") EOL1 (CODE1 "pprint") " "
     (STRONG "object") " " (CODE1 "&optional") " " (STRONG "output-stream") " => "
     (CODE1 "<返却値なし>"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "output-stream")
     " - 出力ストリーム指定子。デフォルトは標準出力。" EOL1 (STRONG "array") " - generalized-boolean" EOL1
     (STRONG "base") " - 基数" EOL1 (STRONG "case") " - 型"
     (CODE1 "(member :upcase :downcase :capitalize)") "のシンボル" EOL1 (STRONG "circle")
     " - generalized-boolean" EOL1 (STRONG "escape") " - generalized-boolean" EOL1
     (STRONG "gensym") " - generalized-boolean" EOL1 (STRONG "length") " - 非負の整数か、"
     (CODE1 "nil") EOL1 (STRONG "level") " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "lines")
     " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "miser-width") " - 非負の整数か、" (CODE1 "nil")
     EOL1 (STRONG "pprint-dispatch") " - " (CODE1 "pprint") "ディスパッチテーブル" EOL1
     (STRONG "pretty") " - generalized-boolean" EOL1 (STRONG "radix")
     " - generalized-boolean" EOL1 (STRONG "readably") " - generalized-boolean" EOL1
     (STRONG "right-margin") " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "stream")
     " - 出力ストリーム指定子。デフォルトは標準出力。")
    (CHAPTER ("## 定義") 2 (CODE1 "write") ", " (CODE1 "prin1") ", " (CODE1 "princ") ", "
     (CODE1 "print") ", " (CODE1 "pprint") "は、" (STRONG "object") "の印刷表現を"
     (STRONG "output-stream") "に書き込みます。" EOL2 (CODE1 "write") "は、Lispプリンターの一般的な入り口です。"
     "次の表で示されるような名前のキーワードパラメーターが明に指定されたとき、" "印刷が実行されている間はそれらの値が対応する"
     "プリンター制御変数に動的に束縛されます。" "次の表で示されるような名前のキーワードパラメーターが明に指定されなかったとき、" "対応するプリンター制御変数の値は"
     (CODE1 "write") "が実行された時点でのものと同じになります。" "いちど適切な束縛が確立されたら、"
     "オブジェクトはLispプリンターによって出力されます。" EOL2 "|パラメーター     |対応する動的変数               |"
     "|:----------------|:------------------------------|" "|array            |"
     (CODE1 "*print-array*") "           |" "|base             |" (CODE1 "*print-base*")
     "            |" "|case             |" (CODE1 "*print-case*") "            |"
     "|circle           |" (CODE1 "*print-circle*") "          |" "|escape           |"
     (CODE1 "*print-escape*") "          |" "|gensym           |"
     (CODE1 "*print-gensym*") "          |" "|length           |"
     (CODE1 "*print-length*") "          |" "|level            |" (CODE1 "*print-level*")
     "           |" "|lines            |" (CODE1 "*print-lines*") "           |"
     "|miser-width      |" (CODE1 "*print-miser-width*") "     |" "|pprint-dispatch  |"
     (CODE1 "*print-pprint-dispatch*") " |" "|pretty           |"
     (CODE1 "*print-pretty*") "          |" "|radix            |" (CODE1 "*print-radix*")
     "           |" "|readably         |" (CODE1 "*print-readably*") "        |"
     "|right-margin     |" (CODE1 "*print-right-margin*") "    |" EOL2 "Figure 22-7. "
     (CODE1 "WRITE") "関数の引数の対応" EOL2 (CODE1 "prin1") ", " (CODE1 "princ") ", "
     (CODE1 "print") ", " (CODE1 "pprint") "は、" "特定の印刷パラメーターを特定の値に暗に束縛します。"
     "残りのパラメーターの値は、" (CODE1 "*print-array*") "," (CODE1 "*print-base*") ","
     (CODE1 "*print-case*") "," (CODE1 "*print-circle*") "," (CODE1 "*print-escape*") ","
     (CODE1 "*print-gensym*") "," (CODE1 "*print-length*") "," (CODE1 "*print-level*")
     "," (CODE1 "*print-lines*") "," (CODE1 "*print-miser-width*") ","
     (CODE1 "*print-pprint-dispatch*") "," (CODE1 "*print-pretty*") ","
     (CODE1 "*print-radix*") "," (CODE1 "*print-right-margin*") "から取得します。" EOL2
     (CODE1 "prin1") "は、" (CODE1 "read") "からの入力に適切な出力を生成します。" "それは"
     (CODE1 "*print-escape*") "を" (STRONG "true") "に束縛します。" EOL2 (CODE1 "princ") "は、ちょうど"
     (CODE1 "prin1") "と似ていますが、" "出力にエスケープ文字を含めない所が違っています。" (CODE1 "*print-escape*") "を"
     (STRONG "false") "に、" (CODE1 "*print-readably*") "を" (STRONG "false") "に束縛します。"
     "一般的なルールは、" (CODE1 "princ") "による出力は人に見やすいことを意図しており、" (CODE1 "prin1") "による出力は"
     (CODE1 "read") "に受け入れられることを意図しています。" EOL2 (CODE1 "print") "は、ちょうど" (CODE1 "prin1")
     "に似ていますが、" (STRONG "object") "の印刷表現の前に改行を、" "その後にスペースを入れるところが違っています。" EOL2
     (CODE1 "pprint") "は、ちょうど" (CODE1 "print") "に似ていますが、" "末尾の空白が省略され、かつ"
     (STRONG "object") "を印刷するときに" (CODE1 "*print-pretty*") "に" (CODE1 "nil") "以外の値を指定し、"
     "プリティプリントの出力を行うということが違っています。" EOL2 (STRONG "output-stream") "は出力を送信するストリームを指定します。")
    (CHAPTER ("## 影響") 2 (CODE1 "*standard-output*") "," (CODE1 "*terminal-io*") ","
     (CODE1 "*print-escape*") "," (CODE1 "*print-radix*") "," (CODE1 "*print-base*") ","
     (CODE1 "*print-circle*") "," (CODE1 "*print-pretty*") "," (CODE1 "*print-level*")
     "," (CODE1 "*print-length*") "," (CODE1 "*print-case*") "," (CODE1 "*print-gensym*")
     "," (CODE1 "*print-array*") "," (CODE1 "*read-default-float-format*"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "readtable-case") "," "22.3.4. " (CODE1 "FORMAT")
     "プリンター操作")
    (CHAPTER ("## 備考") 2 "関数の" (CODE1 "prin1") "と" (CODE1 "print") "は、"
     (CODE1 "*print-readably*") "を束縛しません。"
     (CODE3 "```lisp" "```" "(prin1 object output-stream)"
      "==  (write object :stream output-stream :escape t)" NIL
      "(princ object output-stream)"
      "==  (write object stream output-stream :escape nil :readably nil)" NIL
      "(print object output-stream)" "==  (progn (terpri output-stream)"
      "           (write object :stream output-stream"
      "                         :escape t)"
      "           (write-char #\\space output-stream))" NIL
      "(pprint object output-stream)"
      "==  (write object :stream output-stream :escape t :pretty t)"))))
(setf (gethash '("WRITE" . "FUNCTION") *table*) (gethash "WRITE" *table*))
(setf (gethash "WRITE-BYTE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "WRITE-BYTE"))
    (CHAPTER ("## 構文") 2 (CODE1 "write-byte") " " (STRONG "byte") " " (STRONG "stream")
     " => " (STRONG "byte"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "byte") " - " (STRONG "stream") "の要素の型の整数" EOL1
     (STRONG "stream") " - バイナリ出力ストリーム")
    (CHAPTER ("## 定義") 2 (CODE1 "write-byte") "は、ひとつのバイトである" (STRONG "byte") "を"
     (STRONG "stream") "に書き込みます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(with-open-file (s \"temp-bytes\" "
      "                   :direction :output"
      "                   :element-type 'unsigned-byte)"
      "   (write-byte 101 s)) =>  101"))
    (CHAPTER ("## 副作用") 2 (STRONG "stream") "は変更されます。")
    (CHAPTER ("## 影響") 2 (STRONG "stream") "の要素の型")
    (CHAPTER ("## 例外") 2 (STRONG "stream") "がストリームではないときは、" "型" (CODE1 "type-error")
     "のエラーを通知するべきです。" (STRONG "stream") "がバイナリ出力ストリームではないとき、" "型" (CODE1 "type-error")
     "のエラーを通知するべきです。" EOL2 (STRONG "byte") "が" (STRONG "stream") "の要素の型の整数ではないときは、" "型"
     (CODE1 "type-error") "のエラーを通知されるでしょう。")
    (CHAPTER ("## 参考") 2 (CODE1 "read-byte") "," (CODE1 "write-char") ","
     (CODE1 "write-sequence"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("WRITE-BYTE" . "FUNCTION") *table*) (gethash "WRITE-BYTE" *table*))
(setf (gethash "WRITE-CHAR" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "WRITE-CHAR"))
    (CHAPTER ("## 構文") 2 (CODE1 "write-char") " " (STRONG "character") " "
     (CODE1 "&optional") " " (STRONG "output-stream") " => " (STRONG "character"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "character") " - 文字" EOL1 (STRONG "output-stream")
     " - 出力ストリーム指定子。デフォルトは標準出力。")
    (CHAPTER ("## 定義") 2 (CODE1 "write-char") "は、" (STRONG "output-stream") "に"
     (STRONG "character") "を出力します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(write-char #\\a)" ">>  a" "=>  #\\a"
      "(with-output-to-string (s) " "  (write-char #\\a s)" "  (write-char #\\Space s)"
      "  (write-char #\\b s))" "=>  \"a b\""))
    (CHAPTER ("## 副作用") 2 (STRONG "output-stream") "は修正されます。")
    (CHAPTER ("## 影響") 2 (CODE1 "*standard-output*") "," (CODE1 "*terminal-io*"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "read-char") "," (CODE1 "write-byte") ","
     (CODE1 "write-sequence"))
    (CHAPTER ("## 備考") 2 "なし。")))
(setf (gethash '("WRITE-CHAR" . "FUNCTION") *table*) (gethash "WRITE-CHAR" *table*))
(setf (gethash "WRITE-LINE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "WRITE-STRING") ", " (CODE1 "WRITE-LINE"))
    (CHAPTER ("## 構文") 2 (CODE1 "write-string") " " (STRONG "string") " "
     (CODE1 "&optional") " " (STRONG "output-stream") " " (CODE1 "&key") " "
     (STRONG "start") " " (STRONG "end") " => " (STRONG "string") EOL1
     (CODE1 "write-line") " " (STRONG "string") " " (CODE1 "&optional") " "
     (STRONG "output-stream") " " (CODE1 "&key") " " (STRONG "start") " " (STRONG "end")
     " => " (STRONG "string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string") " - 文字列" EOL1 (STRONG "output-stream")
     " - 出力ストリーム指定子。デフォルトは標準出力。" EOL1 (STRONG "start") ", " (STRONG "end") " - "
     (STRONG "string") "の境界インデックス指定子。" "デフォルトは" (STRONG "start") ", " (STRONG "end")
     "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "write-string") "は、" (STRONG "string") "の"
     (STRONG "start") "から" (STRONG "end") "で囲まれたサブシーケンスの文字を" (STRONG "output-stream")
     "へ書き込みます。" (CODE1 "write-line") "は同じことをしますが、その後に改行を出力します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(prog1 (write-string \"books\" nil :end 4) (write-string \"worms\"))"
      ">>  bookworms" "=>  \"books\"" "(progn (write-char #\\*)"
      "       (write-line \"test12\" *standard-output* :end 5) "
      "       (write-line \"*test2\")" "       (write-char #\\*)" "       nil)"
      ">>  *test1" ">>  *test2" ">>  *" "=>  NIL"))
    (CHAPTER ("## 副作用") 2 "なし。")
    (CHAPTER ("## 影響") 2 (CODE1 "*standard-output*") "," (CODE1 "*terminal-io*"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "read-line") "," (CODE1 "write-char"))
    (CHAPTER ("## 備考") 2 (CODE1 "write-line") "と" (CODE1 "write-string") "は"
     (STRONG "string") "を返却しますが、" "それは" (STRONG "start") "と" (STRONG "end")
     "に囲まれた部分文字列ではありません。"
     (CODE3 "```lisp" "```" "(write-string string)" "==  (dotimes (i (length string)"
      "      (write-char (char string i)))" NIL "(write-line string)"
      "==  (prog1 (write-string string) (terpri))"))))
(setf (gethash '("WRITE-LINE" . "FUNCTION") *table*) (gethash "WRITE-LINE" *table*))
(setf (gethash "WRITE-SEQUENCE" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "WRITE-SEQUENCE"))
    (CHAPTER ("## 構文") 2 (CODE1 "write-sequence") " " (STRONG "sequence") " "
     (STRONG "stream") " " (CODE1 "&key") " " (STRONG "start") " " (STRONG "end") " => "
     (STRONG "sequence"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "sequence") " - シーケンス" EOL1 (STRONG "stream")
     " - 出力ストリーム" EOL1 (STRONG "start") ", " (STRONG "end") " - " (STRONG "string")
     "の境界インデックス指定子。" "デフォルトは" (STRONG "start") ", " (STRONG "end") "それぞれ" (CODE1 "0") "と"
     (CODE1 "nil") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "write-sequence") "は、" (STRONG "start") "と"
     (STRONG "end") "の境界に囲まれた" (STRONG "sequence") "の部分シーケンスの要素を" (STRONG "stream")
     "に書き込みます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(write-sequence \"bookworms\" *standard-output* :end 4)"
      ">>  book" "=>  \"bookworms\""))
    (CHAPTER ("## 副作用") 2 (STRONG "stream") "は修正されます。") (CHAPTER ("## 影響") 2 "なし。")
    (CHAPTER ("## 例外") 2 (STRONG "sequence") "が正常なシーケンスではなかったときは、" "型"
     (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。" (STRONG "start") "が非負の整数ではなかったときは、"
     "型" (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。" (STRONG "end") "が非負の整数か"
     (CODE1 "nil") "ではなかったときは、" "型" (CODE1 "type-error") "のエラーを通知する準備をしなければなりません。" EOL2
     (STRONG "stream") "から読み込まれた要素が、" (STRONG "sequence") "の要素の型ではなかったときは、" "型"
     (CODE1 "type-error") "のエラーを通知されるかもしれません。")
    (CHAPTER ("## 参考") 2 "3.2.1. コンパイラーの用語," (CODE1 "read-sequence") ","
     (CODE1 "write-string") "," (CODE1 "write-line"))
    (CHAPTER ("## 備考") 2 (CODE1 "write-sequence") "は、指定した部分シーケンスに対して" "ひとつずつ要素を"
     (STRONG "stream") "に書き込む繰り返しと同じ効果ですが、" "おそらくは同等のループよりもより効率的になります。" EOL2
     "ある効率の良い実装では、" (STRONG "sequence") "が" (STRONG "stream") "の要素と同じ型の" (CODE1 "vector")
     "である場合に" "より効率的になるかもしれません。")))
(setf (gethash '("WRITE-SEQUENCE" . "FUNCTION") *table*) (gethash "WRITE-SEQUENCE" *table*))
(setf (gethash "WRITE-STRING" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "WRITE-STRING") ", " (CODE1 "WRITE-LINE"))
    (CHAPTER ("## 構文") 2 (CODE1 "write-string") " " (STRONG "string") " "
     (CODE1 "&optional") " " (STRONG "output-stream") " " (CODE1 "&key") " "
     (STRONG "start") " " (STRONG "end") " => " (STRONG "string") EOL1
     (CODE1 "write-line") " " (STRONG "string") " " (CODE1 "&optional") " "
     (STRONG "output-stream") " " (CODE1 "&key") " " (STRONG "start") " " (STRONG "end")
     " => " (STRONG "string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "string") " - 文字列" EOL1 (STRONG "output-stream")
     " - 出力ストリーム指定子。デフォルトは標準出力。" EOL1 (STRONG "start") ", " (STRONG "end") " - "
     (STRONG "string") "の境界インデックス指定子。" "デフォルトは" (STRONG "start") ", " (STRONG "end")
     "それぞれ" (CODE1 "0") "と" (CODE1 "nil") "。")
    (CHAPTER ("## 定義") 2 (CODE1 "write-string") "は、" (STRONG "string") "の"
     (STRONG "start") "から" (STRONG "end") "で囲まれたサブシーケンスの文字を" (STRONG "output-stream")
     "へ書き込みます。" (CODE1 "write-line") "は同じことをしますが、その後に改行を出力します。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```"
      "(prog1 (write-string \"books\" nil :end 4) (write-string \"worms\"))"
      ">>  bookworms" "=>  \"books\"" "(progn (write-char #\\*)"
      "       (write-line \"test12\" *standard-output* :end 5) "
      "       (write-line \"*test2\")" "       (write-char #\\*)" "       nil)"
      ">>  *test1" ">>  *test2" ">>  *" "=>  NIL"))
    (CHAPTER ("## 副作用") 2 "なし。")
    (CHAPTER ("## 影響") 2 (CODE1 "*standard-output*") "," (CODE1 "*terminal-io*"))
    (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "read-line") "," (CODE1 "write-char"))
    (CHAPTER ("## 備考") 2 (CODE1 "write-line") "と" (CODE1 "write-string") "は"
     (STRONG "string") "を返却しますが、" "それは" (STRONG "start") "と" (STRONG "end")
     "に囲まれた部分文字列ではありません。"
     (CODE3 "```lisp" "```" "(write-string string)" "==  (dotimes (i (length string)"
      "      (write-char (char string i)))" NIL "(write-line string)"
      "==  (prog1 (write-string string) (terpri))"))))
(setf (gethash '("WRITE-STRING" . "FUNCTION") *table*) (gethash "WRITE-STRING" *table*))
(setf (gethash "WRITE-TO-STRING" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "WRITE-TO-STRING") ", " (CODE1 "PRIN1-TO-STRING")
     ", " (CODE1 "PRINC-TO-STRING"))
    (CHAPTER ("## 構文") 2 (CODE1 "write-to-string") " " (STRONG "object") " "
     (CODE1 "&key") " " (STRONG "array") " " (STRONG "base") " " (STRONG "case") " "
     (STRONG "circle") " " (STRONG "escape") " " (STRONG "gensym") " " (STRONG "length")
     " " (STRONG "level") " " (STRONG "lines") " " (STRONG "miser-width") " "
     (STRONG "pprint-dispatch") " " (STRONG "pretty") " " (STRONG "radix") " "
     (STRONG "readably") " " (STRONG "right-margin") " => " (STRONG "string") EOL1
     (CODE1 "prin1-to-string") " " (STRONG "object") " => " (STRONG "string") EOL1
     (CODE1 "princ-to-string") " " (STRONG "object") " => " (STRONG "string"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "object") " - オブジェクト" EOL1 (STRONG "array")
     " - generalized-boolean" EOL1 (STRONG "base") " - 基数" EOL1 (STRONG "case") " - 型"
     (CODE1 "(member :upcase :downcase :capitalize)") "のシンボル" EOL1 (STRONG "circle")
     " - generalized-boolean" EOL1 (STRONG "escape") " - generalized-boolean" EOL1
     (STRONG "gensym") " - generalized-boolean" EOL1 (STRONG "length") " - 非負の整数か、"
     (CODE1 "nil") EOL1 (STRONG "level") " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "lines")
     " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "miser-width") " - 非負の整数か、" (CODE1 "nil")
     EOL1 (STRONG "pprint-dispatch") " - " (CODE1 "pprint") "ディスパッチテーブル" EOL1
     (STRONG "pretty") " - generalized-boolean" EOL1 (STRONG "radix")
     " - generalized-boolean" EOL1 (STRONG "readably") " - generalized-boolean" EOL1
     (STRONG "right-margin") " - 非負の整数か、" (CODE1 "nil") EOL1 (STRONG "string") " - 文字列")
    (CHAPTER ("## 定義") 2 (CODE1 "write-to-string") ", " (CODE1 "prin1-to-string") ", "
     (CODE1 "princ-to-string") "は、" (STRONG "object") "の印刷表現を含む文字列を生成するときに使用されます。"
     (STRONG "object") "は、それぞれ" (CODE1 "write") ", " (CODE1 "prin1") ", " (CODE1 "princ")
     "によるものとして" "効率的に印刷され、" "出力の文字が文字列の中に作成されます。" EOL2 (CODE1 "write-to-string")
     "は一般的な出力関数です。" "これは指定されたすべてのパラメーターを適切に扱い" (STRONG "object") "を印刷する能力があります。" EOL2
     (CODE1 "prin1-to-string") "は、" (CODE1 "write-to-string") "に" (CODE1 ":escape t")
     "を付与したように動作し、" "これはエスケープ文字が適切な場所に記載されることを意味しています。" EOL2 (CODE1 "princ-to-string")
     "は、" (CODE1 "write-to-string") "に" (CODE1 ":escape nil :readably nil")
     "を付与したように動作します。" "したがってエスケープ文字は記載されません。" EOL2 (CODE1 "prin1-to-string") "か"
     (CODE1 "princ-to-string") "が実行されたとき、" "他の全てのキーワードは" (CODE1 "write-to-string")
     "に指定されたもののデフォルト値になります。" EOL2 "この意味は、" (CODE1 "write-to-string") "のキーワード引数のデフォルトは、"
     (CODE1 "write") "のものと同じであるということです。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(prin1-to-string \"abc\") =>  \"\\\"abc\\\"\""
      "(princ-to-string \"abc\") =>  \"abc\""))
    (CHAPTER ("## 副作用") 2 "なし。")
    (CHAPTER ("## 影響") 2 (CODE1 "*print-escape*") "," (CODE1 "*print-radix*") ","
     (CODE1 "*print-base*") "," (CODE1 "*print-circle*") "," (CODE1 "*print-pretty*") ","
     (CODE1 "*print-level*") "," (CODE1 "*print-length*") "," (CODE1 "*print-case*") ","
     (CODE1 "*print-gensym*") "," (CODE1 "*print-array*") ","
     (CODE1 "*read-default-float-format*"))
    (CHAPTER ("## 例外") 2 "なし。") (CHAPTER ("## 参考") 2 (CODE1 "write"))
    (CHAPTER ("## 備考") 2
     (CODE3 "```lisp" "```" "(write-to-string object {key argument}*)"
      "==  (with-output-to-string (#1=#:string-stream) "
      "      (write object :stream #1# {key argument}*))" NIL "(princ-to-string object)"
      "==  (with-output-to-string (string-stream)" "      (princ object string-stream))"
      NIL "(prin1-to-string object)" "==  (with-output-to-string (string-stream)"
      "      (prin1 object string-stream))"))))
(setf (gethash '("WRITE-TO-STRING" . "FUNCTION") *table*) (gethash "WRITE-TO-STRING" *table*))
(setf (gethash "Y-OR-N-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "Y-OR-N-P") ", " (CODE1 "YES-OR-NO-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "y-or-n-p") " " (CODE1 "&optional") " "
     (STRONG "control") " " (CODE1 "&rest") " " (STRONG "arguments") " => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "yes-or-no-p") " " (CODE1 "&optional")
     " " (STRONG "control") " " (CODE1 "&rest") " " (STRONG "arguments") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "control") " - format-control" EOL1
     (STRONG "arguments") " - " (STRONG "control") "に対するformat-arguments" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は質問を行い、ユーザーからの返答を解釈します。" "もし返答が肯定であったときは" (STRONG "true")
     "を返却し、" "返答が否定的であったときは" (STRONG "false") "を返却します。" EOL2 (CODE1 "y-or-n-p")
     "はユーザーに質問を行い、" "答えが「yes」か「no」かのどちらかを問いかけます。" "この関数はユーザーの返答が" (CODE1 "yes") "か"
     (CODE1 "no") "か" "単一の文字であることを要求し、" "返信することを意図しています。" (CODE1 "yes-or-no-p")
     "もまたユーザーに質問を行い、" "答えが「Yes」か「No」かのどちらかを問いかけます。" "この関数はユーザーにちょうどひとつのキー押下以上の行動を要求し、"
     "例えば" (CODE1 "yes") "や" (CODE1 "no") "という完全な単語の後に" "改行をタイプするようなことを意図しています。" EOL2
     (CODE1 "y-or-n-p") "は、（もし指定されたなら）メッセージを出力し、" "実装依存の入力で"
     "（短く単純であることを意図しており、例えば単一の文字である" (CODE1 "Y") "か" (CODE1 "N") "を読み込みます）" "返答を読み込みます。"
     (CODE1 "yes-or-no-p") "は、（もし指定されたなら）メッセージを出力し、" "ユーザーの注意を引き付け"
     "（例えば、ターミナルのベルを鳴らしたり）" "実装依存の入力で" "（複数の文字を意図しており、例えば" (CODE1 "YES") "か" (CODE1 "NO")
     "を読み込みます）" "返答を読み込みます。" EOL2 "もし" (STRONG "format-control") "が指定され、" "それが"
     (CODE1 "nil") "ではないとき、" "まずは" (CODE1 "fresh-line") "操作が実行されます。" "そのあと"
     (STRONG "format-control") "と" (STRONG "arguments") "が" (CODE1 "format") "に与えられて"
     "メッセージが出力されます。" "いかなる場合でも、" (CODE1 "yes-or-no-p") "と" (CODE1 "y-or-n-p") "は"
     "適切であるならば" (CODE1 "(Y or N)") "か" (CODE1 "(Yes or No)") "のようなプロンプトが提供されます。" EOL2
     "全ての入出力はquery I/Oを使い実行されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(y-or-n-p \"(t or nil) given by\")"
      ">>  (t or nil) given by (Y or N) Y" "=>  true"
      "(yes-or-no-p \"a ~S message\" 'frightening) "
      ">>  a FRIGHTENING message (Yes or No) no" "=>  false"
      "(y-or-n-p \"Produce listing file?\") " ">>  Produce listing file?"
      ">>  Please respond with Y or N. n" "=>  false"))
    (CHAPTER ("## 副作用") 2 "query I/Oに対しての入出力が生じます。")
    (CHAPTER ("## 影響") 2 (CODE1 "*query-io*")) (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "format"))
    (CHAPTER ("## 備考") 2 "yes-or-no-p:link}と" (CODE1 "y-or-n-p") "はプロンプトの文字列の"
     "最後にクエスチョン文字を追加しないので、" "クエスチョンの文字や他の句読点を使いたいのであれば、" "テキストの質問文に明示的に含める必要があります。")))
(setf (gethash '("Y-OR-N-P" . "FUNCTION") *table*) (gethash "Y-OR-N-P" *table*))
(setf (gethash "YES-OR-NO-P" *table*)
  '((CHAPTER NIL 0 "Function " (CODE1 "Y-OR-N-P") ", " (CODE1 "YES-OR-NO-P"))
    (CHAPTER ("## 構文") 2 (CODE1 "y-or-n-p") " " (CODE1 "&optional") " "
     (STRONG "control") " " (CODE1 "&rest") " " (STRONG "arguments") " => "
     (STRONG "generalized-boolean") EOL1 (CODE1 "yes-or-no-p") " " (CODE1 "&optional")
     " " (STRONG "control") " " (CODE1 "&rest") " " (STRONG "arguments") " => "
     (STRONG "generalized-boolean"))
    (CHAPTER ("## 引数と戻り値") 2 (STRONG "control") " - format-control" EOL1
     (STRONG "arguments") " - " (STRONG "control") "に対するformat-arguments" EOL1
     (STRONG "generalized-boolean") " - generalized-boolean")
    (CHAPTER ("## 定義") 2 "これらの関数は質問を行い、ユーザーからの返答を解釈します。" "もし返答が肯定であったときは" (STRONG "true")
     "を返却し、" "返答が否定的であったときは" (STRONG "false") "を返却します。" EOL2 (CODE1 "y-or-n-p")
     "はユーザーに質問を行い、" "答えが「yes」か「no」かのどちらかを問いかけます。" "この関数はユーザーの返答が" (CODE1 "yes") "か"
     (CODE1 "no") "か" "単一の文字であることを要求し、" "返信することを意図しています。" (CODE1 "yes-or-no-p")
     "もまたユーザーに質問を行い、" "答えが「Yes」か「No」かのどちらかを問いかけます。" "この関数はユーザーにちょうどひとつのキー押下以上の行動を要求し、"
     "例えば" (CODE1 "yes") "や" (CODE1 "no") "という完全な単語の後に" "改行をタイプするようなことを意図しています。" EOL2
     (CODE1 "y-or-n-p") "は、（もし指定されたなら）メッセージを出力し、" "実装依存の入力で"
     "（短く単純であることを意図しており、例えば単一の文字である" (CODE1 "Y") "か" (CODE1 "N") "を読み込みます）" "返答を読み込みます。"
     (CODE1 "yes-or-no-p") "は、（もし指定されたなら）メッセージを出力し、" "ユーザーの注意を引き付け"
     "（例えば、ターミナルのベルを鳴らしたり）" "実装依存の入力で" "（複数の文字を意図しており、例えば" (CODE1 "YES") "か" (CODE1 "NO")
     "を読み込みます）" "返答を読み込みます。" EOL2 "もし" (STRONG "format-control") "が指定され、" "それが"
     (CODE1 "nil") "ではないとき、" "まずは" (CODE1 "fresh-line") "操作が実行されます。" "そのあと"
     (STRONG "format-control") "と" (STRONG "arguments") "が" (CODE1 "format") "に与えられて"
     "メッセージが出力されます。" "いかなる場合でも、" (CODE1 "yes-or-no-p") "と" (CODE1 "y-or-n-p") "は"
     "適切であるならば" (CODE1 "(Y or N)") "か" (CODE1 "(Yes or No)") "のようなプロンプトが提供されます。" EOL2
     "全ての入出力はquery I/Oを使い実行されます。")
    (CHAPTER ("## 例文") 2
     (CODE3 "```lisp" "```" "(y-or-n-p \"(t or nil) given by\")"
      ">>  (t or nil) given by (Y or N) Y" "=>  true"
      "(yes-or-no-p \"a ~S message\" 'frightening) "
      ">>  a FRIGHTENING message (Yes or No) no" "=>  false"
      "(y-or-n-p \"Produce listing file?\") " ">>  Produce listing file?"
      ">>  Please respond with Y or N. n" "=>  false"))
    (CHAPTER ("## 副作用") 2 "query I/Oに対しての入出力が生じます。")
    (CHAPTER ("## 影響") 2 (CODE1 "*query-io*")) (CHAPTER ("## 例外") 2 "なし。")
    (CHAPTER ("## 参考") 2 (CODE1 "format"))
    (CHAPTER ("## 備考") 2 "yes-or-no-p:link}と" (CODE1 "y-or-n-p") "はプロンプトの文字列の"
     "最後にクエスチョン文字を追加しないので、" "クエスチョンの文字や他の句読点を使いたいのであれば、" "テキストの質問文に明示的に含める必要があります。")))
(setf (gethash '("YES-OR-NO-P" . "FUNCTION") *table*) (gethash "YES-OR-NO-P" *table*))


;;
;;  search
;;
(declaim (ftype function search-object))

(defun search-output-cons (car cdr)
  (case car
    (chapter
      (fresh-line)
      (dolist (x (car cdr))
        (search-object x)
        (terpri))
      (dolist (x (cddr cdr))
        (search-object x))
      (fresh-line)
      (terpri))
    (code1
      (princ (car cdr)))
    (code3
      (fresh-line)
      (dolist (x (cddr cdr))
        (princ x)
        (terpri)))
    (strong
      (search-object (car cdr)))))

(defun search-object (x)
  (cond ((consp x)
         (search-output-cons (car x) (cdr x)))
        ((stringp x)
         (princ x))
        ((eq x 'eol1)
         (fresh-line))
        ((eq x 'eol2)
         (fresh-line)
         (terpri))
        (t (error "Invalid object, ~S." x))))

(defun search-output (list)
  (dolist (x list)
    (search-object x)))

(defun search-partial-list (x)
  (let (list)
    (maphash
      (lambda (key value)
        (declare (ignore value))
        (when (search x key)
          (push key list)))
      *name*)
    (sort list #'string<)))

(defun search-partial (x)
  (dolist (y (search-partial-list x))
    (format t "~A~%" y)))

(defun search-single (x)
  (let ((x (string x)))
    (multiple-value-bind (value check) (gethash x *table*)
      (if check
        (search-output value)
        (search-partial x)))))

(defun search-double (car cdr)
  (destructuring-bind (type) cdr
    (let ((key (cons (string car) (string type))))
      (multiple-value-bind (value check) (gethash key *table*)
        (if check
          (search-output value))))))

(defun search-fasl (args)
  (destructuring-bind (car . cdr) args
    (if cdr
      (search-double car cdr)
      (search-single car))))


;;
;;  Interface
;;
(defun doc-japanese (&rest args)
  (search-fasl args))

(defmacro docjp (&rest args)
  `(doc-japanese ,@(mapcar (lambda (x) `',x) args)))

