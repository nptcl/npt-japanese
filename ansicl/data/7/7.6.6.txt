;;
;;  ANSI Common Lisp 日本語訳
;;  7. オブジェクト
;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  7.6.6 メソッドの選択とコンビネーション
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@begin: 7.6.6
@type: text

ジェネリック関数が特定の引数とともに呼び出されたとき、
実行するコードを決定しなければなりません。
このコードは、これらの引数に対する有効なメソッドと呼ばれます。
有効なメソッドは、ジェネリック関数内の適用可能なメソッドを結びつけたものであり、
このメソッドのいくつかか、あるいは全てのメソッドが呼び出されます。

もしジェネリック関数が呼び出されたときに、適用可能なメソッドが存在しなかった場合は、
ジェネリック関数{no-applicable-method:link}が呼び出されます。
その呼び出した結果の返却値は、
最初のジェネリック関数が呼び出されたものの返却値として使用されます。
{no-applicable-method:link}の呼び出しは、
キーワード引数が受付可能かどうか先行してチェックされます。
{7.6.5:ab}を参照。

もし有効なメソッドが決定されたら、
ジェネリック関数に渡されたものと同じ引数とともに呼び出されます。
どのような返却値であれ、それはジェネリック関数が返却した値として返却されます。

@index

@end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  7.6.6.1 有効なメソッドの決定
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@begin: 7.6.6.1
@type: text

有効なメソッドは、下記の3ステップによって決定されます。

1. 適用可能なメソッドの選択します。

2. 優先順位によって適用可能なメソッドをソートし、最も特定的なメソッドを最初に選択します。

3. ソートされた適用可能なメソッドをmethod-combinationに渡して実行し、
有効なメソッドを生成します。

@index
@end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  7.6.6.1.1 適用可能なメソッドの選択
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@begin: 7.6.6.1.1
@type: text

この手順は、{7.6.2:ab}で定義されています。

@end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  7.6.6.1.2 優先順位による適用可能なメソッドのソート
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@begin: 7.6.6.1.2
@type: text

2つのメソッドの優先順位を比べるために、特定パラメーターが順番に調べられます。
デフォルトの調査順は左から右ですが、{defgeneric:link}か、あるいは別のオペレーターによる
ジェネリック関数の`:argument-precedence-order`オプションによって、逆順に指定されます。

各メソッドの対応する特定パラメーターが比較されます。
特定パラメーターのペアが一致していたら、次のペアが比較されます。
もし対応する全ての特定パラメーターが一致していたのであれば、
２つのメソッドは違った{qualifiers}を持っている必要があります。
このケースの場合、メソッドはどちらの順番でも選択できます。
一致についての詳細は、{7.6.3:ab}を参照。

もしいくつかの特定パラメーターが一致していなかった場合、
最初に一致しなかった特定パラメーターのペアが優先順位を決定します。
もしどちらの特定パラメーターもクラスであったとき、
その2つのメソッドの対応する特定パラメーターを見て、
クラス優先リストの中に早く現われた方がより特定的なメソッドとなります。
適用可能なメソッドの集合から選択する方法を行っているため、
特定パラメーターは引数のクラスのクラス優先リストに存在することが保証されます。

もし対応する特定パラメーターのペアのうち、ちょうど1つが`(eql object)`であったときは、
その特定パラメーターを持つメソッドが、他のメソッドより優先します。
もし両方の特定パラメーターが`eql`形式であったときは、
特定は一致するとしなければなりません
（そうでなければ2つのメソッドはこの引数において両方とも適用できなかったでしょう）。

適用可能なメソッドリストの結果は、最も特定的なメソッドが最初であり、
最も特定的ではないメソッドが最後になります。

@end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  7.6.6.1.3 ソートされた適用可能なメソッドのMethod-Combination実行
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@begin: 7.6.6.1.3
@type: text

単純な場合として、method-combinationは`standard`が使われており、
全ての適用可能なメソッドはプライマリメソッドであるとします。
この場合は、有効メソッドは最も特定的なメソッドとなります。
メソッドは、次に特定的なメソッドを関数{call-next-method:link}の使用にて呼び出すことができます。
{call-next-method:link}によって呼び出されるメソッドは、次のメソッドと言います。
関数{next-method-p:link}は、次のメソッドが存在するかどうかをテストします。
もし{call-next-method:link}が呼ばれたものの、次の特定的なメソッドが存在しなかった場合は、
ジェネリック関数{no-next-method:link}が呼び出されます。

一般的に、有効なメソッドは、適用可能なメソッドを組み合わせた結果のいくつかとなります。
これは次に記載されたような目的によりフォームとして定義されます。
適用可能なメソッドは、いくつかが呼ばれるか、あるいは全部が呼ばれるかを定義します。
また、返却値は1つか複数が返却されるように定義します。
その返却値はジェネリック関数として返却されるものです。
付加的にはいくつかのメソッドが{call-next-method:link}を用いてアクセス可能になるように定義します。

有効なメソッドにおける各メソッドの役割は、
メソッドの{qualifiers}と特定子によって決定されます。
{qualifiers}はメソッドに印をつけるものであり、
{qualifiers}の意味は手続きにおいて印を用いることで決定されます。
もし適用可能なメソッドが認識できない{qualifiers}を持っていた場合はエラーを発し、
有効なメソッドの中にこのメソッドが存在しないものとします。

method-combinationの`standard`が限定されたメソッドと一緒に使われたときは、
有効なメソッドは{7.6.6.2:ab}に記載されたものとして生成されます。

他のタイプのmethod-combinationは、{defgeneric:link}かあるいは別のオペレーターで
ジェネリック関数のオプション`:method-combination`を使うことで使用できます。
この方法により、手順をカスタマイズできます。

新しいタイプのmethod-combinationは、
{define-method-combination:link}マクロを使うことによって定義することができます。

@end

